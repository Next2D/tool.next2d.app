/*!
 * licenses: このプログラムを無断で利用、複製、配布を一切禁止します。
 *           但し、書き出したn2d,JSON,WebM,GIFはその限りではありません。
 *           Unauthorized use, reproduction, or distribution of this program is strictly prohibited.
 *           However, the exported n2d, JSON, WebM and GIF are exempt from this restriction.
 * version: 0.6.0
 * author: Toshiyuki Ienaga <ienaga@tvon.jp>
 * copyright: (c) 2021 Toshiyuki Ienaga.
 */
if (!("next2d-tools" in window)) {
    (function (global)
    {
        "use strict";

/**
 * @class
 */
class Language
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        this.mapping = this.createMapping();
    }

    /**
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    replace (value)
    {
        return this.mapping.has(value)
            ? this.mapping.get(value)
            : value;
    }
}
/**
 * @class
 * @extends Language
 */
class Chinese extends Language
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();
    }

    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{フレームピッカー}}", "选框机"],
            ["{{左揃え}}", "左对齐"],
            ["{{中央揃え(水平方向)}}", "居中（水平方向）"],
            ["{{右揃え}}", "右对齐"],
            ["{{上揃え}}", "上对齐"],
            ["{{中央揃え(垂直方向)}}", "居中（垂直方向）"],
            ["{{下揃え}}", "下对齐"],
            ["{{開始フレーム}}", "起始框架"],
            ["{{終了フレーム}}", "终端框架"],
            ["{{ループで再生}}", "循环播放"],
            ["{{1回再生}}", "1次播放"],
            ["{{指定したフレームで固定}}", "固定在指定的框架内"],
            ["{{1回逆再生}}", "1 反向播放"],
            ["{{逆ループで再生}}", "反向循环播放"],
            ["{{画面の拡大・縮小}}", "画面的放大和缩小"],
            ["{{カスタムイージングデータを保存}}", "保存自定义缓和数据"],
            ["{{カスタムイージングデータの読込}}", "读取自定义宽松数据"],
            ["{{プレビューのON/OFF}}", "预览开/关"],
            ["{{フォント枠サイズ}}", "字体帧大小"],
            ["{{フォント枠カラー}}", "字体帧颜色"],
            ["{{オニオンスキン}}", "洋葱皮"],
            ["{{バケツツール}}", "整体填充工具"],
            ["{{ペンツール}}", "钢笔工具"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "双击来添加一个曲线点"],
            ["{{選択ツール}}", "选择工具"],
            ["{{Shape変形ツール}}", "形状变换工具"],
            ["{{テキストツール}}", "文本工具"],
            ["{{短形ツール}}", "矩形工具"],
            ["{{楕円ツール}}", "椭圆工具"],
            ["{{角丸矩形ツール}}", "圆角矩形工具"],
            ["{{塗りのカラー}}", "填充颜色"],
            ["{{線のカラー}}", "画笔颜色"],
            ["{{線の太さ}}", "画笔宽度"],
            ["{{プロジェクトデータの読込}}", "载入工程文件"],
            ["{{プロジェクトデータを保存}}", "保存工程文件"],
            ["{{書き出し}}", "导出"],
            ["{{Discordへ移動}}", "前往discord"],
            ["{{バグ報告}}", "错误报告"],
            ["{{設定}}", "设置"],
            ["{{タブを追加}}", "添加标签页"],
            ["{{タブの一覧を表示・移動}}", "标签页列表"],
            ["{{スクリプトを追加}}", "添加一个脚本"],
            ["{{キーフレームを追加}}", "添加一个关键帧"],
            ["{{空のキーフレームを追加}}", "添加一个空的关键帧"],
            ["{{フレームを追加}}", "添加帧"],
            ["{{フレームを削除}}", "删除帧"],
            ["{{再生}}", "播放"],
            ["{{停止}}", "停止"],
            ["{{ループ設定}}", "循环设置"],
            ["{{レイヤーを追加}}", "添加图层"],
            ["{{レイヤーを削除}}", "删除图层"],
            ["{{全てのレイヤーをハイライト}}", "高亮所有图层"],
            ["{{全てのレイヤーを非表示}}", "隐藏所有图层"],
            ["{{全てのレイヤーをロック}}", "锁定所有图层"],
            ["{{比率を固定}}", "锁定比例"],
            ["{{ステージの幅}}", "画面宽度"],
            ["{{背景色}}", "背景颜色"],
            ["{{ステージの高さ}}", "画面高度"],
            ["{{フレームレート}}", "帧速率"],
            ["{{シンボル名}}", "符号名称"],
            ["{{イージング設定}}", "过渡设置"],
            ["{{ビデオの音量設定}}", "视频音量设置"],
            ["{{自動再生}}", "自动播放"],
            ["{{テキストエリアのボーダー設定}}", "文本框边框设置"],
            ["{{テキスト入力設定}}", "文本输入设置"],
            ["{{フォント選択}}", "字体选择"],
            ["{{自動サイズ調整}}", "自动调整尺寸"],
            ["{{フォントスタイルタイプ}}", "字体风格类型"],
            ["{{行揃え}}", "对齐设置"],
            ["{{改行設定}}", "换行设置"],
            ["{{スクロール設定}}", "滚动设置"],
            ["{{フォントサイズ}}", "字体大小"],
            ["{{フォントカラー}}", "字体颜色"],
            ["{{行間}}", "行间距"],
            ["{{文字幅}}", "字符宽度"],
            ["{{左マージン}}", "左边距"],
            ["{{右マージン}}", "右边距"],
            ["{{カラー種別の選択}}", "选择颜色类型"],
            ["{{背景画像の選択}}", "选择背景图片"],
            ["{{カラーポインターを追加}}", "添加颜色指针"],
            ["{{カラー値}}", "颜色"],
            ["{{アルファ(0%-100%)}}", "透明度（0%-100%）"],
            ["{{アルファ値}}", "透明度"],
            ["{{選択対象の幅}}", "选择对象的宽度"],
            ["{{選択対象のX座標}}", "选择对象的X轴坐标"],
            ["{{選択対象の高さ}}", "选择对象的高度"],
            ["{{選択対象のY座標}}", "选择对象的Y轴坐标"],
            ["{{選択対象の幅の伸縮}}", "选定对象的X轴缩放"],
            ["{{選択対象を回転}}", "旋转物体"],
            ["{{選択対象の高さの伸縮}}", "所选对象的比例Y"],
            ["{{アルファオフセット(-255〜255)}}", "透明度偏移（-255~255）"],
            ["{{赤(0%-100%)}}", "红色（0%-100%）"],
            ["{{赤オフセット(-255〜255)}}", "红色偏移（-255~255）"],
            ["{{緑(0%-100%)}}", "绿色（0%-100%）"],
            ["{{緑オフセット(-255〜255)}}", "绿色偏移（-255~255）"],
            ["{{青(0%-100%)}}", "蓝色（0%-100%）"],
            ["{{青オフセット(-255〜255)}}", "蓝色偏移（-255~255）"],
            ["{{ブレンドモード}}", "混合模式"],
            ["{{フィルターを選択}}", "选择滤镜"],
            ["{{フィルターを追加}}", "添加滤镜"],
            ["{{サウンドを追加}}", "添加声音"],
            ["{{フィルターを表示・非表示する}}", "显示和隐藏滤镜"],
            ["{{フィルターを削除}}", "删除滤镜"],
            ["{{水平方向にぼかす}}", "横向模糊"],
            ["{{垂直方向にぼかす}}", "纵向模糊"],
            ["{{フィルター強度}}", "滤镜强度"],
            ["{{フィルター角度}}", "滤镜角度"],
            ["{{シャドウのアルファ}}", "阴影透明度"],
            ["{{シャドウのカラー}}", "阴影颜色"],
            ["{{フィルター距離}}", "滤镜距离"],
            ["{{ハイライトのカラー}}", "高光色"],
            ["{{ハイライトのアルファ}}", "高光透明度"],
            ["{{グラデーションカラー}}", "渐变色"],
            ["{{グラデーションのアルファ}}", "渐变透明度"],
            ["{{タブの移動・名前を変更}}", "移动/重命名标签"],
            ["{{プロジェクトを閉じる}}", "关闭工程"],
            ["{{上下に移動}}", "上下移动"],
            ["{{レイヤー変更(ダブルクリック)}}", "改变图层（双击）"],
            ["{{レイヤーをハイライト}}", "高亮图层"],
            ["{{レイヤーを非表示}}", "隐藏图层"],
            ["{{レイヤーをロック}}", "锁定图层"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "曲线指针（双击打开/关闭）"],
            ["{{インスタンス名}}", "实例名称"],
            ["{{ライブラリ内の検索}}", "在库中搜索"],
            ["{{フレームラベル}}", "帧标签"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "如果工程没有保存，将无法恢复此标签页数据。 你想删除这个标签页吗？"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class English extends Language
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();
    }

    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{フレームピッカー}}", "Frame Picker"],
            ["{{左揃え}}", "Left"],
            ["{{中央揃え(水平方向)}}", "Center (Horizontal)"],
            ["{{右揃え}}", "Right"],
            ["{{上揃え}}", "Top"],
            ["{{中央揃え(垂直方向)}}", "Center (Vertical)"],
            ["{{下揃え}}", "Bottom"],
            ["{{開始フレーム}}", "Start Frame"],
            ["{{終了フレーム}}", "End Frame"],
            ["{{ループで再生}}", "Play in loop"],
            ["{{1回再生}}", "1 playback"],
            ["{{指定したフレームで固定}}", "Fixed at the specified frame"],
            ["{{1回逆再生}}", "1 reverse playback"],
            ["{{逆ループで再生}}", "Playback in reverse loop"],
            ["{{画面の拡大・縮小}}", "Zoom in/out of screen"],
            ["{{カスタムイージングデータを保存}}", "Save custom easing data"],
            ["{{カスタムイージングデータの読込}}", "Reading custom easing data"],
            ["{{プレビューのON/OFF}}", "Preview on/off"],
            ["{{フォント枠サイズ}}", "Font Frame Size"],
            ["{{フォント枠カラー}}", "Font Frame Color"],
            ["{{オニオンスキン}}", "Onion Skin"],
            ["{{バケツツール}}", "Bucket Tools"],
            ["{{ペンツール}}", "Pen Tool"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Double-click to add a curve point"],
            ["{{選択ツール}}", "Selection Tool"],
            ["{{Shape変形ツール}}", "Shape Transform Tool"],
            ["{{テキストツール}}", "Text Tool"],
            ["{{短形ツール}}", "Rectangle Tool"],
            ["{{楕円ツール}}", "Ellipse Tool"],
            ["{{角丸矩形ツール}}", "Rounded Rectangle Tool"],
            ["{{塗りのカラー}}", "Fill Color"],
            ["{{線のカラー}}", "Stroke Color"],
            ["{{線の太さ}}", "Stroke Width"],
            ["{{プロジェクトデータの読込}}", "Loading project data"],
            ["{{プロジェクトデータを保存}}", "Save project data"],
            ["{{書き出し}}", "Export"],
            ["{{Discordへ移動}}", "Go to discord"],
            ["{{バグ報告}}", "Bug reports"],
            ["{{設定}}", "Setting"],
            ["{{タブを追加}}", "Add a tab"],
            ["{{タブの一覧を表示・移動}}", "View and move through the list of tabs"],
            ["{{スクリプトを追加}}", "Add a script"],
            ["{{キーフレームを追加}}", "Add a keyframe"],
            ["{{空のキーフレームを追加}}", "Add an empty keyframe"],
            ["{{フレームを追加}}", "Add a frame"],
            ["{{フレームを削除}}", "Delete frame"],
            ["{{再生}}", "Play"],
            ["{{停止}}", "Stop"],
            ["{{ループ設定}}", "Loop Setting"],
            ["{{レイヤーを追加}}", "Add a layer"],
            ["{{レイヤーを削除}}", "Delete layer"],
            ["{{全てのレイヤーをハイライト}}", "Highlight all layers"],
            ["{{全てのレイヤーを非表示}}", "Hide all layers"],
            ["{{全てのレイヤーをロック}}", "Lock all layers"],
            ["{{比率を固定}}", "Fixed ratio"],
            ["{{ステージの幅}}", "Stage Width"],
            ["{{背景色}}", "Background Color"],
            ["{{ステージの高さ}}", "Stage Height"],
            ["{{フレームレート}}", "Frame Rate"],
            ["{{シンボル名}}", "Symbol Name"],
            ["{{イージング設定}}", "Easing Setting"],
            ["{{ビデオの音量設定}}", "Video Volume Setting"],
            ["{{自動再生}}", "Auto Play"],
            ["{{テキストエリアのボーダー設定}}", "Text Area Border Setting"],
            ["{{テキスト入力設定}}", "Text Input Setting"],
            ["{{フォント選択}}", "Font Select"],
            ["{{自動サイズ調整}}", "Automatic size adjustment"],
            ["{{フォントスタイルタイプ}}", "Font Style Type"],
            ["{{行揃え}}", "Align Setting"],
            ["{{改行設定}}", "Newline Setting"],
            ["{{スクロール設定}}", "Scroll Setting"],
            ["{{フォントサイズ}}", "Font Size"],
            ["{{フォントカラー}}", "Font Color"],
            ["{{行間}}", "Line Space"],
            ["{{文字幅}}", "Character Width"],
            ["{{左マージン}}", "Left Margin"],
            ["{{右マージン}}", "Right Margin"],
            ["{{カラー種別の選択}}", "Select a color type"],
            ["{{背景画像の選択}}", "Selecting a background image"],
            ["{{カラーポインターを追加}}", "Add color pointers"],
            ["{{カラー値}}", "Color"],
            ["{{アルファ(0%-100%)}}", "Alpha(0%-100%)"],
            ["{{アルファ値}}", "Alpha"],
            ["{{選択対象の幅}}", "Width of the selection object"],
            ["{{選択対象のX座標}}", "X coordinate of the selection object"],
            ["{{選択対象の高さ}}", "Height  of the selection object"],
            ["{{選択対象のY座標}}", "Y coordinate of the selection object"],
            ["{{選択対象の幅の伸縮}}", "scaleX of the selected object"],
            ["{{選択対象を回転}}", "Rotate the object"],
            ["{{選択対象の高さの伸縮}}", "scaleY of the selected object"],
            ["{{アルファオフセット(-255〜255)}}", "Alpha Offset(-255〜255)"],
            ["{{赤(0%-100%)}}", "Red(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Red Offset(-255〜255)"],
            ["{{緑(0%-100%)}}", "Green(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Green Offset(-255〜255)"],
            ["{{青(0%-100%)}}", "Blue(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Blue Offset(-255〜255)"],
            ["{{ブレンドモード}}", "Blend Mode"],
            ["{{フィルターを選択}}", "Select a filter"],
            ["{{フィルターを追加}}", "Add a filter"],
            ["{{サウンドを追加}}", "Add a sound"],
            ["{{フィルターを表示・非表示する}}", "Show and Hide filters"],
            ["{{フィルターを削除}}", "Delete Filter"],
            ["{{水平方向にぼかす}}", "Blur Horizontally"],
            ["{{垂直方向にぼかす}}", "Blur Vertically"],
            ["{{フィルター強度}}", "Filter Strength"],
            ["{{フィルター角度}}", "Filter Angle"],
            ["{{シャドウのアルファ}}", "Shadow Alpha"],
            ["{{シャドウのカラー}}", "Shadow Color"],
            ["{{フィルター距離}}", "Filter Distance"],
            ["{{ハイライトのカラー}}", "Highlight Color"],
            ["{{ハイライトのアルファ}}", "Highlight Alpha"],
            ["{{グラデーションカラー}}", "Gradient Color"],
            ["{{グラデーションのアルファ}}", "Gradient Alpha"],
            ["{{タブの移動・名前を変更}}", "Move/Rename tabs"],
            ["{{プロジェクトを閉じる}}", "Close the project"],
            ["{{上下に移動}}", "Move up and down"],
            ["{{レイヤー変更(ダブルクリック)}}", "Layer Change(double-click)"],
            ["{{レイヤーをハイライト}}", "Highlight Layer"],
            ["{{レイヤーを非表示}}", "Hide Layer"],
            ["{{レイヤーをロック}}", "Lock the Layer"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Curve Pointer (double click to turn on/off)"],
            ["{{インスタンス名}}", "Instance Name"],
            ["{{ライブラリ内の検索}}", "Search in the library"],
            ["{{フレームラベル}}", "Frame Label"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "If the project is not saved, the project data in this tab cannot be recovered. Do you want to delete the tab?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class French extends Language
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();
    }

    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{フレームピッカー}}", "ramasseur de cadres"],
            ["{{左揃え}}", "Gauche"],
            ["{{中央揃え(水平方向)}}", "Centre(sens horizontal)"],
            ["{{右揃え}}", "Droit"],
            ["{{上揃え}}", "Top"],
            ["{{中央揃え(垂直方向)}}", "Centre(Vertical)"],
            ["{{下揃え}}", "Fond"],
            ["{{開始フレーム}}", "cadre de départ"],
            ["{{終了フレーム}}", "cadre terminal"],
            ["{{ループで再生}}", "Lecture en boucle"],
            ["{{1回再生}}", "1 lecture"],
            ["{{指定したフレームで固定}}", "Fixé dans le cadre spécifié"],
            ["{{1回逆再生}}", "1 lecture en sens inverse"],
            ["{{逆ループで再生}}", "Lecture en boucle inversée"],
            ["{{画面の拡大・縮小}}", "Zoom avant et arrière sur l'écran"],
            ["{{カスタムイージングデータを保存}}", "Enregistrez les données d'assouplissement personnalisées"],
            ["{{カスタムイージングデータの読込}}", "Lecture des données de l'assouplissement personnalisé"],
            ["{{プレビューのON/OFF}}", "Activation/désactivation de la prévisualisation"],
            ["{{フォント枠サイズ}}", "Taille du cadre de la police"],
            ["{{フォント枠カラー}}", "Couleur du cadre de la police"],
            ["{{オニオンスキン}}", "Peau d'oignon"],
            ["{{バケツツール}}", "Outils à godets"],
            ["{{ペンツール}}", "Outil stylo"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Double-cliquez pour ajouter un point de courbe"],
            ["{{選択ツール}}", "Outils de sélection"],
            ["{{Shape変形ツール}}", "Outil de transformation des formes"],
            ["{{テキストツール}}", "Outil texte"],
            ["{{短形ツール}}", "Outil Rectangle"],
            ["{{楕円ツール}}", "Outil Ellipse"],
            ["{{角丸矩形ツール}}", "Outil Rectangle arrondi"],
            ["{{塗りのカラー}}", "Couleur de remplissage"],
            ["{{線のカラー}}", "Couleur du trait"],
            ["{{線の太さ}}", "Largeur de course"],
            ["{{プロジェクトデータの読込}}", "Chargement des données du projet"],
            ["{{プロジェクトデータを保存}}", "Sauvegarder les données du projet"],
            ["{{書き出し}}", "Exportation"],
            ["{{Discordへ移動}}", "Aller sur le discord"],
            ["{{バグ報告}}", "Rapports de bogue"],
            ["{{設定}}", "Réglage de"],
            ["{{タブを追加}}", "Ajouter un onglet"],
            ["{{タブの一覧を表示・移動}}", "Visualiser et se déplacer dans la liste des onglets"],
            ["{{スクリプトを追加}}", "Ajouter un script"],
            ["{{キーフレームを追加}}", "Ajouter une image clé"],
            ["{{空のキーフレームを追加}}", "Ajouter une image clé vide"],
            ["{{フレームを追加}}", "Ajouter un cadre"],
            ["{{フレームを削除}}", "Supprimer le cadre"],
            ["{{再生}}", "Jouer"],
            ["{{停止}}", "Stop"],
            ["{{ループ設定}}", "Réglage de la boucle"],
            ["{{レイヤーを追加}}", "Ajouter une couche"],
            ["{{レイヤーを削除}}", "Supprimer la couche"],
            ["{{全てのレイヤーをハイライト}}", "Mettez en évidence toutes les couches"],
            ["{{全てのレイヤーを非表示}}", "Cacher toutes les couches"],
            ["{{全てのレイヤーをロック}}", "Verrouiller toutes les couches"],
            ["{{比率を固定}}", "Ratio fixe"],
            ["{{ステージの幅}}", "Largeur de la scène"],
            ["{{背景色}}", "Couleur de fond"],
            ["{{ステージの高さ}}", "Hauteur de la scène"],
            ["{{フレームレート}}", "Fréquence d'images"],
            ["{{シンボル名}}", "Nom du symbole"],
            ["{{イージング設定}}", "Réglage de l'assouplissement"],
            ["{{ビデオの音量設定}}", "Réglage du volume vidéo"],
            ["{{自動再生}}", "Lecture automatique"],
            ["{{テキストエリアのボーダー設定}}", "Réglage de la bordure de la zone de texte"],
            ["{{テキスト入力設定}}", "Réglage de la saisie du texte"],
            ["{{フォント選択}}", "Sélection de la police"],
            ["{{自動サイズ調整}}", "Ajustement automatique de la taille"],
            ["{{フォントスタイルタイプ}}", "Type de police"],
            ["{{行揃え}}", "Réglage de l'alignement"],
            ["{{改行設定}}", "Réglage des nouvelles lignes"],
            ["{{スクロール設定}}", "Réglage du défilement"],
            ["{{フォントサイズ}}", "Taille de la police"],
            ["{{フォントカラー}}", "Couleur de la police"],
            ["{{行間}}", "Espace linéaire"],
            ["{{文字幅}}", "Largeur des caractères"],
            ["{{左マージン}}", "Marge gauche"],
            ["{{右マージン}}", "Marge droite"],
            ["{{カラー種別の選択}}", "Sélectionnez un type de couleur"],
            ["{{背景画像の選択}}", "Sélection d'une image de fond"],
            ["{{カラーポインターを追加}}", "Ajouter des pointeurs de couleur"],
            ["{{カラー値}}", "Couleur"],
            ["{{アルファ(0%-100%)}}", "Alpha(0%-100%)"],
            ["{{アルファ値}}", "Alpha"],
            ["{{選択対象の幅}}", "Largeur de l'objet de sélection"],
            ["{{選択対象のX座標}}", "Coordonnée X de l'objet de sélection"],
            ["{{選択対象の高さ}}", "Hauteur de l'objet de sélection"],
            ["{{選択対象のY座標}}", "Coordonnée Y de l'objet de sélection"],
            ["{{選択対象の幅の伸縮}}", "scaleX de l'objet sélectionné"],
            ["{{選択対象を回転}}", "Faire pivoter l'objet"],
            ["{{選択対象の高さの伸縮}}", "scaleY de l'objet sélectionné"],
            ["{{アルファオフセット(-255〜255)}}", "Décalage alpha(-255〜255)"],
            ["{{赤(0%-100%)}}", "Rouge(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Décalage rouge(-255〜255)"],
            ["{{緑(0%-100%)}}", "Vert(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Compensation verte(-255〜255)"],
            ["{{青(0%-100%)}}", "Bleu(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Décalage bleu(-255〜255)"],
            ["{{ブレンドモード}}", "Mode de mélange"],
            ["{{フィルターを選択}}", "Sélectionnez un filtre"],
            ["{{フィルターを追加}}", "Ajouter un filtre"],
            ["{{サウンドを追加}}", "Ajouter un son"],
            ["{{フィルターを表示・非表示する}}", "Afficher et masquer les filtres"],
            ["{{フィルターを削除}}", "Supprimer le filtre"],
            ["{{水平方向にぼかす}}", "Flou horizontal"],
            ["{{垂直方向にぼかす}}", "Flou vertical"],
            ["{{フィルター強度}}", "Résistance du filtre"],
            ["{{フィルター角度}}", "Angle du filtre"],
            ["{{シャドウのアルファ}}", "Shadow Alpha"],
            ["{{シャドウのカラー}}", "Couleur de l'ombre"],
            ["{{フィルター距離}}", "Distance du filtre"],
            ["{{ハイライトのカラー}}", "Couleur de mise en évidence"],
            ["{{ハイライトのアルファ}}", "Highlight Alpha"],
            ["{{グラデーションカラー}}", "Couleur dégradée"],
            ["{{グラデーションのアルファ}}", "Gradient Alpha"],
            ["{{タブの移動・名前を変更}}", "Déplacer/Renommer les onglets"],
            ["{{プロジェクトを閉じる}}", "Fermer le projet"],
            ["{{上下に移動}}", "Déplacement vers le haut et le bas"],
            ["{{レイヤー変更(ダブルクリック)}}", "Changement de couche (double-clic)"],
            ["{{レイヤーをハイライト}}", "Couche de mise en évidence"],
            ["{{レイヤーを非表示}}", "Masquer la couche"],
            ["{{レイヤーをロック}}", "Verrouiller le calque"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Pointeur de courbe (double-cliquez pour l'activer ou le désactiver)"],
            ["{{インスタンス名}}", "Nom de l'instance"],
            ["{{ライブラリ内の検索}}", "Recherche dans la bibliothèque"],
            ["{{フレームラベル}}", "Étiquette du cadre"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "Si le projet n'est pas sauvegardé, les données du projet dans cet onglet ne peuvent pas être récupérées. Voulez-vous supprimer l'onglet ?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Italiano extends Language
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();
    }

    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{フレームピッカー}}", "raccoglitore di cornici"],
            ["{{左揃え}}", "Sinistra"],
            ["{{中央揃え(水平方向)}}", "Centro (Orizzontalità)"],
            ["{{右揃え}}", "Destra"],
            ["{{上揃え}}", "Top"],
            ["{{中央揃え(垂直方向)}}", "Centro (Verticale)"],
            ["{{下揃え}}", "Fondo"],
            ["{{開始フレーム}}", "telaio di partenza"],
            ["{{終了フレーム}}", "telaio finale"],
            ["{{ループで再生}}", "Gioca in loop"],
            ["{{1回再生}}", "1 riproduzione"],
            ["{{指定したフレームで固定}}", "Fissato nella cornice specificata"],
            ["{{1回逆再生}}", "1 riproduzione inversa"],
            ["{{逆ループで再生}}", "Riproduzione in loop inverso"],
            ["{{画面の拡大・縮小}}", "Ingrandire e rimpicciolire lo schermo"],
            ["{{カスタムイージングデータを保存}}", "Salva i dati di easing personalizzati"],
            ["{{カスタムイージングデータの読込}}", "Lettura dei dati di easing personalizzati"],
            ["{{プレビューのON/OFF}}", "Anteprima on/off"],
            ["{{フォント枠サイズ}}", "Dimensione della cornice del carattere"],
            ["{{フォント枠カラー}}", "Colore della cornice del carattere"],
            ["{{オニオンスキン}}", "Pelle di cipolla"],
            ["{{バケツツール}}", "Strumenti a secchiello"],
            ["{{ペンツール}}", "Strumento penna"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Doppio clic per aggiungere un punto di curva"],
            ["{{選択ツール}}", "Strumenti di selezione"],
            ["{{Shape変形ツール}}", "Strumento di trasformazione della forma"],
            ["{{テキストツール}}", "Text Tool"],
            ["{{短形ツール}}", "Strumento di testo"],
            ["{{楕円ツール}}", "Strumento Ellisse"],
            ["{{角丸矩形ツール}}", "Strumento Rettangolo arrotondato"],
            ["{{塗りのカラー}}", "Colore di riempimento"],
            ["{{線のカラー}}", "Colore del tratto"],
            ["{{線の太さ}}", "Larghezza della corsa"],
            ["{{プロジェクトデータの読込}}", "Caricamento dei dati del progetto"],
            ["{{プロジェクトデータを保存}}", "Salvare i dati del progetto"],
            ["{{書き出し}}", "Esportazione"],
            ["{{Discordへ移動}}", "Vai su discordia"],
            ["{{バグ報告}}", "Segnalazioni di bug"],
            ["{{設定}}", "Impostazione"],
            ["{{タブを追加}}", "Aggiungere una scheda"],
            ["{{タブの一覧を表示・移動}}", "Visualizzare e spostarsi attraverso l'elenco delle schede"],
            ["{{スクリプトを追加}}", "Aggiungere uno script"],
            ["{{キーフレームを追加}}", "Aggiungere un keyframe"],
            ["{{空のキーフレームを追加}}", "Aggiungere un keyframe vuoto"],
            ["{{フレームを追加}}", "Aggiungere una cornice"],
            ["{{フレームを削除}}", "Cancellare la cornice"],
            ["{{再生}}", "Gioca"],
            ["{{停止}}", "Fermare"],
            ["{{ループ設定}}", "Impostazione del loop"],
            ["{{レイヤーを追加}}", "Aggiungere uno strato"],
            ["{{レイヤーを削除}}", "Cancellare il livello"],
            ["{{全てのレイヤーをハイライト}}", "Evidenzia tutti i livelli"],
            ["{{全てのレイヤーを非表示}}", "Nascondi tutti i livelli"],
            ["{{全てのレイヤーをロック}}", "Blocca tutti i livelli"],
            ["{{比率を固定}}", "Rapporto fisso"],
            ["{{ステージの幅}}", "Larghezza del palco"],
            ["{{背景色}}", "Colore di sfondo"],
            ["{{ステージの高さ}}", "Altezza del palco"],
            ["{{フレームレート}}", "Frame Rate"],
            ["{{シンボル名}}", "Nome del simbolo"],
            ["{{イージング設定}}", "Impostazione di rilassamento"],
            ["{{ビデオの音量設定}}", "Impostazione del volume video"],
            ["{{自動再生}}", "Riproduzione automatica"],
            ["{{テキストエリアのボーダー設定}}", "Impostazione del bordo dell'area di testo"],
            ["{{テキスト入力設定}}", "Impostazione dell'inserimento del testo"],
            ["{{フォント選択}}", "Seleziona il carattere"],
            ["{{自動サイズ調整}}", "Regolazione automatica delle dimensioni"],
            ["{{フォントスタイルタイプ}}", "Tipo di stile di carattere"],
            ["{{行揃え}}", "Allineare l'impostazione"],
            ["{{改行設定}}", "Impostazione Newline"],
            ["{{スクロール設定}}", "Impostazione dello scorrimento"],
            ["{{フォントサイズ}}", "Dimensione del carattere"],
            ["{{フォントカラー}}", "Colore del carattere"],
            ["{{行間}}", "Spazio di linea"],
            ["{{文字幅}}", "Larghezza del carattere"],
            ["{{左マージン}}", "Margine sinistro"],
            ["{{右マージン}}", "Margine destro"],
            ["{{カラー種別の選択}}", "Seleziona un tipo di colore"],
            ["{{背景画像の選択}}", "Selezionare un'immagine di sfondo"],
            ["{{カラーポインターを追加}}", "Aggiungere i puntatori di colore"],
            ["{{カラー値}}", "Colore"],
            ["{{アルファ(0%-100%)}}", "Alpha(0%-100%)"],
            ["{{アルファ値}}", "Alpha"],
            ["{{選択対象の幅}}", "Larghezza dell'oggetto di selezione"],
            ["{{選択対象のX座標}}", "Coordinata X dell'oggetto di selezione"],
            ["{{選択対象の高さ}}", "Altezza dell'oggetto di selezione"],
            ["{{選択対象のY座標}}", "Coordinata Y dell'oggetto di selezione"],
            ["{{選択対象の幅の伸縮}}", "scaleX dell'oggetto selezionato"],
            ["{{選択対象を回転}}", "Ruotare l'oggetto"],
            ["{{選択対象の高さの伸縮}}", "scalaY dell'oggetto selezionato"],
            ["{{アルファオフセット(-255〜255)}}", "Offset alfa(-255〜255)"],
            ["{{赤(0%-100%)}}", "Rosso(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Offset rosso(-255〜255)"],
            ["{{緑(0%-100%)}}", "Verde(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Offset Verde(-255〜255)"],
            ["{{青(0%-100%)}}", "Blu(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Offset Blu(-255〜255)"],
            ["{{ブレンドモード}}", "Modalità di fusione"],
            ["{{フィルターを選択}}", "Seleziona un filtro"],
            ["{{フィルターを追加}}", "Aggiungere un filtro"],
            ["{{サウンドを追加}}", "Aggiungere un suono"],
            ["{{フィルターを表示・非表示する}}", "Mostrare e nascondere i filtri"],
            ["{{フィルターを削除}}", "Cancellare il filtro"],
            ["{{水平方向にぼかす}}", "Sfocatura orizzontale"],
            ["{{垂直方向にぼかす}}", "Sfocatura verticale"],
            ["{{フィルター強度}}", "Forza del filtro"],
            ["{{フィルター角度}}", "Angolo del filtro"],
            ["{{シャドウのアルファ}}", "Ombra alfa"],
            ["{{シャドウのカラー}}", "Colore dell'ombra"],
            ["{{フィルター距離}}", "Distanza del filtro"],
            ["{{ハイライトのカラー}}", "Colore in evidenza"],
            ["{{ハイライトのアルファ}}", "Evidenziare l'alfa"],
            ["{{グラデーションカラー}}", "Colore sfumato"],
            ["{{グラデーションのアルファ}}", "Gradiente alfa"],
            ["{{タブの移動・名前を変更}}", "Spostare/rinominare le schede"],
            ["{{プロジェクトを閉じる}}", "Chiudere il progetto"],
            ["{{上下に移動}}", "Sposta su e giù"],
            ["{{レイヤー変更(ダブルクリック)}}", "Cambio di livello (doppio clic)"],
            ["{{レイヤーをハイライト}}", "Strato di evidenziazione"],
            ["{{レイヤーを非表示}}", "Nascondere lo strato"],
            ["{{レイヤーをロック}}", "Bloccare il livello"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Curve Pointer (doppio clic per attivare/disattivare)"],
            ["{{インスタンス名}}", "Nome dell'istanza"],
            ["{{ライブラリ内の検索}}", "Cerca nella biblioteca"],
            ["{{フレームラベル}}", "Etichetta del telaio"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "Se il progetto non viene salvato, i dati del progetto in questa scheda non possono essere recuperati. Vuoi cancellare la scheda?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Japanese extends Language
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();
    }

    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{フレームピッカー}}", "フレームピッカー"],
            ["{{左揃え}}", "左揃え"],
            ["{{中央揃え(水平方向)}}", "中央揃え(水平方向)"],
            ["{{右揃え}}", "右揃え"],
            ["{{上揃え}}", "上揃え"],
            ["{{中央揃え(垂直方向)}}", "中央揃え(垂直方向)"],
            ["{{下揃え}}", "下揃え"],
            ["{{開始フレーム}}", "開始フレーム"],
            ["{{終了フレーム}}", "終了フレーム"],
            ["{{ループで再生}}", "ループで再生"],
            ["{{1回再生}}", "1回再生"],
            ["{{指定したフレームで固定}}", "指定したフレームで固定"],
            ["{{1回逆再生}}", "1回逆再生"],
            ["{{逆ループで再生}}", "逆ループで再生"],
            ["{{画面の拡大・縮小}}", "画面の拡大・縮小"],
            ["{{カスタムイージングデータを保存}}", "カスタムイージングデータを保存"],
            ["{{カスタムイージングデータの読込}}", "カスタムイージングデータの読込"],
            ["{{プレビューのON/OFF}}", "プレビューのON/OFF"],
            ["{{フォント枠サイズ}}", "フォント枠サイズ"],
            ["{{フォント枠カラー}}", "フォント枠カラー"],
            ["{{オニオンスキン}}", "オニオンスキン"],
            ["{{バケツツール}}", "バケツツール"],
            ["{{ペンツール}}", "ペンツール"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "ダブルクリックでカーブポイントが追加されます"],
            ["{{選択ツール}}", "選択ツール"],
            ["{{Shape変形ツール}}", "Shape変形ツール"],
            ["{{テキストツール}}", "テキストツール"],
            ["{{短形ツール}}", "短形ツール"],
            ["{{楕円ツール}}", "楕円ツール"],
            ["{{角丸矩形ツール}}", "角丸矩形ツール"],
            ["{{塗りのカラー}}", "塗りのカラー"],
            ["{{線のカラー}}", "線のカラー"],
            ["{{線の太さ}}", "線の太さ"],
            ["{{プロジェクトデータの読込}}", "プロジェクトデータの読込"],
            ["{{プロジェクトデータを保存}}", "プロジェクトデータを保存"],
            ["{{書き出し}}", "書き出し"],
            ["{{Discordへ移動}}", "Discordへ移動"],
            ["{{バグ報告}}", "バグ報告"],
            ["{{設定}}", "設定"],
            ["{{タブを追加}}", "タブを追加"],
            ["{{タブの一覧を表示・移動}}", "タブの一覧を表示・移動"],
            ["{{スクリプトを追加}}", "スクリプトを追加"],
            ["{{キーフレームを追加}}", "キーフレームを追加"],
            ["{{空のキーフレームを追加}}", "空のキーフレームを追加"],
            ["{{フレームを追加}}", "フレームを追加"],
            ["{{フレームを削除}}", "フレームを削除"],
            ["{{再生}}", "再生"],
            ["{{停止}}", "停止"],
            ["{{ループ設定}}", "ループ設定"],
            ["{{レイヤーを追加}}", "レイヤーを追加"],
            ["{{レイヤーを削除}}", "レイヤーを削除"],
            ["{{全てのレイヤーをハイライト}}", "全てのレイヤーをハイライト"],
            ["{{全てのレイヤーを非表示}}", "全てのレイヤーを非表示"],
            ["{{全てのレイヤーをロック}}", "全てのレイヤーをロック"],
            ["{{比率を固定}}", "比率を固定"],
            ["{{ステージの幅}}", "ステージの幅"],
            ["{{背景色}}", "背景色"],
            ["{{ステージの高さ}}", "ステージの高さ"],
            ["{{フレームレート}}", "フレームレート"],
            ["{{シンボル名}}", "シンボル名"],
            ["{{イージング設定}}", "イージング設定"],
            ["{{ビデオの音量設定}}", "ビデオの音量設定"],
            ["{{自動再生}}", "自動再生"],
            ["{{テキストエリアのボーダー設定}}", "テキストエリアのボーダー設定"],
            ["{{テキスト入力設定}}", "テキスト入力設定"],
            ["{{フォント選択}}", "フォント選択"],
            ["{{自動サイズ調整}}", "自動サイズ調整"],
            ["{{フォントスタイルタイプ}}", "フォントスタイルタイプ"],
            ["{{行揃え}}", "行揃え"],
            ["{{改行設定}}", "改行設定"],
            ["{{スクロール設定}}", "スクロール設定"],
            ["{{フォントサイズ}}", "フォントサイズ"],
            ["{{フォントカラー}}", "フォントカラー"],
            ["{{行間}}", "行間"],
            ["{{文字幅}}", "文字幅"],
            ["{{左マージン}}", "左マージン"],
            ["{{右マージン}}", "右マージン"],
            ["{{カラー種別の選択}}", "カラー種別の選択"],
            ["{{背景画像の選択}}", "背景画像の選択"],
            ["{{カラーポインターを追加}}", "カラーポインターを追加"],
            ["{{カラー値}}", "カラー値"],
            ["{{アルファ(0%-100%)}}", "アルファ(0%-100%)"],
            ["{{アルファ値}}", "アルファ値"],
            ["{{選択対象の幅}}", "選択対象の幅"],
            ["{{選択対象のX座標}}", "選択対象のX座標"],
            ["{{選択対象の高さ}}", "選択対象の高さ"],
            ["{{選択対象のY座標}}", "選択対象のY座標"],
            ["{{選択対象の幅の伸縮}}", "選択対象の幅の伸縮"],
            ["{{選択対象を回転}}", "選択対象を回転"],
            ["{{選択対象の高さの伸縮}}", "選択対象の高さの伸縮"],
            ["{{アルファオフセット(-255〜255)}}", "アルファオフセット(-255〜255)"],
            ["{{赤(0%-100%)}}", "赤(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "赤オフセット(-255〜255)"],
            ["{{緑(0%-100%)}}", "緑(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "緑オフセット(-255〜255)"],
            ["{{青(0%-100%)}}", "青(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "青オフセット(-255〜255)"],
            ["{{ブレンドモード}}", "ブレンドモード"],
            ["{{フィルターを選択}}", "フィルターを選択"],
            ["{{フィルターを追加}}", "フィルターを追加"],
            ["{{サウンドを追加}}", "サウンドを追加"],
            ["{{フィルターを表示・非表示する}}", "フィルターを表示・非表示する"],
            ["{{フィルターを削除}}", "フィルターを削除"],
            ["{{水平方向にぼかす}}", "水平方向にぼかす"],
            ["{{垂直方向にぼかす}}", "垂直方向にぼかす"],
            ["{{フィルター強度}}", "フィルター強度"],
            ["{{フィルター角度}}", "フィルター角度"],
            ["{{シャドウのアルファ}}", "シャドウのアルファ"],
            ["{{シャドウのカラー}}", "シャドウのカラー"],
            ["{{フィルター距離}}", "フィルター距離"],
            ["{{ハイライトのカラー}}", "ハイライトのカラー"],
            ["{{ハイライトのアルファ}}", "ハイライトのアルファ"],
            ["{{グラデーションカラー}}", "グラデーションカラー"],
            ["{{グラデーションのアルファ}}", "グラデーションのアルファ"],
            ["{{タブの移動・名前を変更}}", "タブの移動・名前を変更"],
            ["{{プロジェクトを閉じる}}", "プロジェクトを閉じる"],
            ["{{上下に移動}}", "上下に移動"],
            ["{{レイヤー変更(ダブルクリック)}}", "レイヤー変更(ダブルクリック)"],
            ["{{レイヤーをハイライト}}", "レイヤーをハイライト"],
            ["{{レイヤーを非表示}}", "レイヤーを非表示"],
            ["{{レイヤーをロック}}", "レイヤーをロック"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "カーブポインター(ダブルクリックでON/OFF)"],
            ["{{インスタンス名}}", "インスタンス名"],
            ["{{ライブラリ内の検索}}", "ライブラリ内の検索"],
            ["{{フレームラベル}}", "フレームラベル"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Korean extends Language
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();
    }

    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{フレームピッカー}}", "프레임 선택기"],
            ["{{左揃え}}", "왼쪽 정렬"],
            ["{{中央揃え(水平方向)}}", "중앙 정렬(수평 방향)"],
            ["{{右揃え}}", "오른쪽 정렬"],
            ["{{上揃え}}", "상단 정렬"],
            ["{{中央揃え(垂直方向)}}", "중앙 정렬(수직 방향)"],
            ["{{下揃え}}", "아래 정렬"],
            ["{{開始フレーム}}", "시작 프레임"],
            ["{{終了フレーム}}", "종료 프레임"],
            ["{{ループで再生}}", "루프로 재생"],
            ["{{1回再生}}", "한 번 재생"],
            ["{{指定したフレームで固定}}", "지정된 프레임으로 고정"],
            ["{{1回逆再生}}", "1회 역재생"],
            ["{{逆ループで再生}}", "역 루프로 재생"],
            ["{{画面の拡大・縮小}}", "화면 확대/축소"],
            ["{{カスタムイージングデータを保存}}", "맞춤형 여유 데이터 저장"],
            ["{{カスタムイージングデータの読込}}", "사용자 정의 여유 데이터 읽기"],
            ["{{プレビューのON/OFF}}", "프레뷰의 ON/OFF"],
            ["{{フォント枠サイズ}}", "글꼴 프레임 크기"],
            ["{{フォント枠カラー}}", "글꼴 프레임 색상"],
            ["{{オニオンスキン}}", "양파 껍질"],
            ["{{バケツツール}}", "버킷 도구"],
            ["{{ペンツール}}", "펜 도구"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "곡선 점을 추가하려면 두 번 클릭"],
            ["{{選択ツール}}", "선택 도구"],
            ["{{Shape変形ツール}}", "모양 변형 도구"],
            ["{{テキストツール}}", "텍스트 도구"],
            ["{{短形ツール}}", "너무 직사각형"],
            ["{{楕円ツール}}", "타원 도구"],
            ["{{角丸矩形ツール}}", "둥근 사각형 도구"],
            ["{{塗りのカラー}}", "채우기 색상"],
            ["{{線のカラー}}", "획 색상"],
            ["{{線の太さ}}", "획 폭"],
            ["{{プロジェクトデータの読込}}", "프로젝트 데이터 로드"],
            ["{{プロジェクトデータを保存}}", "프로젝트 데이터 저장"],
            ["{{書き出し}}", "내 보내다"],
            ["{{Discordへ移動}}", "불화로 이동"],
            ["{{バグ報告}}", "버그 보고서"],
            ["{{設定}}", "환경"],
            ["{{タブを追加}}", "탭 추가"],
            ["{{タブの一覧を表示・移動}}", "탭 목록 보기 및 이동"],
            ["{{スクリプトを追加}}", "스크립트 추가"],
            ["{{キーフレームを追加}}", "키프레임 추가"],
            ["{{空のキーフレームを追加}}", "빈 키프레임 추가"],
            ["{{フレームを追加}}", "프레임 추가"],
            ["{{フレームを削除}}", "프레임 삭제"],
            ["{{再生}}", "놀다"],
            ["{{停止}}", "중지"],
            ["{{ループ設定}}", "루프 설정"],
            ["{{レイヤーを追加}}", "레이어 추가"],
            ["{{レイヤーを削除}}", "레이어 삭제"],
            ["{{全てのレイヤーをハイライト}}", "모든 레이어 강조 표시"],
            ["{{全てのレイヤーを非表示}}", "모든 레이어 숨기기"],
            ["{{全てのレイヤーをロック}}", "모든 레이어 잠금"],
            ["{{比率を固定}}", "고정 비율"],
            ["{{ステージの幅}}", "무대 폭"],
            ["{{背景色}}", "배경색"],
            ["{{ステージの高さ}}", "무대 높이"],
            ["{{フレームレート}}", "프레임 속도"],
            ["{{シンボル名}}", "기호 이름"],
            ["{{イージング設定}}", "이징 설정"],
            ["{{ビデオの音量設定}}", "비디오 볼륨 설정"],
            ["{{自動再生}}", "자동 재생"],
            ["{{テキストエリアのボーダー設定}}", "텍스트 영역 테두리 설정"],
            ["{{テキスト入力設定}}", "텍스트 입력 설정"],
            ["{{フォント選択}}", "글꼴 선택"],
            ["{{自動サイズ調整}}", "자동 크기 조정"],
            ["{{フォントスタイルタイプ}}", "글꼴 스타일 유형"],
            ["{{行揃え}}", "정렬 설정"],
            ["{{改行設定}}", "개행 설정"],
            ["{{スクロール設定}}", "스크롤 설정"],
            ["{{フォントサイズ}}", "글꼴 크기"],
            ["{{フォントカラー}}", "글꼴 색상"],
            ["{{行間}}", "줄 간격"],
            ["{{文字幅}}", "문자 너비"],
            ["{{左マージン}}", "왼쪽 여백"],
            ["{{右マージン}}", "오른쪽 여백"],
            ["{{カラー種別の選択}}", "색상 유형 선택"],
            ["{{背景画像の選択}}", "배경 이미지 선택"],
            ["{{カラーポインターを追加}}", "색상 포인터 추가"],
            ["{{カラー値}}", "색상"],
            ["{{アルファ(0%-100%)}}", "알파(0%-100%)"],
            ["{{アルファ値}}", "알파"],
            ["{{選択対象の幅}}", "선택 개체의 너비"],
            ["{{選択対象のX座標}}", "선택 객체의 X 좌표"],
            ["{{選択対象の高さ}}", "선택 개체의 높이"],
            ["{{選択対象のY座標}}", "선택 객체의 Y 좌표"],
            ["{{選択対象の幅の伸縮}}", "선택한 객체의 scaleX"],
            ["{{選択対象を回転}}", "개체 회전"],
            ["{{選択対象の高さの伸縮}}", "선택한 객체의 scaleY"],
            ["{{アルファオフセット(-255〜255)}}", "알파 오프셋(-255〜255)"],
            ["{{赤(0%-100%)}}", "빨간색(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "레드 오프셋(-255〜255)"],
            ["{{緑(0%-100%)}}", "녹색(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "그린 오프셋(-255〜255)"],
            ["{{青(0%-100%)}}", "파란색(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "블루 오프셋(-255〜255)"],
            ["{{ブレンドモード}}", "혼합 모드"],
            ["{{フィルターを選択}}", "필터 선택"],
            ["{{フィルターを追加}}", "필터 추가"],
            ["{{サウンドを追加}}", "소리 추가"],
            ["{{フィルターを表示・非表示する}}", "필터 표시 및 숨기기"],
            ["{{フィルターを削除}}", "필터 삭제"],
            ["{{水平方向にぼかす}}", "수평으로 흐림"],
            ["{{垂直方向にぼかす}}", "수직으로 흐림"],
            ["{{フィルター強度}}", "필터 강도"],
            ["{{フィルター角度}}", "필터 각도"],
            ["{{シャドウのアルファ}}", "섀도우 알파"],
            ["{{シャドウのカラー}}", "그림자 색상"],
            ["{{フィルター距離}}", "필터 거리"],
            ["{{ハイライトのカラー}}", "하이라이트 색상"],
            ["{{ハイライトのアルファ}}", "하이라이트 알파"],
            ["{{グラデーションカラー}}", "그라데이션 색상"],
            ["{{グラデーションのアルファ}}", "그라디언트 알파"],
            ["{{タブの移動・名前を変更}}", "탭 이동/이름 바꾸기"],
            ["{{プロジェクトを閉じる}}", "프로젝트 닫기"],
            ["{{上下に移動}}", "위아래로 이동"],
            ["{{レイヤー変更(ダブルクリック)}}", "레이어 변경(더블 클릭)"],
            ["{{レイヤーをハイライト}}", "하이라이트 레이어"],
            ["{{レイヤーを非表示}}", "레이어 숨기기"],
            ["{{レイヤーをロック}}", "레이어 잠금"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "곡선 포인터(켜기/끄려면 두 번 클릭)"],
            ["{{インスタンス名}}", "인스턴스 이름"],
            ["{{ライブラリ内の検索}}", "도서관에서 검색"],
            ["{{フレームラベル}}", "프레임 라벨"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "프로젝트를 저장하지 않으면 이 탭의 프로젝트 데이터를 복구할 수 없습니다. 탭을 삭제하시겠습니까?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Russia extends Language
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();
    }

    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{フレームピッカー}}", "подборщик рам"],
            ["{{左揃え}}", "Слева"],
            ["{{中央揃え(水平方向)}}", "Центр (горизонтальность)"],
            ["{{右揃え}}", "Справа"],
            ["{{上揃え}}", "Топ"],
            ["{{中央揃え(垂直方向)}}", "Центр (вертикальный)"],
            ["{{下揃え}}", "Дно"],
            ["{{開始フレーム}}", "начальная рамка"],
            ["{{終了フレーム}}", "торцевая рама"],
            ["{{ループで再生}}", "Воспроизведение по кругу"],
            ["{{1回再生}}", "1 воспроизведение"],
            ["{{指定したフレームで固定}}", "Фиксируется в указанном кадре"],
            ["{{1回逆再生}}", "1 воспроизведение в обратном направлении"],
            ["{{逆ループで再生}}", "Воспроизведение в обратном цикле"],
            ["{{画面の拡大・縮小}}", "Увеличение и уменьшение масштаба экрана"],
            ["{{カスタムイージングデータを保存}}", "Сохраните данные пользовательского смягчения"],
            ["{{カスタムイージングデータの読込}}", "Чтение пользовательских данных о смягчении"],
            ["{{プレビューのON/OFF}}", "Включение/выключение предварительного просмотра"],
            ["{{フォント枠サイズ}}", "Размер рамки шрифта"],
            ["{{フォント枠カラー}}", "Цвет шрифтовой рамки"],
            ["{{オニオンスキン}}", "Луковая шкурка"],
            ["{{バケツツール}}", "Ведерные инструменты"],
            ["{{ペンツール}}", "Инструмент \"Перо"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Дважды щелкните, чтобы добавить точку кривой"],
            ["{{選択ツール}}", "Инструменты выбора"],
            ["{{Shape変形ツール}}", "Инструмент преобразования формы"],
            ["{{テキストツール}}", "Текстовый инструмент"],
            ["{{短形ツール}}", "Инструмент \"Прямоугольник"],
            ["{{楕円ツール}}", "Инструмент \"Эллипс"],
            ["{{角丸矩形ツール}}", "Инструмент \"Скругленный прямоугольник"],
            ["{{塗りのカラー}}", "Цвет заливки"],
            ["{{線のカラー}}", "Цвет штриха"],
            ["{{線の太さ}}", "Ширина штриха"],
            ["{{プロジェクトデータの読込}}", "Загрузка данных проекта"],
            ["{{プロジェクトデータを保存}}", "Сохранить данные проекта"],
            ["{{書き出し}}", "Экспорт"],
            ["{{Discordへ移動}}", "Зайдите в дискорд"],
            ["{{バグ報告}}", "Сообщения об ошибках"],
            ["{{設定}}", "Настройка"],
            ["{{タブを追加}}", "Добавить вкладку"],
            ["{{タブの一覧を表示・移動}}", "Просмотр и перемещение по списку вкладок"],
            ["{{スクリプトを追加}}", "Добавить сценарий"],
            ["{{キーフレームを追加}}", "Добавить ключевой кадр"],
            ["{{空のキーフレームを追加}}", "Добавьте пустой ключевой кадр"],
            ["{{フレームを追加}}", "Добавить рамку"],
            ["{{フレームを削除}}", "Удалить рамку"],
            ["{{再生}}", "Играть"],
            ["{{停止}}", "Остановить"],
            ["{{ループ設定}}", "Настройка контура"],
            ["{{レイヤーを追加}}", "Добавить слой"],
            ["{{レイヤーを削除}}", "Удалить слой"],
            ["{{全てのレイヤーをハイライト}}", "Выделите все слои"],
            ["{{全てのレイヤーを非表示}}", "Скрыть все слои"],
            ["{{全てのレイヤーをロック}}", "Заблокируйте все слои"],
            ["{{比率を固定}}", "Фиксированный коэффициент"],
            ["{{ステージの幅}}", "Ширина сцены"],
            ["{{背景色}}", "Цвет фона"],
            ["{{ステージの高さ}}", "Высота сцены"],
            ["{{フレームレート}}", "Частота кадров"],
            ["{{シンボル名}}", "Название символа"],
            ["{{イージング設定}}", "Установка облегчения"],
            ["{{ビデオの音量設定}}", "Настройка громкости видео"],
            ["{{自動再生}}", "Автоматическое воспроизведение"],
            ["{{テキストエリアのボーダー設定}}", "Настройка границ текстовой области"],
            ["{{テキスト入力設定}}", "Настройка ввода текста"],
            ["{{フォント選択}}", "Выбор шрифта"],
            ["{{自動サイズ調整}}", "Автоматическая регулировка размера"],
            ["{{フォントスタイルタイプ}}", "Тип стиля шрифта"],
            ["{{行揃え}}", "Настройка выравнивания"],
            ["{{改行設定}}", "Установка новой строки"],
            ["{{スクロール設定}}", "Настройка прокрутки"],
            ["{{フォントサイズ}}", "Размер шрифта"],
            ["{{フォントカラー}}", "Цвет шрифта"],
            ["{{行間}}", "Пространство линии"],
            ["{{文字幅}}", "Ширина символа"],
            ["{{左マージン}}", "Левое поле"],
            ["{{右マージン}}", "Правая граница"],
            ["{{カラー種別の選択}}", "Выберите тип цвета"],
            ["{{背景画像の選択}}", "Выбор фонового изображения"],
            ["{{カラーポインターを追加}}", "Добавьте указатели цвета"],
            ["{{カラー値}}", "Цвет"],
            ["{{アルファ(0%-100%)}}", "Альфа(0%-100%)"],
            ["{{アルファ値}}", "Альфа"],
            ["{{選択対象の幅}}", "Ширина объекта выделения"],
            ["{{選択対象のX座標}}", "X координата объекта выделения"],
            ["{{選択対象の高さ}}", "Высота объекта выделения"],
            ["{{選択対象のY座標}}", "Y координата объекта выделения"],
            ["{{選択対象の幅の伸縮}}", "масштабX выбранного объекта"],
            ["{{選択対象を回転}}", "Повернуть объект"],
            ["{{選択対象の高さの伸縮}}", "scaleY выбранного объекта"],
            ["{{アルファオフセット(-255〜255)}}", "Альфа-смещение(-255〜255)"],
            ["{{赤(0%-100%)}}", "Красный(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Красное смещение(-255〜255)"],
            ["{{緑(0%-100%)}}", "Зеленый(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Зеленый зачет(-255〜255)"],
            ["{{青(0%-100%)}}", "Голубой(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Синее смещение(-255〜255)"],
            ["{{ブレンドモード}}", "Режим наложения"],
            ["{{フィルターを選択}}", "Выберите фильтр"],
            ["{{フィルターを追加}}", "Добавить фильтр"],
            ["{{サウンドを追加}}", "Добавить звук"],
            ["{{フィルターを表示・非表示する}}", "Показать и скрыть фильтры"],
            ["{{フィルターを削除}}", "Удалить фильтр"],
            ["{{水平方向にぼかす}}", "Размытие по горизонтали"],
            ["{{垂直方向にぼかす}}", "Размытие по вертикали"],
            ["{{フィルター強度}}", "Прочность фильтра"],
            ["{{フィルター角度}}", "Угол фильтрации"],
            ["{{シャドウのアルファ}}", "Тень Альфа"],
            ["{{シャドウのカラー}}", "Цвет теней"],
            ["{{フィルター距離}}", "Расстояние между фильтрами"],
            ["{{ハイライトのカラー}}", "Цвет подсветки"],
            ["{{ハイライトのアルファ}}", "Выделение Альфа"],
            ["{{グラデーションカラー}}", "Цвет градиента"],
            ["{{グラデーションのアルファ}}", "Градиент Альфа"],
            ["{{タブの移動・名前を変更}}", "Переместить/именовать вкладки"],
            ["{{プロジェクトを閉じる}}", "Закрыть проект"],
            ["{{上下に移動}}", "Двигайтесь вверх и вниз"],
            ["{{レイヤー変更(ダブルクリック)}}", "Смена слоя (двойной щелчок)"],
            ["{{レイヤーをハイライト}}", "Выделительный слой"],
            ["{{レイヤーを非表示}}", "Скрыть слой"],
            ["{{レイヤーをロック}}", "Заблокировать слой"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Указатель кривой (двойной щелчок для включения/выключения)"],
            ["{{インスタンス名}}", "Имя экземпляра"],
            ["{{ライブラリ内の検索}}", "Поиск в библиотеке"],
            ["{{フレームラベル}}", "Рамочная этикетка"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "Если проект не сохранен, данные проекта на этой вкладке не могут быть восстановлены. Вы хотите удалить вкладку?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Spanish extends Language
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();
    }

    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{フレームピッカー}}", "Recogedor de marcos"],
            ["{{左揃え}}", "Izquierda"],
            ["{{中央揃え(水平方向)}}", "Centro (Horizontal)"],
            ["{{右揃え}}", "Derecho"],
            ["{{上揃え}}", "Arriba"],
            ["{{中央揃え(垂直方向)}}", "Centro (Vertical)"],
            ["{{下揃え}}", "Fondo"],
            ["{{開始フレーム}}", "marco de inicio"],
            ["{{終了フレーム}}", "marco final"],
            ["{{ループで再生}}", "Reproducir en bucle"],
            ["{{1回再生}}", "1 reproducción"],
            ["{{指定したフレームで固定}}", "Fijado en el marco especificado"],
            ["{{1回逆再生}}", "1 reproducción inversa"],
            ["{{逆ループで再生}}", "Reproducción en bucle invertido"],
            ["{{画面の拡大・縮小}}", "Acercar y alejar la pantalla"],
            ["{{カスタムイージングデータを保存}}", "Guarda los datos de la flexión personalizada"],
            ["{{カスタムイージングデータの読込}}", "Lectura de datos de flexibilización personalizados"],
            ["{{プレビューのON/OFF}}", "Activación/desactivación de la vista previa"],
            ["{{フォント枠サイズ}}", "Tamaño del marco de la fuente"],
            ["{{フォント枠カラー}}", "Color del marco de la fuente"],
            ["{{オニオンスキン}}", "Piel de cebolla"],
            ["{{バケツツール}}", "Herramientas para cubos"],
            ["{{ペンツール}}", "Herramienta de la pluma"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Haga doble clic para añadir un punto de curva"],
            ["{{選択ツール}}", "Herramientas de selección"],
            ["{{Shape変形ツール}}", "Herramienta de transformación de formas"],
            ["{{テキストツール}}", "Herramienta de texto"],
            ["{{短形ツール}}", "Herramienta Rectángulo"],
            ["{{楕円ツール}}", "Herramienta Elipse"],
            ["{{角丸矩形ツール}}", "Herramienta Rectángulo Redondeado"],
            ["{{塗りのカラー}}", "Color de relleno"],
            ["{{線のカラー}}", "Color del trazo"],
            ["{{線の太さ}}", "Anchura de la carrera"],
            ["{{プロジェクトデータの読込}}", "Carga de los datos del proyecto"],
            ["{{プロジェクトデータを保存}}", "Guardar los datos del proyecto"],
            ["{{書き出し}}", "Exportar"],
            ["{{Discordへ移動}}", "Ir a la discordia"],
            ["{{バグ報告}}", "Informes de errores"],
            ["{{設定}}", "Configuración"],
            ["{{タブを追加}}", "Añadir una pestaña"],
            ["{{タブの一覧を表示・移動}}", "Ver y desplazarse por la lista de pestañas"],
            ["{{スクリプトを追加}}", "Añadir una secuencia de comandos"],
            ["{{キーフレームを追加}}", "Añadir un fotograma clave"],
            ["{{空のキーフレームを追加}}", "Añadir un fotograma clave vacío"],
            ["{{フレームを追加}}", "Añadir un marco"],
            ["{{フレームを削除}}", "Borrar el marco"],
            ["{{再生}}", "Juega a"],
            ["{{停止}}", "Detener"],
            ["{{ループ設定}}", "Ajuste del bucle"],
            ["{{レイヤーを追加}}", "Añadir una capa"],
            ["{{レイヤーを削除}}", "Eliminar la capa"],
            ["{{全てのレイヤーをハイライト}}", "Resaltar todas las capas"],
            ["{{全てのレイヤーを非表示}}", "Ocultar todas las capas"],
            ["{{全てのレイヤーをロック}}", "Bloquear todas las capas"],
            ["{{比率を固定}}", "Relación fija"],
            ["{{ステージの幅}}", "Anchura del escenario"],
            ["{{背景色}}", "Color de fondo"],
            ["{{ステージの高さ}}", "Altura del escenario"],
            ["{{フレームレート}}", "Velocidad de fotogramas"],
            ["{{シンボル名}}", "Nombre del símbolo"],
            ["{{イージング設定}}", "Ajuste de la flexibilización"],
            ["{{ビデオの音量設定}}", "Ajuste del volumen de vídeo"],
            ["{{自動再生}}", "Reproducción automática"],
            ["{{テキストエリアのボーダー設定}}", "Configuración del borde del área de texto"],
            ["{{テキスト入力設定}}", "Ajuste de la entrada de texto"],
            ["{{フォント選択}}", "Selección de fuentes"],
            ["{{自動サイズ調整}}", "Ajuste automático del tamaño"],
            ["{{フォントスタイルタイプ}}", "Tipo de letra"],
            ["{{行揃え}}", "Ajuste de la alineación"],
            ["{{改行設定}}", "Ajuste de la nueva línea"],
            ["{{スクロール設定}}", "Ajuste de desplazamiento"],
            ["{{フォントサイズ}}", "Tamaño de la fuente"],
            ["{{フォントカラー}}", "Color de la fuente"],
            ["{{行間}}", "Espacio de la línea"],
            ["{{文字幅}}", "Anchura de los caracteres"],
            ["{{左マージン}}", "Margen izquierdo"],
            ["{{右マージン}}", "Margen derecho"],
            ["{{カラー種別の選択}}", "Seleccione un tipo de color"],
            ["{{背景画像の選択}}", "Seleccionar una imagen de fondo"],
            ["{{カラーポインターを追加}}", "Añadir punteros de color"],
            ["{{カラー値}}", "Color"],
            ["{{アルファ(0%-100%)}}", "Alpha(0%-100%)"],
            ["{{アルファ値}}", "Alpha"],
            ["{{選択対象の幅}}", "Anchura del objeto de selección"],
            ["{{選択対象のX座標}}", "Coordenada X del objeto de selección"],
            ["{{選択対象の高さ}}", "Altura del objeto de selección"],
            ["{{選択対象のY座標}}", "Coordenada Y del objeto de selección"],
            ["{{選択対象の幅の伸縮}}", "scaleX del objeto seleccionado"],
            ["{{選択対象を回転}}", "Girar el objeto"],
            ["{{選択対象の高さの伸縮}}", "escalaY del objeto seleccionado"],
            ["{{アルファオフセット(-255〜255)}}", "Desplazamiento alfa(-255〜255)"],
            ["{{赤(0%-100%)}}", "Rojo(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Compensación roja(-255〜255)"],
            ["{{緑(0%-100%)}}", "Verde(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Compensación verde(-255〜255)"],
            ["{{青(0%-100%)}}", "Azul(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Offset azul(-255〜255)"],
            ["{{ブレンドモード}}", "Modo de fusión"],
            ["{{フィルターを選択}}", "Seleccione un filtro"],
            ["{{フィルターを追加}}", "Añadir un filtro"],
            ["{{サウンドを追加}}", "Añadir un sonido"],
            ["{{フィルターを表示・非表示する}}", "Mostrar y ocultar filtros"],
            ["{{フィルターを削除}}", "Eliminar el filtro"],
            ["{{水平方向にぼかす}}", "Desenfoque horizontal"],
            ["{{垂直方向にぼかす}}", "Desenfoque vertical"],
            ["{{フィルター強度}}", "Fuerza del filtro"],
            ["{{フィルター角度}}", "Ángulo del filtro"],
            ["{{シャドウのアルファ}}", "Sombra Alfa"],
            ["{{シャドウのカラー}}", "Color de la sombra"],
            ["{{フィルター距離}}", "Distancia del filtro"],
            ["{{ハイライトのカラー}}", "Color de realce"],
            ["{{ハイライトのアルファ}}", "Resaltar Alpha"],
            ["{{グラデーションカラー}}", "Color degradado"],
            ["{{グラデーションのアルファ}}", "Gradiente Alfa"],
            ["{{タブの移動・名前を変更}}", "Mover/Renombrar pestañas"],
            ["{{プロジェクトを閉じる}}", "Cerrar el proyecto"],
            ["{{上下に移動}}", "Subir y bajar"],
            ["{{レイヤー変更(ダブルクリック)}}", "Cambio de capa (doble clic)"],
            ["{{レイヤーをハイライト}}", "Capa de resaltado"],
            ["{{レイヤーを非表示}}", "Ocultar capa"],
            ["{{レイヤーをロック}}", "Bloquear la capa"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Puntero de curva (doble clic para activar/desactivar)"],
            ["{{インスタンス名}}", "Nombre de la instancia"],
            ["{{ライブラリ内の検索}}", "Buscar en la biblioteca"],
            ["{{フレームラベル}}", "Etiqueta del marco"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "Si el proyecto no se guarda, los datos del proyecto en esta pestaña no se pueden recuperar. ¿Desea eliminar la pestaña?"]
        ]);
    }
}

let characterId = 0;

const Util = {};

Util.VERSION                    = 1;
Util.PREFIX                     = "__next2d-tools__";
Util.STAGE_MIN_SIZE             = 1;
Util.STAGE_MAX_SIZE             = 3000;
Util.FONT_DEFAULT_SIZE          = 200;
Util.FONT_MIN_SIZE              = 10;
Util.FONT_MAX_SIZE              = 255;
Util.FONT_PARAM_MIN_SIZE        = 0;
Util.FONT_PARAM_MAX_SIZE        = 255;
Util.STAGE_DEFAULT_WIDTH        = 550;
Util.STAGE_DEFAULT_HEIGHT       = 400;
Util.STAGE_DEFAULT_FPS          = 24;
Util.STAGE_MIN_FPS              = 1;
Util.STAGE_MAX_FPS              = 60;
Util.STROKE_MIN_SIZE            = 0;
Util.STROKE_MAX_SIZE            = 200;
Util.STAGE_DEFAULT_COLOR        = "#ffffff";
Util.TOOLS_FILL_DEFAULT_COLOR   = "#000000";
Util.TOOLS_STROKE_DEFAULT_COLOR = "#000000";
Util.COLOR_MIN_OFFSET           = -255;
Util.COLOR_MAX_OFFSET           = 255;
Util.COLOR_MIN_MULTIPLIER       = 0;
Util.COLOR_MAX_MULTIPLIER       = 100;
Util.MIN_INT                    = -32768;
Util.MAX_INT                    = 32767;
Util.MIN_ROTATE                 = -360;
Util.MAX_ROTATE                 = 360;
Util.MIN_COLOR                  = 0;
Util.MAX_COLOR                  = 255;
Util.MIN_BLUR                   = 0;
Util.MAX_BLUR                   = 255;
Util.MIN_STRENGTH               = 0;
Util.MAX_STRENGTH               = 255;
Util.MIN_DISTANCE               = -255;
Util.MAX_DISTANCE               = 255;
Util.LAYER_MODE_NORMAL          = 0;
Util.LAYER_MODE_MASK            = 1;
Util.LAYER_MODE_MASK_IN         = 2;
Util.TIMELINE_DEFAULT_SIZE      = 280;
Util.TIMELINE_MIN_SIZE          = 150;
Util.CONTROLLER_DEFAULT_SIZE    = 360;
Util.REVISION_LIMIT             = 100;
Util.STAGE_SKIP_TARGETA         = 10;
Util.GRADIENT_CANVAS_WIDTH      = 255;
Util.GRADIENT_CANVAS_HEIGHT     = 30;
Util.SCRIPT_MODAL_WIDTH         = 620;
Util.SCRIPT_MODAL_HEIGHT        = 450;
Util.SCRIPT_MODAL_BAR_HEIGHT    = 25;
Util.MIN_VOLUME                 = 0;
Util.MAX_VOLUME                 = 100;
Util.FOLDER_OPEN                = "open";
Util.FOLDER_CLOSE               = "close";
Util.EASE_CANVAS_WIDTH          = 300;
Util.EASE_CANVAS_HEIGHT         = 400;
Util.EASE_BASE_CANVAS_SIZE      = 200;
Util.EASE_MIN_POINTER_X         = 6;
Util.EASE_MIN_POINTER_Y         = -5;
Util.EASE_MAX_POINTER_X         = 306;
Util.EASE_MAX_POINTER_Y         = 395;
Util.EASE_SCREEN_X              = 57;
Util.EASE_SCREEN_Y              = 94;
Util.EASE_MOVE_Y                = 294;
Util.EASE_OFFSET_X              = 50;
Util.EASE_OFFSET_Y              = 100;
Util.EASE_RANGE                 = 100;
Util.$activeWorkSpaceId         = 0;
Util.$workSpaces                = [];
Util.$readStatus                = 0;
Util.$readEnd                   = 5;
Util.$shiftKey                  = false;
Util.$zoomScale                 = 1;
Util.$frameWidth                = 65;
Util.$root                      = null;
Util.$Rad2Deg                   = 180 / Math.PI;
Util.$Deg2Rad                   = Math.PI / 180;
Util.$keyLock                   = false;
Util.$activeScript              = false;
Util.$previewMod                = false;
Util.$offsetLeft                = 0;
Util.$offsetTop                 = 0;
Util.$currentCursor             = "auto";
Util.$useIds                    = new Map();
Util.$symbols                   = new Map();
Util.$copyWorkSpaceId           = -1;
Util.$copyLibrary               = null;
Util.$copyLayer                 = null;
Util.$copyCharacter             = null;
Util.$canCopyLayer              = false;
Util.$canCopyCharacter          = false;
Util.$hitColor                  = null;
Util.$updated                   = false;
Util.$languages                 = new Map();
Util.$currentLanguage           = null;
Util.$shapePointerColor         = "#009900";
Util.$shapeLinkedPointerColor   = "#ffa500";
Util.$isMac                     = window.navigator.userAgent.indexOf("Mac") > -1;

const canvas     = document.createElement("canvas");
canvas.width     = 1;
canvas.height    = 1;
Util.$hitContext = canvas.getContext("2d");

Util.$transformTargets = [
    "scale-top-left",
    "scale-top-right",
    "scale-bottom-left",
    "scale-bottom-right",
    "scale-center-left",
    "scale-center-top",
    "scale-center-right",
    "scale-center-bottom",
    "target-rect",
    "target-rotation"
];

Util.$gridTargets = [
    "grid-top-left",
    "grid-top-right",
    "grid-bottom-left",
    "grid-bottom-right"
];

/**
 * @type {HTMLImageElement}
 */
Util.$emptyImage = new Image();
Util.$emptyImage.draggable = false;

/**
 * @param  {*}   value
 * @param  {int} min
 * @param  {int} max
 * @return {number}
 * @static
 */
Util.$clamp = function (value, min, max)
{
    const number = +value;
    return Math.min(Math.max(min, isNaN(number) ? 0 : number), max);
};

/**
 * @param  {*} source
 * @return {boolean}
 * @static
 */
Util.$isArray = function (source)
{
    return Array.isArray(source);
};

/**
 * @param  {string} [value="auto"]
 * @return {void}
 * @static
 */
Util.$setCursor = function (value = "auto")
{
    if (Util.$currentCursor !== value) {
        Util.$currentCursor = value;
        document
            .documentElement
            .style
            .setProperty("--tool-cursor", value);
    }
};

/**
 * @param  {HTMLElement} element
 * @return {void}
 * @static
 */
Util.$addModalEvent = function (element)
{
    const elements = element.querySelectorAll("[data-detail]");

    for (let idx = 0; idx < elements.length; ++idx) {

        const element = elements[idx];

        element.addEventListener("mouseover", function (event)
        {
            const object = Util.$tools.getUserPublishSetting();
            if ("modal" in object && !object.modal) {
                return ;
            }

            const element = document.getElementById("detail-modal");

            element.textContent = Util.$currentLanguage.replace(
                event.currentTarget.dataset.detail
            );

            // x position
            switch (true) {

                case element.clientWidth + event.pageX - 20 > window.innerWidth:
                    element.style.left = `${event.pageX - (element.clientWidth + event.pageX + 10 - window.innerWidth)}px`;
                    break;

                case 0 > event.pageX - 20:
                    element.style.left = "10px";
                    break;

                default:
                    element.style.left  = `${event.pageX - 20}px`;
                    break;

            }

            switch (true) {

                case element.clientHeight + event.pageY + 20 > window.innerHeight:
                    element.style.top = `${event.pageY - element.clientHeight - 20}px`;
                    break;

                default:
                    element.style.top = `${event.pageY + 20}px`;
                    break;

            }

            element.setAttribute("class", "fadeIn");

            element.dataset.timerId = setTimeout(function ()
            {
                if (!this.classList.contains("fadeOut")) {
                    this.setAttribute("class", "fadeOut");
                }
            }.bind(element), 1500);
        });

        element.addEventListener("mouseout", function ()
        {
            const object = Util.$tools.getUserPublishSetting();
            if ("modal" in object && !object.modal) {
                return ;
            }

            const element = document.getElementById("detail-modal");
            clearTimeout(element.dataset.timerId | 0);
            element.setAttribute("class", "fadeOut");
        });

    }
};

/**
 * @param  {string} ignore
 * @return {void}
 * @static
 */
Util.$endMenu = function (ignore)
{
    const names = [
        "timeline-menu",
        "library-menu",
        "tab-name-menu",
        "timeline-layer-menu",
        "scene-name-menu",
        "user-setting",
        "screen-menu",
        "editor-modal"
    ];

    for (let idx = 0; idx < names.length; ++idx) {

        const name = names[idx];
        if (name === ignore) {
            continue;
        }

        const menu = document.getElementById(name);
        if (menu.classList.contains("fadeIn")) {
            menu.setAttribute("class", "fadeOut");
        }

        if (name === "editor-modal"
            && Util.$timeline._$actionFrame > 0
        ) {
            Util.$timeline.saveActionScript();
        }
    }
};

/**
 * @param  {MouseEvent} event
 * @return {void}
 * @static
 */
Util.$changeScene = function (event)
{
    const scenes = document
        .getElementById("scene-name-menu-list");

    while (scenes.children.length) {
        scenes.children[0].remove();
    }

    const workSpace = Util.$currentWorkSpace();

    // add scene
    workSpace.root.addSceneName();

    // fixed logic
    document
        .getElementById("current-frame")
        .textContent = "1";

    document
        .getElementById("timeline-marker")
        .style
        .left = "0px";

    const base = document
        .getElementById("timeline-controller-base");

    if (base.scrollLeft) {
        Util.$timeline.moveTimeLine(0);
    }

    // update
    workSpace.scene = workSpace.getLibrary(
        event.currentTarget.dataset.libraryId | 0
    );
};

/**
 * @return {void}
 * @static
 */
Util.$loadSaveData = function ()
{
    const binary = localStorage
        .getItem(`${Util.PREFIX}@save-data`);

    if (binary) {

        let length = binary.length;

        let buffer = new Uint8Array(length);
        for (let idx = 0; idx < length; ++idx) {
            buffer[idx] = binary.charCodeAt(idx) & 0xff;
        }

        Util.$unZlibWorker.postMessage({
            "buffer": buffer,
            "type": "local"
        }, [buffer.buffer]);

    } else {

        Util.$workSpaces.push(new WorkSpace());

        Util.$screen.initializeTab();

        Util.$initializeEnd();

    }
};

/**
 * @param   {Float32Array} a
 * @param   {Float32Array} b
 * @returns {Float32Array}
 * @static
 */
Util.$multiplicationMatrix = function(a, b)
{
    return new Float32Array([
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        a[0] * b[4] + a[2] * b[5] + a[4],
        a[1] * b[4] + a[3] * b[5] + a[5]
    ]);
};

/**
 * @param  {KeyboardEvent} event
 * @return {boolean}
 */
Util.$keyCommandFunction = function (event)
{
    Util.$shiftKey = event.shiftKey;

    switch (event.code) {

        case "ArrowRight":
        case "ArrowLeft":
        case "ArrowDown":
        case "ArrowUp":
            if (!Util.$keyLock) {
                event.preventDefault();
                return false;
            }
            break;

        case "KeyS": // save
            if (event.ctrlKey && !event.metaKey
                || !event.ctrlKey && event.metaKey
            ) {
                event.preventDefault();
                Util.$autoSave();
                return false;
            }
            break;

        case "KeyZ": // undo
            if (event.ctrlKey && !event.metaKey
                || !event.ctrlKey && event.metaKey
            ) {
                event.preventDefault();

                // reset
                Util.$screen.clearActiveCharacter();
                Util.$screen.clearTweenMarker();
                Util.$tools.deactiveStageAreaNode();

                if (Util.$currentWorkSpace()) {
                    if (event.shiftKey) {
                        Util
                            .$currentWorkSpace()
                            .redo();
                    } else {
                        Util
                            .$currentWorkSpace()
                            .undo();
                    }
                }

                return false;
            }
            break;

        case "Enter":
            if (event.ctrlKey && !event.metaKey // windows
                || !event.ctrlKey && event.metaKey // mac
            ) {

                if (Util.$previewMode) {
                    return false;
                }

                if (!Util.$keyLock || Util.$keyLock && Util.$activeScript) {
                    event.preventDefault();
                    Util.$showPreview();
                    return false;
                }

            }

            if (!Util.$keyLock && !Util.$activeScript) {

                event.preventDefault();

                if (Util.$timeline._$stopFlag) {
                    Util.$timeline.play();
                } else {
                    Util.$timeline.stop();
                }

            }
            break;

        case "Escape":
            if (Util.$previewMode) {
                event.preventDefault();
                Util.$hidePreview();
                return false;
            }
            break;

    }
};

/**
 * @return {void}
 * @static
 */
Util.$initialize = function ()
{
    // end event
    window.removeEventListener("DOMContentLoaded", Util.$initialize);

    Util.$filterClasses = {
        "BevelFilter": BevelFilter,
        "BlurFilter": BlurFilter,
        "DropShadowFilter": DropShadowFilter,
        "GlowFilter": GlowFilter,
        "GradientBevelFilter": GradientBevelFilter,
        "GradientGlowFilter": GradientGlowFilter
    };

    Util.$languages.set("Japanese", Japanese);
    Util.$languages.set("English", English);
    Util.$languages.set("Chinese", Chinese);
    Util.$languages.set("Korean", Korean);
    Util.$languages.set("French", French);
    Util.$languages.set("Russia", Russia);
    Util.$languages.set("Italiano", Italiano);
    Util.$languages.set("Spanish", Spanish);

    let language = localStorage
        .getItem(`${Util.PREFIX}@language-setting`);

    if (!language) {

        switch (navigator.language) {

            case "ja":
                language = "Japanese";
                break;

            case "ko":
                language = "Korean";
                break;

            case "zh":
                language = "Chinese";
                break;

            case "fr":
                language = "French";
                break;

            case "ru":
                language = "Russia";
                break;

            case "it":
                language = "Italiano";
                break;

            case "es":
                language = "Spanish";
                break;

            default:
                language = "English";
                break;

        }

    }

    const LanguageClass = Util.$languages.get(language);
    Util.$currentLanguage = new LanguageClass();

    // load local data
    Util.$loadSaveData();

    // added event
    window.addEventListener("keydown", Util.$keyCommandFunction);

    // key reset
    window.addEventListener("keyup", function ()
    {
        Util.$shiftKey = false;
    });

    window.addEventListener("beforeunload", function (event)
    {
        if (Util.$updated) {

            event.preventDefault();
            event.returnValue = "データ保存中...";

            Util.$autoSave();

        }
    });

    const width  = Util.STAGE_DEFAULT_WIDTH;
    const height = Util.STAGE_DEFAULT_HEIGHT;
    const fps    = Util.STAGE_DEFAULT_FPS;

    const previewDisplay = document.getElementById("preview-display");
    previewDisplay.style.width  = `${width}px`;
    previewDisplay.style.height = `${height}px`;

    Util.$root = window
        .next2d
        .createRootMovieClip(width, height, fps, {
            "tagId": "preview-display"
        });

    Util.$root.stage._$player.stop();

    document
        .getElementById("preview-stop")
        .addEventListener("click", Util.$hidePreview);

    // 課金設定
    let usePaid = false;
    if (usePaid) {

        document.getElementById("advertisement").remove();

        document
            .documentElement
            .style
            .setProperty("--ad", "0px");

        // document
        //     .getElementById("user-plan").
        //     style.display = "none";

    } else {

        document
            .documentElement
            .style
            .setProperty("--ad", "260px");

    }

    // clear
    Util.$initialize = null;
};
window.addEventListener("DOMContentLoaded", Util.$initialize);

/**
 * @return {void}
 * @static
 */
Util.$showPreview = function ()
{
    Util.$timeline.saveActionScript();

    Util.$previewMode = true;
    Util.$keyLock     = true;

    const element = document.getElementById("player-preview");
    element.style.display = "";
    element.style.zIndex  = "9999";

    const workSpace = Util.$currentWorkSpace();

    const preview = document.getElementById("preview-display");
    preview.style.width  = `${workSpace.stage.width}px`;
    preview.style.height = `${workSpace.stage.height}px`;

    const stopElement = document.getElementById("preview-stop");
    stopElement.style.top  = `${preview.offsetTop - 20}px`;
    stopElement.style.left = `${preview.offsetLeft + workSpace.stage.width}px`;
    stopElement.addEventListener("click", Util.$hidePreview);

    const stage = Util.$root.stage;
    stage.frameRate = document.getElementById("stage-fps").value | 0;

    const player  = stage._$player;
    player.width  = workSpace.stage.width;
    player.height = workSpace.stage.height;

    // fixed logic
    player._$resize();
    stage.clearGlobalVariable();
    stage._$events = new Map();
    player._$broadcastEvents = new Map();

    const json = Publish.toJSON();
    Util.$useIds.clear();

    const { Loader } = window.next2d.display;
    const { URLRequest } = window.next2d.net;
    const { Event } = window.next2d.events;

    const loader = new Loader();

    loader
        .contentLoaderInfo
        .addEventListener(Event.COMPLETE, function (event)
        {
            const loaderInfo = event.currentTarget;

            const stage  = Util.$root.stage;
            const player = stage._$player;
            const data   = loaderInfo._$data;

            player.width  = data.stage.width;
            player.height = data.stage.height;
            player.stage.frameRate = data.stage.fps;

            const color = Util.$intToRGB(
                `0x${data.stage.bgColor.substr(1)}` | 0
            );

            player._$context._$setColor(
                color.R / 255,
                color.G / 255,
                color.B / 255,
                1
            );

            player._$backgroundColor = [
                color.R / 255,
                color.G / 255,
                color.B / 255,
                1
            ];

            Util.$root = null;
            Util.$root = loaderInfo.content;
            while (stage.numChildren) {
                stage.removeChildAt(0);
            }

            stage.addChild(Util.$root);

            player._$cacheStore.reset();
            player.play();
        });

    loader.load(new URLRequest(
        URL.createObjectURL(new Blob([json], { "type": "application/json" }))
    ));

    // setup clear
    player._$broadcastEvents.clear();
    window.next2d.media.SoundMixer.volume = 1;

    player._$loadStatus = 1;
    player._$updateLoadStatus();
};

/**
 * @return {void}
 * @static
 */
Util.$hidePreview = function ()
{
    const stopElement = document.getElementById("preview-stop");
    stopElement.removeEventListener("click", Util.$hidePreview);

    const element = document.getElementById("player-preview");
    element.style.display = "none";
    element.style.zIndex  = "0";

    Util.$previewMode = false;
    if (!Util.$activeScript) {
        Util.$keyLock = false;
    }

    while (Util.$root.numChildren) {
        Util.$root.removeChild(Util.$root.getChildAt(0));
    }
    Util.$root.stage._$player.stop();
};

/**
 * @return {string}
 * @static
 */
Util.$toJSON = function ()
{
    const data = [];

    const children = document
        .getElementById("view-tab-area")
        .children;

    for (let idx = 0; idx < children.length; ++idx) {

        const node = children[idx];

        const workSpace = Util.$workSpaces[node.dataset.tabId | 0];
        if (!workSpace) {
            continue;
        }

        data.push(workSpace.toJSON());

    }

    return JSON.stringify(data);
};

/**
 * @return {void}
 * @static
 */
Util.$autoSave = function ()
{
    Util.$timeline.saveActionScript();

    const postData = {
        "object": Util.$toJSON(),
        "type": "local"
    };

    if (Util.$zlibWorkerActive) {

        Util.$zlibQueues.push(postData);

    } else {

        Util.$zlibWorkerActive = true;
        Util.$zlibWorker.postMessage(postData);

    }

};

/**
 * @return {WorkSpace}
 * @static
 */
Util.$currentWorkSpace = function ()
{
    return Util.$workSpaces[Util.$activeWorkSpaceId];
};

/**
 * @return {void}
 * @static
 */
Util.$initializeEnd = function ()
{
    Util.$readStatus++;
    if (Util.$readStatus === Util.$readEnd) {
        Util.$currentWorkSpace().run();

        // サウンドセレクト起動
        Util.$controller.createSoundListArea();
    }
};

/**
 * @param {number} id
 * @static
 */
Util.$changeWorkSpace = function (id)
{
    Util.$currentWorkSpace().stop();

    Util.$activeWorkSpaceId = id | 0;

    Util.$currentWorkSpace().run();
};

// ZLIB Inflate Worker
Util.$unZlibWorker = new Worker(URL.createObjectURL(
    new Blob(["/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function(){\"use strict\";let t,i=this;function r(r,e){let s=r.split(\".\"),h=i;!(s[0]in h)&&h.execScript&&h.execScript(\"var \"+s[0]);for(var n;s.length&&(n=s.shift());)s.length||e===t?h=h[n]?h[n]:h[n]={}:h[n]=e}let e=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Uint32Array&&\"undefined\"!=typeof DataView;function s(t){let i,r,s,h,n,a,f,o,l,u,c=t.length,b=0,y=Number.POSITIVE_INFINITY;for(o=0;o<c;++o)t[o]>b&&(b=t[o]),t[o]<y&&(y=t[o]);for(i=1<<b,r=new(e?Uint32Array:Array)(i),s=1,h=0,n=2;s<=b;){for(o=0;o<c;++o)if(t[o]===s){for(a=0,f=h,l=0;l<s;++l)a=a<<1|1&f,f>>=1;for(u=s<<16|o,l=a;l<i;l+=n)r[l]=u;++h}++s,h<<=1,n<<=1}return[r,b,y]}function h(t,i){switch(this.g=[],this.h=32768,this.d=this.f=this.a=this.l=0,this.input=e?new Uint8Array(t):t,this.m=!1,this.i=a,this.r=!1,!i&&(i={})||(i.index&&(this.a=i.index),i.bufferSize&&(this.h=i.bufferSize),i.bufferType&&(this.i=i.bufferType),i.resize&&(this.r=i.resize)),this.i){case n:this.b=32768,this.c=new(e?Uint8Array:Array)(32768+this.h+258);break;case a:this.b=0,this.c=new(e?Uint8Array:Array)(this.h),this.e=this.z,this.n=this.v,this.j=this.w;break;default:throw Error(\"invalid inflate mode\")}}var n=0,a=1,f={t:n,s:a};h.prototype.k=function(){for(;!this.m;){let N=T(this,3);switch(1&N&&(this.m=!0),N>>>=1,N){case 0:var i=this.input,r=this.a,h=this.c,f=this.b,o=i.length,l=t,u=h.length,b=t;if(this.d=this.f=0,r+1>=o)throw Error(\"invalid uncompressed block header: LEN\");if(l=i[r++]|i[r++]<<8,r+1>=o)throw Error(\"invalid uncompressed block header: NLEN\");if(l===~(i[r++]|i[r++]<<8))throw Error(\"invalid uncompressed block header: length verify\");if(r+l>i.length)throw Error(\"input buffer is broken\");switch(this.i){case n:for(;f+l>h.length;){if(l-=b=u-f,e)h.set(i.subarray(r,r+b),f),f+=b,r+=b;else for(;b--;)h[f++]=i[r++];this.b=f,h=this.e(),f=this.b}break;case a:for(;f+l>h.length;)h=this.e({p:2});break;default:throw Error(\"invalid inflate mode\")}if(e)h.set(i.subarray(r,r+l),f),f+=l,r+=l;else for(;l--;)h[f++]=i[r++];this.a=r,this.b=f,this.c=h;break;case 1:this.j(E,I);break;case 2:var y,p,d,g,w=T(this,5)+257,A=T(this,5)+1,v=T(this,4)+4,k=new(e?Uint8Array:Array)(c.length),U=t,m=t,z=t,j=t,x=t;for(x=0;x<v;++x)k[c[x]]=T(this,3);if(!e)for(x=v,v=k.length;x<v;++x)k[c[x]]=0;for(y=s(k),U=new(e?Uint8Array:Array)(w+A),x=0,g=w+A;x<g;)switch(m=S(this,y)){case 16:for(j=3+T(this,2);j--;)U[x++]=z;break;case 17:for(j=3+T(this,3);j--;)U[x++]=0;z=0;break;case 18:for(j=11+T(this,7);j--;)U[x++]=0;z=0;break;default:z=U[x++]=m}p=s(e?U.subarray(0,w):U.slice(0,w)),d=s(e?U.subarray(w):U.slice(w)),this.j(p,d);break;default:throw Error(\"unknown BTYPE: \"+N)}}return this.n()};var o,l,u=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],c=e?new Uint16Array(u):u,b=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],y=e?new Uint16Array(b):b,p=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],d=e?new Uint8Array(p):p,g=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],w=e?new Uint16Array(g):g,A=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],v=e?new Uint8Array(A):A,k=new(e?Uint8Array:Array)(288);for(o=0,l=k.length;o<l;++o)k[o]=143>=o?8:255>=o?9:279>=o?7:8;var U,m,E=s(k),z=new(e?Uint8Array:Array)(30);for(U=0,m=z.length;U<m;++U)z[U]=5;var I=s(z);function T(t,i){for(var r,e=t.f,s=t.d,h=t.input,n=t.a,a=h.length;s<i;){if(n>=a)throw Error(\"input buffer is broken\");e|=h[n++]<<s,s+=8}return r=e&(1<<i)-1,t.f=e>>>i,t.d=s-i,t.a=n,r}function S(t,i){for(var r,e,s=t.f,h=t.d,n=t.input,a=t.a,f=n.length,o=i[0],l=i[1];h<l&&!(a>=f);)s|=n[a++]<<h,h+=8;if((e=(r=o[s&(1<<l)-1])>>>16)>h)throw Error(\"invalid code length: \"+e);return t.f=s>>e,t.d=h-e,t.a=a,65535&r}function j(t,i){let r,e;if(this.input=t,this.a=0,!i&&(i={})||(i.index&&(this.a=i.index),i.verify&&(this.A=i.verify)),r=t[this.a++],e=t[this.a++],(15&r)!==x)throw Error(\"unsupported compression method\");if(this.method=x,0!=((r<<8)+e)%31)throw Error(\"invalid fcheck flag:\"+((r<<8)+e)%31);if(32&e)throw Error(\"fdict flag is not supported\");this.q=new h(t,{index:this.a,bufferSize:i.bufferSize,bufferType:i.bufferType,resize:i.resize})}h.prototype.j=function(t,i){let r=this.c,e=this.b;this.o=t;for(var s,h,n,a,f=r.length-258;256!==(s=S(this,t));)if(256>s)e>=f&&(this.b=e,r=this.e(),e=this.b),r[e++]=s;else for(a=y[h=s-257],0<d[h]&&(a+=T(this,d[h])),s=S(this,i),n=w[s],0<v[s]&&(n+=T(this,v[s])),e>=f&&(this.b=e,r=this.e(),e=this.b);a--;)r[e]=r[e++-n];for(;8<=this.d;)this.d-=8,this.a--;this.b=e},h.prototype.w=function(t,i){let r=this.c,e=this.b;this.o=t;for(var s,h,n,a,f=r.length;256!==(s=S(this,t));)if(256>s)e>=f&&(r=this.e(),f=r.length),r[e++]=s;else for(a=y[h=s-257],0<d[h]&&(a+=T(this,d[h])),s=S(this,i),n=w[s],0<v[s]&&(n+=T(this,v[s])),e+a>f&&(r=this.e(),f=r.length);a--;)r[e]=r[e++-n];for(;8<=this.d;)this.d-=8,this.a--;this.b=e},h.prototype.e=function(){let t,i,r=new(e?Uint8Array:Array)(this.b-32768),s=this.b-32768,h=this.c;if(e)r.set(h.subarray(32768,r.length));else for(t=0,i=r.length;t<i;++t)r[t]=h[t+32768];if(this.g.push(r),this.l+=r.length,e)h.set(h.subarray(s,s+32768));else for(t=0;32768>t;++t)h[t]=h[s+t];return this.b=32768,h},h.prototype.z=function(t){let i,r,s,h,n=this.input.length/this.a+1|0,a=this.input,f=this.c;return t&&(\"number\"==typeof t.p&&(n=t.p),\"number\"==typeof t.u&&(n+=t.u)),2>n?(r=(a.length-this.a)/this.o[2],h=r/2*258|0,s=h<f.length?f.length+h:f.length<<1):s=f.length*n,e?(i=new Uint8Array(s),i.set(f)):i=f,this.c=i},h.prototype.n=function(){let t,i,r,s,h,n=0,a=this.c,f=this.g,o=new(e?Uint8Array:Array)(this.l+(this.b-32768));if(0===f.length)return e?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);for(i=0,r=f.length;i<r;++i)for(t=f[i],s=0,h=t.length;s<h;++s)o[n++]=t[s];for(i=32768,r=this.b;i<r;++i)o[n++]=a[i];return this.g=[],this.buffer=o},h.prototype.v=function(){let t,i=this.b;return e?this.r?(t=new Uint8Array(i),t.set(this.c.subarray(0,i))):t=this.c.subarray(0,i):(this.c.length>i&&(this.c.length=i),t=this.c),this.buffer=t},j.prototype.k=function(){let t,i,r=this.input;if(t=this.q.k(),this.a=this.q.a,this.A){i=(r[this.a++]<<24|r[this.a++]<<16|r[this.a++]<<8|r[this.a++])>>>0;let f=t;if(\"string\"==typeof f){let t,i,r=f.split(\"\");for(t=0,i=r.length;t<i;t++)r[t]=(255&r[t].charCodeAt(0))>>>0;f=r}for(var e,s=1,h=0,n=f.length,a=0;0<n;){n-=e=1024<n?1024:n;do{h+=s+=f[a++]}while(--e);s%=65521,h%=65521}if(i!==(h<<16|s)>>>0)throw Error(\"invalid adler-32 checksum\")}return t};var x=8;r(\"Zlib.Inflate\",j),r(\"Zlib.Inflate.prototype.decompress\",j.prototype.k);let N,C,L,O,Z={ADAPTIVE:f.s,BLOCK:f.t};if(Object.keys)N=Object.keys(Z);else for(C in N=[],L=0,Z)N[L++]=C;for(L=0,O=N.length;L<O;++L)C=N[L],r(\"Zlib.Inflate.BufferType.\"+C,Z[C])}).call(this),this.addEventListener(\"message\",(function(t){const i=new Zlib.Inflate(t.data.buffer).decompress();let r=\"\";for(let t=0;t<i.length;t+=4096)r+=String.fromCharCode.apply(null,i.slice(t,t+4096));this.postMessage({json:r,type:t.data.type})}));"], { "type": "text/javascript" })
));

/**
 * @param {MessageEvent} event
 * @public
 */
Util.$unZlibWorker.onmessage = function (event)
{
    if (event.data.type === "n2d") {

        const workSpaces = new WorkSpace(decodeURIComponent(event.data.json));

        Util
            .$workSpaces
            .push(workSpaces);

        Util
            .$screen
            .addTab(workSpaces, Util.$workSpaces.length - 1);

    } else {

        const values = JSON.parse(decodeURIComponent(event.data.json));

        for (let idx = 0; idx < values.length; ++idx) {
            Util.$workSpaces.push(new WorkSpace(values[idx]));
        }

        if (!Util.$workSpaces.length) {
            Util.$workSpaces.push(new WorkSpace());
        }

        // タブセット
        Util.$screen.initializeTab();

        // end
        Util.$initializeEnd();

    }
};

// ZLIB Deflate Worker
Util.$zlibWorker = new Worker(URL.createObjectURL(
    new Blob(["/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function(){\"use strict\";let e,r=!0,t=this;function n(r,n){let a=r.split(\".\"),i=t;!(a[0]in i)&&i.execScript&&i.execScript(\"var \"+a[0]);for(var s;a.length&&(s=a.shift());)a.length||n===e?i=i[s]?i[s]:i[s]={}:i[s]=n}let a=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Uint32Array&&\"undefined\"!=typeof DataView;function i(e,r){if(this.index=\"number\"==typeof r?r:0,this.e=0,this.buffer=e instanceof(a?Uint8Array:Array)?e:new(a?Uint8Array:Array)(32768),2*this.buffer.length<=this.index)throw Error(\"invalid index\");this.buffer.length<=this.index&&s(this)}function s(e){let r,t=e.buffer,n=t.length,i=new(a?Uint8Array:Array)(n<<1);if(a)i.set(t);else for(r=0;r<n;++r)i[r]=t[r];return e.buffer=i}i.prototype.b=function(e,r,t){let n,a=this.buffer,i=this.index,f=this.e,h=a[i];if(t&&1<r&&(e=8<r?(l[255&e]<<24|l[e>>>8&255]<<16|l[e>>>16&255]<<8|l[e>>>24&255])>>32-r:l[e]>>8-r),8>r+f)h=h<<r|e,f+=r;else for(n=0;n<r;++n)h=h<<1|e>>r-n-1&1,8==++f&&(f=0,a[i++]=l[h],h=0,i===a.length&&(a=s(this)));a[i]=h,this.buffer=a,this.e=f,this.index=i},i.prototype.finish=function(){let e,r=this.buffer,t=this.index;return 0<this.e&&(r[t]<<=8-this.e,r[t]=l[r[t]],t++),a?e=r.subarray(0,t):(r.length=t,e=r),e};let f,h=new(a?Uint8Array:Array)(256);for(f=0;256>f;++f){for(var o=c=f,u=7,c=c>>>1;c;c>>>=1)o<<=1,o|=1&c,--u;h[f]=(o<<u&255)>>>0}var l=h;function b(e){this.buffer=new(a?Uint16Array:Array)(2*e),this.length=0}function y(e,r){this.d=g,this.i=0,this.input=a&&e instanceof Array?new Uint8Array(e):e,this.c=0,r&&(r.lazy&&(this.i=r.lazy),\"number\"==typeof r.compressionType&&(this.d=r.compressionType),r.outputBuffer&&(this.a=a&&r.outputBuffer instanceof Array?new Uint8Array(r.outputBuffer):r.outputBuffer),\"number\"==typeof r.outputIndex&&(this.c=r.outputIndex)),this.a||(this.a=new(a?Uint8Array:Array)(32768))}b.prototype.getParent=function(e){return 2*((e-2)/4|0)},b.prototype.push=function(e,r){let t,n,a,i=this.buffer;for(t=this.length,i[this.length++]=r,i[this.length++]=e;0<t&&(n=this.getParent(t),i[t]>i[n]);)a=i[t],i[t]=i[n],i[n]=a,a=i[t+1],i[t+1]=i[n+1],i[n+1]=a,t=n;return this.length},b.prototype.pop=function(){let e,r,t,n,a,i=this.buffer;for(r=i[0],e=i[1],this.length-=2,i[0]=i[this.length],i[1]=i[this.length+1],a=0;(n=2*a+2,!(n>=this.length))&&(n+2<this.length&&i[n+2]>i[n]&&(n+=2),i[n]>i[a]);)t=i[a],i[a]=i[n],i[n]=t,t=i[a+1],i[a+1]=i[n+1],i[n+1]=t,a=n;return{index:e,value:r,length:this.length}};var p,g=2,A={NONE:0,h:1,g:g,n:3},k=[];for(p=0;288>p;p++)switch(r){case 143>=p:k.push([p+48,8]);break;case 255>=p:k.push([p-144+400,9]);break;case 279>=p:k.push([p-256+0,7]);break;case 287>=p:k.push([p-280+192,8]);break;default:throw\"invalid literal: \"+p}function w(e,r){this.length=e,this.k=r}y.prototype.f=function(){let t,n,s,f,h=this.input;switch(this.d){case 0:for(s=0,f=h.length;s<f;){n=a?h.subarray(s,s+65535):h.slice(s,s+65535),s+=n.length;let r=n,t=s===f,i=e,o=e,u=e,c=e,l=e,b=this.a,y=this.c;if(a){for(b=new Uint8Array(this.a.buffer);b.length<=y+r.length+5;)b=new Uint8Array(b.length<<1);b.set(this.a)}if(i=t?1:0,b[y++]=0|i,o=r.length,u=65536+~o&65535,b[y++]=255&o,b[y++]=o>>>8&255,b[y++]=255&u,b[y++]=u>>>8&255,a)b.set(r,y),y+=r.length,b=b.subarray(0,y);else{for(c=0,l=r.length;c<l;++c)b[y++]=r[c];b.length=y}this.c=y,this.a=b}break;case 1:var o=new i(a?new Uint8Array(this.a.buffer):this.a,this.c);o.b(1,1,r),o.b(1,2,r);var u,c,l,b=v(this,h);for(u=0,c=b.length;u<c;u++)if(l=b[u],i.prototype.b.apply(o,k[l]),256<l)o.b(b[++u],b[++u],r),o.b(b[++u],5),o.b(b[++u],b[++u],r);else if(256===l)break;this.a=o.finish(),this.c=this.a.length;break;case g:var y,p,A,w,d,U,m,D,E,j,O,Z,B,C,I,M=new i(a?new Uint8Array(this.a.buffer):this.a,this.c),T=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=Array(19);for(y=g,M.b(1,1,r),M.b(y,2,r),p=v(this,h),m=N(U=x(this.m,15)),E=N(D=x(this.l,7)),A=286;257<A&&0===U[A-1];A--);for(w=30;1<w&&0===D[w-1];w--);var S,L,P,F,G,J,R=A,V=w,X=new(a?Uint32Array:Array)(R+V),Y=new(a?Uint32Array:Array)(316),q=new(a?Uint8Array:Array)(19);for(S=L=0;S<R;S++)X[L++]=U[S];for(S=0;S<V;S++)X[L++]=D[S];if(!a)for(S=0,F=q.length;S<F;++S)q[S]=0;for(S=G=0,F=X.length;S<F;S+=L){for(L=1;S+L<F&&X[S+L]===X[S];++L);if(P=L,0===X[S])if(3>P)for(;0<P--;)Y[G++]=0,q[0]++;else for(;0<P;)(J=138>P?P:138)>P-3&&J<P&&(J=P-3),10>=J?(Y[G++]=17,Y[G++]=J-3,q[17]++):(Y[G++]=18,Y[G++]=J-11,q[18]++),P-=J;else if(Y[G++]=X[S],q[X[S]]++,3>--P)for(;0<P--;)Y[G++]=X[S],q[X[S]]++;else for(;0<P;)(J=6>P?P:6)>P-3&&J<P&&(J=P-3),Y[G++]=16,Y[G++]=J-3,q[16]++,P-=J}for(t=a?Y.subarray(0,G):Y.slice(0,G),j=x(q,7),C=0;19>C;C++)z[C]=j[T[C]];for(d=19;4<d&&0===z[d-1];d--);for(O=N(j),M.b(A-257,5,r),M.b(w-1,5,r),M.b(d-4,4,r),C=0;C<d;C++)M.b(z[C],3,r);for(C=0,I=t.length;C<I;C++)if(Z=t[C],M.b(O[Z],j[Z],r),16<=Z){switch(C++,Z){case 16:B=2;break;case 17:B=3;break;case 18:B=7;break;default:throw\"invalid code: \"+Z}M.b(t[C],B,r)}var H,K,Q,W,$,_,ee,re,te=[m,U],ne=[E,D];for($=te[0],_=te[1],ee=ne[0],re=ne[1],H=0,K=p.length;H<K;++H)if(Q=p[H],M.b($[Q],_[Q],r),256<Q)M.b(p[++H],p[++H],r),W=p[++H],M.b(ee[W],re[W],r),M.b(p[++H],p[++H],r);else if(256===Q)break;this.a=M.finish(),this.c=this.a.length;break;default:throw\"invalid compression type\"}return this.a};let d=function(){function e(e){switch(r){case 3===e:return[257,e-3,0];case 4===e:return[258,e-4,0];case 5===e:return[259,e-5,0];case 6===e:return[260,e-6,0];case 7===e:return[261,e-7,0];case 8===e:return[262,e-8,0];case 9===e:return[263,e-9,0];case 10===e:return[264,e-10,0];case 12>=e:return[265,e-11,1];case 14>=e:return[266,e-13,1];case 16>=e:return[267,e-15,1];case 18>=e:return[268,e-17,1];case 22>=e:return[269,e-19,2];case 26>=e:return[270,e-23,2];case 30>=e:return[271,e-27,2];case 34>=e:return[272,e-31,2];case 42>=e:return[273,e-35,3];case 50>=e:return[274,e-43,3];case 58>=e:return[275,e-51,3];case 66>=e:return[276,e-59,3];case 82>=e:return[277,e-67,4];case 98>=e:return[278,e-83,4];case 114>=e:return[279,e-99,4];case 130>=e:return[280,e-115,4];case 162>=e:return[281,e-131,5];case 194>=e:return[282,e-163,5];case 226>=e:return[283,e-195,5];case 257>=e:return[284,e-227,5];case 258===e:return[285,e-258,0];default:throw\"invalid length: \"+e}}let t,n,a=[];for(t=3;258>=t;t++)n=e(t),a[t]=n[2]<<24|n[1]<<16|n[0];return a}(),U=a?new Uint32Array(d):d;function v(t,n){function i(e,t){let n,a,i,s,f=e.k,h=[],o=0;switch(n=U[e.length],h[o++]=65535&n,h[o++]=n>>16&255,h[o++]=n>>24,r){case 1===f:a=[0,f-1,0];break;case 2===f:a=[1,f-2,0];break;case 3===f:a=[2,f-3,0];break;case 4===f:a=[3,f-4,0];break;case 6>=f:a=[4,f-5,1];break;case 8>=f:a=[5,f-7,1];break;case 12>=f:a=[6,f-9,2];break;case 16>=f:a=[7,f-13,2];break;case 24>=f:a=[8,f-17,3];break;case 32>=f:a=[9,f-25,3];break;case 48>=f:a=[10,f-33,4];break;case 64>=f:a=[11,f-49,4];break;case 96>=f:a=[12,f-65,5];break;case 128>=f:a=[13,f-97,5];break;case 192>=f:a=[14,f-129,6];break;case 256>=f:a=[15,f-193,6];break;case 384>=f:a=[16,f-257,7];break;case 512>=f:a=[17,f-385,7];break;case 768>=f:a=[18,f-513,8];break;case 1024>=f:a=[19,f-769,8];break;case 1536>=f:a=[20,f-1025,9];break;case 2048>=f:a=[21,f-1537,9];break;case 3072>=f:a=[22,f-2049,10];break;case 4096>=f:a=[23,f-3073,10];break;case 6144>=f:a=[24,f-4097,11];break;case 8192>=f:a=[25,f-6145,11];break;case 12288>=f:a=[26,f-8193,12];break;case 16384>=f:a=[27,f-12289,12];break;case 24576>=f:a=[28,f-16385,13];break;case 32768>=f:a=[29,f-24577,13];break;default:throw\"invalid distance\"}for(n=a,h[o++]=n[0],h[o++]=n[1],h[o++]=n[2],i=0,s=h.length;i<s;++i)g[A++]=h[i];w[h[0]]++,d[h[3]]++,k=e.length+t-1,b=null}var s,f,h,o,u,c,l,b,y,p={},g=a?new Uint16Array(2*n.length):[],A=0,k=0,w=new(a?Uint32Array:Array)(286),d=new(a?Uint32Array:Array)(30),v=t.i;if(!a){for(h=0;285>=h;)w[h++]=0;for(h=0;29>=h;)d[h++]=0}for(w[256]=1,s=0,f=n.length;s<f;++s){for(h=u=0,o=3;h<o&&s+h!==f;++h)u=u<<8|n[s+h];if(p[u]===e&&(p[u]=[]),c=p[u],!(0<k--)){for(;0<c.length&&32768<s-c[0];)c.shift();if(s+3>=f){for(b&&i(b,-1),h=0,o=f-s;h<o;++h)y=n[s+h],g[A++]=y,++w[y];break}0<c.length?(l=m(n,s,c),b?b.length<l.length?(y=n[s-1],g[A++]=y,++w[y],i(l,0)):i(b,-1):l.length<v?b=l:i(l,0)):b?i(b,-1):(y=n[s],g[A++]=y,++w[y])}c.push(s)}return g[A++]=256,w[256]++,t.m=w,t.l=d,a?g.subarray(0,A):g}function m(e,r,t){let n,a,i,s,f,h,o=0,u=e.length;s=0,h=t.length;e:for(;s<h;s++){if(n=t[h-s-1],i=3,3<o){for(f=o;3<f;f--)if(e[n+f-1]!==e[r+f-1])continue e;i=o}for(;258>i&&r+i<u&&e[n+i]===e[r+i];)++i;if(i>o&&(a=n,o=i),258===i)break}return new w(o,r-a)}function x(e,r){let t,n,i,s,f,h=e.length,o=new b(572),u=new(a?Uint8Array:Array)(h);if(!a)for(s=0;s<h;s++)u[s]=0;for(s=0;s<h;++s)0<e[s]&&o.push(s,e[s]);if(t=Array(o.length/2),n=new(a?Uint32Array:Array)(o.length/2),1===t.length)return u[o.pop().index]=1,u;for(s=0,f=o.length/2;s<f;++s)t[s]=o.pop(),n[s]=t[s].value;for(i=function(e,r,t){function n(e){let t=y[e][p[e]];t===r?(n(e+1),n(e+1)):--l[t],++p[e]}var i,s,f,h,o,u=new(a?Uint16Array:Array)(t),c=new(a?Uint8Array:Array)(t),l=new(a?Uint8Array:Array)(r),b=Array(t),y=Array(t),p=Array(t),g=(1<<t)-r,A=1<<t-1;for(u[t-1]=r,s=0;s<t;++s)g<A?c[s]=0:(c[s]=1,g-=A),g<<=1,u[t-2-s]=(u[t-1-s]/2|0)+r;for(u[0]=c[0],b[0]=Array(u[0]),y[0]=Array(u[0]),s=1;s<t;++s)u[s]>2*u[s-1]+c[s]&&(u[s]=2*u[s-1]+c[s]),b[s]=Array(u[s]),y[s]=Array(u[s]);for(i=0;i<r;++i)l[i]=t;for(f=0;f<u[t-1];++f)b[t-1][f]=e[f],y[t-1][f]=f;for(i=0;i<t;++i)p[i]=0;for(1===c[t-1]&&(--l[0],++p[t-1]),s=t-2;0<=s;--s){for(h=i=0,o=p[s+1],f=0;f<u[s];f++)(h=b[s+1][o]+b[s+1][o+1])>e[i]?(b[s][f]=h,y[s][f]=r,o+=2):(b[s][f]=e[i],y[s][f]=i,++i);p[s]=0,1===c[s]&&n(s)}return l}(n,n.length,r),s=0,f=t.length;s<f;++s)u[t[s].index]=i[s];return u}function N(e){let r,t,n,i,s=new(a?Uint16Array:Array)(e.length),f=[],h=[],o=0;for(r=0,t=e.length;r<t;r++)f[e[r]]=1+(0|f[e[r]]);for(r=1,t=16;r<=t;r++)h[r]=o,o+=0|f[r],o<<=1;for(r=0,t=e.length;r<t;r++)for(o=h[e[r]],h[e[r]]+=1,n=s[r]=0,i=e[r];n<i;n++)s[r]=s[r]<<1|1&o,o>>>=1;return s}function D(e,r){this.input=e,this.a=new(a?Uint8Array:Array)(32768),this.d=E.g;let t,n={};for(t in!r&&(r={})||\"number\"!=typeof r.compressionType||(this.d=r.compressionType),r)n[t]=r[t];n.outputBuffer=this.a,this.j=new y(this.input,n)}var E=A;D.prototype.f=function(){let e,r,t,n,i,s,f=0;switch(s=this.a,e=Math.LOG2E*Math.log(32768)-8,r=e<<4|8,s[f++]=r,this.d){case E.NONE:n=0;break;case E.h:n=1;break;case E.g:n=2;break;default:throw Error(\"unsupported compression type\")}t=n<<6|0,s[f++]=t|31-(256*r+t)%31;let h=this.input;if(\"string\"==typeof h){let e,r,t=h.split(\"\");for(e=0,r=t.length;e<r;e++)t[e]=(255&t[e].charCodeAt(0))>>>0;h=t}for(var o,u=1,c=0,l=h.length,b=0;0<l;){l-=o=1024<l?1024:l;do{c+=u+=h[b++]}while(--o);u%=65521,c%=65521}return i=(c<<16|u)>>>0,this.j.c=f,s=this.j.f(),f=s.length,a&&(s=new Uint8Array(s.buffer),s.length<=f+4&&(this.a=new Uint8Array(s.length+4),this.a.set(s),s=this.a),s=s.subarray(0,f+4)),s[f++]=i>>24&255,s[f++]=i>>16&255,s[f++]=i>>8&255,s[f++]=255&i,s},n(\"Zlib.Deflate\",D),n(\"Zlib.Deflate.compress\",(function(e,r){return new D(e,r).f()})),n(\"Zlib.Deflate.prototype.compress\",D.prototype.f);let j,O,Z,B,C={NONE:E.NONE,FIXED:E.h,DYNAMIC:E.g};if(Object.keys)j=Object.keys(C);else for(O in j=[],Z=0,C)j[Z++]=O;for(Z=0,B=j.length;Z<B;++Z)O=j[Z],n(\"Zlib.Deflate.CompressionType.\"+O,C[O])}).call(this),this.addEventListener(\"message\",(function(e){const r=Uint8Array.from(encodeURIComponent(e.data.object).split(\"\"),(e=>e.charCodeAt(0))),t=e.data.type;if(\"json\"===t)this.postMessage({json:JSON.stringify({buffer:Array.from(new Zlib.Deflate(r).compress()),type:\"zlib\"}),type:t});else{const e=new Zlib.Deflate(r).compress();this.postMessage({buffer:e,type:t},[e.buffer])}}));"], { "type": "text/javascript" })
));

/**
 * @param {MessageEvent} event
 * @public
 */
Util.$zlibWorker.onmessage = function (event)
{
    const type = event.data.type;
    switch (type) {

        case "json":
        case "n2d":
            {
                const anchor = document.getElementById("save-anchor");
                if (anchor.href) {
                    URL.revokeObjectURL(anchor.href);
                }

                anchor.download = `${Util.$currentWorkSpace().name}.${type}`;

                anchor.href = type === "json"
                    ? URL.createObjectURL(new Blob([event.data.json],   { "type" : "application/json" }))
                    : URL.createObjectURL(new Blob([event.data.buffer], { "type" : "text/plain" }));

                anchor.click();
            }
            break;

        case "local":
            {
                const buffer = event.data.buffer;

                let binary = "";
                for (let idx = 0; idx < buffer.length; idx += 4096) {
                    binary += String.fromCharCode.apply(null, buffer.slice(idx, idx + 4096));
                }

                try {

                    localStorage.setItem(`${Util.PREFIX}@save-data`, binary);

                } catch (e) {

                    console.log(e);

                    alert("ブラウザでキャッシュできる容量は5Mまでです。\n" +
                        "ツールの「プロジェクトデータを保存」からデータをPCに保存してください。");

                }

                Util.$updated = false;
            }

            break;

    }

    if (Util.$zlibQueues.length) {

        Util.$zlibWorker.postMessage(Util.$zlibQueues.pop());

    } else {

        Util.$zlibWorkerActive = false;

    }
};

Util.$zlibQueues       = [];
Util.$zlibWorkerActive = false;

// Unzip Worker
Util.$unzipURL = URL.createObjectURL(
    new Blob(["const Util={};Util.$Uint8Array=Uint8Array,Util.$Uint16Array=Uint16Array,Util.$Int16Array=Int16Array,Util.$ArrayBuffer=ArrayBuffer,Util.$max=Math.max,Util.$min=Math.min,Util.$potArrayBuffers=new Map,Util.$codeTables=[],Util.$getCodeTable=function(t,e){const i=Util.$codeTables.pop()||{key:null,value:null};return i.key=t,i.value=e,i},Util.$poolCodeTable=function(t){Util.$codeTables.push(t)},Util.$poolTypedArrayBuffer=function(t){const e=t.buffer,i=e.byteLength;if(!i||i!==Util.$upperPowerOfTwo(i))return;let r=Util.$potArrayBuffers.get(i);r||(r=[],Util.$potArrayBuffers.set(i,r)),r.push(e)},Util.$upperPowerOfTwo=function(t){return t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t},Util.$getUint8Array=function(t){let e;const i=Util.$upperPowerOfTwo(t),r=Util.$potArrayBuffers.get(i),l=r&&r.pop();return l?(e=new Util.$Uint8Array(l,0,t),e.fill(0)):e=new Util.$Uint8Array(new Util.$ArrayBuffer(i),0,t),e},Util.$getUint16Array=function(t){let e;const i=Util.$upperPowerOfTwo(2*t),r=Util.$potArrayBuffers.get(i),l=r&&r.pop();return l?(e=new Util.$Uint16Array(l,0,t),e.fill(0)):e=new Util.$Uint16Array(new Util.$ArrayBuffer(i),0,t),e},Util.$fixedDistTable={key:new Util.$Uint16Array([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]),value:new Util.$Uint16Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31])},Util.$fixedLitTable={key:new Util.$Uint16Array([7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9]),value:new Util.$Uint16Array([256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,280,281,282,283,284,285,286,287,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255])},Util.$ORDER=new Util.$Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Util.$LEXT=new Util.$Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,99,99]),Util.$LENS=new Util.$Int16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Util.$DEXT=new Util.$Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),Util.$DISTS=new Util.$Int16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577]);class ByteStream{constructor(){this.initialization()}initialization(){this.data=null,this.bit_offset=0,this.byte_offset=0,this.bit_buffer=null}byteAlign(){this.bit_offset&&(this.byte_offset=this.byte_offset+(this.bit_offset+7)/8|0,this.bit_offset=0)}getData(t){this.byteAlign();const e=this.byte_offset+t,i=this.data.slice(this.byte_offset,e);return this.byte_offset=e,i}setOffset(t,e){this.byte_offset=t,this.bit_offset=e}unzip(t,e=0){let i=e;const r=Util.$getUint8Array(19);let l=null,a=null;for(;;){const e=this.readUB(1),s=this.readUB(2);if(l&&(Util.$poolCodeTable(l),Util.$poolCodeTable(a)),l=null,a=null,s){if(1===s)l=Util.$fixedDistTable,a=Util.$fixedLitTable;else{const t=this.readUB(5)+257,e=this.readUB(5)+1,i=this.readUB(4)+4;for(let t=0;t<i;++t)r[Util.$ORDER[t]]=this.readUB(3);const s=this.buildHuffTable(r);r.fill(0);const f=t+e|0,o=Util.$getUint8Array(f);let n=0;for(let t=0;t<f;){const e=this.decodeSymbol(s.key,s.value);switch(e){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:o[t++]=e,n=e;break;case 16:{let e=this.readUB(2)+3|0;for(;e;)--e,o[t++]=n}break;case 17:{let e=this.readUB(3)+3|0;for(;e;)--e,o[t++]=0}break;case 18:{let e=this.readUB(7)+11|0;for(;e;)--e,o[t++]=0}}}Util.$poolCodeTable(s),l=this.buildHuffTable(o.subarray(t)),a=this.buildHuffTable(o.subarray(0,t)),Util.$poolTypedArrayBuffer(o),Util.$poolTypedArrayBuffer(s.key),Util.$poolTypedArrayBuffer(s.value)}for(;;){const e=0|this.decodeSymbol(a.key,a.value);if(256===e)break;if(e<256)t[i++]=e;else{const r=e-257|0;let a=Util.$LENS[r]+this.readUB(Util.$LEXT[r])|0;const s=this.decodeSymbol(l.key,l.value);let f=i-(Util.$DISTS[s]+this.readUB(Util.$DEXT[s])|0)|0;for(;a;)--a,t[i++]=t[f++]}}}else{this.bit_offset=8,this.bit_buffer=null;const e=0|this.readNumber(2);this.byte_offset+=2;for(let r=0;r<e;++r)t[i++]=this.readNumber(1)}if(e)break}Util.$poolTypedArrayBuffer(r)}buildHuffTable(t){const e=t.length,i=Util.$max.apply(null,t),r=Util.$getUint8Array(i),l=Util.$getUint16Array(i+1);let a=0,s=0,f=e;for(;f;)s=t[--f],s&&++r[s];let o=0;for(let t=0;t<i;)a=a+r[t++]<<1,l[t]=a,o=Util.$max(o,a);const n=o+e,U=Util.$getUint16Array(n),u=Util.$getUint16Array(n);for(let i=0;i<e;++i)if(s=t[i],s){const t=l[s];U[t]=s,u[t]=i,l[s]=t+1|0}return Util.$poolTypedArrayBuffer(r),Util.$poolTypedArrayBuffer(l),Util.$getCodeTable(U,u)}decodeSymbol(t,e){let i=0,r=0;for(;;)if(i=i<<1|this.readUB(1),++r,t[i]===r)return e[i]}readUB(t){let e=0;for(let i=0;i<t;++i)8===this.bit_offset&&(this.bit_buffer=this.readNumber(1),this.bit_offset=0),e|=(this.bit_buffer&1<<this.bit_offset++?1:0)<<i;return e}readNumber(t){let e=0;const i=this.byte_offset;let r=i+t|0;for(;r>i;)e=e<<8|this.data[--r];return this.byte_offset+=t,e}}Util.$byteStream=new ByteStream,Util.$lossless=function(t,e,i,r,l,a){const s=new Util.$Uint8Array(e*i*4);if(3===r){const r=(e+3&-4)-e;let f=0;if(a){let a=4*l;for(let l=0;l<i;++l){for(let i=0;i<e;++i){const e=4*t[a++],i=t[e+3];if(0===i){s[f++]=0,s[f++]=0,s[f++]=0,s[f++]=0;continue}const r=t[e],l=t[e+1],o=t[e+2];255!==i?(s[f++]=255&Util.$min(r/i*255,255),s[f++]=255&Util.$min(l/i*255,255),s[f++]=255&Util.$min(o/i*255,255),s[f++]=i):(s[f++]=r,s[f++]=l,s[f++]=o,s[f++]=i)}a+=r}return s}let o=3*l;for(let l=0;l<i;++l){for(let i=0;i<e;++i){const e=3*t[o++];s[f++]=t[e],s[f++]=t[e+1],s[f++]=t[e+2],s[f++]=255}o+=r}return s}const f=e*i;if(a){for(let e=0;e<f;++e){const i=4*e,r=i,l=i+1,a=i+2,f=i+3,o=t[r];0!==o?255!==o?(s[r]=255&Util.$min(t[l]/o*255,255),s[l]=255&Util.$min(t[a]/o*255,255),s[a]=255&Util.$min(t[f]/o*255,255),s[f]=o):(s[r]=t[l],s[l]=t[a],s[a]=t[f],s[f]=o):(s[r]=0,s[l]=0,s[a]=0,s[f]=0)}return s}for(let e=0;e<f;++e){const i=4*e,r=i+1,l=i+2,a=i+3;s[i]=t[r],s[r]=t[l],s[l]=t[a],s[a]=255}return s},this.addEventListener(\"message\",(function(t){const e=Util.$byteStream;switch(t.data.mode){case\"swf\":{e.data=t.data.buffer;const i=t.data.fileSize,r=new Util.$Uint8Array(i),l=e.getData(8);e.setOffset(10,8),r.set(l,0),e.unzip(r,8),this.postMessage({buffer:r,mode:t.data.mode},[r.buffer])}break;case\"lossless\":{const i=t.data,r=new Util.$Uint8Array(i.fileSize);e.data=t.data.buffer,e.setOffset(2,8),e.unzip(r,0);const l=Util.$lossless(r,i.width,i.height,i.format,i.tableSize,i.isAlpha);this.postMessage({buffer:l,mode:t.data.mode},[l.buffer])}break;case\"jpegAlpha\":{const i=t.data.width*t.data.height,r=new Util.$Uint8Array(i);e.data=t.data.alphaData,e.setOffset(2,8),e.unzip(r,0),t.data.alphaData=r,this.postMessage(t.data,[t.data.buffer.buffer,t.data.alphaData.buffer])}}Util.$byteStream.initialization()}));"], { "type": "text/javascript" }
    ));
Util.$unzipWorker       = null;
Util.$unzipQueues       = [];
Util.$unzipWorkerActive = false;

/**
 * @param  {object} event
 * @return void
 * @static
 */
Util.$unzipHandler = function (event)
{
    const worker = event.target;

    // event end
    worker.onmessage = null;

    // setup
    switch (event.data.mode) {

        case "swf":
            this._$byteStream._$buffer = event.data.buffer;
            this.parseAndBuild();
            break;

        case "lossless":
            {
                const workSpace    = Util.$currentWorkSpace();
                const instance     = workSpace.getLibrary(this.libraryId);
                instance._$buffer  = event.data.buffer;
                instance._$command = null;
            }
            break;

        case "jpegAlpha":
            {
                const buffer    = event.data.buffer;
                const alphaData = event.data.alphaData;

                let index = 0;
                for (let idx = 0; idx < buffer.length; idx += 4) {
                    buffer[idx + 3] = alphaData[index++];
                }

                const workSpace    = Util.$currentWorkSpace();
                const instance     = workSpace.getLibrary(this.libraryId);
                instance._$buffer  = buffer;
                instance._$command = null;
            }
            break;

    }

    // next
    if (Util.$unzipQueues.length) {

        const object = Util.$unzipQueues.shift();
        worker.onmessage = Util.$unzipHandler.bind(object);
        switch (object.mode) {

            case "swf":
                {
                    const buffer = object._$byteStream._$buffer;
                    worker.postMessage({
                        "fileSize": object.fileSize,
                        "mode":     object.mode,
                        "buffer":   buffer
                    }, [buffer.buffer]);
                }
                break;

            case "lossless":
                worker.postMessage(object, [object.buffer.buffer]);
                break;

            case "jpegAlpha":
                worker.postMessage(object, [
                    object.buffer.buffer,
                    object.alphaData.buffer
                ]);
                break;

        }

    } else {

        Util.$unzipWorkerActive = false;

    }

};

Util.$unlzmaWorkerURL = URL.createObjectURL(
    new Blob(["const LZMA={init:function(e){const t=[];t.push(e[12],e[13],e[14],e[15],e[16],e[4],e[5],e[6],e[7]);let s=8;for(let e=5;e<9;++e){if(t[e]>=s){t[e]=t[e]-s|0;break}t[e]=256+t[e]-s|0,s=1}return t.push(0,0,0,0),e.set(t,4),e.subarray(4)},reverseDecode2:function(e,t,s,i){let r=1,o=0,d=0;for(;d<i;++d){const i=s.decodeBit(e,t+r);r=r<<1|i,o|=i<<d}return o},decompress:function(e,t){const s=new Decoder,i=s.decodeHeader(e),r=i.uncompressedSize;if(s.setProperties(i),!s.decodeBody(e,t,r))throw new Error(\"Error in lzma data stream\");return t}};class OutWindow{constructor(){this._buffer=null,this._stream=null,this._pos=0,this._streamPos=0,this._windowSize=0}create(e){this._buffer&&this._windowSize===e||(this._buffer=new Uint8Array(e)),this._windowSize=e}flush(){const e=this._pos-this._streamPos;e&&(this._stream.writeBytes(this._buffer,e),this._pos>=this._windowSize&&(this._pos=0),this._streamPos=this._pos)}releaseStream(){this.flush(),this._stream=null}setStream(e){this._stream=e}init(e=!1){e||(this._streamPos=0,this._pos=0)}copyBlock(e,t){let s=this._pos-e-1;for(s<0&&(s+=this._windowSize);t--;)s>=this._windowSize&&(s=0),this._buffer[this._pos++]=this._buffer[s++],this._pos>=this._windowSize&&this.flush()}putByte(e){this._buffer[this._pos++]=e,this._pos>=this._windowSize&&this.flush()}getByte(e){let t=this._pos-e-1;return t<0&&(t+=this._windowSize),this._buffer[t]}}class RangeDecoder{constructor(){this._stream=null,this._code=0,this._range=-1}setStream(e){this._stream=e}releaseStream(){this._stream=null}init(){let e=5;for(this._code=0,this._range=-1;e--;)this._code=this._code<<8|this._stream.readByte()}decodeDirectBits(e){let t=0,s=e;for(;s--;){this._range>>>=1;const e=this._code-this._range>>>31;this._code-=this._range&e-1,t=t<<1|1-e,0==(4278190080&this._range)&&(this._code=this._code<<8|this._stream.readByte(),this._range<<=8)}return t}decodeBit(e,t){const s=e[t],i=(this._range>>>11)*s;return(2147483648^this._code)<(2147483648^i)?(this._range=i,e[t]+=2048-s>>>5,0==(4278190080&this._range)&&(this._code=this._code<<8|this._stream.readByte(),this._range<<=8),0):(this._range-=i,this._code-=i,e[t]-=s>>>5,0==(4278190080&this._range)&&(this._code=this._code<<8|this._stream.readByte(),this._range<<=8),1)}}class BitTreeDecoder{constructor(e){this._models=Array(1<<e).fill(1024),this._numBitLevels=e}decode(e){let t=1,s=this._numBitLevels;for(;s--;)t=t<<1|e.decodeBit(this._models,t);return t-(1<<this._numBitLevels)}reverseDecode(e){let t=1,s=0,i=0;for(;i<this._numBitLevels;++i){const r=e.decodeBit(this._models,t);t=t<<1|r,s|=r<<i}return s}}class LenDecoder{constructor(){this._choice=[1024,1024],this._lowCoder=[],this._midCoder=[],this._highCoder=new BitTreeDecoder(8),this._numPosStates=0}create(e){for(;this._numPosStates<e;++this._numPosStates)this._lowCoder[this._numPosStates]=new BitTreeDecoder(3),this._midCoder[this._numPosStates]=new BitTreeDecoder(3)}decode(e,t){return 0===e.decodeBit(this._choice,0)?this._lowCoder[t].decode(e):0===e.decodeBit(this._choice,1)?8+this._midCoder[t].decode(e):16+this._highCoder.decode(e)}}class Decoder2{constructor(){this._decoders=Array(768).fill(1024)}decodeNormal(e){let t=1;do{t=t<<1|e.decodeBit(this._decoders,t)}while(t<256);return 255&t}decodeWithMatchByte(e,t){let s=1;do{const i=t>>7&1;t<<=1;const r=e.decodeBit(this._decoders,(1+i<<8)+s);if(s=s<<1|r,i!==r){for(;s<256;)s=s<<1|e.decodeBit(this._decoders,s);break}}while(s<256);return 255&s}}class LiteralDecoder{create(e,t){if(this._coders&&this._numPrevBits===t&&this._numPosBits===e)return;this._numPosBits=e,this._posMask=(1<<e)-1,this._numPrevBits=t,this._coders=[];let s=1<<this._numPrevBits+this._numPosBits;for(;s--;)this._coders[s]=new Decoder2}getDecoder(e,t){return this._coders[((e&this._posMask)<<this._numPrevBits)+((255&t)>>>8-this._numPrevBits)]}}class Decoder{constructor(){this._outWindow=new OutWindow,this._rangeDecoder=new RangeDecoder,this._isMatchDecoders=Array(192).fill(1024),this._isRepDecoders=Array(12).fill(1024),this._isRepG0Decoders=Array(12).fill(1024),this._isRepG1Decoders=Array(12).fill(1024),this._isRepG2Decoders=Array(12).fill(1024),this._isRep0LongDecoders=Array(192).fill(1024),this._posDecoders=Array(114).fill(1024),this._posAlignDecoder=new BitTreeDecoder(4),this._lenDecoder=new LenDecoder,this._repLenDecoder=new LenDecoder,this._literalDecoder=new LiteralDecoder,this._dictionarySize=-1,this._dictionarySizeCheck=-1,this._posSlotDecoder=[new BitTreeDecoder(6),new BitTreeDecoder(6),new BitTreeDecoder(6),new BitTreeDecoder(6)]}setDictionarySize(e){return!(e<0)&&(this._dictionarySize!==e&&(this._dictionarySize=e,this._dictionarySizeCheck=Math.max(this._dictionarySize,1),this._outWindow.create(Math.max(this._dictionarySizeCheck,4096))),!0)}setLcLpPb(e,t,s){if(e>8||t>4||s>4)return!1;const i=1<<s;return this._literalDecoder.create(t,e),this._lenDecoder.create(i),this._repLenDecoder.create(i),this._posStateMask=i-1,!0}setProperties(e){if(!this.setLcLpPb(e.lc,e.lp,e.pb))throw Error(\"Incorrect stream properties\");if(!this.setDictionarySize(e.dictionarySize))throw Error(\"Invalid dictionary size\")}decodeHeader(e){if(e._$size<13)return!1;let t=e.readByte();const s=t%9;t=~~(t/9);const i=t%5,r=~~(t/5);let o=e.readByte();o|=e.readByte()<<8,o|=e.readByte()<<16,o+=16777216*e.readByte();let d=e.readByte();return d|=e.readByte()<<8,d|=e.readByte()<<16,d+=16777216*e.readByte(),e.readByte(),e.readByte(),e.readByte(),e.readByte(),{lc:s,lp:i,pb:r,dictionarySize:o,uncompressedSize:d}}decodeBody(e,t,s){let i,r,o=0,d=0,h=0,c=0,n=0,_=0,a=0;for(this._rangeDecoder.setStream(e),this._rangeDecoder.init(),this._outWindow.setStream(t),this._outWindow.init(!1);_<s;){const e=_&this._posStateMask;if(0===this._rangeDecoder.decodeBit(this._isMatchDecoders,(o<<4)+e)){const e=this._literalDecoder.getDecoder(_++,a);a=o>=7?e.decodeWithMatchByte(this._rangeDecoder,this._outWindow.getByte(d)):e.decodeNormal(this._rangeDecoder),this._outWindow.putByte(a),o=o<4?0:o-(o<10?3:6)}else{if(1===this._rangeDecoder.decodeBit(this._isRepDecoders,o))i=0,0===this._rangeDecoder.decodeBit(this._isRepG0Decoders,o)?0===this._rangeDecoder.decodeBit(this._isRep0LongDecoders,(o<<4)+e)&&(o=o<7?9:11,i=1):(0===this._rangeDecoder.decodeBit(this._isRepG1Decoders,o)?r=h:(0===this._rangeDecoder.decodeBit(this._isRepG2Decoders,o)?r=c:(r=n,n=c),c=h),h=d,d=r),0===i&&(i=2+this._repLenDecoder.decode(this._rangeDecoder,e),o=o<7?8:11);else{n=c,c=h,h=d,i=2+this._lenDecoder.decode(this._rangeDecoder,e),o=o<7?7:10;const t=this._posSlotDecoder[i<=5?i-2:3].decode(this._rangeDecoder);if(t>=4){const e=(t>>1)-1;if(d=(2|1&t)<<e,t<14)d+=LZMA.reverseDecode2(this._posDecoders,d-t-1,this._rangeDecoder,e);else if(d+=this._rangeDecoder.decodeDirectBits(e-4)<<4,d+=this._posAlignDecoder.reverseDecode(this._rangeDecoder),d<0){if(-1===d)break;return!1}}else d=t}if(d>=_||d>=this._dictionarySizeCheck)return!1;this._outWindow.copyBlock(d,i),_+=i,a=this._outWindow.getByte(0)}}return this._outWindow.releaseStream(),this._rangeDecoder.releaseStream(),!0}}class InStream{constructor(e){this._$data=e,this._$size=e.length,this._$offset=0}readByte(){return this._$data[this._$offset++]}}class OutStream{constructor(e){this.size=8,this.buffers=e}writeBytes(e,t){e.length===t?this.buffers.set(e,this.size):this.buffers.set(e.subarray(0,t),this.size),this.size+=t}}this.addEventListener(\"message\",(function(e){const t=e.data.fileSize,s=e.data.buffer,i=new Uint8Array(t+8);i.set(s.slice(0,8),0),LZMA.decompress(new InStream(LZMA.init(s)),new OutStream(i)),this.postMessage(i,[i.buffer]),this.close()}));"], { "type": "text/javascript" })
);
Util.$unlzmaQueues       = [];
Util.$unlzmaWorkerActive = false;

Util.$parserURL = URL.createObjectURL(
    new Blob(["const Util={$tagObjects:[]};Util.$installed=new Map,Util.$swfParser=null,Util.$Rad2Deg=180/Math.PI,Util.$JCT11280=Function('var a=\"zKV33~jZ4zN=~ji36XazM93y!{~k2y!o~k0ZlW6zN?3Wz3W?{EKzK[33[`y|;-~j^YOTz$!~kNy|L1$353~jV3zKk3~k-4P4zK_2+~jY4y!xYHR~jlz$_~jk4z$e3X5He<0y!wy|X3[:~l|VU[F3VZ056Hy!nz/m1XD61+1XY1E1=1y|bzKiz!H034zKj~mEz#c5ZA3-3X$1~mBz$$3~lyz#,4YN5~mEz#{ZKZ3V%7Y}!J3X-YEX_J(3~mAz =V;kE0/y|F3y!}~m>z/U~mI~j_2+~mA~jp2;~m@~k32;~m>V}2u~mEX#2x~mBy+x2242(~mBy,;2242(~may->2&XkG2;~mIy-_2&NXd2;~mGz,{4<6:.:B*B:XC4>6:.>B*BBXSA+A:X]E&E<~r#z+625z s2+zN=`HXI@YMXIAXZYUM8X4K/:Q!Z&33 3YWX[~mB`{zKt4z (zV/z 3zRw2%Wd39]S11z$PAXH5Xb;ZQWU1ZgWP%3~o@{Dgl#gd}T){Uo{y5_d{e@}C(} WU9|cB{w}bzvV|)[} H|zT}d||0~{]Q|(l{|x{iv{dw}(5}[Z|kuZ }cq{{y|ij}.I{idbof%cu^d}Rj^y|-M{ESYGYfYsZslS`?ZdYO__gLYRZ&fvb4oKfhSf^d<Yeasc1f&a=hnYG{QY{D`Bsa|u,}Dl|_Q{C%xK|Aq}C>|c#ryW=}eY{L+`)][YF_Ub^h4}[X|?r|u_ex}TL@YR]j{SrXgo*|Gv|rK}B#mu{R1}hs|dP{C7|^Qt3|@P{YVV |8&}#D}ef{e/{Rl|>Hni}R1{Z#{D[}CQlQ||E}[s{SG_+i8eplY[=[|ec[$YXn#`hcm}YR|{Ci(_[ql|?8p3]-}^t{wy}4la&pc|3e{Rp{LqiJ],] `kc(]@chYnrM`O^,ZLYhZB]ywyfGY~aex!_Qww{a!|)*lHrM{N+n&YYj~Z b c#e_[hZSon|rOt`}hBXa^i{lh|<0||r{KJ{kni)|x,|0auY{D!^Sce{w;|@S|cA}Xn{C1h${E]Z-XgZ*XPbp]^_qbH^e[`YM|a||+=]!Lc}]vdBc=j-YSZD]YmyYLYKZ9Z>Xcczc2{Yh}9Fc#Z.l{}(D{G{{mRhC|L3b#|xK[Bepj#ut`H[,{E9Yr}1b{[e]{ZFk7[ZYbZ0XL]}Ye[(`d}c!|*y`Dg=b;gR]Hm=hJho}R-[n}9;{N![7k_{UbmN]rf#pTe[x8}!Qcs_rs[m`|>N}^V})7{^r|/E}),}HH{OYe2{Skx)e<_.cj.cjoMhc^d}0uYZd!^J_@g,[[[?{i@][|3S}Yl3|!1|eZ|5IYw|1D}e7|Cv{OHbnx-`wvb[6[4} =g+k:{C:}ed{S]|2M]-}WZ|/q{LF|dYu^}Gs^c{Z=}h>|/i|{W]:|ip{N:|zt|S<{DH[p_tvD{N<[8Axo{X4a.^o^X>Yfa59`#ZBYgY~_t^9`jZHZn`>G[oajZ;X,i)Z.^~YJe ZiZF^{][[#Zt^|]Fjx]&_5dddW]P0C[-]}]d|y {C_jUql] |OpaA[Z{lp|rz}:Mu#]_Yf6{Ep?f5`$[6^D][^u[$[6^.Z8]]ePc2U/=]K^_+^M{q*|9tYuZ,s(dS{i=|bNbB{uG}0jZOa:[-]dYtu3]:]<{DJ_SZIqr_`l=Yt`gkTnXb3d@kiq0a`Z{|!B|}e}Ww{Sp,^Z|0>_Z}36|]A|-t}lt{R6pi|v8hPu#{C>YOZHYmg/Z4nicK[}hF_Bg|YRZ7c|crkzYZY}_iXcZ.|)U|L5{R~qi^Uga@Y[xb}&qdbd6h5|Btw[}c<{Ds53[Y7]?Z<|e0{L[ZK]mXKZ#Z2^tavf0`PE[OSOaP`4gi`qjdYMgys/?[nc,}EEb,eL]g[n{E_b/vcvgb.{kcwi`~v%|0:|iK{Jh_vf5lb}KL|(oi=LrzhhY_^@`zgf[~g)[J_0fk_V{T)}I_{D&_/d9W/|MU[)f$xW}?$xr4<{Lb{y4}&u{XJ|cm{Iu{jQ}CMkD{CX|7A}G~{kt)nB|d5|<-}WJ}@||d@|Iy}Ts|iL|/^|no|0;}L6{Pm]7}$zf:|r2}?C_k{R(}-w|`G{Gy[g]bVje=_0|PT{^Y^yjtT[[[l!Ye_`ZN]@[n_)j3nEgMa]YtYpZy].d-Y_cjb~Y~[nc~sCi3|zg}B0}do{O^{|$`_|D{}U&|0+{J3|8*]iayx{a{xJ_9|,c{Ee]QXlYb]$[%YMc*]w[aafe]aVYi[fZEii[xq2YQZHg]Y~h#|Y:thre^@^|_F^CbTbG_1^qf7{L-`VFx Zr|@EZ;gkZ@slgko`[e}T:{Cu^pddZ_`yav^Ea+[#ZBbSbO`elQfLui}.F|txYcbQ`XehcGe~fc^RlV{D_0ZAej[l&jShxG[ipB_=u:eU}3e8[=j|{D(}dO{Do[BYUZ0/]AYE]ALYhZcYlYP/^-^{Yt_1_-;YT`P4BZG=IOZ&]H[e]YYd[9^F[1YdZxZ?Z{Z<]Ba2[5Yb[0Z4l?]d_;_)a?YGEYiYv`_XmZs4ZjY^Zb]6gqGaX^9Y}dXZr[g|]Y}K aFZp^k^F]M`^{O1Ys]ZCgCv4|E>}8eb7}l`{L5[Z_faQ|c2}Fj}hw^#|Ng|B||w2|Sh{v+[G}aB|MY}A{|8o}X~{E8paZ:]i^Njq]new)`-Z>haounWhN}c#{DfZ|fK]KqGZ=:u|fqoqcv}2ssm}.r{]{nIfV{JW)[K|,Z{Uxc|]l_KdCb%]cfobya3`p}G^|LZiSC]U|(X|kBlVg[kNo({O:g:|-N|qT}9?{MBiL}Sq{`P|3a|u.{Uaq:{_o|^S}jX{Fob0`;|#y_@[V[K|cw[<_ }KU|0F}d3|et{Q7{LuZttsmf^kYZ`Af`}$x}U`|Ww}d]| >}K,r&|XI|*e{C/a-bmr1fId4[;b>tQ_:]hk{b-pMge]gfpo.|(w[jgV{EC1Z,YhaY^q,_G[c_g[J0YX]`[h^hYK^_Yib,` {i6vf@YM^hdOKZZn(jgZ>bzSDc^Z%[[o9[2=/YHZ(_/Gu_`*|8z{DUZxYt^vuvZjhi^lc&gUd4|<UiA`z]$b/Z?l}YI^jaHxe|;F}l${sQ}5g}hA|e4}?o{ih}Uz{C)jPe4]H^J[Eg[|AMZMlc}:,{iz}#*|gc{Iq|/:|zK{l&}#u|myd{{M&v~nV};L|(g|I]ogddb0xsd7^V})$uQ{HzazsgxtsO^l}F>ZB]r|{7{j@cU^{{CbiYoHlng]f+nQ[bkTn/}<-d9q {KXadZYo+n|l[|lc}V2{[a{S4Zam~Za^`{HH{xx_SvF|ak=c^[v^7_rYT`ld@]:_ub%[$[m](Shu}G2{E.ZU_L_R{tz`vj(f?^}hswz}GdZ}{S:h`aD|?W|`dgG|if{a8|J1{N,}-Ao3{H#{mfsP|[ bzn+}_Q{MT{u4kHcj_q`eZj[8o0jy{p7}C|[}l){MuYY{|Ff!Ykn3{rT|m,^R|,R}$~Ykgx{P!]>iXh6[l[/}Jgcg{JYZ.^qYfYIZl[gZ#Xj[Pc7YyZD^+Yt;4;`e8YyZVbQ7YzZxXja.7SYl[s]2^/Ha$[6ZGYrb%XiYdf2]H]kZkZ*ZQ[ZYS^HZXcCc%Z|[(bVZ]]:OJQ_DZCg<[,]%Zaa [g{C00HY[c%[ChyZ,Z_`PbXa+eh`^&jPi0a[ggvhlekL]w{Yp^v}[e{~;k%a&k^|nR_z_Qng}[E}*Wq:{k^{FJZpXRhmh3^p>de^=_7`|ZbaAZtdhZ?n4ZL]u`9ZNc3g%[6b=e.ZVfC[ZZ^^^hD{E(9c(kyZ=bb|Sq{k`|vmr>izlH[u|e`}49}Y%}FT{[z{Rk}Bz{TCc/lMiAqkf(m$hDc;qooi[}^o:c^|Qm}a_{mrZ(pA`,}<2sY| adf_%|}`}Y5U;}/4|D>|$X{jw{C<|F.hK|*A{MRZ8Zsm?imZm_?brYWZrYx`yVZc3a@f?aK^ojEd {bN}/3ZH]/$YZhm^&j 9|(S|b]mF}UI{q&aM]LcrZ5^.|[j`T_V_Gak}9J[ ZCZD|^h{N9{~&[6Zd{}B}2O|cv]K}3s}Uy|l,fihW{EG`j_QOp~Z$F^zexS`dcISfhZBXP|.vn|_HYQ|)9|cr]<`&Z6]m_(ZhPcSg>`Z]5`~1`0Xcb4k1{O!bz|CN_T{LR|a/gFcD|j<{Z._[f)mPc:1`WtIaT1cgYkZOaVZOYFrEe[}T$}Ch}mk{K-^@]fH{Hdi`c*Z&|Kt{if[C{Q;{xYB`dYIX:ZB[}]*[{{p9|4GYRh2ao{DS|V+[zd$`F[ZXKadb*A] Ys]Maif~a/Z2bmclb8{Jro_rz|x9cHojbZ{GzZx_)]:{wAayeDlx}<=`g{H1{l#}9i|)=|lP{Qq}.({La|!Y{i2EZfp=c*}Cc{EDvVB|;g}2t{W4av^Bn=]ri,|y?|3+}T*ckZ*{Ffr5e%|sB{lx^0]eZb]9[SgAjS_D|uHZx]dive[c.YPkcq/}db{EQh&hQ|eg}G!ljil|BO]X{Qr_GkGl~YiYWu=c3eb}29v3|D|}4i||.{Mv})V{SP1{FX}CZW6{cm|vO{pS|e#}A~|1i}81|Mw}es|5[}3w{C`h9aL]o{}p[G`>i%a1Z@`Ln2bD[$_h`}ZOjhdTrH{[j_:k~kv[Sdu]CtL}41{I |[[{]Zp$]XjxjHt_eThoa#h>sSt8|gK|TVi[Y{t=}Bs|b7Zpr%{gt|Yo{CS[/{iteva|cf^hgn}($_c^wmb^Wm+|55jrbF|{9^ q6{C&c+ZKdJkq_xOYqZYSYXYl`8]-cxZAq/b%b*_Vsa[/Ybjac/OaGZ4fza|a)gY{P?| I|Y |,pi1n7}9bm9ad|=d{aV|2@[(}B`d&|Uz}B}{`q|/H|!JkM{FU|CB|.{}Az}#P|lk}K{|2rk7{^8^?`/|k>|Ka{Sq}Gz}io{DxZh[yK_#}9<{TRdgc]`~Z>JYmYJ]|`!ZKZ]gUcx|^E[rZCd`f9oQ[NcD_$ZlZ;Zr}mX|=!|$6ZPZYtIo%fj}CpcN|B,{VDw~gb}@hZg`Q{LcmA[(bo`<|@$|o1|Ss}9Z_}tC|G`{F/|9nd}i=}V-{L8aaeST]daRbujh^xlpq8|}zs4bj[S`J|]?G{P#{rD{]I`OlH{Hm]VYuSYUbRc*6[j`8]pZ[bt_/^Jc*[<Z?YE|Xb|?_Z^Vcas]h{t9|Uwd)_(=0^6Zb{Nc} E[qZAeX[a]P^|_J>e8`W^j_Y}R{{Jp__]Ee#e:iWb9q_wKbujrbR}CY`,{mJ}gz{Q^{t~N|? gSga`V_||:#mi}3t|/I`X{N*|ct|2g{km}gi|{={jC}F;|E}{ZZjYf*frmu}8Tdroi{T[|+~}HG{cJ}DM{Lp{Ctd&}$hi3|FZ| m}Kr|38}^c|m_|Tr{Qv|36}?Up>|;S{DV{k_as}BK{P}}9p|t`jR{sAm4{D=b4pWa[}Xi{EjwEkI}3S|E?u=X0{jf} S|NM|JC{qo^3cm]-|JUx/{Cj{s>{Crt[UXuv|D~|j|d{YXZR}Aq}0r}(_{pJfi_z}0b|-vi)Z mFe,{f4|q`b{}^Z{HM{rbeHZ|^x_o|XM|L%|uFXm}@C_{{Hhp%a7|0p[Xp+^K}9U{bP}: tT}B|}+$|b2|[^|~h{FAby[`{}xgygrt~h1[li`c4vz|,7p~b(|mviN}^pg[{N/|g3|^0c,gE|f%|7N{q[|tc|TKA{LU}I@|AZp(}G-sz{F |qZ{}F|f-}RGn6{Z]_5})B}UJ{FFb2]4ZI@v=k,]t_Dg5Bj]Z-]L]vrpdvdGlk|gF}G]|IW}Y0[G| /bo|Te^,_B}#n^^{QHYI[?hxg{[`]D^IYRYTb&kJ[cri[g_9]Ud~^_]<p@_e_XdNm-^/|5)|h_{J;{kacVopf!q;asqd}n)|.m|bf{QW|U)}b+{tL|w``N|to{t ZO|T]jF}CB|0Q{e5Zw|k |We}5:{HO{tPwf_uajjBfX}-V_C_{{r~gg|Ude;s+}KNXH}! `K}eW{Upwbk%ogaW}9EYN}YY|&v|SL{C3[5s.]Y]I]u{M6{pYZ`^,`ZbCYR[1mNg>rsk0Ym[jrE]RYiZTr*YJ{Ge|%-lf|y(`=[t}E6{k!|3)}Zk} ][G{E~cF{u3U.rJ|a9p#o#ZE|?|{sYc#vv{E=|LC}cu{N8`/`3`9rt[4|He{cq|iSYxY`}V |(Q|t4{C?]k_Vlvk)BZ^r<{CL}#h}R+[<|i=}X|{KAo]|W<`K{NW|Zx}#;|fe{IMr<|K~tJ_x}AyLZ?{GvbLnRgN}X&{H7|x~}Jm{]-| GpNu0}.ok>|c4{PYisrDZ|fwh9|hfo@{H~XSbO]Odv]%`N]b1Y]]|eIZ}_-ZA]aj,>eFn+j[aQ_+]h[J_m_g]%_wf.`%k1e#Z?{CvYu_B^|gk`Xfh^M3`afGZ-Z|[m{L}|k3cp[it ^>YUi~d>{T*}YJ{Q5{Jxa$hg|%4`}|LAgvb }G}{P=|<;Ux{_skR{cV|-*|s-{Mp|XP|$G|_J}c6cM{_=_D|*9^$ec{V;|4S{qO|w_|.7}d0|/D}e}|0G{Dq]Kdp{}dfDi>}B%{Gd|nl}lf{C-{y}|ANZr}#={T~|-(}c&{pI|ft{lsVP}){|@u}!W|bcmB{d?|iW|:dxj{PSkO|Hl]Li:}VYk@|2={fnWt{M3`cZ6|)}|Xj}BYa?vo{e4|L7|B7{L7|1W|lvYO}W8nJ|$Vih|{T{d*_1|:-n2dblk``fT{Ky|-%}m!|Xy|-a{Pz}[l{kFjz|iH}9N{WE{x,|jz}R {P|{D)c=nX|Kq|si}Ge{sh|[X{RF{t`|jsr*fYf,rK|/9}$}}Nf{y!1|<Std}4Wez{W${Fd_/^O[ooqaw_z[L`Nbv[;l7V[ii3_PeM}.h^viqYjZ*j1}+3{bt{DR[;UG}3Og,rS{JO{qw{d<_zbAh<R[1_r`iZTbv^^a}c{iEgQZ<exZFg.^Rb+`Uj{a+{z<[~r!]`[[|rZYR|?F|qppp]L|-d|}K}YZUM|=Y|ktm*}F]{D;g{uI|7kg^}%?Z%ca{N[_<q4xC]i|PqZC]n}.bDrnh0Wq{tr|OMn6tM|!6|T`{O`|>!]ji+]_bTeU}Tq|ds}n|{Gm{z,f)}&s{DPYJ`%{CGd5v4tvb*hUh~bf]z`jajiFqAii]bfy^U{Or|m+{I)cS|.9k:e3`^|xN}@Dnlis`B|Qo{`W|>||kA}Y}{ERYuYx`%[exd`]|OyiHtb}HofUYbFo![5|+]gD{NIZR|Go}.T{rh^4]S|C9_}xO^i`vfQ}C)bK{TL}cQ|79iu}9a];sj{P.o!f[Y]pM``Jda^Wc9ZarteBZClxtM{LW}l9|a.mU}KX}4@{I+f1}37|8u}9c|v${xGlz}jP{Dd1}e:}31}%3X$|22i<v+r@~mf{sN{C67G97855F4YL5}8f{DT|xy{sO{DXB334@55J1)4.G9A#JDYtXTYM4, YQD9;XbXm9SX]IB^4UN=Xn<5(;(F3YW@XkH-X_VM[DYM:5XP!T&Y`6|,^{IS-*D.H>:LXjYQ0I3XhAF:9:(==.F*3F1189K/7163D,:@|e2{LS36D4hq{Lw/84443@4.933:0307::6D7}&l{Mx657;89;,K5678H&93D(H<&<>0B90X^I;}Ag1{P%3A+>><975}[S{PZE453?4|T2{Q+5187;>447:81{C=hL6{Me^:=7ii{R=.=F<81;48?|h8}Uh{SE|,VxL{ST,7?9Y_5Xk3A#:$%YSYdXeKXOD8+TXh7(@>(YdXYHXl9J6X_5IXaL0N?3YK7Xh!1?XgYz9YEXhXaYPXhC3X`-YLY_XfVf[EGXZ5L8BXL9YHX]SYTXjLXdJ: YcXbQXg1PX]Yx4|Jr{Ys4.8YU+XIY`0N,<H%-H;:0@,74/:8546I=9177154870UC]d<C3HXl7ALYzXFXWP<<?E!88E5@03YYXJ?YJ@6YxX-YdXhYG|9o{`iXjY_>YVXe>AYFX[/(I@0841?):-B=14337:8=|14{c&93788|di{cW-0>0<097/A;N{FqYpugAFT%X/Yo3Yn,#=XlCYHYNX[Xk3YN:YRT4?)-YH%A5XlYF3C1=NWyY}>:74-C673<69545v {iT85YED=64=.F4..9878/D4378?48B3:7:7/1VX[f4{D,{l<5E75{dAbRB-8-@+;DBF/$ZfW8S<4YhXA.(5@*11YV8./S95C/0R-A4AXQYI7?68167B95HA1*<M3?1/@;/=54XbYP36}lc{qzSS38:19?,/39193574/66878Yw1X-87E6=;964X`T734:>86>1/=0;(I-1::7ALYGXhF+Xk[@W%TYbX7)KXdYEXi,H-XhYMRXfYK?XgXj.9HX_SX]YL1XmYJ>Y}WwIXiI-3-GXcYyXUYJ$X`Vs[7;XnYEZ;XF! 3;%8;PXX(N3Y[)Xi1YE&/ :;74YQ6X`33C;-(>Xm0(TYF/!YGXg8 9L5P01YPXO-5%C|qd{{/K/E6,=0144:361:955;6443@?B7*7:F89&F35YaX-CYf,XiFYRXE_e{}sF 0*7XRYPYfXa5YXXY8Xf8Y~XmA[9VjYj*#YMXIYOXk,HHX40YxYMXU8OXe;YFXLYuPXP?EB[QV0CXfY{:9XV[FWE0D6X^YVP*$4%OXiYQ(|xp|%c3{}V`1>Y`XH00:8/M6XhQ1:;3414|TE|&o@1*=81G8<3}6<|(f6>>>5-5:8;093B^3U*+*^*UT30XgYU&7*O1953)5@E78--F7YF*B&0:%P68W9Zn5974J9::3}Vk|-,C)=)1AJ4+<3YGXfY[XQXmT1M-XcYTYZXCYZXEYXXMYN,17>XIG*SaS|/eYJXbI?XdNZ+WRYP<F:R PXf;0Xg`$|1GX9YdXjLYxWX!ZIXGYaXNYm6X9YMX?9EXmZ&XZ#XQ>YeXRXfAY[4 ;0X!Zz0XdN$XhYL XIY^XGNXUYS/1YFXhYk.TXn4DXjB{jg|4DEX]:XcZMW=A.+QYL<LKXc[vV$+&PX*Z3XMYIXUQ:ZvW< YSXFZ,XBYeXMM)?Xa XiZ4/EXcP3%}&-|6~:1(-+YT$@XIYRBC<}&,|7aJ6}bp|8)K1|Xg|8C}[T|8Q.89;-964I38361<=/;883651467<7:>?1:.}le|:Z=39;1Y^)?:J=?XfLXbXi=Q0YVYOXaXiLXmJXO5?.SFXiCYW}-;|=u&D-X`N0X^,YzYRXO(QX_YW9`I|>hZ:N&X)DQXP@YH#XmNXi$YWX^=!G6YbYdX>XjY|XlX^XdYkX>YnXUXPYF)FXT[EVTMYmYJXmYSXmNXi#GXmT3X8HOX[ZiXN]IU2>8YdX1YbX<YfWuZ8XSXcZU%0;1XnXkZ_WTG,XZYX5YSX Yp 05G?XcYW(IXg6K/XlYP4XnI @XnO1W4Zp-9C@%QDYX+OYeX9>--YSXkD.YR%Q/Yo YUX].Xi<HYEZ2WdCE6YMXa7F)=,D>-@9/8@5=?7164;35387?N<618=6>7D+C50<6B03J0{Hj|N9$D,9I-,.KB3}m |NzE0::/81YqXjMXl7YG; [.W=Z0X4XQY]:MXiR,XgM?9$9>:?E;YE77VS[Y564760391?14941:0=:8B:;/1DXjFA-564=0B3XlH1+D85:0Q!B#:-6&N/:9<-R3/7Xn<*3J4.H:+334B.=>30H.;3833/76464665755:/83H6633:=;.>5645}&E|Y)?1/YG-,93&N3AE@5 <L1-G/8A0D858/30>8<549=@B8] V0[uVQYlXeD(P#ID&7T&7;Xi0;7T-$YE)E=1:E1GR):--0YI7=E<}n9|aT6783A>D7&4YG7=391W;Zx<5+>F#J39}o/|cc;6=A050EQXg8A1-}D-|d^5548083563695D?-.YOXd37I$@LYLWeYlX<Yd+YR A$;3-4YQ-9XmA0!9/XLY_YT(=5XdDI>YJ5XP1ZAW{9>X_6R(XhYO65&J%DA)C-!B:97#A9;@?F;&;(9=11/=657/H,<8}bz|j^5446>.L+&Y^8Xb6?(CYOXb*YF(8X`FYR(XPYVXmPQ%&DD(XmZXW??YOXZXfCYJ79,O)XnYF7K0!QXmXi4IYFRXS,6<%-:YO(+:-3Q!1E1:W,Zo}Am|n~;3580534*?3Zc4=9334361693:30C<6/717:<1/;>59&:4}6!|rS36=1?75<8}[B|s809983579I.A.>84758=108564741H*9E{L{|u%YQ<%6XfH.YUXe4YL@,>N}Tv|ve*G0X)Z;/)3@A74(4P&A1X:YVH97;,754*A66:1 D739E3553545558E4?-?K17/770843XAYf838A7K%N!YW4.$T19Z`WJ*0XdYJXTYOXNZ 1XaN1A+I&Xi.Xk3Z3GB&5%WhZ1+5#Y[X<4YMXhQYoQXVXbYQ8XSYUX4YXBXWDMG0WxZA[8V+Z8X;D],Va$%YeX?FXfX[XeYf<X:Z[WsYz8X_Y]%XmQ(!7BXIZFX]&YE3F$(1XgYgYE& +[+W!<YMYFXc;+PXCYI9YrWxGXY9DY[!GXiI7::)OC;*$.>N*HA@{C|}&k=:<TB83X`3YL+G4XiK]i}(fYK<=5$.FYE%4*5*H*6XkCYL=*6Xi6!Yi1KXR4YHXbC8Xj,B9ZbWx/XbYON#5B}Ue}+QKXnF1&YV5XmYQ0!*3IXBYb71?1B75XmF;0B976;H/RXU:YZX;BG-NXj;XjI>A#D3B636N;,*%<D:0;YRXY973H5)-4FXOYf0:0;/7759774;7;:/855:543L43<?6=E,.A4:C=L)%4YV!1(YE/4YF+ F3%;S;&JC:%/?YEXJ4GXf/YS-EXEYW,9;E}X$}547EXiK=51-?71C%?57;5>463553Zg90;6447?<>4:9.7538XgN{|!}9K/E&3-:D+YE1)YE/3;37/:05}n<}:UX8Yj4Yt864@JYK..G=.(A Q3%6K>3(P3#AYE$-6H/456*C=.XHY[#S.<780191;057C)=6HXj?955B:K1 E>-B/9,;5.!L?:0>/.@//:;7833YZ56<4:YE=/:7Z_WGC%3I6>XkC*&NA16X=Yz2$X:Y^&J48<99k8}CyB-61<18K946YO4{|N}E)YIB9K0L>4=46<1K0+R;6-=1883:478;4,S+3YJX`GJXh.Yp+Xm6MXcYpX(>7Yo,/:X=Z;Xi0YTYHXjYmXiXj;*;I-8S6N#XgY}.3XfYGO3C/$XjL$*NYX,1 6;YH&<XkK9C#I74.>}Hd`A748X[T450[n75<4439:18A107>|ET}Rf<1;14876/Yb983E<5.YNXd4149>,S=/4E/<306443G/06}0&}UkYSXFYF=44=-5095=88;63844,9E6644{PL}WA8:>)7+>763>>0/B3A545CCnT}Xm|dv}Xq1L/YNXk/H8;;.R63351YY747@15YE4J8;46;.38.>4A369.=-83,;Ye3?:3@YE.4-+N353;/;@(X[YYD>@/05-I*@.:551741Yf5>6A443<3535;.58/86=D4753442$635D1>0359NQ @73:3:>><Xn?;43C14 ?Y|X611YG1&<+,4<*,YLXl<1/AIXjF*N89A4Z576K1XbJ5YF.ZOWN.YGXO/YQ01:4G38Xl1;KI0YFXB=R<7;D/,/4>;$I,YGXm94@O35Yz66695385.>:6A#5}W7n^4336:4157597434433<3|XA}m`>=D>:4A.337370?-6Q96{`E|4A}C`|Qs{Mk|J+~r>|o,wHv>Vw}!c{H!|Gb|*Ca5}J||,U{t+{CN[!M65YXOY_*B,Y[Z9XaX[QYJYLXPYuZ%XcZ8LY[SYPYKZM<LMYG9OYqSQYM~[e{UJXmQYyZM_)>YjN1~[f3{aXFY|Yk:48YdH^NZ0|T){jVFYTZNFY^YTYN~[h{nPYMYn3I]`EYUYsYIZEYJ7Yw)YnXPQYH+Z.ZAZY]^Z1Y`YSZFZyGYHXLYG 8Yd#4~[i|+)YH9D?Y^F~Y7|-eYxZ^WHYdYfZQ~[j|3>~[k|3oYmYqY^XYYO=Z*4[]Z/OYLXhZ1YLZIXgYIHYEYK,<Y`YEXIGZI[3YOYcB4SZ!YHZ*&Y{Xi3~[l|JSY`Zz?Z,~[m|O=Yi>??XnYWXmYS617YVYIHZ(Z4[~L4/=~[n|Yu{P)|];YOHHZ}~[o33|a>~[r|aE]DH~[s|e$Zz~[t|kZFY~XhYXZB[`Y}~[u|{SZ&OYkYQYuZ2Zf8D~[v}% ~[w3},Q[X]+YGYeYPIS~[y}4aZ!YN^!6PZ*~[z}?E~[{3}CnZ=~[}}EdDZz/9A3(3S<,YR8.D=*XgYPYcXN3Z5 4)~[~}JW=$Yu.XX~] }KDX`PXdZ4XfYpTJLY[F5]X~[2Yp}U+DZJ::<446[m@~]#3}]1~]%}^LZwZQ5Z`/OT<Yh^ -~]&}jx[ ~m<z!%2+~ly4VY-~o>}p62yz!%2+Xf2+~ly4VY-zQ`z (=] 2z~o2\",C={\" \":0,\"!\":1},c=34,i=2,p,s=\"\",u=String.fromCharCode,t=u(12539);for(;++c<127;)C[u(c)]=c^39&&c^92?i++:0;i=0;for(;0<=(c=C[a.charAt(i++)]);)if(16===c)if((c=C[a.charAt(i++)])<87){if(86===c)c=1879;for(;c--;)s+=u(++p)}else s+=s.substr(8272,360);else if(c<86)s+=u(p+=c<51?c-16:(c-55)*92+C[a.charAt(i++)]);else if((c=((c-86)*92+C[a.charAt(i++)])*92+C[a.charAt(i++)])<49152)s+=u(p=c<40960?c:c|57344);else{c&=511;for(;c--;)s+=t;p=12539}return s')(),Util.$decodeToShiftJis=function(t){return t.replace(/%(8[1-9A-F]|[9E][0-9A-F]|F[0-9A-C])(%[4-689A-F][0-9A-F]|%7[0-9A-E]|[@-~])|%([0-7][0-9A-F]|A[1-9A-F]|[B-D][0-9A-F])/gi,(function(t){let e=parseInt(t.substring(1,3),16);const s=t.length;return 3===s?String.fromCharCode(e<160?e:e+65216):Util.$JCT11280.charAt(188*(e<160?e-129:e-193)+(4===s?t.charCodeAt(3)-64:(e=parseInt(t.substring(4),16))<127?e-64:e-65))}))},Util.$getTagObject=function(){return Util.$tagObjects.pop()||{placeObjects:[],sounds:[],removeObjects:[],frameLabel:[]}},Util.$poolTagObject=function(t){t.placeObjects.length=0,t.sounds.length=0,t.removeObjects.length=0,t.frameLabel.length=0,Util.$tagObjects.push(t)},Util.$createMovieClip=function(){const t={_$characterId:0,_$name:\"MovieClip\",_$controller:[],_$placeObjects:[],_$placeMap:[],_$labels:[],_$dictionary:[],_$sounds:[]};return t},Util.$getControllerAt=function(t,e,s){return s in t._$controller[e]?t._$controller[e][s]:null},Util.$addDictionary=function(t,e){const s=t._$dictionary.length,a={CharacterId:e.CharacterId,Depth:e.Depth,Name:null,ClipDepth:0,PlaceFlagHasImage:0|e.PlaceFlagHasImage,StartFrame:0|e.StartFrame,EndFrame:0|e.EndFrame};return e.PlaceFlagHasName&&(a.Name=e.Name),e.PlaceFlagHasClipDepth&&(a.ClipDepth=e.ClipDepth),t._$dictionary[s]=a,s},Util.$getBlendName=function(t){switch(t){default:return\"normal\";case 2:case\"layer\":return\"layer\";case 3:case\"multiply\":return\"multiply\";case 4:case\"screen\":return\"screen\";case 5:case\"lighten\":return\"lighten\";case 6:case\"darken\":return\"darken\";case 7:case\"difference\":return\"difference\";case 8:case\"add\":return\"add\";case 9:case\"subtract\":return\"subtract\";case 10:case\"invert\":return\"invert\";case 11:case\"alpha\":return\"alpha\";case 12:case\"erase\":return\"erase\";case 13:case\"overlay\":return\"overlay\";case 14:case\"hardlight\":return\"hardlight\"}};class ByteStream{constructor(){this.clear()}clear(){this.data=null,this.bit_offset=0,this.byte_offset=0,this.bit_buffer=null}setData(t){this.data=t}getData(t){this.byteAlign();const e=this.byte_offset+t,s=this.data.subarray(this.byte_offset,e);return this.byte_offset=e,s}byteAlign(){this.bit_offset&&(this.byte_offset=this.byte_offset+(this.bit_offset+7)/8|0,this.bit_offset=0)}getDataUntil(t=0){this.byteAlign();let e=\"\";for(;;){const t=this.data[this.byte_offset++];if(!t)break;if(10===t||13===t){e+=\"\\n\";continue}let s=t.toString(16);1===s.length&&(s=\"0\"+s),e+=\"%\"+s}if(!e.length)return\"\";if(e.length>5&&\"\\n\"===e.substr(-5)&&(e=e.slice(0,-5)),t)return Util.$decodeToShiftJis(e);try{return decodeURIComponent(e)}catch(t){return Util.$decodeToShiftJis(e)}}byteCarry(){if(this.bit_offset>7)this.byte_offset=this.byte_offset+(0|(this.bit_offset+7)/8),this.bit_offset&=7;else for(;this.bit_offset<0;)--this.byte_offset,this.bit_offset+=8}getUIBits(t){let e=0;for(;t;)e<<=1,e|=this.getUIBit(),--t;return e}getUIBit(){return this.byteCarry(),this.data[this.byte_offset]>>7-this.bit_offset++&1}getSIBits(t){const e=this.getUIBits(t),s=e&1<<t-1;return s?-(e^2*s-1)-1:e}getUI8(){return this.byteAlign(),this.data[this.byte_offset++]}getUI16(){return this.byteAlign(),this.getUI8()|this.getUI8()<<8}getUI32(){return this.byteAlign(),this.getUI8()|(this.getUI8()|(this.getUI8()|this.getUI8()<<8)<<8)<<8}getFloat16(){const t=this.data[this.byte_offset++];let e=0;return e|=this.data[this.byte_offset++]<<8,e|=t<<0,e}getFloat32(){const t=this.data[this.byte_offset++],e=this.data[this.byte_offset++],s=this.data[this.byte_offset++];let a=0;a|=this.data[this.byte_offset++]<<24,a|=s<<16,a|=e<<8,a|=t<<0;const i=a>>23&255;return a&&2147483648!==a?(2147483648&a?-1:1)*(8388608|8388607&a)*Math.pow(2,i-127-23):0}incrementOffset(t,e){this.byte_offset+=t,this.bit_offset+=e,this.byteCarry()}setOffset(t,e){this.byte_offset=t,this.bit_offset=e}}class SwfParser{constructor(){this.byteStream=new ByteStream,this.currentPosition={x:0,y:0},this.jpegTables=null,this.characters=[],this.frameInfo=[],this.fonts=new Map,this.textSettings=new Map,this.grids=new Map,this.version=0}clear(){this.byteStream.clear(),this.currentPosition.x=0,this.currentPosition.y=0,this.jpegTables=null,this.characters.length=0,this.frameInfo.length=0,this.version=0}getCharacter(t){return this.characters[t]}setCharacter(t,e,s){this.characters[t]=e,globalThis.postMessage({infoKey:\"character\",characterId:t,piece:e},s)}getFont(t){return this.fonts.get(t)}setFont(t,e){this.fonts.set(t,e)}setTextSetting(t,e){this.textSettings.set(t,e)}setGrid(t,e){this.grids.set(t,e)}showFrame(t,e,s,a){let i,r;const h=s-1|0,n=e.frameLabel;i=n.length;for(let e=0;e<i;++e){const a=n[e];a.name in this.frameInfo&&(a.frame=this.frameInfo[\"@\"+a.name]),t._$labels.push({label:a.name,frame:a.frame||s})}const o=e.sounds;i=0|o.length,i&&t._$sounds.push({frame:s,data:o.slice(0)});const l=e.removeObjects;i=l.length;for(let e=0;e<i;++e){const a=l[e],i=Util.$getControllerAt(t,h,a.Depth);t._$dictionary[i].EndFrame=s,Util.$installed.set(a.Depth,1)}s in a||(a[s]=[]),s in t._$controller||(t._$controller[s]=[]),s in t._$placeMap||(t._$placeMap[s]=[]);const c=e.placeObjects,b=h?a[h]:null;i=c.length;for(let e=0;e<i;++e){let i=null;const r=c[e];let n=null;h&&r.Depth in b&&(n=b[r.Depth]),0===r.PlaceFlagHasCharacter&&n&&(r.CharacterId=n.CharacterId);let o=!1;if((0===r.PlaceFlagMove||1===r.PlaceFlagMove&&1===r.PlaceFlagHasCharacter)&&(o=!0),h&&!o&&(i=Util.$getControllerAt(t,h,r.Depth),null===i&&(o=!0)),1===r.PlaceFlagMove&&n&&(1!==n.PlaceFlagHasMatrix||r.PlaceFlagHasMatrix||(r.PlaceFlagHasMatrix=1,r.Matrix=n.Matrix),1!==n.PlaceFlagHasColorTransform||r.PlaceFlagHasColorTransform||(r.PlaceFlagHasColorTransform=1,r.ColorTransform=n.ColorTransform),1!==n.PlaceFlagHasClipDepth||r.PlaceFlagHasClipDepth||(r.PlaceFlagHasClipDepth=1,r.ClipDepth=n.ClipDepth),1!==n.PlaceFlagHasRatio||r.PlaceFlagHasRatio||(r.PlaceFlagHasRatio=1,r.Ratio=n.Ratio),1!==n.PlaceFlagHasFilterList||r.PlaceFlagHasFilterList||(r.PlaceFlagHasFilterList=1,r.SurfaceFilterList=n.SurfaceFilterList),1!==n.PlaceFlagHasBlendMode||r.PlaceFlagHasBlendMode||(r.PlaceFlagHasBlendMode=1,r.BlendMode=n.BlendMode)),h&&!Util.$installed.has(r.Depth)){const e=Util.$getControllerAt(t,h,r.Depth);if(null!==e){const a=t._$dictionary[e];!a||0!==r.PlaceFlagMove&&1!==r.PlaceFlagHasCharacter||(a.EndFrame=0|s,t._$dictionary[e]=a,o=!0)}}if(o){if(r.StartFrame=0|s,r.EndFrame=0,1===r.PlaceFlagHasCharacter&&1===r.PlaceFlagMove){const e=Util.$getControllerAt(t,h,r.Depth),a=t._$dictionary[e];a.EndFrame=0|s,t._$dictionary[e]=a}i=Util.$addDictionary(t,r)}t._$controller[s][r.Depth]=i;const l=t._$placeObjects.length;t._$placeObjects[l]=this.buildPlaceObject(r),t._$placeMap[s][r.Depth]=l,Util.$installed.set(r.Depth,1),a[s][r.Depth]=r}if(h){let e;const n=t._$controller[h];r=Object.keys(n),i=r.length;for(let o=0;o<i;++o)e=0|r[o],Util.$installed.has(e)||(a[s][e]=a[h][e],t._$controller[s][e]=n[e]);const o=t._$placeMap[h];r=Object.keys(o),i=r.length;for(let a=0;a<i;++a)e=r[a],e in t._$placeMap[s]||(t._$placeMap[s][e]=o[e])}Util.$installed.clear()}buildPlaceObject(t){const e={matrix:[1,0,0,1,0,0],colorTransform:[1,1,1,1,0,0,0,0],filters:null,blendMode:\"normal\"};return t.PlaceFlagHasMatrix&&(e.matrix=t.Matrix),t.PlaceFlagHasColorTransform&&(e.colorTransform=t.ColorTransform),t.PlaceFlagHasFilterList&&(e.surfaceFilterList=t.SurfaceFilterList),t.PlaceFlagHasBlendMode&&(e.blendMode=Util.$getBlendName(t.BlendMode)),t.PlaceFlagHasRatio&&(e.ratio=t.Ratio||0),e}postData(t){if(this.textSettings.size){for(let[t,e]of this.textSettings){const s=this.characters[t];s&&(s._$textSetting=e,globalThis.postMessage({infoKey:\"character\",characterId:t,piece:s}))}this.textSettings.clear()}if(this.grids.size){for(let[t,e]of this.grids){const s=this.characters[t];s&&(s._$grid=e,globalThis.postMessage({infoKey:\"character\",characterId:t,piece:s}))}this.grids.clear()}if(this.fonts.size){for(let[t,e]of this.fonts){if(!e._$hasLayout){globalThis.postMessage({infoKey:\"font\",index:t,piece:e});continue}const s=e._$glyphShapeTable,a=e._$zoneTable;e._$glyphShapeTable=[],e._$zoneTable=a?[]:null,globalThis.postMessage({infoKey:\"font\",index:t,piece:e},[e._$advanceTable.buffer,e._$codeTable.buffer]);const i=s.length;if(i){const e=[],a=[];for(let r=0;r<i;++r){const i=s[r];e.push(i),a.push(i.records.buffer),e.length>256&&(globalThis.postMessage({infoKey:\"font_shape\",index:t,pieces:e},a),a.length=0,e.length=0)}e.length&&globalThis.postMessage({infoKey:\"font_shape\",index:t,pieces:e},a)}if(a)for(;a.length;){const e=Math.min(256,a.length);globalThis.postMessage({infoKey:\"font_zone\",index:t,pieces:a.splice(0,e)})}}this.fonts.clear()}for(let e=1;e<t._$controller.length;++e){const s=t._$controller[e];t._$controller[e]=s.filter((()=>!0))}this.setCharacter(0,t)}parseTags(t,e){const s=Util.$getTagObject();let a=1;const i=[],r=this.byteStream;for(;r.byte_offset<t;){const h=r.byte_offset;if(h+2>t)break;const n=r.getUI16(),o=n>>6;let l=63&n;if(63===l){if(h+6>t){r.byte_offset=h,r.bit_offset=0;break}l=r.getUI32()}const c=r.byte_offset;this.parseTag(o,l,e,a,s,i),1===o&&(++a,s.placeObjects.length=0,s.sounds.length=0,s.removeObjects.length=0,s.frameLabel.length=0);const b=r.byte_offset-c|0;b!==l&&b<l&&(r.byte_offset=r.byte_offset+(l-b)),r.bit_offset=0}Util.$poolTagObject(s)}parseTag(t,e,s,a,i,r){switch(t){case 28:i.removeObjects.push({Frame:a,Depth:this.byteStream.getUI16()});break;case 4:case 26:case 70:i.placeObjects.push(this.parsePlaceObject(t,e));break;case 39:{const t=this.byteStream.byte_offset+e,s=this.byteStream.getUI16();this.byteStream.getUI16();const a=Util.$createMovieClip();a._$characterId=s,this.parseTags(t,a);for(let t=1;t<a._$controller.length;++t){const e=a._$controller[t];a._$controller[t]=e.filter((()=>!0))}this.setCharacter(s,a)}break;case 1:this.showFrame(s,i,a,r);break;case 2:case 22:case 32:case 83:e<10?this.byteStream.byte_offset+=e:this.parseDefineShape(t);break;case 20:case 36:this.parseDefineBitsLossLess(t,e);break;case 6:case 21:case 35:case 90:this.parseDefineBits(t,e,this.jpegTables);break;case 15:case 89:i.sounds.push(this.parseStartSound(t));break;case 10:case 48:case 75:this.parseDefineFont(t,e);break;case 14:this.parseDefineSound(e);break;case 13:case 62:this.parseDefineFontInfo(t,e);break;case 43:i.frameLabel.push(this.parseFrameLabel());break;case 11:case 33:this.parseDefineText(t);break;case 37:this.parseDefineEditText(t);break;case 7:case 34:this.parseDefineButton(t,e);break;case 88:this.parseDefineFontName();break;case 8:e&&(this.jpegTables=this.parseJPEGTables(e));break;case 46:case 84:this.parseDefineMorphShape(t);break;case 18:case 45:this.parseSoundStreamHead(t);break;case 17:this.parseDefineButtonSound();break;case 73:this.parseDefineFontAlignZones();break;case 74:this.parseCSMTextSettings(t);break;case 19:this.parseSoundStreamBlock(t,e);break;case 78:this.parseDefineScalingGrid();break;case 5:console.log(\"TODO RemoveObject type 5.\"),i.removeObjects.push({CharacterId:this.byteStream.getUI16(),Depth:this.byteStream.getUI16()});break;default:break;case 86:case 76:case 56:case 9:case 40:case 24:case 63:case 64:case 69:case 65:case 77:case 60:case 61:case 41:case 87:case 59:case 12:case 72:case 82:this.byteStream.byte_offset+=e;break;case 3:case 16:case 23:case 25:case 29:case 31:case 38:case 42:case 44:case 47:case 49:case 52:case 53:case 54:case 55:case 57:case 58:case 66:case 71:case 91:case 93:console.log(\"[TODO] tagType -> \"+t)}}parseDefineShape(t){const e=0|this.byteStream.getUI16(),s=this.rect();if(83===t){const t={};this.rect(),this.byteStream.getUIBits(5),t.UsesFillWindingRule=this.byteStream.getUIBits(1),t.UsesNonScalingStrokes=this.byteStream.getUIBits(1),t.UsesScalingStrokes=this.byteStream.getUIBits(1)}const a=this.shapeWithStyle(t);this.setCharacter(e,{_$records:a,_$name:\"Shape\",_$bounds:s,_$characterId:e},[a.ShapeData.records.buffer])}rect(){this.byteStream.byteAlign();const t=this.byteStream.getUIBits(5);return{xMin:this.byteStream.getSIBits(t)/20,xMax:this.byteStream.getSIBits(t)/20,yMin:this.byteStream.getSIBits(t)/20,yMax:this.byteStream.getSIBits(t)/20}}shapeWithStyle(t){const e={};switch(t){case 46:case 84:break;default:e.fillStyles=this.fillStyleArray(t),e.lineStyles=this.lineStyleArray(t)}const s=this.byteStream.getUI8(),a=s>>4,i=15&s;return e.ShapeData=this.shapeRecords(t,{FillBits:a,LineBits:i}),e}fillStyleArray(t){let e=0|this.byteStream.getUI8();t>2&&255===e&&(e=this.byteStream.getUI16());const s=[];for(let a=0;a<e;++a)s[s.length]=this.fillStyle(t);return s}fillStyle(t){const e=this.byteStream.getUI8(),s={};switch(s.fillStyleType=e,e){case 0:switch(t){case 32:case 83:s.Color=this.rgba();break;case 46:case 84:s.StartColor=this.rgba(),s.EndColor=this.rgba();break;default:s.Color=this.rgb()}break;case 16:case 18:switch(t){case 46:case 84:s.startGradientMatrix=this.matrix(),s.endGradientMatrix=this.matrix(),s.gradient=this.gradient(t);break;default:s.gradientMatrix=this.matrix(),s.gradient=this.gradient(t)}break;case 19:s.gradientMatrix=this.matrix(),s.gradient=this.focalGradient(t);break;case 64:case 65:case 66:case 67:switch(s.bitmapId=this.byteStream.getUI16(),t){case 46:case 84:s.startBitmapMatrix=this.matrix(),s.endBitmapMatrix=this.matrix();break;default:s.bitmapMatrix=this.matrix()}}return s}rgb(){return{R:0|this.byteStream.getUI8(),G:0|this.byteStream.getUI8(),B:0|this.byteStream.getUI8(),A:1}}rgba(){return{R:this.byteStream.getUI8(),G:this.byteStream.getUI8(),B:this.byteStream.getUI8(),A:this.byteStream.getUI8()/255}}matrix(){this.byteStream.byteAlign();const t=[1,0,0,1,0,0];if(this.byteStream.getUIBit()){const e=this.byteStream.getUIBits(5);t[0]=this.byteStream.getSIBits(e)/65536,t[3]=this.byteStream.getSIBits(e)/65536}if(this.byteStream.getUIBit()){const e=this.byteStream.getUIBits(5);t[1]=this.byteStream.getSIBits(e)/65536,t[2]=this.byteStream.getSIBits(e)/65536}const e=this.byteStream.getUIBits(5);return t[4]=this.byteStream.getSIBits(e)/20,t[5]=this.byteStream.getSIBits(e)/20,t}gradient(t){let e,s=0,a=0;switch(this.byteStream.byteAlign(),t){case 46:case 84:e=this.byteStream.getUI8();break;default:s=this.byteStream.getUIBits(2),a=this.byteStream.getUIBits(2),e=this.byteStream.getUIBits(4)}const i=[];for(let s=0;s<e;++s)i[i.length]=this.gradientRecord(t);return{SpreadMode:s,InterpolationMode:a,GradientRecords:i,FocalPoint:0}}gradientRecord(t){switch(t){case 46:case 84:return{StartRatio:this.byteStream.getUI8()/255,StartColor:this.rgba(),EndRatio:this.byteStream.getUI8()/255,EndColor:this.rgba()};default:return{Ratio:this.byteStream.getUI8()/255,Color:t<32?this.rgb():this.rgba()}}}focalGradient(t){this.byteStream.byteAlign();const e=this.byteStream.getUIBits(2),s=this.byteStream.getUIBits(2),a=this.byteStream.getUIBits(4),i=[];for(let e=0;e<a;++e)i[i.length]=this.gradientRecord(t);return{SpreadMode:e,InterpolationMode:s,GradientRecords:i,FocalPoint:this.byteStream.getFloat16()}}lineStyleArray(t){let e=this.byteStream.getUI8();t>2&&255===e&&(e=this.byteStream.getUI16());const s=[];for(let a=0;a<e;++a)s[s.length]=this.lineStyles(t);return s}lineStyles(t){const e={fillStyleType:0};switch(t){case 46:e.StartWidth=this.byteStream.getUI16()/20,e.EndWidth=this.byteStream.getUI16()/20,e.StartColor=this.rgba(),e.EndColor=this.rgba();break;case 84:e.StartWidth=this.byteStream.getUI16()/20,e.EndWidth=this.byteStream.getUI16()/20,e.StartCapStyle=this.byteStream.getUIBits(2),e.JoinStyle=this.byteStream.getUIBits(2),e.HasFillFlag=this.byteStream.getUIBit(),e.NoHScaleFlag=this.byteStream.getUIBit(),e.NoVScaleFlag=this.byteStream.getUIBit(),e.PixelHintingFlag=this.byteStream.getUIBit(),this.byteStream.getUIBits(5),e.NoClose=this.byteStream.getUIBit(),e.EndCapStyle=this.byteStream.getUIBits(2),2===e.JoinStyle&&(e.MiterLimitFactor=this.byteStream.getUI16()/20),e.HasFillFlag?e.FillType=this.fillStyle(t):(e.StartColor=this.rgba(),e.EndColor=this.rgba());break;case 83:e.Width=this.byteStream.getUI16()/20,e.StartCapStyle=this.byteStream.getUIBits(2),e.JoinStyle=this.byteStream.getUIBits(2),e.HasFillFlag=this.byteStream.getUIBit(),e.NoHScaleFlag=this.byteStream.getUIBit(),e.NoVScaleFlag=this.byteStream.getUIBit(),e.PixelHintingFlag=this.byteStream.getUIBit(),this.byteStream.getUIBits(5),e.NoClose=this.byteStream.getUIBit(),e.EndCapStyle=this.byteStream.getUIBits(2),2===e.JoinStyle&&(e.MiterLimitFactor=this.byteStream.getUI16()),e.HasFillFlag?e.FillType=this.fillStyle(t):e.Color=this.rgba();break;case 32:e.Width=this.byteStream.getUI16()/20,e.Color=this.rgba(),e.JoinStyle=0,e.StartCapStyle=0,e.EndCapStyle=0;break;default:e.Width=this.byteStream.getUI16()/20,e.Color=this.rgb(),e.JoinStyle=0,e.StartCapStyle=0,e.EndCapStyle=0}return e}shapeRecords(t,e){this.currentPosition.x=0,this.currentPosition.y=0;const s=[],a=[];for(;;){const i=this.byteStream.getUIBits(6);if(32&i){const e=15&i;if(16&i){this.straightEdgeRecord(t,e,s);continue}this.curvedEdgeRecord(t,e,s)}else{if(!i){s.push(-1),this.byteStream.byteAlign();break}this.styleChangeRecord(t,i,e,s,a)}}const i={records:new Int32Array(s)};return a.length&&(i.styles=a),i}straightEdgeRecord(t,e,s){let a=0,i=0;this.byteStream.getUIBit()?(a=this.byteStream.getSIBits(e+2),i=this.byteStream.getSIBits(e+2)):this.byteStream.getUIBit()?i=this.byteStream.getSIBits(e+2):a=this.byteStream.getSIBits(e+2);let r=a,h=i;switch(t){case 46:case 84:break;default:r=this.currentPosition.x+a,h=this.currentPosition.y+i,this.currentPosition.x=r,this.currentPosition.y=h}s.push(0,0,r,h)}curvedEdgeRecord(t,e,s){const a=this.byteStream.getSIBits(e+2),i=this.byteStream.getSIBits(e+2),r=this.byteStream.getSIBits(e+2),h=this.byteStream.getSIBits(e+2);let n=a,o=i,l=r,c=h;switch(t){case 46:case 84:break;default:n=this.currentPosition.x+a,o=this.currentPosition.y+i,l=n+r,c=o+h,this.currentPosition.x=l,this.currentPosition.y=c}s.push(0,1,n,o,l,c)}styleChangeRecord(t,e,s,a,i){const r=e>>4&1,h=e>>3&1,n=e>>2&1,o=e>>1&1,l=1&e;let c=0,b=0;if(l){const t=this.byteStream.getUIBits(5);c=this.byteStream.getSIBits(t),b=this.byteStream.getSIBits(t),this.currentPosition.x=c,this.currentPosition.y=b}const g=o?this.byteStream.getUIBits(s.FillBits):0,y=n?this.byteStream.getUIBits(s.FillBits):0,S=h?this.byteStream.getUIBits(s.LineBits):0;let m=null,f=null,d=0,Y=0;if(r){m=this.fillStyleArray(t),f=this.lineStyleArray(t);const e=this.byteStream.getUI8();s.FillBits=d=e>>4,s.LineBits=Y=15&e}a.push(1,r),r&&(a.push(d,Y),i.push({FillStyles:m,LineStyles:f})),a.push(l),l&&a.push(c,b),a.push(o),o&&a.push(g),a.push(n),n&&a.push(y),a.push(h),h&&a.push(S)}parseDefineBitsLossLess(t,e){const s=this.byteStream.byte_offset,a=this.byteStream.getUI16(),i=this.byteStream.getUI8(),r=this.byteStream.getUI16(),h=this.byteStream.getUI16(),n=36===t,o=3===i?this.byteStream.getUI8()+1:0;let l=r*h*4;if(3===i){l=(r+((r+3&-4)-r|0))*h+o*(n?4:3)}const c=e-(this.byteStream.byte_offset-s),b=this.byteStream.byte_offset;this.byteStream.byte_offset+=c;const g=this.byteStream.data.slice(b,this.byteStream.byte_offset),y={width:r,height:h,format:i,fileSize:l,tableSize:o,isAlpha:n,color:n?4278190080:0,_$name:\"lossless\",_$characterId:a,buffer:g};this.setCharacter(a,y,[g.buffer])}parseJPEGTables(t){const e=this.byteStream.byte_offset;return this.byteStream.byte_offset+=t,{offset:e,length:this.byteStream.byte_offset}}parseDefineBits(t,e,s=null){const a=this.byteStream.byte_offset,i=this.byteStream.getUI16(),r=this.byteStream.byte_offset-a,h=35===t||90===t?this.byteStream.getUI32():e-r;if(90===t){const t=this.byteStream.getUI16();console.log(\"TODO DeblockParam\",t)}const n=this.byteStream.byte_offset;this.byteStream.byte_offset+=h;let o=this.byteStream.data.slice(n,this.byteStream.byte_offset);if(s){const t=this.byteStream.data.subarray(s.offset,s.length);if(t.length>4&&255===o[0]&&216===o[1]){const e=t.length-2,s=o.length,a=new Uint8Array(e+s);a.set(t.subarray(0,e),0),a.set(o.subarray(2,s),e),o=a}}const l={infoKey:\"character\",_$name:\"imageData\",_$characterId:i,jpegData:o,alphaData:null},c=[];c.push(o.buffer);let b=!1;const g=a+e-this.byteStream.byte_offset;if(g){b=!0;const t=this.byteStream.byte_offset;this.byteStream.byte_offset+=g;const e=this.byteStream.data.slice(t,this.byteStream.byte_offset);l.alphaData=e,c.push(e.buffer)}l.isAlpha=b,l.color=b?4278190080:0,this.setCharacter(i,l,c)}parseDefineFont(t,e){const s=this.byteStream.byte_offset+e|0,a=this.byteStream.getUI16(),i=this.getFont(a)||{};let r=0,h=0,n=0;if(48===t||75===t){const t=this.byteStream.getUI8();i._$hasLayout=t>>>7&1,i._$shiftJIS=t>>>6&1,i._$smallText=t>>>5&1,i._$ANSI=t>>>4&1,h=t>>>3&1,n=t>>>2&1,i._$italic=t>>>1&1,i._$bold=1&t,this.byteStream.byteAlign(),i._$languageCode=this.byteStream.getUI8();const e=this.byteStream.getUI8();if(e){const t=0|this.byteStream.byte_offset;i._$fontName=this.getFontName(this.byteStream.getDataUntil()),this.byteStream.byte_offset=t+e|0}r=this.byteStream.getUI16(),i._$numGlyphs=r}const o=0|this.byteStream.byte_offset;if(10===t&&(r=this.byteStream.getUI16()),r){const e=[];10===t&&(e[0]=r,r/=2,r-=1);let s=0;if(1===h){for(let t=0;t<r;++t)e[e.length]=this.byteStream.getUI32();10!==t&&(s=this.byteStream.getUI32())}else{for(let t=0;t<r;++t)e[e.length]=this.byteStream.getUI16();10!==t&&(s=this.byteStream.getUI16())}const a=[];10===t&&(r+=1);for(let s=0;s<r;++s){this.byteStream.setOffset(e[s]+o,0);const i=this.byteStream.getUI8(),r={FillBits:i>>4,LineBits:15&i};a[a.length]=this.shapeRecords(t,r)}switch(i._$glyphShapeTable=a,t){case 48:case 75:if(this.byteStream.setOffset(s+o,0),1===n){const t=new Uint16Array(r);for(let e=0;e<r;++e)t[e]=this.byteStream.getUI16();i._$codeTable=t}else{const t=new Uint8Array(r);for(let e=0;e<r;++e)t[e]=this.byteStream.getUI8();i._$codeTable=t}if(i._$hasLayout){i._$ascent=this.byteStream.getUI16(),i._$descent=this.byteStream.getUI16(),i._$leading=this.byteStream.getUI16();const e=new Uint16Array(r);for(let t=0;t<r;++t)e[t]=this.byteStream.getUI16();i._$advanceTable=e;const s=[];for(let t=0;t<r;++t)s[s.length]=this.rect();if(75===t){const t=this.byteStream.getUI16(),e=[];for(let s=0;s<t;++s){const t=n?this.byteStream.getUI16():this.byteStream.getUI8(),s=n?this.byteStream.getUI16():this.byteStream.getUI8(),a=this.byteStream.getSIBits(16);e[e.length]={FontKerningCode1:t,FontKerningCode2:s,FontKerningAdjustment:a}}i._$kerningRecords=e}}}}this.byteStream.byte_offset=0|s,this.setFont(a,i)}parseDefineFontInfo(t,e){const s=this.byteStream.byte_offset+e|0,a=this.byteStream.getUI16();let i=this.getFont(a);i||(i={});const r=this.byteStream.getUI8(),h=this.byteStream.getData(r);let n=\"\";for(let t=0;t<r;++t)h[t]>127||(n+=String.fromCharCode(h[t]));this.byteStream.getUIBits(2),i._$smallText=this.byteStream.getUIBits(1),i._$shiftJIS=this.byteStream.getUIBits(1),i._$ANSI=this.byteStream.getUIBits(1),i._$italic=this.byteStream.getUIBits(1),i._$bold=this.byteStream.getUIBits(1);const o=this.byteStream.getUIBits(1);62===t&&(i._$languageCode=this.byteStream.getUI8());const l=i._$shiftJIS||2===i._$languageCode?Util.$decodeToShiftJis(n):decodeURIComponent(n);i._$fontName=this.getFontName(l),this.byteStream.byteAlign();const c=[];let b=null;if(!0==(1===o||62===t)){for(;this.byteStream.byte_offset<s;)c[c.length]=this.byteStream.getUI16();b=new Uint16Array(c)}else{for(;this.byteStream.byte_offset<s;)c[c.length]=this.byteStream.getUI8();b=new Uint8Array(c)}i._$codeTable=b,this.setFont(a,i)}getFontName(t){const e=0|t.length;switch(0===t.substr(e-1).charCodeAt(0)&&(t=t.slice(0,-1)),t){case\"_sans\":return\"_sans\";case\"_serif\":return\"_serif\";case\"_typewriter\":return\"_typewriter\";case\"_等幅\":return\"Osaka\";default:return\"_\"===t.substr(0,1)?\"sans-serif\":t}}parseDefineFontName(){this.byteStream.getUI16(),this.byteStream.getDataUntil(),this.byteStream.getDataUntil()}parseDefineText(t){const e={_$name:\"StaticText\"};e._$characterId=0|this.byteStream.getUI16(),e._$bounds=this.rect(),e._$baseMatrix=this.matrix(),e._$shapeRecords=null;const s=this.byteStream.getUI8(),a=this.byteStream.getUI8();e._$textRecords=this.getTextRecords(t,s,a),this.setCharacter(e._$characterId,e)}getTextRecords(t,e,s){const a=[];for(;0!==this.byteStream.getUI8();){this.byteStream.incrementOffset(-1,0);const i={};i.TextRecordType=this.byteStream.getUIBits(1),i.StyleFlagsReserved=this.byteStream.getUIBits(3),i.StyleFlagsHasFont=this.byteStream.getUIBits(1),i.StyleFlagsHasColor=this.byteStream.getUIBits(1),i.StyleFlagsHasYOffset=this.byteStream.getUIBits(1),i.StyleFlagsHasXOffset=this.byteStream.getUIBits(1),i.StyleFlagsHasFont&&(i.FontId=this.byteStream.getUI16()),i.StyleFlagsHasColor&&(i.TextColor=11===t?this.rgb():this.rgba()),i.StyleFlagsHasXOffset&&(i.XOffset=this.byteStream.getUI16()/20),i.StyleFlagsHasYOffset&&(i.YOffset=this.byteStream.getUI16()/20),i.StyleFlagsHasFont&&(i.TextHeight=this.byteStream.getUI16()),i.GlyphCount=this.byteStream.getUI8(),i.GlyphEntries=this.getGlyphEntries(i.GlyphCount,e,s),a[a.length]=i}return a}getGlyphEntries(t,e,s){const a=[];for(let i=0;i<t;++i)a[a.length]={GlyphIndex:this.byteStream.getUIBits(e),GlyphAdvance:this.byteStream.getSIBits(s)/20};return a}parseDefineEditText(){const t={_$ns:[\"flash\",\"text\"],_$name:\"TextField\"},e={},s=this.byteStream.getUI16();t._$characterId=s,t._$bounds=this.rect();const a=this.byteStream.getUI8(),i=a>>>7&1;t._$wordWrap=a>>>6&1,t._$multiline=a>>>5&1,t._$displayAsPassword=a>>>4&1;const r=a>>>3&1;t._$type=\"dynamic\",r||(t._$type=\"input\");const h=a>>>2&1,n=a>>>1&1,o=1&a,l=this.byteStream.getUI8(),c=l>>>7&1,b=l>>>5&1;t._$selectable=l>>>4&1,t._$border=l>>>3&1;const g=l>>>1&1,y=1&l;t._$border&&(t._$background=!0);let S=0;if(o){const s=this.byteStream.getUI16(),a=this.getFont(s);if(a){if(S=a._$shiftJIS,c){const t=this.byteStream.getDataUntil();console.log(\"TODO HasFontClass: \",t)}e._$font=a._$fontName,e._$size=this.byteStream.getUI16()/20,t._$fontId=0|s,t._$embedFonts=!(!y&&\"embedded\"!==a.fontType||t.displayAsPassword)}}if(h){const e=this.rgba();t._$textColor=(e.R<<16)+(e.G<<8)+e.B+255*e.A*16777216}if(n&&(t._$maxChars=this.byteStream.getUI16()),b){switch(this.byteStream.getUI8()){case 0:e._$align=\"left\";break;case 1:e._$align=\"right\";break;case 2:e._$align=\"center\";break;case 3:e._$align=\"justify\"}e._$leftMargin=this.byteStream.getUI16()/20,e._$rightMargin=this.byteStream.getUI16()/20,e._$indent=this.byteStream.getUI16(),e._$indent>=32768&&(e._$indent-=65536),e._$leading=this.byteStream.getUI16(),e._$leading>=32768&&(e._$leading-=65536),e._$indent/=20,e._$leading/=20}const m=this.byteStream.getDataUntil(S)+\"\";if(t._$text=\"\",i){const e=this.byteStream.getDataUntil(S);if(!0==(1===g))t._$htmlText=e,t._$initText=!0;else t._$text=e}\"\"!==m&&console.log(\"VariableName: \",m),t._$defaultTextFormat=[null,e._$font,e._$size,e._$color,e._$bold,e._$italic,e._$underline,e._$url,e._$target,e._$align,e._$leftMargin,e._$rightMargin,0,e._$leading,e._$indent],this.setCharacter(s,t)}parseDefineMorphShape(t){const e={};e.CharacterId=this.byteStream.getUI16(),e.StartBounds=this.rect(),e.EndBounds=this.rect(),84===t&&(e.StartEdgeBounds=this.rect(),e.EndEdgeBounds=this.rect(),this.byteStream.getUIBits(6),e.UsesNonScalingStrokes=this.byteStream.getUIBits(1),e.UsesScalingStrokes=this.byteStream.getUIBits(1));const s=this.byteStream.getUI32(),a=this.byteStream.byte_offset+s;e.MorphFillStyles=this.fillStyleArray(t),e.MorphLineStyles=this.lineStyleArray(t),e.StartEdges=this.shapeWithStyle(t),this.byteStream.byte_offset!==a&&(this.byteStream.byte_offset=a),e.EndEdges=this.shapeWithStyle(t);const i={x:0,y:0},r={x:0,y:0},h=e.StartEdges.ShapeData.records,n=e.EndEdges.ShapeData.records,o=h.length,l=n.length;let c=Math.max(o,l);const b=[],g=[];let y=0,S=0;for(;c>y||c>S;){const t=h[y++],e=n[S++];if(-1===t&&-1===e)break;switch(!0){case-1===t:case void 0===t:if(e){const t=n[S++];if(g.push(1,t),b.push(1,t),t){const t=n[S++],e=n[S++];g.push(t,e),b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const e=n[S++];if(g.push(e),b.push(e),e){const t=n[S++],e=n[S++];r.x=t,r.y=e,g.push(t,e),b.push(t,e)}const s=n[S++];if(g.push(s),b.push(s),s){const t=n[S++];g.push(t),b.push(t)}const a=n[S++];if(g.push(a),b.push(a),a){const t=n[S++];g.push(t),b.push(t)}const i=n[S++];if(g.push(i),b.push(i),i){const t=n[S++];g.push(t),b.push(t)}break}if(n[S++]){const t=n[S++],e=n[S++],s=n[S++],a=n[S++];r.x+=t+s,r.y+=e+a,g.push(0,1,t,e,s,a),b.push(0,1,t,e,s,a)}else{const t=n[S++],e=n[S++];r.x+=t,r.y+=e,g.push(0,0,t,e),b.push(0,0,t,e)}break;case-1===e:case void 0===e:if(t){const t=h[y++];if(g.push(1,t),b.push(1,t),t){const t=h[y++],e=h[y++];g.push(t,e),b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const e=h[y++];if(g.push(e),b.push(e),e){const t=h[y++],e=h[y++];i.x=t,i.y=e,g.push(t,e),b.push(t,e)}const s=h[y++];if(g.push(s),b.push(s),s){const t=h[y++];g.push(t),b.push(t)}const a=h[y++];if(g.push(a),b.push(a),a){const t=h[y++];g.push(t),b.push(t)}const r=h[y++];if(g.push(r),b.push(r),r){const t=h[y++];g.push(t),b.push(t)}break}if(h[y++]){const t=h[y++],e=h[y++],s=h[y++],a=h[y++];i.x+=t+s,i.y+=e+a,g.push(0,1,t,e,s,a),b.push(0,1,t,e,s,a)}else{const t=h[S++],e=h[S++];i.x+=t,i.y+=e,g.push(0,0,t,e),b.push(0,0,t,e)}break;case 1===t&&1===e:const s=h[y++];if(b.push(1,s),s){const t=h[y++],e=h[y++];b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const a=h[y++];if(b.push(a),a){const t=h[y++],e=h[y++];i.x=t,i.y=e,b.push(t,e)}const o=h[y++];if(b.push(o),o){const t=h[y++];b.push(t)}const l=h[y++];if(b.push(l),l){const t=h[y++];b.push(t)}const c=h[y++];if(b.push(c),c){const t=h[y++];b.push(t)}const m=n[S++];if(g.push(1,m),m){const t=n[S++],e=n[S++];g.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const f=n[S++];if(g.push(f),f){const t=n[S++],e=n[S++];i.x=t,i.y=e,g.push(t,e)}const d=n[S++];if(g.push(d),d){const t=n[S++];g.push(t)}const Y=n[S++];if(g.push(Y),Y){const t=n[S++];g.push(t)}const I=n[S++];if(g.push(I),I){const t=n[S++];g.push(t)}break;case 0===t&&0===e:if(h[y++]){const t=h[y++],e=h[y++],s=h[y++],a=h[y++];i.x=s,i.y=a,b.push(0,1,t,e,s,a)}else{const t=h[y++],e=h[y++];i.x=t,i.y=e,b.push(0,0,t,e)}if(n[S++]){const t=n[S++],e=n[S++],s=n[S++],a=n[S++];r.x=s,r.y=a,g.push(0,1,t,e,s,a)}else{const t=n[S++],e=n[S++];r.x=t,r.y=e,g.push(0,0,t,e)}break;case 1===t&&0===e:{const t=h[y++];if(g.push(1,t),b.push(1,t),t){const t=h[y++],e=h[y++];g.push(t,e),b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const e=h[y++];if(g.push(e),b.push(e),e){const t=h[y++],e=h[y++];i.x=t,i.y=e,g.push(t,e),b.push(t,e)}const s=h[y++];if(g.push(s),b.push(s),s){const t=h[y++];g.push(t),b.push(t)}const a=h[y++];if(g.push(a),b.push(a),a){const t=h[y++];g.push(t),b.push(t)}const r=h[y++];if(g.push(r),b.push(r),r){const t=h[y++];g.push(t),b.push(t)}--S}break;case 0===t&&1===e:{const t=n[S++];if(g.push(1,t),b.push(1,t),t){const t=n[S++],e=n[S++];g.push(t,e),b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const e=n[S++];if(g.push(e),b.push(e),e){const t=n[S++],e=n[S++];r.x=t,r.y=e,g.push(t,e),b.push(t,e)}const s=n[S++];if(g.push(s),b.push(s),s){const t=n[S++];g.push(t),b.push(t)}const a=n[S++];if(g.push(a),b.push(a),a){const t=n[S++];g.push(t),b.push(t)}const i=n[S++];if(g.push(i),b.push(i),i){const t=n[S++];g.push(t),b.push(t)}--y}}}b.push(-1),g.push(-1),e.StartEdges.ShapeData.records=new Int32Array(b),e.EndEdges.ShapeData.records=new Int32Array(g),this.setCharacter(e.CharacterId,{_$ns:[\"flash\",\"display\"],_$name:\"MorphShape\",_$characterId:e.CharacterId,_$endBounds:e.EndBounds,_$endEdges:e.EndEdges,_$fillStyles:e.MorphFillStyles,_$lineStyles:e.MorphLineStyles,_$startBounds:e.StartBounds,_$startEdges:e.StartEdges,_$shapes:null,_$frameData:[],_$frameCreated:!1},[e.StartEdges.ShapeData.records.buffer,e.EndEdges.ShapeData.records.buffer])}parseFrameLabel(){return{name:this.byteStream.getDataUntil(),frame:0}}parseDefineButton(t,e){const s=this.byteStream.byte_offset+e|0,a={_$ns:[\"flash\",\"display\"],_$name:\"SimpleButton\"};a._$characterId=0|this.byteStream.getUI16();let i=0;7!==t&&(this.byteStream.getUIBits(7),a._$trackAsMenu=!!this.byteStream.getUIBits(1),i=0|this.byteStream.getUI16()),a._$characters=this.buttonCharacters(s),7===t?(i=s-this.byteStream.byte_offset|0,this.byteStream.byte_offset+=i):i>0&&(a._$actions=this.buttonActions(s)),this.setCharacter(a._$characterId,a),this.byteStream.byte_offset!==s&&(this.byteStream.byte_offset=0|s)}buttonCharacters(t){const e=[];for(;0!==this.byteStream.getUI8();){this.byteStream.incrementOffset(-1,0);const s=0|this.byteStream.byte_offset,a=this.buttonRecord();if(this.byteStream.byte_offset>t){this.byteStream.byte_offset=0|s;break}e[e.length]=a}return e}buttonRecord(){this.byteStream.getUIBits(2);const t={};return t.PlaceFlagHasBlendMode=this.byteStream.getUIBits(1),t.PlaceFlagHasFilterList=this.byteStream.getUIBits(1),t.ButtonStateHitTest=this.byteStream.getUIBits(1),t.ButtonStateDown=this.byteStream.getUIBits(1),t.ButtonStateOver=this.byteStream.getUIBits(1),t.ButtonStateUp=this.byteStream.getUIBits(1),t.CharacterId=this.byteStream.getUI16(),t.Depth=this.byteStream.getUI16(),t.PlaceFlagHasMatrix=1,t.Matrix=this.matrix(),t.ColorTransform=this.colorTransform(),t.PlaceFlagHasColorTransform=void 0===t.ColorTransform?0:1,t.PlaceFlagHasBlendMode&&(t.BlendMode=this.byteStream.getUI8()),t.PlaceFlagHasFilterList&&(t.SurfaceFilterList=this.getFilterList()),t.PlaceFlagHasRatio=0,t.PlaceFlagHasClipDepth=0,t.Sound=null,t}buttonActions(t){for(;;){const e={},s=0|this.byteStream.byte_offset,a=this.byteStream.getUI16();e.CondIdleToOverDown=this.byteStream.getUIBits(1),e.CondOutDownToIdle=this.byteStream.getUIBits(1),e.CondOutDownToOverDown=this.byteStream.getUIBits(1),e.CondOverDownToOutDown=this.byteStream.getUIBits(1),e.CondOverDownToOverUp=this.byteStream.getUIBits(1),e.CondOverUpToOverDown=this.byteStream.getUIBits(1),e.CondOverUpToIdle=this.byteStream.getUIBits(1),e.CondIdleToOverUp=this.byteStream.getUIBits(1),e.CondKeyPress=this.byteStream.getUIBits(7),e.CondOverDownToIdle=this.byteStream.getUIBits(1);const i=t-this.byteStream.byte_offset+1|0;if(this.byteStream.byte_offset+=i,!a)break;this.byteStream.byte_offset=s+a|0}return[]}parsePlaceObject(t,e){const s=this.byteStream.byte_offset,a={};if(a.tagType=t,4===t)return a.CharacterId=this.byteStream.getUI16(),a.Depth=this.byteStream.getUI16(),a.Matrix=this.matrix(),a.PlaceFlagHasMatrix=1,this.byteStream.byteAlign(),this.byteStream.byte_offset-s<e&&(a.ColorTransform=this.colorTransform(),a.PlaceFlagHasColorTransform=1),this.byteStream.byteAlign(),this.byteStream.byte_offset=s+e,a;const i=this.swfVersion;if(a.PlaceFlagHasClipActions=this.byteStream.getUIBits(1),a.PlaceFlagHasClipDepth=this.byteStream.getUIBits(1),a.PlaceFlagHasName=this.byteStream.getUIBits(1),a.PlaceFlagHasRatio=this.byteStream.getUIBits(1),a.PlaceFlagHasColorTransform=this.byteStream.getUIBits(1),a.PlaceFlagHasMatrix=this.byteStream.getUIBits(1),a.PlaceFlagHasCharacter=this.byteStream.getUIBits(1),a.PlaceFlagMove=this.byteStream.getUIBits(1),70===t&&(this.byteStream.getUIBits(1),a.PlaceFlagOpaqueBackground=this.byteStream.getUIBits(1),a.PlaceFlagHasVisible=this.byteStream.getUIBits(1),a.PlaceFlagHasImage=this.byteStream.getUIBits(1),a.PlaceFlagHasClassName=this.byteStream.getUIBits(1),a.PlaceFlagHasCacheAsBitmap=this.byteStream.getUIBits(1),a.PlaceFlagHasBlendMode=this.byteStream.getUIBits(1),a.PlaceFlagHasFilterList=this.byteStream.getUIBits(1)),a.Depth=this.byteStream.getUI16(),a.PlaceFlagHasClassName&&(a.ClassName=this.byteStream.getDataUntil(),console.log(\"TODO \",a.ClassName)),a.PlaceFlagHasCharacter&&(a.CharacterId=this.byteStream.getUI16()),a.PlaceFlagHasMatrix&&(a.Matrix=this.matrix()),a.PlaceFlagHasColorTransform&&(a.ColorTransform=this.colorTransform()),a.PlaceFlagHasRatio&&(a.Ratio=this.byteStream.getUI16()),a.PlaceFlagHasName&&(a.Name=this.byteStream.getDataUntil()),a.PlaceFlagHasClipDepth&&(a.ClipDepth=this.byteStream.getUI16()),70===t&&(a.PlaceFlagHasFilterList&&(a.SurfaceFilterList=this.getFilterList()),a.PlaceFlagHasBlendMode&&(a.BlendMode=this.byteStream.getUI8()),a.PlaceFlagHasCacheAsBitmap&&(a.BitmapCache=this.byteStream.getUI8()),a.PlaceFlagHasVisible&&(a.Visible=this.byteStream.getUI8()),a.PlaceFlagOpaqueBackground&&(a.BackgroundColor=this.rgba())),a.PlaceFlagHasClipActions){this.byteStream.getUI16(),a.AllEventFlags=this.parseClipEventFlags();const t=s+e;for(;this.byteStream.byte_offset<t;){const e=this.parseClipActionRecord(t);if(t<=this.byteStream.byte_offset)break;if(!(i<=5?this.byteStream.getUI16():this.byteStream.getUI32()))break;this.byteStream.byte_offset-=i<=5?2:4,e.KeyCode&&(this.byteStream.byte_offset-=1)}}return this.byteStream.byteAlign(),this.byteStream.byte_offset=s+e,a}parseClipActionRecord(t){const e={},s=this.parseClipEventFlags();if(t>this.byteStream.byte_offset){const t=this.byteStream.getUI32();s.keyPress&&(e.KeyCode=this.byteStream.getUI8()),this.byteStream.byte_offset+=t}return e}parseClipEventFlags(){const t=this.swfVersion,e={};return e.keyUp=this.byteStream.getUIBits(1),e.keyDown=this.byteStream.getUIBits(1),e.mouseUp=this.byteStream.getUIBits(1),e.mouseDown=this.byteStream.getUIBits(1),e.mouseMove=this.byteStream.getUIBits(1),e.unload=this.byteStream.getUIBits(1),e.enterFrame=this.byteStream.getUIBits(1),e.load=this.byteStream.getUIBits(1),t>=6&&(e.dragOver=this.byteStream.getUIBits(1),e.rollOut=this.byteStream.getUIBits(1),e.rollOver=this.byteStream.getUIBits(1),e.releaseOutside=this.byteStream.getUIBits(1),e.release=this.byteStream.getUIBits(1),e.press=this.byteStream.getUIBits(1),e.initialize=this.byteStream.getUIBits(1)),e.data=this.byteStream.getUIBits(1),t>=6&&(this.byteStream.getUIBits(5),e.construct=this.byteStream.getUIBits(1),e.keyPress=this.byteStream.getUIBits(1),e.dragOut=this.byteStream.getUIBits(1),this.byteStream.getUIBits(8)),this.byteStream.byteAlign(),e}getFilterList(){const t=0|this.byteStream.getUI8(),e=[];for(let s=0;s<t;++s){const t=this.getFilter();t&&(e[e.length]=t)}return e.length?e:null}getFilter(){switch(0|this.byteStream.getUI8()){case 0:return this.dropShadowFilter();case 1:return this.blurFilter();case 2:return this.glowFilter();case 3:return this.bevelFilter();case 4:return this.gradientGlowFilter();case 5:return this.convolutionFilter();case 6:return this.colorMatrixFilter();case 7:return this.gradientBevelFilter()}}dropShadowFilter(){const t={},e=this.rgba(),s=e.A,a=e.R<<16|e.G<<8|e.B,i=this.byteStream.getUI32()/65536,r=this.byteStream.getUI32()/65536,h=this.byteStream.getUI32()/65536*Util.$Rad2Deg,n=this.byteStream.getUI32()/65536,o=this.byteStream.getFloat16()/256,l=!!this.byteStream.getUIBits(1),c=!!this.byteStream.getUIBits(1),b=!this.byteStream.getUIBits(1),g=this.byteStream.getUIBits(5);return t._$ns=[\"flash\",\"filters\"],t._$name=\"DropShadowFilter\",t.params=[null,n,h,a,s,i,r,o,g,l,c,b],t}blurFilter(){const t={},e=this.byteStream.getUI32()/65536,s=this.byteStream.getUI32()/65536,a=this.byteStream.getUIBits(5);return this.byteStream.getUIBits(3),t._$ns=[\"flash\",\"filters\"],t._$name=\"BlurFilter\",t.params=[null,e,s,a],t}glowFilter(){const t={},e=this.rgba(),s=e.A,a=e.R<<16|e.G<<8|e.B,i=this.byteStream.getUI32()/65536,r=this.byteStream.getUI32()/65536,h=this.byteStream.getFloat16()/256,n=!!this.byteStream.getUIBits(1),o=!!this.byteStream.getUIBits(1);this.byteStream.getUIBits(1);const l=this.byteStream.getUIBits(5);return t._$ns=[\"flash\",\"filters\"],t._$name=\"GlowFilter\",t.params=[null,a,s,i,r,h,l,n,o],t}bevelFilter(){const t={};let e=this.rgba();const s=e.A,a=e.R<<16|e.G<<8|e.B;e=this.rgba();const i=e.A,r=e.R<<16|e.G<<8|e.B,h=this.byteStream.getUI32()/65536,n=this.byteStream.getUI32()/65536,o=this.byteStream.getUI32()/65536*Util.$Rad2Deg,l=this.byteStream.getUI32()/65536,c=this.byteStream.getFloat16()/256,b=!!this.byteStream.getUIBits(1),g=!!this.byteStream.getUIBits(1);this.byteStream.getUIBits(1);const y=this.byteStream.getUIBits(1),S=this.byteStream.getUIBits(4);let m=\"inner\";return b||(m=y?\"full\":\"outer\"),t._$ns=[\"flash\",\"filters\"],t._$name=\"BevelFilter\",t.params=[null,l,o,a,s,r,i,h,n,c,S,m,g],t}gradientGlowFilter(){const t={},e=0|this.byteStream.getUI8(),s=[],a=[];for(let t=0;t<e;++t){const t=this.rgba();a[a.length]=t.A,s[s.length]=t.R<<16|t.G<<8|t.B|0}const i=[];for(let t=0;t<e;++t)i[i.length]=+this.byteStream.getUI8()/255;const r=this.byteStream.getUI32()/65536,h=this.byteStream.getUI32()/65536,n=this.byteStream.getUI32()/65536*Util.$Rad2Deg,o=this.byteStream.getUI32()/65536,l=this.byteStream.getFloat16()/256,c=!!this.byteStream.getUIBits(1),b=!!this.byteStream.getUIBits(1);this.byteStream.getUIBits(1);const g=this.byteStream.getUIBits(1),y=this.byteStream.getUIBits(4);let S=\"inner\";return c||(S=g?\"full\":\"outer\"),t._$ns=[\"flash\",\"filters\"],t._$name=\"GradientGlowFilter\",t.params=[null,o,n,s,a,i,r,h,l,y,S,b],t}convolutionFilter(){const t={},e=this.byteStream.getUI8(),s=this.byteStream.getUI8(),a=this.byteStream.getFloat32,i=this.byteStream.getFloat32,r=e*s,h=[];for(let t=0;t<r;++t)h[h.length]=this.byteStream.getFloat32();const n=this.rgba();this.byteStream.getUIBits(6);const o=!!this.byteStream.getUIBits(1),l=!!this.byteStream.getUIBits(1);return t._$ns=[\"flash\",\"filters\"],t._$name=\"ConvolutionFilter\",t.params=[null,e,s,h,a,i,l,o,n],t}gradientBevelFilter(){const t={},e=0|this.byteStream.getUI8(),s=[],a=[];for(let t=0;t<e;++t){const t=this.rgba();a[a.length]=t.A,s[s.length]=t.R<<16|t.G<<8|t.B|0}const i=[];for(let t=0;t<e;++t)i[i.length]=+this.byteStream.getUI8()/255;const r=this.byteStream.getUI32()/65536,h=this.byteStream.getUI32()/65536,n=this.byteStream.getUI32()/65536*Util.$Rad2Deg,o=this.byteStream.getUI32()/65536,l=this.byteStream.getFloat16()/256,c=!!this.byteStream.getUIBits(1),b=!!this.byteStream.getUIBits(1);this.byteStream.getUIBits(1);const g=this.byteStream.getUIBits(1),y=this.byteStream.getUIBits(4);let S=\"inner\";return c||(S=g?\"full\":\"outer\"),t._$ns=[\"flash\",\"filters\"],t._$name=\"GradientBevelFilter\",t.params=[null,o,n,s,a,i,r,h,l,y,S,b],t}colorMatrixFilter(){const t={},e=[];for(let t=0;t<20;t++)e[e.length]=this.byteStream.getFloat32();return t._$ns=[\"flash\",\"filters\"],t._$name=\"ColorMatrixFilter\",t.params=[null,e],t}colorTransform(){this.byteStream.byteAlign();const t=[1,1,1,1,0,0,0,0],e=this.byteStream.getUIBits(6),s=e>>5,a=15&e;return e>>4&1&&(t[0]=this.byteStream.getSIBits(a)/256,t[1]=this.byteStream.getSIBits(a)/256,t[2]=this.byteStream.getSIBits(a)/256,t[3]=this.byteStream.getSIBits(a)/256),s&&(t[4]=this.byteStream.getSIBits(a),t[5]=this.byteStream.getSIBits(a),t[6]=this.byteStream.getSIBits(a),t[7]=this.byteStream.getSIBits(a)),t}parseSoundStreamHead(t){const e={};e.tagType=t,this.byteStream.getUIBits(4),e.PlaybackSoundRate=this.byteStream.getUIBits(2),e.PlaybackSoundSize=this.byteStream.getUIBits(1),e.PlaybackSoundType=this.byteStream.getUIBits(1),e.StreamSoundCompression=this.byteStream.getUIBits(4),e.StreamSoundRate=this.byteStream.getUIBits(2),e.StreamSoundSize=this.byteStream.getUIBits(1),e.StreamSoundType=this.byteStream.getUIBits(1),e.StreamSoundSampleCount=this.byteStream.getUI16(),2===e.StreamSoundCompression&&(e.LatencySeek=this.byteStream.getSIBits(2))}parseDefineSound(t){const e=this.byteStream.byte_offset,s=this.byteStream.getUI16();this.byteStream.getUIBits(4),this.byteStream.getUIBits(2),this.byteStream.getUIBit(),this.byteStream.getUIBit(),this.byteStream.getUI32();const a=t-(this.byteStream.byte_offset-e),i={_$characterId:s,_$data:null,_$buffer:null};i._$length=this.byteStream.byte_offset+a,i._$offset=this.byteStream.byte_offset,this.byteStream.byte_offset=e+t,this.setCharacter(s,i)}parseStartSound(t){const e={};return e.SoundId=this.byteStream.getUI16(),89===t&&(e.SoundClassName=this.byteStream.getDataUntil()),e.SoundInfo=this.parseSoundInfo(),e}parseDefineButtonSound(){const t=this.byteStream.getUI16(),e=this.getCharacter(t);for(let t=0;t<4;t++){const s=this.byteStream.getUI16();if(s){const a=this.parseSoundInfo();switch(t){case 0:e.ButtonStateUpSoundInfo=a,e.ButtonStateUpSoundId=s;break;case 1:e.ButtonStateOverSoundInfo=a,e.ButtonStateOverSoundId=s;break;case 2:e.ButtonStateDownSoundInfo=a,e.ButtonStateDownSoundId=s;break;case 3:e.ButtonStateHitTestSoundInfo=a,e.ButtonStateHitTestSoundId=s}}}this.setCharacter(t,e)}parseSoundInfo(){this.byteStream.getUIBits(2);const t={};if(t.SyncStop=this.byteStream.getUIBit(),t.SyncNoMultiple=this.byteStream.getUIBit(),t.HasEnvelope=this.byteStream.getUIBit(),t.HasLoops=this.byteStream.getUIBit(),t.HasOutPoint=this.byteStream.getUIBit(),t.HasInPoint=this.byteStream.getUIBit(),t.HasInPoint&&(t.InPoint=this.byteStream.getUI32()),t.HasOutPoint&&(t.OutPoint=this.byteStream.getUI32()),t.HasLoops&&(t.LoopCount=this.byteStream.getUI16()),t.HasEnvelope){const e=this.byteStream.getUI8(),s=[];for(let t=0;t<e;++t)s[t]={Pos44:this.byteStream.getUI32(),LeftLevel:this.byteStream.getUI16(),RightLevel:this.byteStream.getUI16()};t.EnvPoints=e,t.EnvelopeRecords=s}return t}parseDefineFontAlignZones(){const t=this.byteStream.getUI16(),e=this.getFont(t)||{};e._$CSMTableHint=this.byteStream.getUIBits(2),this.byteStream.getUIBits(6);const s=0|e._$numGlyphs,a=[];for(let t=0;t<s;++t){const e=this.byteStream.getUI8(),s=[];for(let t=0;t<e;++t)s.push(this.byteStream.getFloat16()),s.push(this.byteStream.getFloat16());this.byteStream.getUIBits(6),this.byteStream.getUIBits(1),this.byteStream.getUIBits(1),a[t]=s}this.byteStream.byteAlign(),e._$zoneTable=a,this.setFont(t,e)}parseCSMTextSettings(t){const e=this.byteStream.getUI16(),s={};s.tagType=t,s.UseFlashType=this.byteStream.getUIBits(2),s.GridFit=this.byteStream.getUIBits(3),this.byteStream.getUIBits(3),s.Thickness=this.byteStream.getUI32(),s.Sharpness=this.byteStream.getUI32(),this.byteStream.getUI8(),this.setTextSetting(e,s)}parseSoundStreamBlock(t,e){const s={};s.tagType=t,s.compressed=this.byteStream.getData(e)}parseDefineScalingGrid(){const t=this.byteStream.getUI16(),e=this.rect();this.setGrid(t,e)}postCharacter(t,e){globalThis.postMessage({infoKey:\"_$characters\",characters:t},e),t.length=0,e&&(e.length=0)}}Util.$swfParser=new SwfParser,this.addEventListener(\"message\",(function(t){const e=Util.$swfParser;e.version=t.data.version,e.byteStream.setData(t.data.buffer),e.byteStream.byte_offset=t.data.offset;const s=Util.$createMovieClip();e.parseTags(t.data.buffer.length,s),e.postData(s),e.clear()}));"], { "type": "text/javascript" })
);
Util.$parserWorker     = null;
Util.$parserQueues     = [];
Util.$parserWorkerWait = false;

/**
 * @param  {object} event
 * @return void
 * @static
 */
Util.$unlzmaHandler = function (event)
{
    // event end
    event.target.onmessage = null;

    // next
    if (Util.$unlzmaQueues.length) {

        const object = Util.$unlzmaQueues.shift();

        const worker = new Worker(Util.$unlzmaWorkerURL);

        worker.onmessage = Util.$unlzmaHandler.bind(object);

        const data = object._$byteStream._$buffer;
        worker.postMessage({
            "fileSize": object.fileSize,
            "mode":     object.mode,
            "buffer":   data
        }, [data.buffer]);

    } else {

        Util.$unlzmaWorkerActive = false;

    }

    // setup
    this._$byteStream._$buffer = event.data;
    this.parseAndBuild();
};

/**
 * @param  {Uint8Array} data
 * @return {string|null}
 * @static
 */
Util.$getImageType = function (data)
{
    switch (true) {

        // JPEG
        case data[0] === 0xff && data[1] === 0xd8:
            return "jpeg";

        // GIF
        case data[0] === 0x47 && data[1] === 0x49 && data[2] === 0x46:
            return "gif";

        // PNG
        case data[0] === 0x89 && data[1] === 0x50 &&
            data[2] === 0x4E && data[3] === 0x47 &&
            data[4] === 0x0D && data[5] === 0x0A &&
            data[6] === 0x1A && data[7] === 0x0A:
            return "png";

        // BMP
        case data[0] === 0x42 && data[1] === 0x4d:
            return "bmp";

        default:
            return null;

    }
};

/**
 * @return {void}
 * @static
 */
Util.$jpegDecodeHandler = function ()
{
    const image  = this.image;
    const width  = image.width;
    const height = image.height;

    const canvas  = document.createElement("canvas");
    canvas.width  = width;
    canvas.height = height;
    const context = canvas.getContext("2d");

    context.drawImage(image, 0, 0, width, height);
    const buffer = new Uint8Array(context
        .getImageData(0, 0, width, height)
        .data);

    // clear
    this.jpegData = null;
    this.image    = null;

    const workSpace = Util.$currentWorkSpace();
    const instance  = workSpace.getLibrary(this.libraryId);
    instance.width  = width;
    instance.height = height;

    if (this.isAlpha) {

        // set
        this.buffer = buffer;
        this.width  = width;
        this.height = height;

        if (Util.$unzipWorkerActive) {
            Util.$unzipQueues.push(this);
            return ;
        }

        Util.$unzipWorkerActive = true;

        if (!Util.$unzipWorker) {
            Util.$unzipWorker = new Worker(Util.$unzipURL);
        }

        const worker = Util.$unzipWorker;
        worker.onmessage = Util.$unzipHandler.bind(this);
        worker.postMessage(this, [
            this.buffer.buffer,
            this.alphaData.buffer
        ]);

    } else {

        instance._$buffer = buffer;

    }
};

/**
 * @type {Map}
 */
Util.$characters = new Map();
Util.$fonts      = new Map();
Util.$texts      = new Map();

/**
 * @param  {object} event
 * @return void
 * @static
 */
Util.$parserHandler = function (event)
{

    const worker = event.target;
    switch (event.data.infoKey) {

        case "character":
            {
                const character = event.data.piece;

                const workSpace = Util.$currentWorkSpace();
                const id = workSpace.nextLibraryId;
                character.libraryId = id;

                switch (character._$name) {

                    case "Shape":
                        {
                            const object = Util
                                .$controller
                                .createContainer("shape", `Shape_${id}`, id);

                            object.recodes = Util.$vtc.convert(character._$records);
                            object.bounds  = {
                                "xMin": character._$bounds.xMin,
                                "xMax": character._$bounds.xMax,
                                "yMin": character._$bounds.yMin,
                                "yMax": character._$bounds.yMax
                            };

                            workSpace.addLibrary(object);

                            Util.$characters.set(character._$characterId, id);
                        }
                        break;

                    case "MovieClip":
                        {
                            for (let idx = 0; idx < character._$dictionary.length; ++idx) {
                                const object = character._$dictionary[idx];
                                object.LibraryId = Util.$characters.get(object.CharacterId);
                            }

                            const object = Util
                                .$controller
                                .createContainer("container", `MovieClip_${id}`, id);

                            // create MovieClip
                            const movieClip = workSpace.addLibrary(object);

                            // create layer
                            let clipMap = new Map();
                            let layerArray = [];
                            for (let idx = 0; idx < character._$dictionary.length; ++idx) {
                                const tag = character._$dictionary[idx];

                                if (layerArray.indexOf(tag.Depth) !== -1) {
                                    continue;
                                }
                                layerArray.push(tag.Depth);

                                if (tag.ClipDepth) {
                                    clipMap.set(tag.Depth, idx);
                                }

                            }

                            layerArray.sort(function(a, b)
                            {
                                switch (true) {

                                    case a > b:
                                        return 1;

                                    case a < b:
                                        return -1;

                                    default:
                                        return 0;

                                }
                            });

                            // adj clips
                            if (clipMap.size) {

                                for (const [depth, index] of clipMap) {

                                    const moveArray = [];

                                    const tag = character._$dictionary[index];
                                    for (let idx = 0; character._$dictionary.length > idx; ++idx) {

                                        const target = character._$dictionary[idx];
                                        if (target.Depth > tag.ClipDepth) {
                                            break;
                                        }

                                        if (target.Depth > depth) {
                                            moveArray.push(target);
                                        }
                                    }

                                    for (let idx = 0; idx < moveArray.length; ++idx) {

                                        const target = moveArray[idx];

                                        const index = layerArray.indexOf(target.Depth);
                                        const depth = layerArray.splice(index, 1)[0];
                                        const insertIndex = layerArray.indexOf(tag.Depth);

                                        layerArray.splice(insertIndex, 0, depth);
                                    }

                                }
                            }

                            let maskId     = -1;
                            let clipDepth  = -1;
                            const index    = layerArray.length - 1;
                            const layerMap = new Map();
                            const layers   = [];
                            for (let idx = index; idx > -1; --idx) {

                                const layer = new Layer();
                                layer.name  = `Layer_${index - idx}`;

                                const depth = layerArray[idx];
                                if (clipMap.size) {

                                    if (clipDepth > -1) {
                                        if (depth > clipDepth) {
                                            layer.mode   = Util.LAYER_MODE_MASK_IN;
                                            layer.maskId = maskId;
                                        } else {
                                            maskId    = -1;
                                            clipDepth = -1;
                                        }
                                    }

                                    if (clipMap.has(depth)) {
                                        clipDepth  = depth;
                                        maskId     = index - idx;
                                        layer.mode = Util.LAYER_MODE_MASK;
                                    }
                                }

                                layers.push(layer);
                                layerMap.set(depth, layer);
                            }

                            for (let idx = 0; idx < layerArray.length; ++idx) {
                                movieClip.setLayer(idx, layers[idx]);
                            }

                            // setup
                            const characters = [];
                            const totalFrame = character._$controller.length - 1;
                            for (let idx = 0; idx < character._$dictionary.length; ++idx) {

                                const tag = character._$dictionary[idx];

                                const instance = new Character();
                                instance.libraryId  = tag.LibraryId;
                                instance.startFrame = tag.StartFrame;
                                instance.endFrame   = tag.EndFrame || totalFrame + 1;
                                instance.name       = tag.Name || "";

                                characters.push(instance);
                            }

                            const dup = new Map();
                            for (let frame = 1; frame < character._$controller.length; ++frame) {

                                const controller = character._$controller[frame];
                                for (let idx = 0; idx < controller.length; ++idx) {

                                    const id  = controller[idx];
                                    const tag = character._$dictionary[id];

                                    const layer = layerMap.get(tag.Depth);

                                    const instance = characters[id];
                                    if (!dup.has(id)) {
                                        dup.set(id, -1);
                                        layer.addCharacter(instance);
                                    }

                                    const nextId    = character._$placeMap[frame][tag.Depth];
                                    const currentId = dup.get(id);
                                    if (currentId !== nextId) {
                                        const placeObject = character._$placeObjects[nextId];

                                        if (!placeObject.loop) {
                                            placeObject.loop = {
                                                "type": 0,
                                                "start": 1,
                                                "end": 0
                                            };
                                        }

                                        instance.setPlace(frame, {
                                            "frame": frame,
                                            "depth": 0,
                                            "matrix": placeObject.matrix,
                                            "colorTransform": placeObject.colorTransform,
                                            "blendMode": placeObject.blendMode,
                                            "filter": placeObject.filters ? placeObject.filters : [],
                                            "loop": {
                                                "type": placeObject.loop.type,
                                                "start": placeObject.loop.start,
                                                "end": placeObject.loop.end
                                            }
                                        });

                                        dup.set(id, nextId);
                                    }
                                }
                            }

                            for (let idx = 0; idx < layers.length; ++idx) {

                                const layer = layers[idx];
                                for (let frame = 1; frame <= totalFrame; ++frame) {

                                    const instance = layer.getActiveCharacter(frame)[0];
                                    if (instance) {

                                        if (!(frame - 1)) {

                                            layer
                                                ._$frame
                                                .setClasses(frame, ["key-frame"]);

                                        } else {

                                            const classes = layer._$frame.getClasses(frame - 1);
                                            switch (true) {

                                                case classes.indexOf("key-frame") !== -1:

                                                    if (frame === totalFrame) {

                                                        if (instance.hasPlace(frame)) {

                                                            layer._$frame.setClasses(frame, [
                                                                "key-frame"
                                                            ]);

                                                        } else {

                                                            classes.push("key-frame-join");
                                                            layer._$frame.setClasses(frame - 1, classes);

                                                            layer._$frame.setClasses(frame, [
                                                                "key-space-frame-end"
                                                            ]);

                                                        }

                                                    } else {

                                                        if (instance.hasPlace(frame)) {

                                                            layer._$frame.setClasses(frame, [
                                                                "key-frame"
                                                            ]);

                                                        } else {

                                                            classes.push("key-frame-join");
                                                            layer._$frame.setClasses(frame - 1, classes);

                                                            layer._$frame.setClasses(frame, [
                                                                "key-space-frame"
                                                            ]);

                                                        }

                                                    }

                                                    break;

                                                case classes.indexOf("empty-space-frame") !== -1:

                                                    layer._$frame.setClasses(frame - 1, [
                                                        "empty-space-frame-end"
                                                    ]);

                                                    layer._$frame.setClasses(frame, [
                                                        "key-frame"
                                                    ]);

                                                    break;

                                                case classes.indexOf("empty-key-frame") !== -1:
                                                    layer._$frame.setClasses(frame, [
                                                        "key-frame"
                                                    ]);
                                                    break;

                                                default:

                                                    if (frame === totalFrame) {

                                                        layer._$frame.setClasses(frame, [
                                                            "key-space-frame-end"
                                                        ]);

                                                    } else {

                                                        if (instance.hasPlace(frame)) {

                                                            layer._$frame.setClasses(frame - 1, [
                                                                "key-space-frame-end"
                                                            ]);

                                                            layer._$frame.setClasses(frame, [
                                                                "key-frame"
                                                            ]);

                                                        } else {

                                                            layer._$frame.setClasses(frame, [
                                                                "key-space-frame"
                                                            ]);

                                                        }

                                                    }
                                                    break;

                                            }
                                        }

                                    } else {

                                        if (!(frame - 1)) {

                                            layer
                                                ._$frame
                                                .setClasses(frame, ["empty-key-frame"]);

                                        } else {

                                            const classes = layer._$frame.getClasses(frame - 1);
                                            switch (true) {

                                                case classes.indexOf("empty-key-frame") !== -1:

                                                    classes.push("empty-key-frame-join");
                                                    layer._$frame.setClasses(frame - 1, classes);

                                                    if (frame === totalFrame) {

                                                        layer._$frame.setClasses(frame, [
                                                            "empty-space-frame-end"
                                                        ]);

                                                    } else {

                                                        layer._$frame.setClasses(frame, [
                                                            "empty-space-frame"
                                                        ]);

                                                    }

                                                    break;

                                                case classes.indexOf("key-space-frame") !== -1:

                                                    layer._$frame.setClasses(frame - 1, [
                                                        "key-space-frame-end"
                                                    ]);

                                                    layer._$frame.setClasses(frame, [
                                                        "empty-key-frame"
                                                    ]);

                                                    break;

                                                case classes.indexOf("key-frame") !== -1:

                                                    layer._$frame.setClasses(frame, [
                                                        "empty-key-frame"
                                                    ]);

                                                    break;

                                                default:

                                                    if (frame === totalFrame) {

                                                        layer._$frame.setClasses(frame, [
                                                            "empty-space-frame-end"
                                                        ]);

                                                    } else {

                                                        layer._$frame.setClasses(frame, [
                                                            "empty-space-frame"
                                                        ]);

                                                    }

                                                    break;

                                            }
                                        }
                                    }
                                }
                            }

                            Util.$characters.set(character._$characterId, id);
                        }
                        break;

                    case "lossless": // PNG
                        {

                            const object = Util
                                .$controller
                                .createContainer("bitmap", `Bitmap_${id}`, id);

                            character.mode   = "lossless";
                            object.imageType = "image/png";
                            object.buffer    = null;
                            object.width     = character.width;
                            object.height    = character.height;

                            workSpace.addLibrary(object);

                            Util.$characters.set(character._$characterId, id);

                            if (Util.$unzipWorkerActive) {
                                Util.$unzipQueues.push(character);
                                return ;
                            }

                            Util.$unzipWorkerActive = true;

                            if (!Util.$unzipWorker) {
                                Util.$unzipWorker = new Worker(Util.$unzipURL);
                            }

                            const worker = Util.$unzipWorker;
                            worker.onmessage = Util.$unzipHandler.bind(character);
                            worker.postMessage(character, [character.buffer.buffer]);
                        }
                        break;

                    case "imageData": // JPEG,GIF,PNG,etc...
                        {
                            const object = Util
                                .$controller
                                .createContainer("bitmap", `Bitmap_${id}`, id);

                            const imageType     = `image/${Util.$getImageType(character.jpegData)}`;
                            character.mode      = "jpegAlpha";
                            character.imageType = imageType;
                            object.imageType    = imageType;
                            object.buffer       = null;
                            object.width        = 0;
                            object.height       = 0;

                            workSpace.addLibrary(object);

                            Util.$characters.set(character._$characterId, id);

                            character.image = new Image();
                            character.image.decoding = "async";
                            character.image.src = URL.createObjectURL(
                                new Blob([character.jpegData], {
                                    "type": character.imageType
                                })
                            );

                            character.image.decode()
                                .then(Util.$jpegDecodeHandler.bind(character));

                        }
                        break;

                    case "StaticText":
                        {
                            const object = Util
                                .$controller
                                .createContainer("shape", `ShapeText_${id}`, id);

                            object.bounds  = {
                                "xMin": character._$bounds.xMin,
                                "xMax": character._$bounds.xMax,
                                "yMin": character._$bounds.yMin,
                                "yMax": character._$bounds.yMax
                            };

                            workSpace.addLibrary(object);

                            Util.$characters.set(character._$characterId, id);

                            Util.$texts.set(Util.$texts.size, character);
                        }
                        break;

                    case "SimpleButton":
                        {
                            console.log("TODO SimpleButton: ", character);

                            const object = Util
                                .$controller
                                .createContainer("button", `Button_${id}`, id);

                            object.bounds  = {
                                "xMin": character._$bounds.xMin,
                                "xMax": character._$bounds.xMax,
                                "yMin": character._$bounds.yMin,
                                "yMax": character._$bounds.yMax
                            };

                            workSpace.addLibrary(object);

                            Util.$characters.set(character._$characterId, id);
                        }
                        break;

                    case "TextField":
                        {
                            const object = Util
                                .$controller
                                .createContainer("text", `Text_${id}`, id);

                            object.bounds  = {
                                "xMin": character._$bounds.xMin,
                                "xMax": character._$bounds.xMax,
                                "yMin": character._$bounds.yMin,
                                "yMax": character._$bounds.yMax
                            };

                            // attach
                            object.text          = character._$text;
                            object.inputType     = character._$type;
                            object.color         = character._$textColor;
                            object.font          = character._$defaultTextFormat[1];
                            object.size          = character._$defaultTextFormat[2];
                            object.align         = character._$defaultTextFormat[7];
                            object.leftMargin    = character._$defaultTextFormat[8];
                            object.rightMargin   = character._$defaultTextFormat[9];
                            object.leading       = character._$defaultTextFormat[10];
                            object.multiline     = character._$multiline === 1;
                            object.wordWrap      = character._$wordWrap === 1;
                            object.border        = character._$border === 1;

                            if (character._$defaultTextFormat[4]
                            && character._$defaultTextFormat[5]
                            ) {
                                object.fontType = 3;
                            } else if (character._$defaultTextFormat[4]) {
                                object.fontType = 2;
                            } else if (character._$defaultTextFormat[5]) {
                                object.fontType = 1;
                            }

                            // TODO
                            object.htmlText = character._$htmlText;

                            workSpace.addLibrary(object);

                            Util.$characters.set(character._$characterId, id);
                        }
                        break;

                    default:
                        console.log("TODO: ", character);
                        break;

                }

                if (character._$characterId) {
                    return ;
                }
            }
            break;

        case "font":
            Util.$fonts.set(event.data.index, event.data.piece);
            return;

        case "font_shape":
            {
                const font = Util.$fonts.get(event.data.index);
                font._$glyphShapeTable.push.apply(font._$glyphShapeTable, event.data.pieces);
                Util.$fonts.set(event.data.index, font);
            }
            return;

        case "font_zone":
            {
                const font = Util.$fonts.get(event.data.index);
                font._$zoneTable.push.apply(font._$zoneTable, event.data.pieces);
                Util.$fonts.set(event.data.index, font);
            }
            return;

        default:
            break;

    }

    if (Util.$texts.size) {

        const { Graphics } = window.next2d.display;

        const workSpace = Util.$currentWorkSpace();

        for (const character of Util.$texts.values()) {

            const shape = workSpace.getLibrary(character.libraryId);

            // build shape data
            let offsetX     = 0;
            let offsetY     = 0;
            let color       = null;
            let codeTables  = null;
            let shapeTables = null;
            let textHeight  = 0;
            let isZoneTable = false;

            const baseMatrix = character._$baseMatrix;

            // build shape data
            const records = character._$textRecords;
            for (let idx = 0; idx < records.length; ++idx) {

                const record = records[idx];

                if ("FontId" in record) {
                    const font  = Util.$fonts.get(record.FontId);
                    codeTables  = font._$codeTable;
                    shapeTables = font._$glyphShapeTable;
                    isZoneTable = font._$zoneTable !== null;
                }

                if ("XOffset" in record) {
                    offsetX = record.XOffset;
                }

                if ("YOffset" in record) {
                    offsetY = record.YOffset;
                }

                if ("TextColor" in record) {
                    color = record.TextColor;
                }

                if ("TextHeight" in record) {
                    textHeight = record.TextHeight;
                    if (isZoneTable) {
                        textHeight /= 20;
                    }
                }

                const entries = record.GlyphEntries;
                const count   = record.GlyphCount;
                const scale   = textHeight / 1024;
                for (let idx = 0; idx < count; ++idx) {

                    const entry = entries[idx];
                    const index = entry.GlyphIndex | 0;

                    // add records
                    const shapeRecodes = Util.$vtc.convert({
                        "ShapeData": shapeTables[index],
                        "lineStyles": [],
                        "fillStyles": [{
                            "Color": color,
                            "fillStyleType": 0
                        }]
                    });

                    const matrix = [
                        scale, baseMatrix[1], baseMatrix[2], scale,
                        baseMatrix[4] + offsetX,
                        baseMatrix[5] + offsetY
                    ];

                    for (let idx = 0; idx < shapeRecodes.length;) {

                        const code = shapeRecodes[idx++];
                        shape._$recodes.push(code);
                        switch (code) {

                            case Graphics.MOVE_TO:
                            case Graphics.LINE_TO:
                                {
                                    const x  = shapeRecodes[idx++];
                                    const y  = shapeRecodes[idx++];
                                    const tx = x * matrix[0] + y * matrix[2] + matrix[4];
                                    const ty = x * matrix[1] + y * matrix[3] + matrix[5];
                                    shape._$recodes.push(tx, ty);
                                }
                                break;

                            case Graphics.CURVE_TO:
                                {
                                    const cx  = shapeRecodes[idx++];
                                    const cy  = shapeRecodes[idx++];
                                    const ctx = cx * matrix[0] + cy * matrix[2] + matrix[4];
                                    const cty = cx * matrix[1] + cy * matrix[3] + matrix[5];
                                    shape._$recodes.push(ctx, cty);

                                    const x  = shapeRecodes[idx++];
                                    const y  = shapeRecodes[idx++];
                                    const tx = x * matrix[0] + y * matrix[2] + matrix[4];
                                    const ty = x * matrix[1] + y * matrix[3] + matrix[5];
                                    shape._$recodes.push(tx, ty);
                                }
                                break;

                            case Graphics.FILL_STYLE:
                                shape._$recodes.push(
                                    shapeRecodes[idx++], shapeRecodes[idx++],
                                    shapeRecodes[idx++], shapeRecodes[idx++]
                                );
                                break;

                            case Graphics.BEGIN_PATH:
                            case Graphics.END_FILL:
                                break;

                        }
                    }

                    offsetX += entry.GlyphAdvance;
                }
            }
        }
    }

    // map clear
    Util.$characters.clear();
    Util.$fonts.clear();
    Util.$texts.clear();

    // parser end
    worker.onmessage = null;

    // next
    if (Util.$parserQueues.length) {

        const object = Util.$parserQueues.shift();

        worker.onmessage = Util.$parserHandler.bind(object);

        const buffer = object._$byteStream._$buffer;
        worker.postMessage({
            "version": object._$swfVersion,
            "offset":  object._$offset,
            "buffer":  buffer
        }, [buffer.buffer]);

    } else {

        Util.$parserWorkerWait = false;

    }

};

/**
 * @param  {object} bounds
 * @param  {Float32Array} matrix
 * @return {object}
 * @method
 * @static
 */
Util.$boundsMatrix = function (bounds, matrix)
{
    const x0 = bounds.xMax * matrix[0] + bounds.yMax * matrix[2] + matrix[4];
    const x1 = bounds.xMax * matrix[0] + bounds.yMin * matrix[2] + matrix[4];
    const x2 = bounds.xMin * matrix[0] + bounds.yMax * matrix[2] + matrix[4];
    const x3 = bounds.xMin * matrix[0] + bounds.yMin * matrix[2] + matrix[4];
    const y0 = bounds.xMax * matrix[1] + bounds.yMax * matrix[3] + matrix[5];
    const y1 = bounds.xMax * matrix[1] + bounds.yMin * matrix[3] + matrix[5];
    const y2 = bounds.xMin * matrix[1] + bounds.yMax * matrix[3] + matrix[5];
    const y3 = bounds.xMin * matrix[1] + bounds.yMin * matrix[3] + matrix[5];

    return {
        "xMin": Math.min( Number.MAX_VALUE, x0, x1, x2, x3),
        "xMax": Math.max(-Number.MAX_VALUE, x0, x1, x2, x3),
        "yMin": Math.min( Number.MAX_VALUE, y0, y1, y2, y3),
        "yMax": Math.max(-Number.MAX_VALUE, y0, y1, y2, y3)
    };
};

/**
 * @param   {number} color
 * @returns {{R: number, G: number, B: number, A: number}}
 * @method
 * @static
 */
Util.$intToRGB = function (color)
{
    return {
        "R": (color & 0xff0000) >> 16,
        "G": (color & 0x00ff00) >> 8,
        "B": color & 0x0000ff
    };
};

/**
 * @param  {number} d
 * @param  {number} sx
 * @param  {number} sy
 * @param  {number} ex
 * @param  {number} ey
 * @param  {array}  curves
 * @return {object}
 */
Util.$getCurvePoint = function (d, sx, sy, ex, ey, curves)
{
    const targets = [];
    for (let idx = 0; idx < curves.length; ++idx) {

        const pointer = curves[idx];

        if (!pointer.usePoint) {
            continue;
        }

        targets.push(pointer);
    }

    if (!targets.length) {
        return null;
    }

    const t = 1 - d;
    const l = targets.length + 1;
    for (let idx = 0; idx < l; ++idx) {
        sx *= t;
        sy *= t;
        ex *= d;
        ey *= d;
    }

    let x = sx + ex;
    let y = sy + ey;
    for (let idx = 0; idx < targets.length; ++idx) {

        const curve = targets[idx];

        const p = idx + 1;

        let cx = curve.x * l;
        let cy = curve.y * l;
        for (let jdx = 0; jdx < p; ++jdx) {
            cx *= d;
            cy *= d;
        }

        for (let jdx = 0; jdx < l - p; ++jdx) {
            cx *= t;
            cy *= t;
        }

        x += cx;
        y += cy;
    }

    return {
        "x": x,
        "y": y
    };
};

/**
 * @param  {object} object
 * @param  {Map}    dup
 * @method
 * @static
 */
Util.$copyContainer = function (object, dup)
{
    const workSpace       = Util.$currentWorkSpace();
    const targetWorkSpace = Util.$workSpaces[Util.$copyWorkSpaceId];

    if (!dup.has(object.id)) {
        dup.set(object.id, workSpace.nextLibraryId);
    }

    object.id = dup.get(object.id);
    workSpace.addLibrary(object);

    for (let idx = 0; idx < object.layers.length; ++idx) {

        const layer = object.layers[idx];
        for (let idx = 0; idx < layer.characters.length; ++idx) {

            const character = layer.characters[idx];
            if (!dup.has(character.libraryId)) {

                dup.set(character.libraryId, workSpace.nextLibraryId);

                const instance = targetWorkSpace
                    .getLibrary(character.libraryId);

                const object = instance.toObject();
                if (object.type === "container") {

                    Util.$copyContainer(object, dup);

                } else {

                    object.id = dup.get(character.libraryId);
                    workSpace.addLibrary(object);

                }
            }

            character.libraryId = dup.get(character.libraryId);
        }
    }

    workSpace.addLibrary(object);
};

/**
 * @return {void}
 * @static
 */
Util.$clearShapePointer = function ()
{
    const element  = document.getElementById("stage-area");
    const children = element.children;
    for (let idx = 0; children.length > idx; ++idx) {

        const node = children[idx];
        if (!node.dataset.shapePointer) {
            continue;
        }

        node.remove();
        --idx;
    }
};

/**
 * @return {void}
 * @static
 */
Util.$clearPenPointer = function ()
{
    const element  = document.getElementById("stage-area");
    const children = element.children;
    for (let idx = 0; children.length > idx; ++idx) {

        const node = children[idx];
        if (!node.dataset.penPointer) {
            continue;
        }

        node.remove();
        --idx;
    }
};

/**
 * @class
 */
class ApngEncoder
{
    /**
     * @param {array}   pngs
     * @param {number}  [width = 0]
     * @param {number}  [height = 0]
     * @param {number}  [fps = 60]
     * @param {boolean} [loop = true]
     * @public
     */
    constructor (pngs, width = 0, height = 0, fps = 60, loop = true)
    {
        this._$pngs   = pngs;
        this._$width  = width;
        this._$height = height;
        this._$fps    = fps;
        this._$loop   = loop ? 0 : 1;

        this._$crcTable = new Uint32Array(256);
        for (let idx = 0; idx < 256; idx++) {

            let c = idx;
            for (let idx = 0; idx < 8; idx++) {
                c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;
            }

            this._$crcTable[idx] = c;
        }
    }

    /**
     * @param  {number} c
     * @param  {Uint8Array} buffer
     * @param  {number} offset
     * @param  {number} length
     * @return {number}
     * @private
     */
    _$crcUpdate (c, buffer, offset, length)
    {
        for (let idx = 0; idx < length; idx++) {
            c = this._$crcTable[(c ^ buffer[offset + idx]) & 0xff] ^ c >>> 8;
        }
        return c;
    }

    /**
     * @param  {Uint8Array} buffer
     * @param  {number} offset
     * @param  {number} length
     * @return {number}
     * @private
     */
    _$crc (buffer, offset, length)
    {
        return this._$crcUpdate(0xffffffff, buffer, offset, length) ^ 0xffffffff;
    }

    /**
     * @param {Uint8Array} buffer
     * @param {number} pos
     * @param {string} value
     * @private
     */
    _$writeString (buffer, pos, value)
    {
        for (let idx = 0; idx < value.length; idx++) {
            buffer[pos + idx] = value.charCodeAt(idx);
        }
    }

    /**
     * @return {Promise}
     * @public
     */
    encode ()
    {
        return new Promise((resolve) =>
        {
            let sequence_number = 0;
            let frame = 0;

            const chunks = [];
            const reader = new FileReader();

            // PNG header (8 bytes)
            const header = new Uint8Array([
                137, 80, 78, 71, 13, 10, 26, 10
            ]);
            chunks.push(header.buffer);

            // add IHDR chunk (25 bytes)
            const IHDR = new Uint8Array(25);
            const IHDR_view = new DataView(IHDR.buffer);
            IHDR_view.setUint32(0, 13);
            this._$writeString(IHDR, 4, "IHDR");
            IHDR_view.setUint32(8, this._$width);
            IHDR_view.setUint32(12, this._$height);
            IHDR_view.setUint8(16, 8); // bit depth
            IHDR_view.setUint8(17, 6); // color_type, 2 = RGB, 6 = RGBA
            IHDR_view.setUint8(18, 0); // compression method
            IHDR_view.setUint8(19, 0); // filter method
            IHDR_view.setUint8(20, 0); // interlace method
            IHDR_view.setUint32(21, this._$crc(IHDR, 4, 4 + 13));
            chunks.push(IHDR.buffer);

            // add acTL (animation control chunk 20 bytes)
            const acTL = new Uint8Array(20);
            const acTL_view = new DataView(acTL.buffer);
            acTL_view.setUint32(0, 8);
            this._$writeString(acTL, 4, "acTL");
            acTL_view.setUint32(8, this._$pngs.length);
            acTL_view.setUint32(12, this._$loop); // num_plays, 0 = loop forever
            acTL_view.setUint32(16, this._$crc(acTL, 4, 4 + 8));
            chunks.push(acTL.buffer);

            reader.onload = () =>
            {
                const view = new DataView(reader.result);

                let pos = 8;

                //######################################
                // add fcTL (frame control chunk 38 bytes)
                //######################################
                const fcTL = new Uint8Array(38);
                const fcTL_view = new DataView(fcTL.buffer);
                fcTL_view.setUint32(0, 26);
                this._$writeString(fcTL, 4, "fcTL");
                fcTL_view.setUint32(8, sequence_number++);
                fcTL_view.setUint32(12, this._$width);
                fcTL_view.setUint32(16, this._$height);
                fcTL_view.setUint32(20, 0);
                fcTL_view.setUint32(24, 0);
                // The delay_num and delay_den parameters together specify a fraction
                // indicating the time to display the current frame, in seconds. If the denominator
                // is 0, it is to be treated as if it were 100 (that is, `delay_num` then specifies
                // 1/100ths of a second). If the the value of the numerator is 0 the decoder should
                // render the next frame as quickly as possible, though viewers may impose a
                // reasonable lower bound.
                fcTL_view.setUint16(28, 1000 / this._$fps); // delay_num
                fcTL_view.setUint16(30, 1000); // delay_den
                fcTL_view.setUint8(32, 0); // dispose_op
                fcTL_view.setUint8(33, 0); // blend_op
                fcTL_view.setUint32(34, this._$crc(fcTL, 4, 4 + 26));
                chunks.push(fcTL.buffer);

                // parse PNG chunks
                const length = reader.result.byteLength;
                for (;;) {

                    const chunkLen = view.getUint32(pos);
                    if (view.getUint32(pos + 4) === 0x49444154) { // 'IDAT'

                        //add either as IDAT or fdAT chunk
                        if (!frame) {

                            //######################################
                            // add IDAT chunk
                            //######################################
                            chunks.push(reader.result.slice(pos, pos + chunkLen + 8 + 4));

                        } else {

                            //######################################
                            // add fdAT chunk
                            //######################################
                            let fdAT = new Uint8Array(4);
                            let fdAT_view = new DataView(fdAT.buffer);
                            fdAT_view.setUint32(0, chunkLen + 4);
                            chunks.push(fdAT.buffer);

                            fdAT = new Uint8Array(reader.result.slice(pos, pos + chunkLen + 8 + 4));
                            fdAT_view = new DataView(fdAT.buffer);
                            this._$writeString(fdAT, 0, "fdAT");
                            fdAT_view.setUint32(4, sequence_number++);
                            fdAT_view.setUint32(chunkLen + 8, this._$crc(fdAT, 0, chunkLen + 8)); // update crc32
                            chunks.push(fdAT.buffer);
                        }
                    }

                    // size (4 bytes) + name (4 bytes) + data + crc (4 bytes)
                    pos += chunkLen + 12;
                    if (pos >= length) {
                        break;
                    }
                }

                frame++;
                if (this._$pngs.length > frame) {

                    // handle next frame
                    reader.readAsArrayBuffer(this._$pngs[frame]);

                } else {

                    //######################################
                    // add IEND chunk 12 bytes
                    //######################################
                    chunks.push(new Uint8Array([
                        0, 0, 0, 0,
                        0x49, 0x45, 0x4E, 0x44,
                        0xAE, 0x42, 0x60, 0x82
                    ]).buffer);

                    resolve(new Blob(chunks, { "type" : "image/apng" }));
                }
            };

            reader.readAsArrayBuffer(this._$pngs[0]);
        });
    }
}
/**
 * @class
 */
class Controller
{
    /**
     * @constructor
     */
    constructor()
    {
        this._$handler = this.initialize.bind(this);
        window.addEventListener("DOMContentLoaded", this._$handler);

        // params
        this._$active                = null;
        this._$stageLock             = false;
        this._$sizeLock              = false;
        this._$scaleLock             = false;
        this._$focus                 = false;
        this._$menuMode              = false;
        this._$target                = null;
        this._$libraryTarget         = null;
        this._$sourceTarget          = null;
        this._$libraryHit            = false;
        this._$inputMode             = false;
        this._$resizeMode            = false;
        this._$easeMode              = false;
        this._$easeTarget            = null;
        this._$currentValue          = null;
        this._$lockTarget            = null;
        this._$gradientTarget        = null;
        this._$gradientPointer       = null;
        this._$filterGradientTarget  = null;
        this._$filterGradientPointer = null;
        this._$filters               = new Map();
        this._$filterId              = 0;
        this._$pointX                = 0;
        this._$scriptId              = 0;
        this._$saved                 = true;
        this._$blurDownEvent         = null;
        this._$blurFocusInEvent      = null;
        this._$drawGradientContext   = null;
        this._$viewGradientContext   = null;
        this._$viewEaseContext       = null;
        this._$drawEaseContext       = null;
        this._$easeCustom            = null;
        this._$frameTarget           = "start";
    }

    /**
     * @return {void}
     * @public
     */
    initialize ()
    {
        // end event
        window.removeEventListener("DOMContentLoaded", this._$handler);

        const adjElement = document.getElementById("controller-adjustment");
        adjElement.addEventListener("mousedown", function (event)
        {
            this._$resizeMode = true;
            this._$pointX     = event.screenX;
            Util.$setCursor("row-resize");
        }.bind(this));

        window.addEventListener("mouseup", function ()
        {
            if (this._$resizeMode) {
                this._$resizeMode = false;
                Util.$setCursor("auto");
            }

            if (this._$easeMode) {
                this._$easeMode   = false;
                this._$easeTarget = null;
            }

            if (this._$filterGradientPointer) {

                const index = this._$filterGradientPointer.dataset.index | 0;
                if (index) {
                    const filterId = this._$filterGradientPointer.dataset.filterId | 0;
                    const filter   = this._$filters.get(filterId).filter;

                    filter.ratios[index] = parseFloat(this._$filterGradientPointer.style.left) + 4;

                    this.disposeCharacterImage();
                    this.updateFilterGradientCanvas(filterId, filter);
                }

                this._$filterGradientPointer = null;
            }

            if (this._$gradientPointer) {

                this._$gradientPointer = null;
            }

        }.bind(this));

        window.addEventListener("mousemove", function (event)
        {
            if (this._$easeMode) {

                window.requestAnimationFrame(function (screen_x, screen_y, element)
                {
                    const layerElement = Util.$timeline._$targetLayer;
                    if (!layerElement) {
                        return ;
                    }

                    let x = element.offsetLeft + screen_x - this._$pointX;
                    let y = element.offsetTop  + screen_y - this._$pointY;

                    // update
                    this._$pointX = screen_x;
                    this._$pointY = screen_y;

                    if (Util.EASE_MIN_POINTER_Y > y) {
                        y = Util.EASE_MIN_POINTER_Y;
                    }

                    if (Util.EASE_MAX_POINTER_Y < y) {
                        y = Util.EASE_MAX_POINTER_Y;
                    }

                    if (Util.EASE_MIN_POINTER_X > x) {
                        x = Util.EASE_MIN_POINTER_X;
                    }

                    if (Util.EASE_MAX_POINTER_X < x) {
                        x = Util.EASE_MAX_POINTER_X;
                    }

                    element.style.left = `${x}px`;
                    element.style.top  = `${y}px`;

                    const layerId = layerElement.dataset.layerId | 0;

                    const layer = Util
                        .$currentWorkSpace()
                        .scene
                        .getLayer(layerId);

                    const character = layer.getActiveCharacter(
                        document.getElementById("current-frame").textContent | 0
                    )[0];

                    const tween  = character.getTween();
                    const custom = tween.custom[element.dataset.index];

                    const scale = Util.EASE_BASE_CANVAS_SIZE / Util.EASE_RANGE;
                    custom.x = (x - Util.EASE_SCREEN_X) / scale;
                    custom.y = (Util.EASE_MOVE_Y - y) / scale;

                    document
                        .getElementById("ease-cubic-current-text")
                        .textContent = `(${(custom.x / Util.EASE_RANGE * 100) | 0})`;

                    document
                        .getElementById("ease-cubic-current-tween")
                        .textContent = `(${(custom.y / Util.EASE_RANGE * 100) | 0})`;

                    // restart
                    this.createEasingGraph();
                    Util.$screen.executeTween(layer);
                    Util.$screen.createTweenMarker();

                    const onionElement = document
                        .getElementById("timeline-onion-skin");

                    if (onionElement.classList.contains("onion-skin-active")) {
                        Util.$currentWorkSpace().scene.changeFrame(
                            document.getElementById("current-frame").textContent | 0
                        );
                    }

                }.bind(this, event.screenX, event.screenY, this._$easeTarget));

            }

            if (this._$resizeMode) {

                const diff = this._$pointX - event.screenX;

                const value = document
                    .documentElement
                    .style
                    .getPropertyValue("--controller-width")
                    .split("px")[0] | 0;

                document
                    .documentElement
                    .style
                    .setProperty(
                        "--controller-width",
                        `${Math.max(Util.CONTROLLER_DEFAULT_SIZE, value + diff)}px`
                    );

                this._$pointX = event.screenX;

            }

            if (this._$filterGradientPointer) {

                const index = this._$filterGradientPointer.dataset.index | 0;
                if (index) {

                    window.requestAnimationFrame(function (event, element, point_x)
                    {
                        const currentPoint = parseFloat(
                            element.style.left
                        );

                        const value = Util.$clamp(
                            currentPoint + (event.screenX - point_x) + 4,
                            Util.MIN_COLOR,
                            Util.MAX_COLOR
                        );

                        element.style.left = `${value - 4}px`;

                        const filterId = element.dataset.filterId | 0;
                        const filter = this._$filters.get(filterId).filter;

                        const index = element.dataset.index | 0;
                        filter._$ratios[index] = value;

                        if (this._$pointX) {
                            this._$pointX = event.screenX;
                        }

                        this.disposeCharacterImage();
                        this.updateFilterGradientCanvas(filterId, filter);

                    }.bind(this, event, this._$filterGradientPointer, this._$pointX));

                }
            }

            if (this._$gradientPointer && Util.$hitColor) {

                window.requestAnimationFrame(function (event, element, point_x)
                {
                    if (!Util.$hitColor) {
                        return ;
                    }

                    const currentPoint = parseFloat(
                        element.style.left
                    );

                    const value = Util.$clamp(
                        currentPoint + (event.screenX - point_x) + 4,
                        Util.MIN_COLOR,
                        Util.MAX_COLOR
                    );

                    element.style.left = `${value - 4}px`;

                    Util.$hitColor.ratios[element.dataset.index].ratio = value / 255;

                    if (this._$pointX) {
                        this._$pointX = event.screenX;
                    }

                    Util.$hitColor.shape.cacheClear();

                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    Util.$currentWorkSpace().scene.changeFrame(frame);

                    this.updateGradientCanvas();

                }.bind(this, event, this._$gradientPointer, this._$pointX));

            }

        }.bind(this));

        // init size
        document
            .documentElement
            .style
            .setProperty("--controller-width", `${Util.CONTROLLER_DEFAULT_SIZE}px`);

        // タブの初期設定
        this.initializeTab();

        // コントロール本体の初期設定
        this.initializeArea();

        // ライブラリ初期設定
        this.initializeLibrary();

        // end
        Util.$initializeEnd();
        this._$handler = null;
    }

    /**
     * @return {void}
     * @public
     */
    initializeTab ()
    {
        const tabs = document
            .getElementById("controller-tab-area")
            .children;

        const tabDownEvent = function (event)
        {
            Util.$endMenu();

            // reset
            this
                ._$active
                .classList
                .remove("active");

            this
                ._$active
                .classList
                .add("disable");

            // change active
            event
                .target
                .classList
                .remove("disable");

            event
                .target
                .classList
                .add("active");

            this._$active = event.target;

            const nodes = document
                .getElementById("controller-area")
                .children;

            for (let idx = 0; idx < nodes.length; ++idx) {

                const node = nodes[idx];

                if (node.id !== event.target.dataset.tabType) {
                    node.style.display = "none";
                    continue;
                }

                node.style.display = "";

            }

            // remove
            const previewElement = document
                .getElementById("library-preview-area");

            while (previewElement.children.length) {
                previewElement.children[0].remove();
            }

        }.bind(this);

        for (let idx = 0; idx < tabs.length; ++idx) {

            const tab = tabs[idx];

            // set active(init)
            if (!this._$active) {
                tab.classList.add("active");
                this._$active = tab;
            }

            tab.addEventListener("mousedown", tabDownEvent);

        }

        const nodes = document
            .getElementById("controller-area")
            .children;

        for (let idx = 0; idx < nodes.length; ++idx) {

            const node = nodes[idx];
            if (idx) {
                node.style.display = "none";
            }

        }
    }

    /**
     * @return {void}
     * @public
     */
    initializeArea ()
    {
        // Stageの初期設定
        this.initializeStageSetting();

        // オブジェクト設定の初期化
        this.initializeObjectSetting();

        // サウンド初期設定
        this.initializeSoundSetting();

        // スケールの初期設定
        this.initializeTransformSetting();

        // カラー効果の初期化
        this.initializeColorSetting();

        // ループの初期化
        this.initializeLoopSetting();

        // ブレンドモードの初期化
        this.initializeBlendSetting();

        // フィルターの初期設定
        this.initializeFilterSetting();

        // テキスト設定の初期化
        this.initializeTextSetting();

        // ビデオ設定の初期化
        this.initializeVideoSetting();

        // イージングの初期化
        this.initializeEaseSetting();

        // global event
        window.addEventListener("mouseup", this.mouseUp.bind(this));
        window.addEventListener("mousemove", this.mouseMove.bind(this));
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseOver (event)
    {
        if (!this._$focus && !this._$target && this._$currentValue === null) {
            Util.$setCursor("ew-resize");
            event.target.style.cursor = "ew-resize";
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseOut (event)
    {
        if (this._$focus || !this._$target) {
            Util.$setCursor("auto");
            event.target.style.cursor = "";
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseDown (event)
    {
        if (this._$focus) {
            return ;
        }

        event.preventDefault();

        // setup
        this._$saved        = false;
        this._$pointX       = event.screenX;
        this._$target       = event.target;
        this._$currentValue = +event.target.value;

        Util.$setCursor("ew-resize");
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseUp (event)
    {

        // reset
        Util.$setCursor("auto");

        if (!this._$target) {
            return ;
        }
        Util.$setCursor("auto");
        event.target.style.cursor = "";

        if (!this._$focus) {
            this._$target.dispatchEvent(new FocusEvent("focusout"));
        }

        // reset
        if (event.target === this._$target) {
            this._$target.focus();
        }

        this._$target = null;
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseMove (event)
    {
        if (!this._$target || this._$focus) {
            return ;
        }

        window.requestAnimationFrame(function (event)
        {
            if (!this._$target || this._$focus) {
                return ;
            }

            event.preventDefault();

            Util.$setCursor("ew-resize");

            const diff = event.screenX - this._$pointX;

            let currentValue = +this._$target.value;
            if (isNaN(currentValue)) {
                currentValue = 0;
            }

            this._$target.value = currentValue + diff;
            this.updateProperty(this._$target, diff);

            this._$currentValue = +this._$target.value;
            if (this._$lockTarget) {

                const currentValue      = +this._$lockTarget.value;
                this._$lockTarget.value = currentValue + diff;

                this.updateProperty(this._$lockTarget, diff);

            }

            this._$pointX = event.screenX;

            const frame = document
                .getElementById("current-frame")
                .textContent | 0;

            Util.$currentWorkSpace().scene.changeFrame(frame);

        }.bind(this, event));
    }

    /**
     * @return {void}
     * @public
     */
    showStageSetting ()
    {
        document.getElementById("instance-setting").style.display = "none";
        document.getElementById("stage-setting").style.display = "";
    }

    /**
     * @return {void}
     * @public
     */
    showEaseCanvasArea ()
    {
        document
            .getElementById("ease-canvas-view-area")
            .style.display = "";

        this.createEasingPointer();
        this.createEasingGraph();
    }

    /**
     * @return {void}
     * @public
     */
    hideEaseCanvasArea ()
    {
        document
            .getElementById("ease-canvas-view-area")
            .style.display = "none";

        this._$easeCustom = null;

        const children = document
            .getElementById("ease-cubic-pointer-area")
            .children;

        while (children.length) {
            children[0].remove();
        }
    }

    /**
     * @return {void}
     * @public
     */
    loadLoopFrameList ()
    {
        if (Util.$screen._$moveTargets.length > 1) {
            return ;
        }

        const element = document.getElementById("loop-image-list");

        const children = element.children;
        while (children.length) {
            children[0].remove();
        }

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        const target = Util.$screen._$moveTargets[0].target;

        const layerId = target.dataset.layerId | 0;
        const layer   = scene.getLayer(layerId);

        const characterId = target.dataset.characterId | 0;
        const character   = layer.getCharacter(characterId);

        const instance = workSpace.getLibrary(character.libraryId);

        const currentFrame = document
            .getElementById("current-frame")
            .textContent | 0;

        const { Sprite, BitmapData } = window.next2d.display;
        const { Matrix, ColorTransform } = window.next2d.geom;

        const promises = [];
        const endFrame = instance.totalFrame;
        for (let frame = character.startFrame; endFrame >= frame; ++frame) {

            promises.push(new Promise((resolve) =>
            {
                window.requestAnimationFrame(function (frame, resolve)
                {
                    document
                        .getElementById("current-frame")
                        .textContent = `${frame}`;

                    const place  = character.getPlace(frame);
                    const sprite = new Sprite();

                    const placeObject = {};
                    let keys = Object.keys(place);
                    for (let idx = 0; idx < keys.length; ++idx) {
                        const name = keys[idx];
                        placeObject[name] = place[name];
                    }

                    // init
                    placeObject.loop = {};

                    keys = Object.keys(place.loop);
                    for (let idx = 0; idx < keys.length; ++idx) {
                        const name = keys[idx];
                        placeObject.loop[name] = place.loop[name];
                    }

                    placeObject.loop.type  = 0;
                    placeObject.loop.start = 1;
                    placeObject.loop.end   = 0;

                    const displayObject = sprite.addChild(workSpace
                        .getLibrary(character.libraryId)
                        .createInstance(placeObject));

                    displayObject.transform.matrix = new Matrix(
                        place.matrix[0], place.matrix[1],
                        place.matrix[2], place.matrix[3],
                        place.matrix[4], place.matrix[5]
                    );
                    displayObject.transform.colorTransform = new ColorTransform(
                        place.colorTransform[0], place.colorTransform[1],
                        place.colorTransform[2], place.colorTransform[3],
                        place.colorTransform[4], place.colorTransform[5],
                        place.colorTransform[6], place.colorTransform[7]
                    );

                    const bounds = Util.$boundsMatrix(
                        instance.getBounds(placeObject),
                        place.matrix
                    );

                    const width  = Math.ceil(Math.abs(bounds.xMax - bounds.xMin));
                    const height = Math.ceil(Math.abs(bounds.yMax - bounds.yMin));
                    const scale  = Math.min(95 / width, 95 / height);
                    const ratio  = window.devicePixelRatio;

                    const bitmapData = new BitmapData(
                        width  * scale * ratio,
                        height * scale * ratio,
                        true, 0
                    );

                    const matrix = new Matrix(
                        ratio, 0, 0, ratio,
                        -bounds.xMin * ratio,
                        -bounds.yMin * ratio
                    );

                    matrix.scale(scale, scale);
                    bitmapData.draw(sprite, matrix);

                    const image  = bitmapData.toImage();
                    image.width  = image.width  / ratio;
                    image.height = image.height / ratio;

                    document
                        .getElementById("current-frame")
                        .textContent = `${currentFrame}`;

                    return resolve({
                        "index": frame - 1,
                        "image": image
                    });
                }.bind(this, frame, resolve));
            }));
        }

        Promise.all(promises)
            .then((results) =>
            {
                // reset
                document
                    .getElementById("current-frame")
                    .textContent = `${currentFrame}`;

                const images = [];
                for (let idx = 0; idx < results.length; ++idx) {
                    const object = results[idx];
                    images[object.index] = object.image;
                }

                for (let idx = 0; idx < images.length; ++idx) {

                    const frame = idx + 1;

                    const span = document.createElement("span");
                    span.textContent = `[ ${frame} ]`;

                    const p = document.createElement("p");
                    p.appendChild(images[idx]);

                    const div = document.createElement("div");
                    div.dataset.frame = `${frame}`;

                    div.appendChild(p);
                    div.appendChild(span);

                    div.addEventListener("click", (event) =>
                    {
                        const input = document
                            .getElementById("loop-start-frame");

                        input.value = event.currentTarget.dataset.frame;

                        this.frameSizeOut(this._$frameTarget, {
                            "type": "focusout",
                            "target": input
                        });
                    });

                    element.appendChild(div);
                }

                element.style.display = "";
            });
    }

    /**
     * @return {void}
     * @public
     */
    hideStageSetting ()
    {
        document.getElementById("stage-setting").style.display = "none";
    }

    /**
     * @param  {array} names
     * @return {void}
     * @public
     */
    showObjectSetting (names)
    {
        for (let idx = 0; idx < names.length; ++idx) {
            document.getElementById(names[idx]).style.display = "";
        }
    }

    /**
     * @param  {array} names
     * @return {void}
     * @public
     */
    hideObjectSetting (names)
    {
        for (let idx = 0; idx < names.length; ++idx) {
            document.getElementById(names[idx]).style.display = "none";
        }
    }

    /**
     * @return {void}
     * @public
     */
    showObjectArea ()
    {
        document.getElementById("object-area").style.display = "";
    }

    /**
     * @return {void}
     * @public
     */
    hideObjectArea ()
    {
        document.getElementById("object-area").style.display = "none";
    }

    /**
     * @return {void}
     * @public
     */
    setDefaultController ()
    {

        const scene = Util.$currentWorkSpace().scene;

        // コントローラー
        this.hideObjectSetting([
            "object-area",
            "instance-setting"
        ]);

        this.showObjectSetting([
            "stage-setting",
            "object-setting"
        ]);

        document
            .getElementById("object-name")
            .value = scene.name;

        document
            .getElementById("object-symbol")
            .value = scene.symbol;
    }

    /**
     * @param  {HTMLInputElement} target
     * @param  {number} diff
     * @return {void}
     * @public
     */
    updateProperty (target, diff = 0)
    {

        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }

        switch (target.id) {

            case "object-width":
                Util.$screen.updateWidth(Math.max(1, +target.value));
                break;

            case "object-height":
                Util.$screen.updateHeight(Math.max(1, +target.value));
                break;

            case "object-x":
                if (diff) {
                    Util.$screen.updateX(diff);
                    Util.$screen.placeTransformTarget();
                }
                break;

            case "object-y":
                if (diff) {
                    Util.$screen.updateY(diff);
                    Util.$screen.placeTransformTarget();
                }
                break;

            case "transform-scale-x":
                Util.$screen.updateScaleX(+target.value / 100);
                break;

            case "transform-scale-y":
                Util.$screen.updateScaleY(+target.value / 100);
                break;

            case "transform-rotate":
                Util.$screen.updateRotate(+target.value % 360);
                break;

            case "color-red-multiplier":
                Util.$screen.updateColorMultiplier(+target.value, 0);
                break;

            case "color-green-multiplier":
                Util.$screen.updateColorMultiplier(+target.value, 1);
                break;

            case "color-blue-multiplier":
                Util.$screen.updateColorMultiplier(+target.value, 2);
                break;

            case "color-alpha-multiplier":
                Util.$screen.updateColorMultiplier(+target.value, 3);
                break;

            case "fill-stroke-width-value":
            case "fill-alpha-value":
                if (Util.$hitColor) {

                    Util.$hitColor.shape.changeColor(Util.$hitColor.width | 0);

                    if (this._$gradientTarget) {
                        this._$gradientTarget.dataset.alpha = target.value;
                        this.updateGradientCanvas();
                    }
                }
                break;

            case "color-red-offset":
                Util.$screen.updateColorOffset(target.value | 0, 4);
                break;

            case "color-green-offset":
                Util.$screen.updateColorOffset(target.value | 0, 5);
                break;

            case "color-blue-offset":
                Util.$screen.updateColorOffset(target.value | 0, 6);
                break;

            case "color-alpha-offset":
                Util.$screen.updateColorOffset(target.value | 0, 7);
                break;

            case "font-size":
                Util.$screen.updateText({
                    "name": "size",
                    "value": Util.$clamp(
                        target.value | 0,
                        Util.FONT_MIN_SIZE,
                        Util.FONT_MAX_SIZE
                    )
                });
                break;

            case "font-color":
                Util.$screen.updateText({
                    "name": "color",
                    "value": `0x${target.value.substr(1)}` | 0
                });
                break;

            case "font-stroke-size":
                Util.$screen.updateText({
                    "name": "thickness",
                    "value": Util.$clamp(
                        target.value | 0,
                        Util.STROKE_MIN_SIZE,
                        Util.STROKE_MAX_SIZE
                    )
                });
                break;

            case "font-stroke-color":
                Util.$screen.updateText({
                    "name": "thicknessColor",
                    "value": `0x${target.value.substr(1)}` | 0
                });
                break;

            case "font-letterSpacing":
                Util.$screen.updateText({
                    "name": target.id.split("-")[1],
                    "value": Util.$clamp(
                        target.value | 0,
                        -Util.FONT_PARAM_MAX_SIZE,
                        Util.FONT_PARAM_MAX_SIZE
                    )
                });
                break;

            case "font-leading":
            case "font-leftMargin":
            case "font-rightMargin":
                Util.$screen.updateText({
                    "name": target.id.split("-")[1],
                    "value": Util.$clamp(
                        target.value | 0,
                        Util.FONT_PARAM_MIN_SIZE,
                        Util.FONT_PARAM_MAX_SIZE
                    )
                });
                break;

            case "video-volume":
                Util.$screen.updateVideoVolume(target);
                break;

            case "nine-slice-setting-x":
            case "nine-slice-setting-y":
            case "nine-slice-setting-w":
            case "nine-slice-setting-h":
                if (diff) {
                    Util.$screen.updateShapeGrid();
                }
                break;

            default:

                switch (target.dataset.name) {

                    case "volume":
                        this.updateSoundVolume(target);
                        break;

                    case "blurX":
                    case "blurY":
                        this.updateFilterBlur(target);
                        break;

                    case "gradientAlpha":
                        this.updateFilterGradientAlpha(target);
                        break;

                    case "alpha":
                    case "highlightAlpha":
                    case "shadowAlpha":
                        this.updateFilterAlpha(target);
                        break;

                    case "strength":
                        this.updateFilterStrength(target);
                        break;

                    case "angle":
                        this.updateFilterAngle(target);
                        break;

                    case "distance":
                        this.updateFilterDistance(target);
                        break;

                }
                break;

        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    stageWidthOut (event)
    {
        if (event.code === "Enter") {
            event.target.blur();
            return ;
        }

        if (event.type === "focusout") {

            const value = Util.$clamp(
                event.target.value | 0,
                Util.STAGE_MIN_SIZE,
                Util.STAGE_MAX_SIZE
            );

            const stageArea = document.getElementById("stage-area");
            const stage     = document.getElementById("stage");

            stageArea.style.width = `${value + window.screen.width}px`;
            stage.style.width     = `${value}px`;

            const workSpace = Util.$currentWorkSpace();
            workSpace.stage.width = value;

            event.target.value = value;
            if (this._$stageLock && this._$lockTarget
                && this._$currentValue !== null
            ) {

                const diff = value - this._$currentValue;

                const targetValue = Util.$clamp(
                    (this._$lockTarget.value | 0) + diff,
                    Util.STAGE_MIN_SIZE,
                    Util.STAGE_MAX_SIZE
                );

                this._$lockTarget.value = targetValue;
                stageArea.style.height  = `${targetValue + window.screen.height}px`;
                stage.style.height      = `${targetValue}px`;
                workSpace.stage.height  = targetValue;
            }

            this._$focus        = false;
            this._$lockTarget   = null;
            this._$currentValue = null;
            Util.$keyLock       = false;

            Util.$offsetLeft = stage.offsetLeft;
            Util.$offsetTop  = stage.offsetTop;

        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    stageHeightOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            const value = Util.$clamp(
                event.target.value | 0,
                Util.STAGE_MIN_SIZE,
                Util.STAGE_MAX_SIZE
            );

            const stageArea = document.getElementById("stage-area");
            const stage     = document.getElementById("stage");

            stageArea.style.height = `${value + window.screen.height}px`;
            stage.style.height     = `${value}px`;

            const workSpace = Util.$currentWorkSpace();
            workSpace.stage.height = value;

            event.target.value = value;
            if (this._$stageLock && this._$lockTarget
                && this._$currentValue !== null
            ) {

                const diff = value - this._$currentValue;

                const targetValue = Util.$clamp(
                    (this._$lockTarget.value | 0) + diff,
                    Util.STAGE_MIN_SIZE,
                    Util.STAGE_MAX_SIZE
                );

                this._$lockTarget.value = targetValue;
                stageArea.style.width   = `${targetValue + window.screen.width}px`;
                stage.style.width       = `${targetValue}px`;
                workSpace.stage.width   = targetValue;
            }

            this._$focus        = false;
            this._$lockTarget   = null;
            this._$currentValue = null;
            Util.$keyLock       = false;

            Util.$offsetLeft = stage.offsetLeft;
            Util.$offsetTop  = stage.offsetTop;
        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    stageFpsOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            const value = Util.$clamp(
                event.target.value,
                Util.STAGE_MIN_FPS,
                Util.STAGE_MAX_FPS
            );

            Util.$timeline.buildTimeline();

            const workSpace = Util.$currentWorkSpace();
            workSpace.stage.fps = value;
            event.target.value  = value;

            this._$focus        = false;
            this._$currentValue = null;
            this._$lockTarget   = null;
            Util.$keyLock       = false;
        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    strokeSizeOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            event.target.value = Util.$clamp(
                event.target.value,
                Util.STROKE_MIN_SIZE,
                Util.STROKE_MAX_SIZE
            );

            this._$focus        = false;
            this._$currentValue = null;
            this._$lockTarget   = null;
            Util.$keyLock       = false;

        }
    }

    /**
     * @return {void}
     * @public
     */
    initializeStageSetting()
    {

        document
            .getElementById("stage-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("stage-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            });

        document
            .getElementById("stage-lock")
            .addEventListener("mousedown", function ()
            {
                this._$stageLock    = !this._$stageLock;
                this._$currentValue = null;

                const element = document
                    .getElementById("stage-lock")
                    .childNodes[1];

                element
                    .setAttribute("class", this._$stageLock ? "active" : "disable");

                const workSpace = Util.$currentWorkSpace();
                workSpace.stage.lock = this._$stageLock;

            }.bind(this));

        // 線の幅
        const strokeSizeInput = document.getElementById("stroke-size");
        strokeSizeInput.value = 1;

        strokeSizeInput.addEventListener("mouseover", this.mouseOver.bind(this));
        strokeSizeInput.addEventListener("mouseout",  this.mouseOut.bind(this));
        strokeSizeInput.addEventListener("mousedown", this.mouseDown.bind(this));
        strokeSizeInput.addEventListener("focusin", function ()
        {
            this._$focus        = true;
            this._$currentValue = null;
            this._$lockTarget   = null;
            Util.$keyLock       = true;
        }.bind(this));

        strokeSizeInput.addEventListener("focusout", this.strokeSizeOut.bind(this));
        strokeSizeInput.addEventListener("keypress", this.strokeSizeOut.bind(this));

        // 幅
        const stageWidthInput = document.getElementById("stage-width");
        stageWidthInput.value = Util.STAGE_DEFAULT_WIDTH;

        stageWidthInput.addEventListener("mouseover", this.mouseOver.bind(this));
        stageWidthInput.addEventListener("mouseout",  this.mouseOut.bind(this));
        stageWidthInput.addEventListener("mousedown", this.mouseDown.bind(this));
        stageWidthInput.addEventListener("mousedown", function ()
        {
            if (!this._$focus && this._$stageLock) {
                this._$lockTarget = document.getElementById("stage-height");
            }
        }.bind(this));

        stageWidthInput.addEventListener("focusin", function ()
        {
            this._$focus        = true;
            this._$currentValue = null;
            this._$lockTarget   = null;
            Util.$keyLock       = true;

            if (this._$stageLock) {
                this._$lockTarget = document.getElementById("stage-height");
            }
        }.bind(this));

        stageWidthInput.addEventListener("focusout", this.stageWidthOut.bind(this));
        stageWidthInput.addEventListener("keypress", this.stageWidthOut.bind(this));

        // 高さ
        const stageHeightInput = document.getElementById("stage-height");
        stageHeightInput.value = Util.STAGE_DEFAULT_HEIGHT;

        stageHeightInput.addEventListener("mouseover", this.mouseOver.bind(this));
        stageHeightInput.addEventListener("mouseout",  this.mouseOut.bind(this));
        stageHeightInput.addEventListener("mousedown", this.mouseDown.bind(this));
        stageHeightInput.addEventListener("mousedown", function ()
        {
            if (!this._$focus && this._$stageLock) {
                this._$lockTarget = document.getElementById("stage-width");
            }
        }.bind(this));

        stageHeightInput.addEventListener("focusin", function ()
        {
            this._$focus        = true;
            this._$currentValue = null;
            this._$lockTarget   = null;
            Util.$keyLock       = true;

            if (this._$stageLock) {
                this._$lockTarget = document.getElementById("stage-width");
            }
        }.bind(this));

        stageHeightInput.addEventListener("focusout", this.stageHeightOut.bind(this));
        stageHeightInput.addEventListener("keypress", this.stageHeightOut.bind(this));

        // 背景色
        document
            .getElementById("stage-bgColor")
            .addEventListener("change", function (event)
            {
                const value = event.target.value;
                document
                    .getElementById("stage")
                    .style.backgroundColor = value;

                document
                    .getElementById("library-preview-area")
                    .style.backgroundColor = value;

                const workSpace = Util.$currentWorkSpace();
                workSpace.stage.bgColor = value;
            });

        // FPS
        const stageFpsInput = document.getElementById("stage-fps");
        stageFpsInput.value = Util.STAGE_DEFAULT_FPS;

        stageFpsInput.addEventListener("mouseover", this.mouseOver.bind(this));
        stageFpsInput.addEventListener("mouseout",  this.mouseOut.bind(this));
        stageFpsInput.addEventListener("mousedown", this.mouseDown.bind(this));
        stageFpsInput.addEventListener("focusin", function ()
        {
            this._$focus        = true;
            this._$currentValue = null;
            this._$lockTarget   = null;
            Util.$keyLock       = true;
        }.bind(this));

        stageFpsInput.addEventListener("focusout", this.stageFpsOut.bind(this));
        stageFpsInput.addEventListener("keypress", this.stageFpsOut.bind(this));

    }

    /**
     * @param  {string} type
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    frameSizeOut (type, event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            if (!Util.$screen._$moveTargets.length) {
                return ;
            }

            const workSpace = Util.$currentWorkSpace();
            const scene     = workSpace.scene;
            const element   = Util.$screen._$moveTargets[0].target;
            const instance  = workSpace.getLibrary(
                element.dataset.libraryId | 0
            );

            const frame = document
                .getElementById("current-frame")
                .textContent | 0;

            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            let place = character.getPlace(frame);
            if (!place.loop.referenceFrame) {

                const frameElement = document
                    .getElementById(`${layer.id}-${frame}`);

                if (frameElement.dataset.frameState !== "key-frame") {

                    character.setPlace(frame,
                        character.clonePlace(frame, frame)
                    );

                    Util.$timeline._$targetFrames = [frameElement];
                    Util.$timeline.addKeyFrame();
                    Util.$timeline._$targetFrames.length = 0;
                    frameElement.classList.remove("frame-active");

                }

            } else {
                place = character.getPlace(place.loop.referenceFrame);
            }

            const value = Util.$clamp(
                event.target.value | 0,
                type === "start" ? 1 : 0,
                instance.totalFrame
            );

            event.target.value = type === "start"
                ? `${value}`
                : value === 0 ? "-" : `${value}`;

            // update
            place.loop[type] = value;
            character._$image = null;

            scene.changeFrame(frame);
            Util.$screen.updatePropertyArea(false);

            this._$focus        = false;
            this._$currentValue = null;
            Util.$keyLock       = false;
        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    objectVolumeSizeOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            const value = Util.$clamp(
                event.target.value | 0,
                Util.MIN_VOLUME,
                Util.MAX_VOLUME
            );

            event.target.value = value;
            if (this._$currentValue !== value) {
                this.updateProperty(event.target);
            }

            this._$focus        = false;
            this._$currentValue = null;
            Util.$keyLock       = false;
        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    objectFontSizeOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            const value = Util.$clamp(
                event.target.value | 0,
                Util.FONT_MIN_SIZE,
                Util.FONT_MAX_SIZE
            );

            event.target.value = value;
            if (this._$currentValue !== value) {
                this.updateProperty(event.target);
            }

            this._$focus        = false;
            this._$currentValue = null;
            Util.$keyLock       = false;
        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    objectFontStrokeSizeOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            const value = Util.$clamp(
                event.target.value | 0,
                Util.STROKE_MIN_SIZE,
                Util.STROKE_MAX_SIZE
            );

            event.target.value = value;
            if (this._$currentValue !== value) {
                this.updateProperty(event.target);
            }

            this._$focus        = false;
            this._$currentValue = null;
            Util.$keyLock       = false;
        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    objectFontParamOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            let value = event.target.value | 0;
            if (event.target.id === "font-letterSpacing") {
                value = Util.$clamp(
                    value,
                    -Util.FONT_PARAM_MAX_SIZE,
                    Util.FONT_PARAM_MAX_SIZE
                );
            } else {
                value = Util.$clamp(
                    value,
                    Util.FONT_PARAM_MIN_SIZE,
                    Util.FONT_PARAM_MAX_SIZE
                );
            }

            event.target.value = value;
            if (this._$currentValue !== value) {
                this.updateProperty(event.target);
            }

            this._$focus        = false;
            this._$currentValue = null;
            Util.$keyLock       = false;
        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    objectSizeOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            const value = Util.$clamp(
                +event.target.value,
                Util.STAGE_MIN_SIZE,
                Util.STAGE_MAX_SIZE
            );

            event.target.value = value;
            if (this._$currentValue !== value) {

                this.updateProperty(event.target);

                if (this._$sizeLock && this._$lockTarget
                    && this._$currentValue !== null
                ) {

                    this._$lockTarget.value = Util.$clamp(
                        +this._$lockTarget.value + value - this._$currentValue,
                        Util.STAGE_MIN_SIZE,
                        Util.STAGE_MAX_SIZE
                    );

                    this.updateProperty(this._$lockTarget);

                }

                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                const scene = Util.$currentWorkSpace().scene;
                scene.changeFrame(frame);

            }

            this._$focus        = false;
            this._$lockTarget   = null;
            this._$currentValue = null;
            Util.$keyLock       = false;
        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    objectPointOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            const value = +event.target.value;

            event.target.value = Util.$clamp(
                value,
                Util.MIN_INT,
                Util.MAX_INT
            );

            this.updateProperty(event.target, value - this._$currentValue);

            this._$focus        = false;
            this._$lockTarget   = null;
            this._$currentValue = null;
            Util.$keyLock       = false;
        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    objectNameOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            const workSpace = Util.$currentWorkSpace();
            const scene = workSpace.scene;

            const moveTargets = Util.$screen._$moveTargets;
            if (moveTargets.length === 1) {

                const element = moveTargets[0].target;
                const layerId = element.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = element.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);
                character.name    = event.currentTarget.value;

            } else {

                scene.name = event.currentTarget.value;

            }

            Util.$keyLock = false;

        }
    }

    /**
     * @param  {FocusEvent|KeyboardEvent} event
     * @return {void}
     * @public
     */
    objectSymbolOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            const workSpace = Util.$currentWorkSpace();
            if (Util.$screen._$moveTargets.length) {

                const element   = Util.$screen._$moveTargets[0].target;
                const instance  = workSpace.getLibrary(element.dataset.libraryId | 0);
                instance.symbol = event.currentTarget.value;

            } else {

                workSpace.scene.symbol = event.currentTarget.value;

            }

            Util.$keyLock = false;
        }
    }

    /**
     * @return {void}
     * @public
     */
    initializeObjectSetting()
    {
        document
            .getElementById("instance-setting")
            .style.display = "none";

        document
            .getElementById("object-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("object-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            });

        const objectName = document.getElementById("object-name");
        objectName.addEventListener("focusout", this.objectNameOut.bind(this));
        objectName.addEventListener("keypress", this.objectNameOut.bind(this));
        objectName.addEventListener("focusin", function()
        {
            Util.$keyLock  = true;
        });

        const objectSymbol = document.getElementById("object-symbol");
        objectSymbol.addEventListener("focusout", this.objectSymbolOut.bind(this));
        objectSymbol.addEventListener("keypress", this.objectSymbolOut.bind(this));
        objectSymbol.addEventListener("focusin", function()
        {
            Util.$keyLock  = true;
        });

        document
            .getElementById("transform-size-lock")
            .addEventListener("mousedown", function ()
            {
                this._$sizeLock     = !this._$sizeLock;
                this._$currentValue = null;

                const element = document
                    .getElementById("transform-size-lock")
                    .childNodes[1];

                element
                    .setAttribute("class", this._$sizeLock ? "active" : "disable");

            }.bind(this));

        const size = [
            "object-width",
            "object-height"
        ];

        const widthDownEvent = function ()
        {
            if (!this._$focus && this._$sizeLock) {
                this._$lockTarget = document.getElementById("object-height");
            }
        }.bind(this);

        const heightDownEvent = function ()
        {
            if (!this._$focus && this._$sizeLock) {
                this._$lockTarget = document.getElementById("object-width");
            }
        }.bind(this);

        const focusInEvent = function (event)
        {
            this._$focus        = true;
            this._$currentValue = +event.target.value;
            this._$lockTarget   = null;
            Util.$keyLock       = true;

            if (this._$sizeLock) {
                this._$lockTarget = document.getElementById(name);
            }
        }.bind(this);

        for (let idx = 0; idx < size.length; ++idx) {

            const element = document.getElementById(size[idx]);

            element.addEventListener("mouseover", this.mouseOver.bind(this));
            element.addEventListener("mouseout",  this.mouseOut.bind(this));
            element.addEventListener("mousedown", this.mouseDown.bind(this));
            element.addEventListener("mousedown", !idx ? widthDownEvent : heightDownEvent);
            element.addEventListener("focusin",   focusInEvent);
            element.addEventListener("focusout",  this.objectSizeOut.bind(this));
            element.addEventListener("keypress",  this.objectSizeOut.bind(this));

        }

        const point = [
            "object-x",
            "object-y"
        ];

        const pointFocusInEvent = function (event)
        {
            this._$focus        = true;
            this._$currentValue = +event.target.value;
            this._$lockTarget   = null;
            Util.$keyLock       = true;
        }.bind(this);

        for (let idx = 0; idx < point.length; ++idx) {

            const element = document.getElementById(point[idx]);

            element.addEventListener("mouseover", this.mouseOver.bind(this));
            element.addEventListener("mouseout",  this.mouseOut.bind(this));
            element.addEventListener("mousedown", this.mouseDown.bind(this));
            element.addEventListener("focusin",   pointFocusInEvent);
            element.addEventListener("focusout",  this.objectPointOut.bind(this));
            element.addEventListener("keypress",  this.objectPointOut.bind(this));

        }

    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    transformScaleOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        if (event.type === "focusout") {

            const value = Util.$clamp(
                +event.target.value,
                Util.MIN_INT,
                Util.MAX_INT
            );

            event.target.value = value;
            if (this._$currentValue !== value) {

                this.updateProperty(event.target);

                if (this._$scaleLock && this._$lockTarget
                    && this._$currentValue !== null
                ) {

                    const diff = value - this._$currentValue;

                    this._$lockTarget.value = Util.$clamp(
                        +this._$lockTarget.value + diff,
                        Util.MIN_INT,
                        Util.MAX_INT
                    );

                    this.updateProperty(this._$lockTarget);
                }

                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                const scene = Util.$currentWorkSpace().scene;
                scene.changeFrame(frame);

            }

            this._$focus        = false;
            this._$lockTarget   = null;
            this._$currentValue = null;
            Util.$keyLock       = false;
        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    transformRotateOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return;
        }

        if (event.type === "focusout") {

            let value = Util.$clamp(
                (event.target.value | 0) % 360,
                Util.MIN_ROTATE,
                Util.MAX_ROTATE
            );
            if (0 > value) {
                value += 360;
            }

            event.target.value = value;
            this.updateProperty(event.target);

            this._$focus        = false;
            this._$currentValue = null;
            this._$lockTarget   = null;
            Util.$keyLock       = false;

            const frame = document
                .getElementById("current-frame")
                .textContent | 0;

            const scene = Util.$currentWorkSpace().scene;
            scene.changeFrame(frame);
        }
    }

    /**
     * @return {void}
     * @public
     */
    initializeTransformSetting ()
    {

        document
            .getElementById("transform-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("transform-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            }.bind(this));

        document
            .getElementById("transform-scale-lock")
            .addEventListener("mousedown", function ()
            {
                this._$scaleLock    = !this._$scaleLock;
                this._$currentValue = null;

                const element = document
                    .getElementById("transform-scale-lock")
                    .childNodes[1];

                element
                    .setAttribute("class", this._$scaleLock ? "active" : "disable");

            }.bind(this));

        const scale = [
            "transform-scale-x",
            "transform-scale-y"
        ];

        const xDownEvent = function ()
        {
            if (!this._$focus && this._$scaleLock) {
                this._$lockTarget = document.getElementById("transform-scale-y");
            }
        }.bind(this);

        const yDownEvent = function ()
        {
            if (!this._$focus && this._$scaleLock) {
                this._$lockTarget = document.getElementById("transform-scale-x");
            }
        }.bind(this);

        const xFocusInEvent = function (event)
        {
            this._$focus        = true;
            this._$currentValue = +event.target.value;
            this._$lockTarget   = null;
            Util.$keyLock       = true;

            if (this._$scaleLock) {
                this._$lockTarget = document.getElementById("transform-scale-y");
            }
        }.bind(this);

        const yFocusInEvent = function (event)
        {
            this._$focus        = true;
            this._$currentValue = +event.target.value;
            this._$lockTarget   = null;
            Util.$keyLock       = true;

            if (this._$scaleLock) {
                this._$lockTarget = document.getElementById("transform-scale-x");
            }
        }.bind(this);

        for (let idx = 0; idx < scale.length; ++idx) {

            const element = document.getElementById(scale[idx]);

            element.addEventListener("mouseover", this.mouseOver.bind(this));
            element.addEventListener("mouseout",  this.mouseOut.bind(this));
            element.addEventListener("mousedown", this.mouseDown.bind(this));
            element.addEventListener("mousedown", !idx ? xDownEvent : yDownEvent);
            element.addEventListener("focusin",   !idx ? xFocusInEvent : yFocusInEvent);
            element.addEventListener("focusout",  this.transformScaleOut.bind(this));
            element.addEventListener("keypress",  this.transformScaleOut.bind(this));

        }

        const element = document.getElementById("transform-rotate");
        element.addEventListener("mouseover", this.mouseOver.bind(this));
        element.addEventListener("mouseout",  this.mouseOut.bind(this));
        element.addEventListener("mousedown", this.mouseDown.bind(this));
        element.addEventListener("focusin", function (event)
        {
            this._$focus        = true;
            this._$currentValue = +event.target.value;
            this._$lockTarget   = null;
            Util.$keyLock       = true;
        }.bind(this));

        element.addEventListener("focusout", this.transformRotateOut.bind(this));
        element.addEventListener("keypress", this.transformRotateOut.bind(this));

    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    colorMultiplierOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return;
        }

        if (event.type === "focusout") {

            event.target.value = Util.$clamp(
                event.target.value | 0,
                Util.COLOR_MIN_MULTIPLIER,
                Util.COLOR_MAX_MULTIPLIER
            );

            const value = +event.target.value;
            if (this._$currentValue !== value) {

                let index = 0;
                switch (event.target.id) {

                    case "color-red-multiplier":
                        index = 0;
                        break;

                    case "color-green-multiplier":
                        index = 1;
                        break;

                    case "color-blue-multiplier":
                        index = 2;
                        break;

                    case "color-alpha-multiplier":
                        index = 3;
                        break;

                    case "fill-alpha-value":
                        index = 4;
                        break;

                }

                if (index === 4) {

                    if (Util.$hitColor) {
                        Util.$hitColor.shape.changeColor();
                    }

                } else {
                    Util
                        .$screen
                        .updateColorMultiplier(value, index);
                }

                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                const scene = Util.$currentWorkSpace().scene;
                scene.changeFrame(frame);

            }

            this._$focus        = false;
            this._$currentValue = null;
            this._$lockTarget   = null;
            Util.$keyLock       = false;
        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    colorOffsetOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return;
        }

        if (event.type === "focusout") {

            event.target.value = Util.$clamp(
                event.target.value | 0,
                Util.COLOR_MIN_OFFSET,
                Util.COLOR_MAX_OFFSET
            );

            const value = +event.target.value;
            if (this._$currentValue !== value) {

                let index = 4;
                switch (event.target.id) {

                    case "color-red-offset":
                        index = 4;
                        break;

                    case "color-green-offset":
                        index = 5;
                        break;

                    case "color-blue-offset":
                        index = 6;
                        break;

                    case "color-alpha-offset":
                        index = 7;
                        break;

                }

                Util
                    .$screen
                    .updateColorOffset(value, index);

                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                const scene = Util.$currentWorkSpace().scene;
                scene.changeFrame(frame);

            }

            this._$focus        = false;
            this._$currentValue = null;
            this._$lockTarget   = null;
            Util.$keyLock       = false;
        }
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    colorShapeOut (event)
    {
        if (event.code === "Enter") {
            event.currentTarget.blur();
            return;
        }

        if (event.type === "focusout") {

            event.target.value = Util.$clamp(
                event.target.value | 0,
                Util.COLOR_MIN_MULTIPLIER,
                Util.COLOR_MAX_MULTIPLIER
            );

            const value = +event.target.value;
            if (this._$currentValue !== value && Util.$hitColor) {

                Util.$hitColor.shape.changeColor();

                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                const scene = Util.$currentWorkSpace().scene;
                scene.changeFrame(frame);

                const { GradientType } = window.next2d.display;
                switch (Util.$hitColor.type) {

                    case GradientType.LINEAR:
                    case GradientType.RADIAL:
                        this.updateGradientCanvas();
                        break;

                    default:
                        break;

                }

            }

            this._$focus        = false;
            this._$currentValue = null;
            this._$lockTarget   = null;
            Util.$keyLock       = false;
        }
    }

    /**
     * @return {void}
     * @public
     */
    initializeColorSetting ()
    {

        document
            .getElementById("color-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("color-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            });

        const multiplier = [
            "color-alpha-multiplier",
            "color-red-multiplier",
            "color-green-multiplier",
            "color-blue-multiplier"
        ];

        const multiFocusIn = function (event)
        {
            this._$focus        = true;
            this._$currentValue = +event.target.value;
            this._$lockTarget   = null;
            Util.$keyLock       = true;
        }.bind(this);

        for (let idx = 0; idx < multiplier.length; ++idx) {

            const element = document.getElementById(multiplier[idx]);

            element.addEventListener("mouseover", this.mouseOver.bind(this));
            element.addEventListener("mouseout",  this.mouseOut.bind(this));
            element.addEventListener("mousedown", this.mouseDown.bind(this));
            element.addEventListener("focusin",   multiFocusIn);
            element.addEventListener("focusout",  this.colorMultiplierOut.bind(this));
            element.addEventListener("keypress",  this.colorMultiplierOut.bind(this));

        }

        const offset = [
            "color-alpha-offset",
            "color-red-offset",
            "color-green-offset",
            "color-blue-offset"
        ];

        const offsetFocusIn = function (event)
        {
            this._$focus        = true;
            this._$currentValue = +event.target.value;
            this._$lockTarget   = null;
            Util.$keyLock       = true;
        }.bind(this);

        for (let idx = 0; idx < offset.length; ++idx) {

            const element = document.getElementById(offset[idx]);

            element.addEventListener("mouseover", this.mouseOver.bind(this));
            element.addEventListener("mouseout",  this.mouseOut.bind(this));
            element.addEventListener("mousedown", this.mouseDown.bind(this));
            element.addEventListener("focusin",   offsetFocusIn);
            element.addEventListener("focusout",  this.colorOffsetOut.bind(this));
            element.addEventListener("keypress",  this.colorOffsetOut.bind(this));

        }

        document
            .getElementById("fill-color-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("fill-color-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            });

        document
            .getElementById("nine-slice-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("nine-slice-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            });

        const nineSlices = [
            "nine-slice-setting-x",
            "nine-slice-setting-y",
            "nine-slice-setting-w",
            "nine-slice-setting-h"
        ];

        for (let idx = 0; idx < nineSlices.length; ++idx) {

            const element = document.getElementById(nineSlices[idx]);

            element.addEventListener("mouseover", this.mouseOver.bind(this));
            element.addEventListener("mouseout",  this.mouseOut.bind(this));
            element.addEventListener("mousedown", this.mouseDown.bind(this));
            element.addEventListener("focusin",   function (event)
            {
                this._$focus        = true;
                this._$currentValue = +event.target.value;
                this._$lockTarget   = null;
                Util.$keyLock       = true;
            }.bind(this));

            element.addEventListener("focusout",  this.objectPointOut.bind(this));
            element.addEventListener("keypress",  this.objectPointOut.bind(this));

        }

        document
            .getElementById("fill-color-type-select")
            .addEventListener("change", this.changeShapeColor.bind(this));

        document
            .getElementById("fill-color-value")
            .addEventListener("change", function (event)
            {
                if (Util.$hitColor) {

                    if (this._$gradientTarget) {

                        const pointerColor = this
                            ._$gradientTarget
                            .getElementsByTagName("i")[0];

                        this._$gradientTarget.dataset.color = event.target.value;
                        pointerColor.style.backgroundColor  = event.target.value;

                        Util.$hitColor.shape.changeColor();

                        this.updateGradientCanvas();

                    } else {

                        Util.$hitColor.shape.changeColor();

                    }

                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    const scene = Util.$currentWorkSpace().scene;
                    scene.changeFrame(frame);

                }

            }.bind(this));

        const alphaElement = document.getElementById("fill-alpha-value");
        alphaElement.addEventListener("mouseover", this.mouseOver.bind(this));
        alphaElement.addEventListener("mouseout",  this.mouseOut.bind(this));
        alphaElement.addEventListener("mousedown", this.mouseDown.bind(this));
        alphaElement.addEventListener("focusin", function (event)
        {
            this._$focus        = true;
            this._$currentValue = +event.target.value;
            this._$lockTarget   = null;
            Util.$keyLock       = true;
        }.bind(this));
        alphaElement.addEventListener("focusout", this.colorShapeOut.bind(this));
        alphaElement.addEventListener("keypress", this.colorShapeOut.bind(this));

        const widthElement = document.getElementById("fill-stroke-width-value");
        widthElement.addEventListener("mouseover", this.mouseOver.bind(this));
        widthElement.addEventListener("mouseout",  this.mouseOut.bind(this));
        widthElement.addEventListener("mousedown", this.mouseDown.bind(this));
        widthElement.addEventListener("focusin", function (event)
        {
            this._$focus        = true;
            this._$currentValue = +event.target.value;
            this._$lockTarget   = null;
            Util.$keyLock       = true;
        }.bind(this));
        widthElement.addEventListener("focusout", this.colorShapeOut.bind(this));
        widthElement.addEventListener("keypress", this.colorShapeOut.bind(this));

        document
            .getElementById("color-pointer-list")
            .addEventListener("mousedown", function (event)
            {
                if (this._$gradientPointer || !Util.$hitColor) {
                    return ;
                }

                const color  = document.getElementById("fill-color-value").value;
                const alpha  = document.getElementById("fill-alpha-value").value | 0;
                const object = Util.$intToRGB(`0x${color.substr(1)}` | 0);

                const stopObject = {
                    "R": object.R,
                    "G": object.G,
                    "B": object.B,
                    "A": alpha / 100 * 255,
                    "ratio": event.offsetX / 255
                };

                Util.$hitColor.ratios.push(stopObject);

                Util.$hitColor.ratios.sort(function (a, b)
                {
                    switch (true) {

                        case a.ratio > b.ratio:
                            return 1;

                        case a.ratio < b.ratio:
                            return -1;

                        default:
                            return 0;

                    }
                });

                Util.$hitColor.shape.cacheClear();

                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                Util.$currentWorkSpace().scene.changeFrame(frame);

                this.initializeGradient();

                // fixed logic
                this._$gradientTarget = document
                    .getElementById("color-pointer-list")
                    .children[Util.$hitColor.ratios.indexOf(stopObject)];

            }.bind(this));

        const viewCanvas  = document.getElementById("gradient-canvas");
        viewCanvas.width  = Util.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio;
        viewCanvas.height = Util.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio;

        viewCanvas.style.transform          = `scale(${1 / window.devicePixelRatio}, ${1 / window.devicePixelRatio})`;
        viewCanvas.style.backfaceVisibility = "hidden";
        viewCanvas.style.transformOrigin    = "0 0";

        this._$viewGradientContext = viewCanvas.getContext("2d");

        const drawCanvas  = document.createElement("canvas");
        drawCanvas.width  = Util.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio;
        drawCanvas.height = Util.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio;

        this._$drawGradientContext = drawCanvas.getContext("2d");

        document
            .getElementById("fill-bitmap-select")
            .addEventListener("change", function (event)
            {
                if (!Util.$hitColor) {
                    return ;
                }

                const instance = Util.$currentWorkSpace().getLibrary(
                    event.target.value | 0
                );

                Util.$hitColor.shape.bitmapId = instance.id;
                Util.$hitColor.shape.cacheClear();

                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                Util.$currentWorkSpace().scene.changeFrame(frame);

            });

    }

    /**
     * @param  {Event} event
     * @return {void}
     * @public
     */
    changeShapeColor (event = null)
    {

        this._$gradientPointer = null;
        this._$gradientTarget  = null;

        const element = document
            .getElementById("fill-color-type-select");

        const style = element.value;

        const gradientElement = document
            .getElementById("fill-color-gradient-container");

        const bitmapElement = document
            .getElementById("fill-color-bitmap-container");

        const colorElement = document
            .getElementById("fill-color-rgba-container");

        const widthElement = document
            .getElementById("fill-stroke-color-rgba-container");

        // reset
        if (event) {
            Util.$hitColor.shape.bitmapId = 0;
        }

        // update
        switch (style) {

            case "rgba":
                gradientElement.style.display = "none";
                bitmapElement.style.display   = "none";
                colorElement.style.display    = "";
                widthElement.style.display    = Util.$hitColor.width ? "" : "none";
                break;

            case "bitmap":
                gradientElement.style.display = "none";
                bitmapElement.style.display   = "";
                colorElement.style.display    = "none";
                widthElement.style.display    = Util.$hitColor.width ? "" : "none";
                this.createBitmapList();
                break;

            default:
                gradientElement.style.display = "";
                bitmapElement.style.display   = "none";
                colorElement.style.display    = "";
                widthElement.style.display    = Util.$hitColor.width ? "" : "none";
                if (!event) {
                    this.initializeGradient();
                }
                break;

        }

        if (event) {
            Util.$hitColor.shape.changeStyle(style);
        }
    }

    /**
     * @return {void}
     * @public
     */
    createBitmapList ()
    {
        const element = document.getElementById("fill-bitmap-select");

        const children = element.children;
        while (children.length) {
            children[0].remove();
        }

        const option = document.createElement("option");
        option.innerHTML       = "Select Bitmap";
        option.defaultSelected = true;
        option.disabled        = true;
        element.appendChild(option);

        const bitmapId = Util.$hitColor.shape.bitmapId;

        const workSpace = Util.$currentWorkSpace();
        for (const instance of workSpace._$libraries.values()) {

            if (instance.type !== "bitmap") {
                continue;
            }

            const option = document.createElement("option");

            option.value     = instance.id;
            option.innerHTML = instance.name;

            if (bitmapId && bitmapId === instance.id) {
                option.selected = true;
            }

            element.appendChild(option);
        }
    }

    /**
     * @return {void}
     * @public
     */
    initializeLoopSetting ()
    {
        document
            .getElementById("loop-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("loop-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            });

        document
            .getElementById("loop-repeat")
            .addEventListener("mousedown", function (event)
            {
                const element = event.target;

                const children = element.parentNode.children;
                for (let idx = 0; idx < children.length; ++idx) {
                    children[idx].classList.remove("active");
                }

                element.classList.add("active");

                this.updateLoopType(0);

            }.bind(this));

        document
            .getElementById("loop-no-repeat")
            .addEventListener("mousedown", function (event)
            {
                const element = event.target;

                const children = element.parentNode.children;
                for (let idx = 0; idx < children.length; ++idx) {
                    children[idx].classList.remove("active");
                }

                element.classList.add("active");

                this.updateLoopType(1);

            }.bind(this));

        document
            .getElementById("fixed-one")
            .addEventListener("mousedown", function (event)
            {
                const element = event.target;

                const children = element.parentNode.children;
                for (let idx = 0; idx < children.length; ++idx) {
                    children[idx].classList.remove("active");
                }

                element.classList.add("active");

                this.updateLoopType(2);

            }.bind(this));

        document
            .getElementById("loop-no-repeat-reversal")
            .addEventListener("mousedown", function (event)
            {
                const element = event.target;

                const children = element.parentNode.children;
                for (let idx = 0; idx < children.length; ++idx) {
                    children[idx].classList.remove("active");
                }

                element.classList.add("active");

                this.updateLoopType(3);

            }.bind(this));

        document
            .getElementById("loop-repeat-reversal")
            .addEventListener("mousedown", function (event)
            {
                const element = event.target;

                const children = element.parentNode.children;
                for (let idx = 0; idx < children.length; ++idx) {
                    children[idx].classList.remove("active");
                }

                element.classList.add("active");

                this.updateLoopType(4);

            }.bind(this));

        const startFrame = document
            .getElementById("loop-start-frame");

        startFrame.addEventListener("mouseover", this.mouseOver.bind(this));
        startFrame.addEventListener("mouseout",  this.mouseOut.bind(this));
        startFrame.addEventListener("mousedown", this.mouseDown.bind(this));
        startFrame.addEventListener("focusin", function (event)
        {
            this._$focus        = true;
            this._$currentValue = event.target.value | 0;
            Util.$keyLock       = true;
        }.bind(this));

        startFrame.addEventListener("focusout", this.frameSizeOut.bind(this, "start"));
        startFrame.addEventListener("keypress", this.frameSizeOut.bind(this, "start"));

        const endFrame = document
            .getElementById("loop-end-frame");

        endFrame.addEventListener("mouseover", this.mouseOver.bind(this));
        endFrame.addEventListener("mouseout",  this.mouseOut.bind(this));
        endFrame.addEventListener("mousedown", this.mouseDown.bind(this));
        endFrame.addEventListener("focusin", function (event)
        {
            this._$focus        = true;
            this._$currentValue = event.target.value | 0;
            Util.$keyLock       = true;
        }.bind(this));

        endFrame.addEventListener("focusout", this.frameSizeOut.bind(this, "end"));
        endFrame.addEventListener("keypress", this.frameSizeOut.bind(this, "end"));

        document
            .getElementById("loop-image-list")
            .style.display = "none";

        document
            .getElementById("frame-picker-button")
            .addEventListener("mousedown", function ()
            {

                document
                    .getElementById("loop-image-list")
                    .style.display = "none";

                this.loadLoopFrameList();

            }.bind(this));

        document
            .getElementById("target-start-button")
            .addEventListener("mousedown", function (event)
            {
                const element = event.currentTarget;
                if (!element.classList.contains("active")) {
                    element.classList.add("active");
                }

                document
                    .getElementById("target-end-button")
                    .classList.remove("active");

                this._$frameTarget = "start";

            }.bind(this));

        document
            .getElementById("target-end-button")
            .addEventListener("mousedown", function (event)
            {
                const element = event.currentTarget;
                if (!element.classList.contains("active")) {
                    element.classList.add("active");
                }

                document
                    .getElementById("target-start-button")
                    .classList.remove("active");

                this._$frameTarget = "end";

            }.bind(this));
    }

    /**
     * @param  {number} [type=0]
     * @return {void}
     * @public
     */
    updateLoopType (type = 0)
    {
        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const scene   = Util.$currentWorkSpace().scene;
        const element = Util.$screen._$moveTargets[0].target;
        const layerId = element.dataset.layerId | 0;
        const layer   = scene.getLayer(layerId);

        const character = layer
            .getCharacter(element.dataset.characterId | 0);

        let place = character.getPlace(frame);
        if (!place.loop.referenceFrame) {

            const frameElement = document
                .getElementById(`${layer.id}-${frame}`);

            if (frameElement.dataset.frameState !== "key-frame") {

                character.setPlace(frame,
                    character.clonePlace(frame, frame)
                );

                Util.$timeline._$targetFrames = [frameElement];
                Util.$timeline.addKeyFrame();
                Util.$timeline._$targetFrames.length = 0;
                frameElement.classList.remove("frame-active");

            }

            place = character.getPlace(frame);
        } else {
            place = character.getPlace(place.loop.referenceFrame);
        }

        // update
        place.loop.type = type;

        // cache clear
        character._$image = null;
        scene.changeFrame(frame);
        Util.$screen.updatePropertyArea(false);
    }

    /**
     * @return {void}
     * @public
     */
    initializeBlendSetting ()
    {
        document
            .getElementById("blend-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("blend-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            });

        document
            .getElementById("blend-select")
            .addEventListener("change", function (event)
            {
                Util.$screen.updateBlendMode(event.target.value);
            });

    }

    /**
     * @return {void}
     * @public
     */
    initializeFilterSetting ()
    {

        document
            .getElementById("filter-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("filter-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            });

        document
            .getElementById("filter-add")
            .addEventListener("mousedown", function ()
            {
                document
                    .querySelectorAll(".filter-none")[0]
                    .style.display = "none";

                const select = document.getElementById("filter-select");
                this[`add${select.value}`](
                    document.getElementById("filter-setting-list")
                );

            }.bind(this));

    }

    /**
     * @return {void}
     * @public
     */
    initializeVideoSetting ()
    {
        document
            .getElementById("video-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("video-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            });

        document
            .getElementById("video-loop-select")
            .addEventListener("change", function (event)
            {
                const element   = Util.$screen._$moveTargets[0].target;
                const workSpace = Util.$currentWorkSpace();
                const instance  = workSpace.getLibrary(
                    element.dataset.libraryId | 0
                );

                instance.loop = (event.target.value | 0) === 1;
            });

        document
            .getElementById("video-auto-select")
            .addEventListener("change", function (event)
            {
                const element   = Util.$screen._$moveTargets[0].target;
                const workSpace = Util.$currentWorkSpace();
                const instance  = workSpace.getLibrary(
                    element.dataset.libraryId | 0
                );

                instance.autoPlay = (event.target.value | 0) === 1;
            });

        const volume = document.getElementById("video-volume");

        volume.addEventListener("mouseover", this.mouseOver.bind(this));
        volume.addEventListener("mouseout",  this.mouseOut.bind(this));
        volume.addEventListener("mousedown", this.mouseDown.bind(this));
        volume.addEventListener("focusin", function (event)
        {
            this._$focus        = true;
            this._$currentValue = event.target.value | 0;
            Util.$keyLock       = true;
        }.bind(this));

        volume.addEventListener("focusout", this.objectVolumeSizeOut.bind(this));
        volume.addEventListener("keypress", this.objectVolumeSizeOut.bind(this));

    }

    /**
     * @return {void}
     * @public
     */
    initializeEaseSetting ()
    {
        document
            .getElementById("ease-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("ease-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            });

        document
            .getElementById("ease-select")
            .addEventListener("change", function (event)
            {
                if (event.target.value === "custom") {
                    this.showEaseCanvasArea();
                } else {
                    this.hideEaseCanvasArea();
                }

                const scene = Util.$currentWorkSpace().scene;

                const layerElement = Util.$timeline._$targetLayer;

                Util.$screen.executeTween(scene.getLayer(
                    layerElement.dataset.layerId | 0
                ), true);

                Util.$screen.createTweenMarker();

                const onionElement = document
                    .getElementById("timeline-onion-skin");
                if (onionElement.classList.contains("onion-skin-active")) {
                    scene.changeFrame(
                        document.getElementById("current-frame").textContent | 0
                    );
                }
            }.bind(this));

        document
            .getElementById("ease-custom-data-export")
            .addEventListener("click", function ()
            {
                const layerElement = Util.$timeline._$targetLayer;
                if (!layerElement) {
                    return ;
                }

                const layerId   = layerElement.dataset.layerId | 0;
                const workSpace = Util.$currentWorkSpace();
                const layer     = workSpace.scene.getLayer(layerId);
                const character = layer.getActiveCharacter(
                    document.getElementById("current-frame").textContent | 0
                )[0];

                const instance = workSpace.getLibrary(character.libraryId);
                const tween    = character.getTween();

                const anchor    = document.createElement("a");
                anchor.download = `${instance.name}.json`;
                anchor.href     = URL.createObjectURL(new Blob(
                    [JSON.stringify(tween.custom)],
                    { "type" : "application/json" }
                ));
                anchor.click();
            });

        document
            .getElementById("ease-custom-data-load")
            .addEventListener("click", function (event)
            {
                const input = document.getElementById("ease-custom-file-input");
                input.click();

                event.preventDefault();
            });

        document
            .getElementById("ease-custom-file-input")
            .addEventListener("change", function (event)
            {
                const file = event.target.files[0];

                file
                    .text()
                    .then(function (text)
                    {
                        const layerElement = Util.$timeline._$targetLayer;
                        if (!layerElement) {
                            return ;
                        }

                        const layerId   = layerElement.dataset.layerId | 0;
                        const workSpace = Util.$currentWorkSpace();
                        const layer     = workSpace.scene.getLayer(layerId);
                        const character = layer.getActiveCharacter(
                            document.getElementById("current-frame").textContent | 0
                        )[0];

                        const tween  = character.getTween();
                        tween.custom = JSON.parse(text);

                        const children = document
                            .getElementById("ease-cubic-pointer-area")
                            .children;

                        while (children.length) {
                            children[0].remove();
                        }

                        this.createEasingPointer();
                        this.createEasingGraph();
                        Util.$screen.executeTween(layer);
                        Util.$screen.createTweenMarker();

                    }.bind(this));

                // reset
                event.target.value = "";

            }.bind(this));

        const ratio = window.devicePixelRatio;

        const viewCanvas  = document.getElementById("ease-custom-canvas");
        viewCanvas.width  = Util.EASE_CANVAS_WIDTH  * ratio;
        viewCanvas.height = Util.EASE_CANVAS_HEIGHT * ratio;

        viewCanvas.style.transform          = `scale(${1 / ratio}, ${1 / ratio})`;
        viewCanvas.style.backfaceVisibility = "hidden";

        this._$viewEaseContext = viewCanvas.getContext("2d");

        viewCanvas.addEventListener("dblclick", function (event)
        {
            const layerElement = Util.$timeline._$targetLayer;
            if (!layerElement) {
                return ;
            }

            const layerId = layerElement.dataset.layerId | 0;

            const layer = Util
                .$currentWorkSpace()
                .scene
                .getLayer(layerId);

            const character = layer.getActiveCharacter(
                document.getElementById("current-frame").textContent | 0
            )[0];

            const parent = document
                .getElementById("ease-cubic-pointer-area");

            const children = parent.children;

            const tween  = character.getTween();
            const types  = ["curve", "pointer", "curve"];
            const points = [-20, 0, 20];

            const scale = Util.EASE_BASE_CANVAS_SIZE / Util.EASE_RANGE;

            const x = (event.layerX - Util.EASE_BASE_CANVAS_SIZE) / scale;
            const y = (Util.EASE_BASE_CANVAS_SIZE - (event.layerY - 300)) / scale;

            // new pointer
            for (let idx = 0; idx < types.length; ++idx) {

                const type = types[idx];

                const dx = x + points[idx];
                const dy = y + points[idx];

                const div = this.createEasingPointerDiv(dx, dy, type);

                parent.insertBefore(
                    div, children[children.length - 1]
                );

                tween.custom.splice(-2, 0, {
                    "type": type,
                    "x": dx,
                    "y": dy
                });
            }

            for (let idx = 0; idx < children.length; ++idx) {
                const child = children[idx];
                child.dataset.index = `${idx + 1}`;
            }

            this._$easeMode   = false;
            this._$easeTarget = null;

            this.createEasingGraph();
            Util.$screen.executeTween(layer);
            Util.$screen.createTweenMarker();

        }.bind(this));

        const drawCanvas  = document.createElement("canvas");
        drawCanvas.width  = Util.EASE_CANVAS_WIDTH  * ratio;
        drawCanvas.height = Util.EASE_CANVAS_HEIGHT * ratio;

        this._$drawEaseContext = drawCanvas.getContext("2d");

        this.hideEaseCanvasArea();
    }

    /**
     * @return {array}
     * @public
     */
    createEasingObject ()
    {
        return [
            {
                "type": "pointer",
                "fixed": true,
                "x": 0,
                "y": 0
            },
            {
                "type": "curve",
                "x": 0,
                "y": 0
            },
            {
                "type": "curve",
                "x": 100,
                "y": 100
            },
            {
                "type": "pointer",
                "fixed": true,
                "x": 100,
                "y": 100
            }
        ];
    }

    /**
     * @return {void}
     * @public
     */
    createEasingPointer ()
    {
        const target    = Util.$timeline._$targetLayer;
        const layerId   = target.dataset.layerId | 0;
        const layer     = Util.$currentWorkSpace().scene.getLayer(layerId);
        const character = layer.getActiveCharacter(
            document.getElementById("current-frame").textContent | 0
        )[0];

        // init
        if (!character.hasTween()) {
            character.setTween({
                "method": "linear",
                "curve": [],
                "custom": this.createEasingObject()
            });
        }

        const tween   = character.getTween();
        const element = document
            .getElementById("ease-cubic-pointer-area");

        for (let idx = 0; idx < tween.custom.length; ++idx) {

            const custom = tween.custom[idx];
            if (custom.fixed) {
                continue;
            }

            const div = this.createEasingPointerDiv(
                custom.x, custom.y, custom.type, idx
            );

            if (custom.off) {
                div.classList.add("ease-cubic-disable");
            }

            element.appendChild(div);

        }
    }

    /**
     * @param  {number}  [x=0]
     * @param  {number}  [y=0]
     * @param  {string}  [type="pointer"]
     * @param  {number}  [index=0]
     * @return {HTMLDivElement}
     * @public
     */
    createEasingPointerDiv (x = 0, y = 0, type = "pointer", index = 0)
    {
        const div = document.createElement("div");

        div
            .addEventListener("mousedown", function (event)
            {
                this._$easeMode     = true;
                this._$easeTarget   = event.currentTarget;
                this._$deleteTarget = event.currentTarget;
                this._$pointX       = event.screenX;
                this._$pointY       = event.screenY;
            }.bind(this));

        if (type === "pointer") {

            div
                .addEventListener("dblclick", function (event)
                {

                    const layerElement = Util.$timeline._$targetLayer;
                    if (!layerElement) {
                        return ;
                    }

                    const layerId = layerElement.dataset.layerId | 0;

                    const layer = Util
                        .$currentWorkSpace()
                        .scene
                        .getLayer(layerId);

                    const character = layer.getActiveCharacter(
                        document.getElementById("current-frame").textContent | 0
                    )[0];

                    const tween  = character.getTween();
                    const index  = event.target.dataset.index | 0;
                    const custom = tween.custom[index];

                    custom.off = !custom.off;
                    tween.custom[index - 1].off = custom.off;
                    tween.custom[index + 1].off = custom.off;

                    const children = document
                        .getElementById("ease-cubic-pointer-area")
                        .children;

                    if (custom.off) {
                        children[index - 2].classList.add("ease-cubic-disable");
                        children[index - 1].classList.add("ease-cubic-disable");
                        children[index    ].classList.add("ease-cubic-disable");
                    } else {
                        children[index - 2].classList.remove("ease-cubic-disable");
                        children[index - 1].classList.remove("ease-cubic-disable");
                        children[index    ].classList.remove("ease-cubic-disable");
                    }

                    this.createEasingGraph();
                    Util.$screen.executeTween(layer);
                    Util.$screen.createTweenMarker();

                }.bind(this));
        }

        div.classList.add(`ease-cubic-${type}`);
        div.dataset.index = `${index}`;
        div.dataset.type  = `${type}`;

        const scale = Util.EASE_BASE_CANVAS_SIZE / Util.EASE_RANGE;
        div.style.left = `${Util.EASE_SCREEN_X + x * scale}px`;
        div.style.top  = `${Util.EASE_SCREEN_Y + (Util.EASE_RANGE - y) * scale}px`;

        return div;
    }

    /**
     * @return {void}
     * @public
     */
    createEasingGraph ()
    {
        const target    = Util.$timeline._$targetLayer;
        const layerId   = target.dataset.layerId | 0;
        const layer     = Util.$currentWorkSpace().scene.getLayer(layerId);
        const character = layer.getActiveCharacter(
            document.getElementById("current-frame").textContent | 0
        )[0];

        // init
        const tween = character.getTween();

        const ratio = window.devicePixelRatio;

        const offsetX = Util.EASE_OFFSET_X * ratio;
        const offsetY = Util.EASE_OFFSET_Y * ratio;

        const ctx = this._$drawEaseContext;
        ctx.fillStyle = "rgb(240, 240, 240)";

        const size = Util.EASE_BASE_CANVAS_SIZE * ratio;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.fillRect(offsetX, offsetY, size, size);

        ctx.lineCap = "round";
        ctx.translate(offsetX, offsetY);

        // base guide line
        ctx.beginPath();
        ctx.strokeStyle = "rgba(200, 200, 200, 0.6)";
        ctx.lineWidth   = 10;
        ctx.moveTo(0, 0);
        ctx.lineTo(size, size);
        ctx.stroke();

        const scale = Util.EASE_BASE_CANVAS_SIZE / Util.EASE_RANGE * ratio;
        for (let idx = 0; idx < tween.custom.length; idx += 3) {

            const startPointer = tween.custom[idx    ];
            const startCurve   = tween.custom[idx + 1];
            let endCurve       = tween.custom[idx + 2];
            let endPointer     = tween.custom[idx + 3];

            if (endPointer.off) {
                idx += 3;
                for (;;) {
                    endCurve   = tween.custom[idx + 2];
                    endPointer = tween.custom[idx + 3];
                    if (endPointer.fixed || !endPointer.off) {
                        break;
                    }
                    idx += 3;
                }
            }

            // start line
            ctx.beginPath();
            ctx.strokeStyle = "rgb(160, 160, 160)";
            ctx.lineWidth   = 3;
            ctx.moveTo(startPointer.x * scale, startPointer.y * scale);
            ctx.lineTo(startCurve.x * scale, startCurve.y * scale);
            ctx.stroke();

            // end line
            ctx.beginPath();
            ctx.strokeStyle = "rgb(160, 160, 160)";
            ctx.lineWidth   = 3;
            ctx.moveTo(endPointer.x * scale, endPointer.y * scale);
            ctx.lineTo(endCurve.x * scale, endCurve.y * scale);
            ctx.stroke();

            // bezier curve
            ctx.beginPath();
            ctx.strokeStyle = "rgb(80, 80, 80)";
            ctx.lineWidth   = 10;
            ctx.moveTo(startPointer.x * scale, startPointer.y * scale);
            ctx.bezierCurveTo(
                startCurve.x * scale, startCurve.y * scale,
                endCurve.x * scale, endCurve.y * scale,
                endPointer.x * scale, endPointer.y * scale
            );
            ctx.stroke();

            if (endPointer.fixed) {
                break;
            }
        }

        const viewContext = this._$viewEaseContext;

        // clear
        viewContext.setTransform(1, 0, 0, 1, 0, 0);
        viewContext.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        // 反転して出力
        viewContext.scale(1, -1);
        viewContext.translate(0, -ctx.canvas.height);
        viewContext.drawImage(ctx.canvas, 0, 0);
    }

    /**
     * @param  {number} $x1
     * @param  {number} $y1
     * @param  {number} $x2
     * @param  {number} $y2
     * @return {function}
     * @public
     */
    cubicBezier ($x1, $y1, $x2, $y2)
    {

        const cx = 3 * $x1,
            bx = 3 * ($x2 - $x1) - cx,
            ax = 1 - cx - bx;

        const cy = 3 * $y1,
            by = 3 * ($y2 - $y1) - cy,
            ay = 1 - cy - by;

        const bezierX = function ($t)
        {
            return $t * (cx + $t * (bx + $t * ax));
        };

        const bezierDX = function($t)
        {
            return cx + $t * (2 * bx + 3 * ax * $t);
        };

        const newtonRaphson = function($x)
        {
            if ($x <= 0) {
                return 0;
            }

            if ($x >= 1) {
                return 1;
            }

            let limit = 0;
            let prev = 0, t = $x;
            while (Math.abs(t - prev) > 1e-4) {

                prev = t;
                t = t - (bezierX(t) - $x) / bezierDX(t);

                limit++;
                if (limit > 1000) {
                    break;
                }
            }

            return t;
        };

        return function ($t)
        {
            const t = newtonRaphson($t);
            return t * (cy + t * (by + t * ay));
        };
    }

    /**
     * @param  {object} instance
     * @return {void}
     * @public
     */
    createInstanceSelect (instance)
    {
        const workSpace = Util.$currentWorkSpace();

        const element = document
            .getElementById("instance-type-name");

        while (element.children.length) {
            element.children[0].remove();
        }

        const i = document.createElement("i");
        i.setAttribute("class", `library-type-${instance.type}`);
        element.appendChild(i);

        const select = document.createElement("select");
        select.classList.add("instance-select");
        element.appendChild(select);

        select.addEventListener("mousedown", function (event)
        {

            this._$selectId = event.target.value | 0;

        }.bind(this));

        select.addEventListener("change", function (event)
        {

            const targets = Util.$screen._$moveTargets;
            if (targets.length !== 1) {
                return ;
            }

            const workSpace = Util.$currentWorkSpace();
            const scene     = workSpace.scene;

            const target = targets[0].target;

            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            // update
            character._$libraryId = event.target.value | 0;
            character._$image     = null;

            const frame = document
                .getElementById("current-frame")
                .textContent | 0;

            Util.$screen.clearTweenMarker();
            if (character._$tween
                && character.hasTween()
            ) {
                Util.$screen.executeTween(layer);
                Util.$screen.createTweenMarker(false);
            }

            scene.changeFrame(frame);

        }.bind(this));

        for (const value of workSpace._$libraries.values()) {

            if (!value.id) {
                continue;
            }

            switch (value.type) {

                case "folder":
                case "sound":
                    continue;

                default:
                    break;

            }

            const option     = document.createElement("option");
            option.value     = value.id;
            option.innerHTML = value.name;

            if (value.id === instance.id) {
                option.defaultSelected = true;
            }

            select.appendChild(option);
        }
    }

    /**
     * @param  {number} id
     * @param  {string} name
     * @return {void}
     * @public
     */
    addInstanceSelectOption (id, name)
    {
        const element = document
            .getElementById("instance-type-name");

        const select = element.getElementsByTagName("select")[0];
        if (select) {
            const option     = document.createElement("option");
            option.value     = `${id}`;
            option.innerHTML = name;
            select.appendChild(option);
        }
    }

    /**
     * @param  {number} id
     * @return {void}
     * @public
     */
    deleteInstanceSelectOption (id)
    {
        const element = document
            .getElementById("instance-type-name");

        const select = element.getElementsByTagName("select")[0];
        if (select) {
            const children = select.children;
            for (let idx = 0; idx < children.length; ++idx) {

                const option = children[idx];

                const optionId = option.value | 0;
                if  (optionId !== id) {
                    continue;
                }

                option.remove();
                break;

            }
        }

    }

    /**
     * @return {void}
     * @public
     */
    initializeTextSetting ()
    {
        document
            .getElementById("text-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("text-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            });

        document
            .getElementById("font-select")
            .addEventListener("change", function (event)
            {
                Util.$screen.updateText({
                    "name": "font",
                    "value": event.target.value
                });
            });

        document
            .getElementById("font-style-select")
            .addEventListener("change", function (event)
            {
                Util.$screen.updateText({
                    "name": "fontType",
                    "value": event.target.value
                });
            });

        document
            .getElementById("font-align-select")
            .addEventListener("change", function (event)
            {
                Util.$screen.updateText({
                    "name": "align",
                    "value": event.target.value
                });
            });

        document
            .getElementById("font-wrap-select")
            .addEventListener("change", function (event)
            {
                const value = event.target.value | 0;
                switch (value) {

                    case 0:
                        Util.$screen.updateText({
                            "name": "wordWrap",
                            "value": false
                        });
                        Util.$screen.updateText({
                            "name": "multiline",
                            "value": false
                        });
                        break;

                    case 1:
                        Util.$screen.updateText({
                            "name": "wordWrap",
                            "value": false
                        });
                        Util.$screen.updateText({
                            "name": "multiline",
                            "value": true
                        });
                        break;

                    case 2:
                        Util.$screen.updateText({
                            "name": "wordWrap",
                            "value": true
                        });
                        Util.$screen.updateText({
                            "name": "multiline",
                            "value": true
                        });
                        break;
                }

            });

        document
            .getElementById("font-input-select")
            .addEventListener("change", function (event)
            {
                const value = event.target.value | 0;
                switch (value) {

                    case 0:
                        Util.$screen.updateText({
                            "name": "inputType",
                            "value": "static"
                        });
                        break;

                    case 1:
                        Util.$screen.updateText({
                            "name": "inputType",
                            "value": "input"
                        });
                        break;

                }

            });

        document
            .getElementById("font-scroll-select")
            .addEventListener("change", function (event)
            {
                const value = event.target.value | 0;
                switch (value) {

                    case 0:
                        Util.$screen.updateText({
                            "name": "scroll",
                            "value": false
                        });
                        break;

                    case 1:
                        Util.$screen.updateText({
                            "name": "scroll",
                            "value": true
                        });
                        break;

                }

            });

        document
            .getElementById("font-border-select")
            .addEventListener("change", function (event)
            {
                const value = event.target.value | 0;
                switch (value) {

                    case 0:
                        Util.$screen.updateText({
                            "name": "border",
                            "value": event.target.value | 0
                        });
                        break;

                    case 1:
                        Util.$screen.updateText({
                            "name": "border",
                            "value": true
                        });
                        break;

                }

            });

        document
            .getElementById("font-auto-size-select")
            .addEventListener("change", function (event)
            {
                Util.$screen.updateText({
                    "name": "autoSize",
                    "value": event.target.value | 0
                });
            });

        const fontSize = document.getElementById("font-size");

        fontSize.addEventListener("mouseover", this.mouseOver.bind(this));
        fontSize.addEventListener("mouseout",  this.mouseOut.bind(this));
        fontSize.addEventListener("mousedown", this.mouseDown.bind(this));
        fontSize.addEventListener("focusin", function (event)
        {
            this._$focus        = true;
            this._$currentValue = +event.target.value;
            Util.$keyLock       = true;
        }.bind(this));

        fontSize.addEventListener("focusout", this.objectFontSizeOut.bind(this));
        fontSize.addEventListener("keypress", this.objectFontSizeOut.bind(this));

        document
            .getElementById("font-color")
            .addEventListener("change", function (event)
            {
                this.updateProperty(event.target);
            }.bind(this));

        const fontStrokeSize = document.getElementById("font-stroke-size");

        fontStrokeSize.addEventListener("mouseover", this.mouseOver.bind(this));
        fontStrokeSize.addEventListener("mouseout",  this.mouseOut.bind(this));
        fontStrokeSize.addEventListener("mousedown", this.mouseDown.bind(this));
        fontStrokeSize.addEventListener("focusin", function (event)
        {
            this._$focus        = true;
            this._$currentValue = +event.target.value;
            Util.$keyLock       = true;
        }.bind(this));

        fontStrokeSize.addEventListener("focusout", this.objectFontStrokeSizeOut.bind(this));
        fontStrokeSize.addEventListener("keypress", this.objectFontStrokeSizeOut.bind(this));

        document
            .getElementById("font-stroke-color")
            .addEventListener("change", function (event)
            {
                this.updateProperty(event.target);
            }.bind(this));

        const params = [
            "font-leading",
            "font-letterSpacing",
            "font-leftMargin",
            "font-rightMargin"
        ];

        const focusInEvent = function (event)
        {
            this._$focus        = true;
            this._$currentValue = +event.target.value;
            Util.$keyLock       = true;
        }.bind(this);

        for (let idx = 0; idx < params.length; ++idx) {

            const name = params[idx];

            const element = document.getElementById(name);

            element.addEventListener("mouseover", this.mouseOver.bind(this));
            element.addEventListener("mouseout",  this.mouseOut.bind(this));
            element.addEventListener("mousedown", this.mouseDown.bind(this));
            element.addEventListener("focusin",   focusInEvent);
            element.addEventListener("focusout",  this.objectFontParamOut.bind(this));
            element.addEventListener("keypress",  this.objectFontParamOut.bind(this));

        }
    }

    /**
     * @return {void}
     * @public
     */
    disposeCharacterImage ()
    {
        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const target  = Util.$screen._$moveTargets[0].target;
        const layerId = target.dataset.layerId | 0;

        const scene   = Util.$currentWorkSpace().scene;
        const layer   = scene.getLayer(layerId);

        const characterId = target.dataset.characterId | 0;
        const character   = layer.getCharacter(characterId);
        character._$image = null;

        if (document
            .getElementById(`${layerId}-${frame}`)
            .classList
            .contains("tween-frame")
        ) {
            Util.$screen.executeTween(layer);
            Util.$screen.createTweenMarker();
        }

        scene.changeFrame(frame);
    }

    /**
     * @return {void}
     * @public
     */
    clearFilters ()
    {
        this._$filterId = 0;
        this._$filters.clear();

        const element = document
            .getElementById("filter-setting-list");

        const textElement = document
            .querySelectorAll(".filter-none")[0];

        while (element.children.length) {
            element.children[0].remove();
        }

        textElement.style.display = "";

        element.appendChild(textElement);
    }

    /**
     * @param  {HTMLInputElement} target
     * @return {void}
     * @public
     */
    updateFilterBlur (target)
    {
        const filterId = target.dataset.filterId | 0;
        if (this._$filters.has(filterId)) {

            const object = this._$filters.get(filterId);

            const value = Util.$clamp(
                +target.value,
                Util.MIN_BLUR,
                Util.MAX_BLUR
            );

            object.filter[target.dataset.name] = value;
            target.value = value;

            this.disposeCharacterImage();
        }
    }

    /**
     * @param  {HTMLInputElement} target
     * @return {void}
     * @public
     */
    updateFilterAlpha (target)
    {
        const filterId = target.dataset.filterId | 0;
        if (this._$filters.has(filterId)) {

            target.value = Util.$clamp(
                +target.value,
                Util.COLOR_MIN_MULTIPLIER,
                Util.COLOR_MAX_MULTIPLIER
            );

            const object = this._$filters.get(filterId);
            object.filter[target.dataset.name] = +target.value;

            this.disposeCharacterImage();
        }
    }

    /**
     * @param  {HTMLInputElement} target
     * @return {void}
     * @public
     */
    updateFilterGradientAlpha (target)
    {
        if (!this._$fildterGradientTarget) {
            return ;
        }

        const index = this._$filterGradientTarget.dataset.index | 0;
        if (!index) {
            target.value = "0";
            return ;
        }

        const filterId = this._$filterGradientTarget.dataset.filterId | 0;
        if (this._$filters.has(filterId)) {

            target.value = Util.$clamp(
                +target.value,
                Util.COLOR_MIN_MULTIPLIER,
                Util.COLOR_MAX_MULTIPLIER
            );

            const filter = this._$filters.get(filterId).filter;
            filter._$alphas[index] = +target.value;

            this.disposeCharacterImage();
            this.updateFilterGradientCanvas(filterId, filter);
        }
    }

    /**
     * @param  {HTMLInputElement} target
     * @return {void}
     * @public
     */
    updateFilterStrength (target)
    {
        const filterId = target.dataset.filterId | 0;
        if (this._$filters.has(filterId)) {

            target.value = Util.$clamp(
                +target.value,
                Util.MIN_STRENGTH,
                Util.MAX_STRENGTH
            );

            const object = this._$filters.get(filterId);
            object.filter.strength = +target.value;

            this.disposeCharacterImage();
        }
    }

    /**
     * @param  {HTMLInputElement} target
     * @return {void}
     * @public
     */
    updateFilterAngle (target)
    {
        const filterId = target.dataset.filterId | 0;
        if (this._$filters.has(filterId)) {

            let value = Util.$clamp(
                (target.value | 0) % 360,
                Util.MIN_ROTATE,
                Util.MAX_ROTATE
            );

            if (0 > value) {
                value += 360;
            }

            const object = this._$filters.get(filterId);
            object.filter.angle = value;
            target.value = `${value}`;

            this.disposeCharacterImage();
        }
    }

    /**
     * @param  {HTMLInputElement} target
     * @return {void}
     * @public
     */
    updateFilterDistance (target)
    {
        const filterId = target.dataset.filterId | 0;
        if (this._$filters.has(filterId)) {

            target.value = Util.$clamp(
                +target.value,
                Util.MIN_DISTANCE,
                Util.MAX_DISTANCE
            );

            const object = this._$filters.get(filterId);
            object.filter.distance = +target.value;

            this.disposeCharacterImage();
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    blurDownEvent (event)
    {
        const data = event.target.dataset;
        if (!this._$focus && this[`_$filter-${data.filterId}-lock`]) {

            const name = data.name === "blurX"
                ? "blurY"
                : "blurX";

            this._$lockTarget = document
                .getElementById(`${name}-${data.filterId}`);

            this._$currentValue = +event.target.value;
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    blurFocusInEvent (event)
    {
        const target        = event.target;
        this._$currentValue = +target.value;
        this._$focus        = true;
        this._$lockTarget   = null;
        Util.$keyLock       = true;

        if (this[`_$filter-${target.dataset.filterId}-lock`]) {

            const name = target.dataset.name === "blurX"
                ? "blurY"
                : "blurX";

            this._$lockTarget = document
                .getElementById(`${name}-${target.dataset.filterId}`);

        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    blurFocusOutEvent (event)
    {
        this.updateFilterBlur(event.target);

        if (this._$lockTarget && this._$currentValue !== null) {

            const diff = +event.target.value - this._$currentValue;

            const currentValue      = +this._$lockTarget.value;
            this._$lockTarget.value = currentValue + diff;

            this.updateProperty(this._$lockTarget, diff);
        }

        Util.$keyLock       = false;
        this._$focus        = false;
        this._$lockTarget   = null;
        this._$currentValue = null;
    }

    /**
     * @param  {number} id
     * @param  {number} quality
     * @return {void}
     * @public
     */
    commonFilterEvent (id, quality = 1)
    {
        const blurParams = [
            `blurX-${id}`,
            `blurY-${id}`
        ];

        if (!this._$blurDownEvent) {
            this._$blurDownEvent = this.blurDownEvent.bind(this);
        }
        if (!this._$blurFocusInEvent) {
            this._$blurFocusInEvent = this.blurFocusInEvent.bind(this);
        }
        if (!this._$blurFocusOutEvent) {
            this._$blurFocusOutEvent = this.blurFocusOutEvent.bind(this);
        }

        for (let idx = 0; idx < blurParams.length; ++idx) {

            const blur = document.getElementById(blurParams[idx]);

            blur.addEventListener("mouseover", this.mouseOver.bind(this));
            blur.addEventListener("mouseout",  this.mouseOut.bind(this));
            blur.addEventListener("mousedown", this.mouseDown.bind(this));
            blur.addEventListener("mousedown", this._$blurDownEvent);
            blur.addEventListener("focusin",   this._$blurFocusInEvent);
            blur.addEventListener("focusout",  this._$blurFocusOutEvent);
            blur.addEventListener("keypress", function (event)
            {
                if (event.code === "Enter") {
                    event.target.blur();
                }
            });

        }

        // quality
        const qualityElement = document.getElementById(`quality-${id}`);

        qualityElement.addEventListener("change", function (event)
        {
            const target = event.target;

            const filterId = target.dataset.filterId | 0;
            const object = this._$filters.get(filterId);
            object.filter.quality = +target.value;

            this.disposeCharacterImage();

        }.bind(this));

        const children = qualityElement.children;
        for (let idx = 0; idx < children.length; ++idx) {

            const option = children[idx];

            if (+option.value !== quality) {
                continue;
            }

            option.selected = true;
            break;
        }

        // lock
        document
            .getElementById(`filter-${id}-lock`)
            .addEventListener("mousedown", function (event)
            {
                const filterId = event.currentTarget.dataset.filterId;

                this[`_$filter-${filterId}-lock`] = !this[`_$filter-${filterId}-lock`];
                this._$currentValue = null;

                const element = document
                    .getElementById(`filter-${filterId}-lock`)
                    .childNodes[1];

                element
                    .setAttribute("class", this[`_$filter-${filterId}-lock`]
                        ? "active"
                        : "disable"
                    );

            }.bind(this));

        // view
        document
            .getElementById(`filter-name-${id}`)
            .addEventListener("mousedown", function (event)
            {
                const filterId = event.target.dataset.filterId;

                const element = document
                    .getElementById(`filter-view-area-${filterId}`);

                if (element.style.display === "none") {

                    element.style.display = "";
                    document
                        .getElementById(`filter-title-arrow-${filterId}`)
                        .setAttribute("class", "arrow active");

                } else {

                    element.style.display = "none";
                    document
                        .getElementById(`filter-title-arrow-${filterId}`)
                        .setAttribute("class", "arrow disable");

                }

            }.bind(this));

        // filter state
        document
            .getElementById(`filter-state-${id}`)
            .addEventListener("mousedown", function (event)
            {
                const filterId = event.target.dataset.filterId | 0;

                const object = this._$filters.get(filterId);

                object.filter.state = !object.filter.state;

                document
                    .getElementById(`filter-state-${filterId}`)
                    .setAttribute("class",object.filter.state
                        ? "filter-active"
                        : "filter-disable"
                    );

                this.disposeCharacterImage();

            }.bind(this));

        document
            .getElementById(`filter-state-${id}`)
            .setAttribute("class",this._$filters.get(id).filter.state
                ? "filter-active"
                : "filter-disable"
            );

        // trash
        document
            .getElementById(`trash-${id}`)
            .addEventListener("click", function (event)
            {
                const filterId = event.target.dataset.filterId | 0;

                const target  = Util.$screen._$moveTargets[0].target;
                const layerId = target.dataset.layerId | 0;

                const workSpace = Util.$currentWorkSpace();
                const scene   = workSpace.scene;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                const place  = character.getPlace(frame);
                const object = this._$filters.get(filterId);
                const index  = place.filter.indexOf(object.filter);

                if (document
                    .getElementById(`${layerId}-${frame}`)
                    .classList
                    .contains("tween-frame")
                ) {

                    let startFrame = frame;
                    while (startFrame > 1) {

                        const element = document
                            .getElementById(`${layerId}-${startFrame}`);

                        if (element.classList.contains("key-frame")) {
                            break;
                        }

                        --startFrame;
                    }

                    let endFrame = frame;
                    for (;;) {

                        ++endFrame;

                        const element = document
                            .getElementById(`${layerId}-${endFrame}`);

                        if (!element.classList.contains("tween-frame")) {
                            break;
                        }
                    }

                    for (let frame = startFrame; frame < endFrame; ++frame) {
                        const place = character.getPlace(frame);
                        place.filter.splice(index, 1);
                    }

                } else {

                    place.filter.splice(index, 1);

                }

                // remove
                this._$filters.delete(filterId);
                if (!this._$filters.size) {
                    document
                        .querySelectorAll(".filter-none")[0]
                        .style.display = "";
                }

                document
                    .getElementById(`filter-id-${filterId}`)
                    .remove();

                this._$focus        = false;
                this._$lockTarget   = null;
                this._$currentValue = null;

                character._$image = null;
                scene.changeFrame(frame);

            }.bind(this));
    }

    /**
     * @param  {uint} id
     * @param  {string} name
     * @return {void}
     * @public
     */
    createAlphaEvent (id, name)
    {
        // strength
        const element = document.getElementById(`${name}-${id}`);

        element.addEventListener("mouseover", this.mouseOver.bind(this));
        element.addEventListener("mouseout",  this.mouseOut.bind(this));
        element.addEventListener("mousedown", this.mouseDown.bind(this));
        element.addEventListener("focusin", function ()
        {
            Util.$keyLock       = true;
            this._$focus        = true;
            this._$currentValue = null;
            this._$lockTarget   = null;
        }.bind(this));

        element.addEventListener("focusout", function (event)
        {
            this.updateFilterAlpha(event.target);
            this._$focus        = false;
            this._$currentValue = null;
            this._$lockTarget   = null;
            Util.$keyLock       = false;
        }.bind(this));

        element.addEventListener("keypress", function (event)
        {
            if (event.code === "Enter") {
                event.target.blur();
            }
        });
    }

    /**
     * @param  {uint} id
     * @return {void}
     * @public
     */
    createStrengthEvent (id)
    {
        // strength
        const element = document.getElementById(`strength-${id}`);

        element.addEventListener("mouseover", this.mouseOver.bind(this));
        element.addEventListener("mouseout",  this.mouseOut.bind(this));
        element.addEventListener("mousedown", this.mouseDown.bind(this));
        element.addEventListener("focusin", function ()
        {
            Util.$keyLock       = true;
            this._$focus        = true;
            this._$currentValue = null;
            this._$lockTarget   = null;
        }.bind(this));

        element.addEventListener("focusout", function (event)
        {
            this.updateFilterStrength(event.target);
            Util.$keyLock       = false;
            this._$focus        = false;
            this._$currentValue = null;
            this._$lockTarget   = null;

        }.bind(this));

        element.addEventListener("keypress", function (event)
        {
            if (event.code === "Enter") {
                event.target.blur();
            }
        });
    }

    /**
     * @param  {uint} id
     * @return {void}
     * @public
     */
    createAngleEvent (id)
    {
        const element = document.getElementById(`angle-${id}`);

        element.addEventListener("mouseover", this.mouseOver.bind(this));
        element.addEventListener("mouseout",  this.mouseOut.bind(this));
        element.addEventListener("mousedown", this.mouseDown.bind(this));
        element.addEventListener("focusin", function ()
        {
            Util.$keyLock       = true;
            this._$focus        = true;
            this._$currentValue = null;
            this._$lockTarget   = null;
        }.bind(this));

        element.addEventListener("focusout", function (event)
        {
            this.updateFilterAngle(event.target);
            Util.$keyLock       = false;
            this._$focus        = false;
            this._$currentValue = null;
            this._$lockTarget   = null;

        }.bind(this));

        element.addEventListener("keypress", function (event)
        {
            if (event.code === "Enter") {
                event.target.blur();
            }
        });
    }

    /**
     * @param  {uint} id
     * @return {void}
     * @public
     */
    createDistanceEvent (id)
    {
        const element = document.getElementById(`distance-${id}`);

        element.addEventListener("mouseover", this.mouseOver.bind(this));
        element.addEventListener("mouseout",  this.mouseOut.bind(this));
        element.addEventListener("mousedown", this.mouseDown.bind(this));
        element.addEventListener("focusin", function ()
        {
            Util.$keyLock       = true;
            this._$focus        = true;
            this._$currentValue = null;
            this._$lockTarget   = null;
        }.bind(this));

        element.addEventListener("focusout", function (event)
        {
            this.updateFilterDistance(event.target);
            Util.$keyLock       = false;
            this._$focus        = false;
            this._$currentValue = null;
            this._$lockTarget   = null;

        }.bind(this));

        element.addEventListener("keypress", function (event)
        {
            if (event.code === "Enter") {
                event.target.blur();
            }
        });
    }

    /**
     * @param  {uint} id
     * @param  {string} name
     * @return {void}
     * @public
     */
    createColorEvent (id, name)
    {
        document
            .getElementById(`${name}-${id}`)
            .addEventListener("change", function (event)
            {
                const target = event.target;

                const filterId = target.dataset.filterId | 0;
                const object = this._$filters.get(filterId);
                object.filter[target.dataset.name] = `0x${target.value.substr(1)}` | 0;

                this._$focus        = false;
                this._$currentValue = null;
                this._$lockTarget   = null;

                this.disposeCharacterImage();

            }.bind(this));
    }

    /**
     * @param  {uint} id
     * @param  {string} name
     * @return {void}
     * @public
     */
    createCheckBoxEvent (id, name)
    {
        const element = document.getElementById(`${name}-${id}`);

        element.addEventListener("click", function (event)
        {
            const target = event.target;

            const filterId = target.dataset.filterId | 0;
            const object = this._$filters.get(filterId);
            object.filter[target.dataset.name] = target.checked;

            this.disposeCharacterImage();

        }.bind(this));

    }

    /**
     * @param  {uint} id
     * @param  {string} value
     * @return {void}
     * @public
     */
    createTypeEvent (id, value)
    {
        const element = document.getElementById(`type-${id}`);

        element.addEventListener("change", function (event)
        {
            const target = event.target;

            const filterId = target.dataset.filterId | 0;
            const object = this._$filters.get(filterId);
            object.filter.type = target.value;

            this.disposeCharacterImage();

        }.bind(this));

        const children = element.children;
        for (let idx = 0; idx < children.length; ++idx) {

            const option = children[idx];

            if (option.value !== value) {
                continue;
            }

            option.selected = true;
            break;
        }
    }

    /**
     * @param  {number} id
     * @param  {array}  ratios
     * @param  {array}  colors
     * @param  {array}  alphas
     * @return {void}
     * @public
     */
    createGradientColorPointerEvent (id, ratios, colors, alphas)
    {
        const element = document
            .getElementById(`color-pointer-list-${id}`);

        for (let idx = 0; idx < ratios.length; ++idx) {

            const ratio = ratios[idx];
            const color = `#${colors[idx].toString(16).padStart(6, "0")}`;
            const alpha = alphas[idx];

            this.addFilterGradientColorPointer(id, idx, ratio, color, alpha);

        }

        element.addEventListener("mousedown", function (event)
        {
            if (this._$filterGradientPointer) {
                return ;
            }

            const filterId = event.target.dataset.filterId | 0;
            const filter   = this._$filters.get(filterId).filter;

            this._$filterGradientTarget = null;

            const index = filter.ratios.length;
            const ratio = event.offsetX;
            const color = document.getElementById(`color-${filterId}`).value;
            const alpha = document.getElementById(`alpha-${filterId}`).value | 0;

            filter.ratios.push(ratio);
            filter.colors.push(`0x${color.substr(1)}` | 0);
            filter.alphas.push(alpha);

            this.addFilterGradientColorPointer(
                filterId, index, ratio, color, alpha
            );

            this._$filterGradientTarget = element.lastElementChild;

            this.updateFilterGradientCanvas(filterId, filter);
            this.disposeCharacterImage();

        }.bind(this));

    }

    /**
     * @param  {number} id
     * @return {void}
     * @public
     */
    createGradientColorEvent (id)
    {
        document
            .getElementById(`color-${id}`)
            .addEventListener("change", function (event)
            {
                const target = event.target;
                if (this._$filterGradientTarget) {

                    const pointerColor = this
                        ._$filterGradientTarget
                        .getElementsByTagName("i")[0];

                    this._$filterGradientTarget.dataset.color = target.value;
                    pointerColor.style.backgroundColor  = target.value;

                    const filterId = this._$filterGradientTarget.dataset.filterId | 0;
                    const filter   = this._$filters.get(filterId).filter;

                    const index = this._$filterGradientTarget.dataset.index | 0;
                    filter._$colors[index] = `0x${target.value.substr(1)}` | 0;

                    this.disposeCharacterImage();
                    this.updateFilterGradientCanvas(filterId, filter);
                }

            }.bind(this));
    }

    /**
     * @param  {number} id
     * @return {void}
     * @public
     */
    createGradientAlphaEvent (id)
    {
        // strength
        const element = document.getElementById(`alpha-${id}`);

        element.addEventListener("mouseover", this.mouseOver.bind(this));
        element.addEventListener("mouseout",  this.mouseOut.bind(this));
        element.addEventListener("mousedown", this.mouseDown.bind(this));
        element.addEventListener("focusin", function ()
        {
            Util.$keyLock       = true;
            this._$focus        = true;
            this._$currentValue = null;
            this._$lockTarget   = null;
        }.bind(this));

        element.addEventListener("focusout", function (event)
        {
            this.updateFilterGradientAlpha(event.target);
            this._$focus        = false;
            this._$currentValue = null;
            this._$lockTarget   = null;
            Util.$keyLock       = false;
        }.bind(this));

        element.addEventListener("keypress", function (event)
        {
            if (event.code === "Enter") {
                event.target.blur();
            }
        });
    }

    /**
     * @param  {number} index
     * @param  {number} ratio
     * @param  {string} color
     * @param  {number} alpha
     * @return {void}
     * @public
     */
    addGradientColorPointer (index, ratio, color, alpha)
    {
        const element = document
            .getElementById("color-pointer-list");

        const htmlTag = `
<div class="color-pointer" style="left: ${ratio - 4}px;" data-index="${index}" data-color="${color}" data-alpha="${alpha}">
    <div class="color-pointer-triangle"></div>
    <div class="color-pointer-rect">
        <i class="pointer-color" style="background-color: ${color}"></i>
    </div>
</div>
`;

        element.insertAdjacentHTML("beforeend", htmlTag);

        const pointer = element.lastElementChild;

        pointer.addEventListener("mousedown", function (event)
        {
            const target = event.target;

            document
                .getElementById("fill-color-value")
                .value = target.dataset.color;

            document
                .getElementById("fill-alpha-value")
                .value = target.dataset.alpha;

            this._$pointX          = event.screenX;
            this._$gradientTarget  = target;
            this._$gradientPointer = target;

        }.bind(this));

        pointer.addEventListener("dblclick", function (event)
        {

            const element = document
                .getElementById("color-pointer-list");

            if (element.children.length > 2 && Util.$hitColor) {

                const index  = event.target.dataset.index | 0;

                Util.$hitColor.ratios.splice(index, 1);

                // remove
                event.target.remove();

                // adj
                for (let idx = index; idx < element.children.length; ++idx) {

                    const child = element.children[idx];
                    const index = (child.dataset.index | 0) - 1;

                    child.dataset.index = `${index}`;
                }

                // reset
                this._$gradientPointer = null;
                this._$gradientTarget  = null;
                Util.$hitColor.shape.cacheClear();

                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                Util.$currentWorkSpace().scene.changeFrame(frame);

                this.updateGradientCanvas();
            }

        }.bind(this));

        this._$gradientTarget = pointer;
    }

    /**
     * @param  {number} id
     * @param  {number} index
     * @param  {number} ratio
     * @param  {string} color
     * @param  {number} alpha
     * @return {void}
     * @public
     */
    addFilterGradientColorPointer (id, index, ratio, color, alpha)
    {
        const element = document
            .getElementById(`color-pointer-list-${id}`);

        const htmlTag = `
<div class="color-pointer" style="left: ${ratio - 4}px;" data-filter-id="${id}" data-index="${index}" data-color="${color}" data-alpha="${alpha}">
    <div class="color-pointer-triangle"></div>
    <div class="color-pointer-rect">
        <i class="pointer-color" style="background-color: ${color}"></i>
    </div>
</div>
`;

        element.insertAdjacentHTML("beforeend", htmlTag);

        const pointer = element.lastElementChild;

        pointer.addEventListener("mousedown", function (event)
        {
            const target   = event.target;
            const filterId = target.dataset.filterId;

            document
                .getElementById(`color-${filterId}`)
                .value = target.dataset.color;

            document
                .getElementById(`alpha-${filterId}`)
                .value = target.dataset.alpha;

            this._$pointX                = event.screenX;
            this._$filterGradientTarget  = target;
            this._$filterGradientPointer = target;

        }.bind(this));

        if (index) {

            pointer.addEventListener("dblclick", function (event)
            {

                const filterId = event.target.dataset.filterId | 0;

                const element = document
                    .getElementById(`color-pointer-list-${filterId}`);

                if (element.children.length > 2) {

                    const index  = event.target.dataset.index | 0;
                    const filter = this._$filters.get(filterId).filter;

                    filter.ratios.splice(index, 1);
                    filter.colors.splice(index, 1);
                    filter.alphas.splice(index, 1);

                    // remove
                    event.target.remove();

                    // adj
                    for (let idx = index; idx < element.children.length; ++idx) {

                        const child = element.children[idx];
                        const index = (child.dataset.index | 0) - 1;

                        child.dataset.index = `${index}`;
                    }

                    // reset
                    this._$filterGradientPointer = null;
                    this._$filterGradientTarget  = null;

                    this.disposeCharacterImage();
                    this.updateFilterGradientCanvas(filterId, filter);
                }

            }.bind(this));
        }
    }

    /**
     * @return {void}
     * @public
     */
    updateGradientCanvas ()
    {
        const drawContext = this._$drawGradientContext;

        // clear
        drawContext.clearRect(0, 0,
            Util.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            Util.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );

        drawContext.beginPath();

        const ratios = Util.$hitColor.ratios;

        const length = ratios.length;
        const x1 = Math.ceil(ratios[length - 1].ratio * 255 * window.devicePixelRatio);

        const gradient = drawContext.createLinearGradient(0, 0, x1, 0);
        for (let idx = 0; idx < length; ++idx) {

            const object = ratios[idx];

            gradient.addColorStop(
                object.ratio,
                `rgba(${object.R}, ${object.G}, ${object.B}, ${object.A / 255})`
            );

        }

        drawContext.fillStyle = gradient;
        drawContext.rect(0, 0,
            Util.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            Util.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );

        drawContext.fill();

        const viewContext = this._$viewGradientContext;
        viewContext.clearRect(0, 0,
            Util.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            Util.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );
        viewContext.drawImage(drawContext.canvas, 0, 0);
    }

    /**
     * @param  {number} id
     * @param  {GradientBevelFilter|GradientGlowFilter} filter
     * @return {void}
     * @public
     */
    updateFilterGradientCanvas (id, filter)
    {
        const drawContext = this._$drawGradientContext;

        // clear
        drawContext.clearRect(0, 0,
            Util.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            Util.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );

        const object = filter.adjustment();

        drawContext.beginPath();

        const length = object.ratios.length;
        const x1 = Math.ceil(object.ratios[length - 1] * 255 * window.devicePixelRatio);
        const gradient = drawContext.createLinearGradient(0, 0, x1, 0);

        for (let idx = 0; idx < length; ++idx) {
            const obj = Util.$intToRGB(object.colors[idx]);
            gradient.addColorStop(
                object.ratios[idx],
                `rgba(${obj.R}, ${obj.G}, ${obj.B}, ${object.alphas[idx]})`
            );
        }

        drawContext.fillStyle = gradient;
        drawContext.rect(0, 0,
            Util.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            Util.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );

        drawContext.fill();

        const viewContext = this[`_$filter-${id}-context`];
        viewContext.clearRect(0, 0,
            Util.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            Util.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );
        viewContext.drawImage(drawContext.canvas, 0, 0);
    }

    /**
     * @param  {number} id
     * @param  {string} name
     * @return {string}
     * @public
     */
    getFilterHeaderHTML (id, name)
    {
        return `
<div id="filter-id-${id}" class="filter-border">

    <div class="filter-title">
        <i id="filter-title-arrow-${id}" class="arrow active"></i>
        <span id="filter-name-${id}" data-filter-id="${id}">${name}</span>
        <i class="filter-active" id="filter-state-${id}" data-filter-id="${id}" data-detail="{{フィルターを表示・非表示する}}"></i>
        <i class="trash" id="trash-${id}" data-filter-id="${id}" data-detail="{{フィルターを削除}}"></i>
    </div>
    
    <div id="filter-view-area-${id}" class="filter-view-area">
    
        <div class="filter-view-area-left">
        
            <div id="filter-${id}-lock" data-filter-id="${id}" class="filter-lock">
                ┌
                <div class="disable" data-detail="{{比率を固定}}"></div>
                └
            </div>
        
        </div>
`;
    }

    /**
     * @param  {function} filterClass
     * @param  {DropShadowFilter|BlurFilter|GlowFilter|BevelFilter|GradientGlowFilter|GradientBevelFilter} [filter=null]
     * @return {number}
     */
    createFilter (filterClass, filter = null)
    {
        const id = this._$filterId++;

        if (!filter) {

            filter = new filterClass();

            const target  = Util.$screen._$moveTargets[0].target;
            const layerId = target.dataset.layerId | 0;

            const scene  = Util.$currentWorkSpace().scene;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            const frame = document
                .getElementById("current-frame")
                .textContent | 0;

            const place = character.getPlace(frame);
            place.filter.push(filter);

            if (document
                .getElementById(`${layerId}-${frame}`)
                .classList
                .contains("tween-frame")
            ) {

                let startFrame = frame;
                while (startFrame > 1) {

                    const element = document
                        .getElementById(`${layerId}-${startFrame}`);

                    if (element.classList.contains("key-frame")) {
                        break;
                    }

                    --startFrame;
                }

                let endFrame = frame;
                for (;;) {

                    ++endFrame;

                    const element = document
                        .getElementById(`${layerId}-${endFrame}`);

                    if (!element.classList.contains("tween-frame")) {
                        break;
                    }
                }

                for (let frame = startFrame; frame < endFrame; ++frame) {

                    const place = character.getPlace(frame);
                    if (place.filter.indexOf(filter) > -1) {
                        continue;
                    }

                    place.filter.push(new filterClass());

                }
            }
        }

        // setup
        this._$filters.set(id, {
            "id": id,
            "filter": filter
        });

        return id;
    }

    /**
     * @param  {HTMLDivElement} element
     * @param  {DropShadowFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @public
     */
    addDropShadowFilter (element, filter = null, reload = true)
    {

        const id = this.createFilter(DropShadowFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = this.getFilterHeaderHTML(id, "DropShadow") + `

        <div class="filter-view-area-right">
        
            <div class="filter-container">
                <div class="filter-text">BlurX</div>
                <div><input type="text" id="blurX-${id}" value="${filter.blurX}" data-name="blurX" data-filter-id="${id}" data-detail="{{水平方向にぼかす}}"></div>
                
                <div class="filter-text">Strength</div>
                <div><input type="text" id="strength-${id}" value="${filter.strength}" data-filter-id="${id}" data-name="strength" data-detail="{{フィルター強度}}"></div>
            </div>
    
            <div class="filter-container">
                <div class="filter-text">BlurY</div>
                <div><input type="text" id="blurY-${id}" value="${filter.blurY}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
                
                <div class="filter-text">Angle</div>
                <div><input type="text" id="angle-${id}" value="${filter.angle}" data-filter-id="${id}" data-name="angle" data-detail="{{フィルター角度}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">Distance</div>
                <div><input type="text" id="distance-${id}" value="${filter.distance}" data-filter-id="${id}" data-name="distance" data-detail="{{フィルター距離}}"></div>
            </div>
    
            <div class="filter-container">
                <div class="filter-text">Shadow</div>
                <div><input type="color" id="color-${id}" value="#${filter.color.toString(16).padStart(6, "0")}" data-filter-id="${id}" data-name="color" data-detail="[[シャドウのカラー]]"></div>
                
                <div class="filter-text">Alpha</div>
                <div><input type="text" id="alpha-${id}" value="${filter.alpha}" data-filter-id="${id}" data-name="alpha" data-detail="{{シャドウのアルファ}}"></div>
            </div>
            
            <div class="filter-container">
                <div><input type="checkbox" id="knockout-${id}" data-name="knockout" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="knockout-${id}">Knockout</label>
                </div>
            </div>

            <div class="filter-container">
                <div><input type="checkbox" id="inner-${id}" data-name="inner" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="inner-${id}">Inner Shadow</label>
                </div>
            </div>
    
            <div class="filter-container">
                <div><input type="checkbox" id="hideObject-${id}" data-name="hideObject" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="hideObject-${id}">Hide Object</label>
                </div>
            </div>

            <div class="filter-container">
                <div class="filter-text-long">Quality</div>
                <div>
                    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
                        <option value="1">Low</option>
                        <option value="2">Middle</option>
                        <option value="3">High</option>
                    </select>
                </div>
            </div> 
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        if (filter.knockout) {
            document.getElementById(`knockout-${id}`).checked = true;
        }
        if (filter.inner) {
            document.getElementById(`inner-${id}`).checked = true;
        }
        if (filter.hideObject) {
            document.getElementById(`hideObject-${id}`).checked = true;
        }

        // add params
        this[`_$filter-${id}-lock`] = false;

        // add event
        this.commonFilterEvent(id, filter.quality);
        this.createAlphaEvent(id, "alpha");
        this.createColorEvent(id, "color");
        this.createStrengthEvent(id);
        this.createAngleEvent(id);
        this.createDistanceEvent(id);
        this.createCheckBoxEvent(id, "knockout");
        this.createCheckBoxEvent(id, "inner");
        this.createCheckBoxEvent(id, "hideObject");

        // update
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(document.getElementById(`filter-id-${id}`));
    }

    /**
     * @param  {HTMLDivElement} element
     * @param  {BlurFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @public
     */
    addBlurFilter (element, filter = null, reload = true)
    {

        const id = this.createFilter(BlurFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = this.getFilterHeaderHTML(id, "Blur") + `
    
        <div class="filter-view-area-right">
        
            <div class="filter-container">
                <div class="filter-text">BlurX</div>
                <div><input type="text" id="blurX-${id}" value="${filter.blurX}" data-name="blurX" data-filter-id="${id}" data-detail="{{水平方向にぼかす}}"></div>
            </div>
        
            <div class="filter-container">
                <div class="filter-text">BlurY</div>
                <div><input type="text" id="blurY-${id}" value="${filter.blurY}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
            </div>
        
            <div class="filter-container">
                <div class="filter-text-long">Quality</div>
                <div>
                    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
                        <option value="1">Low</option>
                        <option value="2">Middle</option>
                        <option value="3">High</option>
                    </select>
                </div>
            </div> 
        
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // add params
        this[`_$filter-${id}-lock`] = false;
        this.commonFilterEvent(id, filter.quality);

        // update
        if (reload) {
            this.disposeCharacterImage();
        }
        Util.$addModalEvent(document.getElementById(`filter-id-${id}`));
    }

    /**
     * @param  {HTMLDivElement} element
     * @param  {GlowFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @public
     */
    addGlowFilter (element, filter = null, reload = true)
    {

        const id = this.createFilter(GlowFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = this.getFilterHeaderHTML(id, "Glow") + `

        <div class="filter-view-area-right">

            <div class="filter-container">
                <div class="filter-text">BlurX</div>
                <div><input type="text" id="blurX-${id}" value="${filter.blurX}" data-name="blurX" data-filter-id="${id}" data-detail="{{水平方向にぼかす}}"></div>
                
                <div class="filter-text">Strength</div>
                <div><input type="text" id="strength-${id}" value="${filter.strength}" data-filter-id="${id}" data-name="strength" data-detail="{{フィルター強度}}"></div>
            </div>
            
            <div class="filter-container">
                <div class="filter-text">BlurY</div>
                <div><input type="text" id="blurY-${id}" value="${filter.blurY}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">Color</div>
                <div><input type="color" id="color-${id}" value="#${filter.color.toString(16).padStart(6, "0")}" data-filter-id="${id}" data-name="color" data-detail="{{シャドウのカラー}}"></div>
                
                <div class="filter-text">Alpha</div>
                <div><input type="text" id="alpha-${id}" value="${filter.alpha}" data-filter-id="${id}" data-name="alpha" data-detail="{{シャドウのアルファ}}"></div>
            </div>
            
            <div class="filter-container">
                <div><input type="checkbox" id="inner-${id}" data-name="inner" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="inner-${id}">Inner Glow</label>
                </div>
            </div>
            
            <div class="filter-container">
                <div><input type="checkbox" id="knockout-${id}" data-name="knockout" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="knockout-${id}">Knockout</label>
                </div>
            </div>

            <div class="filter-container">
                <div class="filter-text-long">Quality</div>
                <div>
                    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
                        <option value="1">Low</option>
                        <option value="2">Middle</option>
                        <option value="3">High</option>
                    </select>
                </div>
            </div> 
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // add params
        this[`_$filter-${id}-lock`] = false;

        // add event
        this.commonFilterEvent(id, filter.quality);
        this.createAlphaEvent(id, "alpha");
        this.createColorEvent(id, "color");
        this.createStrengthEvent(id);
        this.createCheckBoxEvent(id, "knockout");
        this.createCheckBoxEvent(id, "inner");

        // update
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(document.getElementById(`filter-id-${id}`));
    }

    /**
     * @param  {HTMLDivElement} element
     * @param  {BevelFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @public
     */
    addBevelFilter (element, filter = null, reload = true)
    {

        const id = this.createFilter(BevelFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = this.getFilterHeaderHTML(id, "Bevel") + `

        <div class="filter-view-area-right">

            <div class="filter-container">
                <div class="filter-text">BlurX</div>
                <div><input type="text" id="blurX-${id}" value="${filter.blurX}" data-name="blurX" data-filter-id="${id}" data-detail="{{水平方向にぼかす}}"></div>
                 
                <div class="filter-text">Strength</div>
                <div><input type="text" id="strength-${id}" value="${filter.strength}" data-filter-id="${id}" data-name="strength" data-detail="{{フィルター強度}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">BlurY</div>
                <div><input type="text" id="blurY-${id}" value="${filter.blurY}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
                               
                <div class="filter-text">Angle</div>
                <div><input type="text" id="angle-${id}" value="${filter.angle}" data-filter-id="${id}" data-name="angle" data-detail="{{フィルター角度}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">Distance</div>
                <div><input type="text" id="distance-${id}" value="${filter.distance}" data-filter-id="${id}" data-name="distance" data-detail="{{フィルター距離}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">Shadow<br>Color</div>
                <div><input type="color" id="shadowColor-${id}" value="#${filter.shadowColor.toString(16).padStart(6, "0")}" data-filter-id="${id}" data-name="shadowColor" data-detail="{{シャドウのカラー}}"></div>
                
                <div class="filter-text">Shadow<br>Alpha</div>
                <div><input type="text" id="shadowAlpha-${id}" value="${filter.shadowAlpha}" data-filter-id="${id}" data-name="shadowAlpha" data-detail="{{シャドウのアルファ}}"></div>
            </div>
            
            <div class="filter-container">
                <div class="filter-text">Highlight<br>Color</div>
                <div><input type="color" id="highlightColor-${id}" value="#${filter.highlightColor.toString(16).padStart(6, "0")}" data-filter-id="${id}" data-name="highlightColor" data-detail="{{ハイライトのカラー}}"></div>
                
                <div class="filter-text">Highlight<br>Alpha</div>
                <div><input type="text" id="highlightAlpha-${id}" value="${filter.highlightAlpha}" data-filter-id="${id}" data-name="highlightAlpha" data-detail="{{ハイライトのアルファ}}"></div>
            </div>
            
            <div class="filter-container">
                <div><input type="checkbox" id="knockout-${id}" data-name="knockout" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="knockout-${id}">Knockout</label>
                </div>
            </div>

            <div class="filter-container">
                <div class="filter-text-long">Type</div>
                <div>
                    <select id="type-${id}" data-name="type" data-filter-id="${id}">
                        <option value="inner">Inner</option>
                        <option value="outer">Outer</option>
                        <option value="full">Full</option>
                    </select>
                </div>
    
                <div class="filter-text-long">Quality</div>
                <div>
                    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
                        <option value="1">Low</option>
                        <option value="2">Middle</option>
                        <option value="3">High</option>
                    </select>
                </div>
            </div>
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // add params
        this[`_$filter-${id}-lock`] = false;

        if (filter.knockout) {
            document.getElementById(`knockout-${id}`).checked = true;
        }

        // add event
        this.commonFilterEvent(id, filter.quality);
        this.createStrengthEvent(id);
        this.createAngleEvent(id);
        this.createDistanceEvent(id);
        this.createColorEvent(id, "highlightColor");
        this.createAlphaEvent(id, "highlightAlpha");
        this.createColorEvent(id, "shadowColor");
        this.createAlphaEvent(id, "shadowAlpha");
        this.createCheckBoxEvent(id, "knockout");
        this.createTypeEvent(id, filter.type);

        // update
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(document.getElementById(`filter-id-${id}`));
    }

    /**
     * @param  {HTMLDivElement} element
     * @param  {GradientGlowFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @public
     */
    addGradientGlowFilter (element, filter = null, reload = true)
    {

        const id = this.createFilter(GradientGlowFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = this.getFilterHeaderHTML(id, "GradientGlow") + `

        <div class="filter-view-area-right">

            <div class="filter-container">
                <div class="filter-text">BlurX</div>
                <div><input type="text" id="blurX-${id}" value="${filter.blurX}" data-name="blurX" data-filter-id="${id}" data-detail="{{水平方向にぼかす}}"></div>
                          
                <div class="filter-text">Strength</div>
                <div><input type="text" id="strength-${id}" value="${filter.strength}" data-filter-id="${id}" data-name="strength" data-detail="{{フィルター強度}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">BlurY</div>
                <div><input type="text" id="blurY-${id}" value="${filter.blurY}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
            
                <div class="filter-text">Angle</div>
                <div><input type="text" id="angle-${id}" value="${filter.angle}" data-filter-id="${id}" data-name="angle" data-detail="{{フィルター角度}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">Distance</div>
                <div><input type="text" id="distance-${id}" value="${filter.distance}" data-filter-id="${id}" data-name="distance" data-detail="{{フィルター距離}}"></div>
            </div>

            <div class="filter-container">
                <div id="gradient-color-palette-${id}" class="gradient-color-palette">
                    <div id="color-palette-${id}" class="color-palette">
                        <canvas id="gradient-canvas-${id}"></canvas>
                    </div>
                    <div id="color-pointer-list-${id}" data-filter-id="${id}" class="color-pointer-list" data-detail="{{カラーポインターを追加}}"></div>
                </div>
            </div>
            
            <div class="filter-container">
                <div class="filter-text">Color</div>
                <div><input type="color" id="color-${id}" value="#000000" data-detail="{{グラデーションカラー}}"></div>
                
                <div class="filter-text">Alpha</div>
                <div><input type="text" id="alpha-${id}" value="100" data-name="gradientAlpha" data-detail="{{グラデーションのアルファ}}"></div>
            </div>
            
            <div class="filter-container">
                <div><input type="checkbox" id="knockout-${id}" data-name="knockout" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="knockout-${id}">Knockout</label>
                </div>
            </div>

            <div class="filter-container">
                <div class="filter-text-long">Type</div>
                <div>
                    <select id="type-${id}" data-name="type" data-filter-id="${id}">
                        <option value="inner">Inner</option>
                        <option value="outer">Outer</option>
                        <option value="full">Full</option>
                    </select>
                </div>
    
                <div class="filter-text-long">Quality</div>
                <div>
                    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
                        <option value="1">Low</option>
                        <option value="2">Middle</option>
                        <option value="3">High</option>
                    </select>
                </div>
            </div>
            
        </div>
    </div>
</div>
        `;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        const canvas  = document.getElementById(`gradient-canvas-${id}`);
        canvas.width  = Util.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio;
        canvas.height = Util.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio;

        canvas.style.transform          = `scale(${1 / window.devicePixelRatio}, ${1 / window.devicePixelRatio})`;
        canvas.style.backfaceVisibility = "hidden";
        canvas.style.transformOrigin    = "0 0";

        const context = canvas.getContext("2d");

        // add params
        this[`_$filter-${id}-lock`]    = false;
        this[`_$filter-${id}-context`] = context;

        if (filter.knockout) {
            document.getElementById(`knockout-${id}`).checked = true;
        }

        // add event
        this.commonFilterEvent(id, filter.quality);
        this.createStrengthEvent(id);
        this.createAngleEvent(id);
        this.createDistanceEvent(id);
        this.createGradientColorPointerEvent(id, filter.ratios, filter.colors, filter.alphas);
        this.createGradientColorEvent(id);
        this.createGradientAlphaEvent(id);
        this.createCheckBoxEvent(id, "knockout");
        this.createTypeEvent(id, filter.type);
        this.updateFilterGradientCanvas(id, filter);

        // update
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(document.getElementById(`filter-id-${id}`));
    }

    /**
     * @param  {HTMLDivElement} element
     * @param  {GradientBevelFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @public
     */
    addGradientBevelFilter (element, filter = null, reload = true)
    {

        const id = this.createFilter(GradientBevelFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = this.getFilterHeaderHTML(id, "GradientBevel") + `

        <div class="filter-view-area-right">

            <div class="filter-container">
                <div class="filter-text">BlurX</div>
                <div><input type="text" id="blurX-${id}" value="${filter.blurX}" data-name="blurX" data-filter-id="${id}" data-detail="水平方向にぼかす"></div>
                                
                <div class="filter-text">Strength</div>
                <div><input type="text" id="strength-${id}" value="${filter.strength}" data-filter-id="${id}" data-name="strength" data-detail="フィルター強度"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">BlurY</div>
                <div><input type="text" id="blurY-${id}" value="${filter.blurY}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
                
                <div class="filter-text">Angle</div>
                <div><input type="text" id="angle-${id}" value="${filter.angle}" data-filter-id="${id}" data-name="angle" data-detail="{{フィルター角度}}"></div>
            </div>
            
            <div class="filter-container">
                <div class="filter-text">Distance</div>
                <div><input type="text" id="distance-${id}" value="${filter.distance}" data-filter-id="${id}" data-name="distance" data-detail="{{フィルター距離}}"></div>
            </div>
            
            <div class="filter-container">
                <div id="gradient-color-palette-${id}" class="gradient-color-palette">
                    <div id="color-palette-${id}" class="color-palette">
                        <canvas id="gradient-canvas-${id}"></canvas>
                    </div>
                    <div id="color-pointer-list-${id}" data-filter-id="${id}" class="color-pointer-list" data-detail="{{カラーポインターを追加}}"></div>
                </div>
            </div>
            
            <div class="filter-container">
                <div class="filter-text">Color</div>
                <div><input type="color" id="color-${id}" value="#000000" data-detail="{{グラデーションカラー}}"></div>
                
                <div class="filter-text">Alpha</div>
                <div><input type="text" id="alpha-${id}" value="100" data-name="gradientAlpha" data-detail="{{グラデーションのアルファ}}"></div>
            </div>
            
            <div class="filter-container">
                <div><input type="checkbox" id="knockout-${id}" data-name="knockout" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="knockout-${id}">Knockout</label>
                </div>
            </div>

            <div class="filter-container">
                <div class="filter-text-long">Type</div>
                <div>
                    <select id="type-${id}" data-name="type" data-filter-id="${id}">
                        <option value="inner">Inner</option>
                        <option value="outer">Outer</option>
                        <option value="full">Full</option>
                    </select>
                </div>
    
                <div class="filter-text-long">Quality</div>
                <div>
                    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
                        <option value="1">Low</option>
                        <option value="2">Middel</option>
                        <option value="3">High</option>
                    </select>
                </div>
            </div>
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        const canvas  = document.getElementById(`gradient-canvas-${id}`);
        canvas.width  = Util.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio;
        canvas.height = Util.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio;

        canvas.style.transform          = `scale(${1 / window.devicePixelRatio}, ${1 / window.devicePixelRatio})`;
        canvas.style.backfaceVisibility = "hidden";
        canvas.style.transformOrigin    = "0 0";

        const context = canvas.getContext("2d");

        // add params
        this[`_$filter-${id}-lock`]    = false;
        this[`_$filter-${id}-context`] = context;

        if (filter.knockout) {
            document.getElementById(`knockout-${id}`).checked = true;
        }

        // add event
        this.commonFilterEvent(id, filter.quality);
        this.createStrengthEvent(id);
        this.createAngleEvent(id);
        this.createDistanceEvent(id);
        this.createGradientColorPointerEvent(id, filter.ratios, filter.colors, filter.alphas);
        this.createGradientColorEvent(id);
        this.createGradientAlphaEvent(id);
        this.createCheckBoxEvent(id, "knockout");
        this.createTypeEvent(id, filter.type);
        this.updateFilterGradientCanvas(id, filter);

        // update
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(document.getElementById(`filter-id-${id}`));
    }

    /**
     * @return {void}
     * @public
     */
    initializeLibrary ()
    {
        // 右クリック
        const element = document.getElementById("library-list-box");

        element.addEventListener("mouseleave", function ()
        {
            if (this._$menuMode) {
                return ;
            }

            if (this._$libraryTarget) {

                this._$libraryTarget
                    .classList
                    .remove("active");

                this._$libraryTarget = null;

            }
        }.bind(this));

        element.addEventListener("contextmenu", function (event)
        {
            this._$menuMode = true;

            const element = document.getElementById("library-menu");

            element.style.left = element.clientWidth + event.pageX + 5 > window.innerWidth
                ? `${event.pageX - (element.clientWidth + event.pageX + 10 - window.innerWidth)}px`
                : `${event.pageX + 5}px`;

            element.style.top  = `${event.pageY - element.clientHeight / 2}px`;
            element.setAttribute("class", "fadeIn");

            Util.$endMenu("library-menu");

        }.bind(this));

        element.addEventListener("mousedown", function ()
        {
            if (this._$menuMode) {
                return ;
            }

            if (!this._$libraryHit && this._$libraryTarget) {

                this._$libraryTarget
                    .classList
                    .remove("active");

                this._$libraryTarget = null;

            }

            this._$libraryHit = false;

        }.bind(this));

        element.addEventListener("drop", function (event)
        {
            if (this._$libraryTarget) {

                event.preventDefault();

                const target = this._$libraryTarget;

                const workSpace = Util.$currentWorkSpace();
                const instance  = workSpace
                    .getLibrary(target.dataset.libraryId | 0);

                // reset
                if (instance.folderId) {

                    instance.folderId = 0;

                    target.style.display     = "";
                    target.style.paddingLeft = "";

                    this.reAppendFolderChildren(null, target);

                }

                this._$libraryTarget = null;
            }

        }.bind(this));

        // 右クリック解除
        document.body.addEventListener("click", function ()
        {
            if (!this._$menuMode) {
                return ;
            }

            this._$menuMode = false;
            const element = document.getElementById("library-menu");
            element.setAttribute("class", "fadeOut");

        }.bind(this));

        // メニューイベント

        // add MovieClip
        document
            .getElementById("library-menu-container-add")
            .addEventListener("click", function (event)
            {

                Util
                    .$currentWorkSpace()
                    .temporarilySaved();

                this.newContainer(event);

            }.bind(this));

        // add MovieClip
        document
            .getElementById("library-menu-folder-add")
            .addEventListener("click", function (event)
            {

                Util
                    .$currentWorkSpace()
                    .temporarilySaved();

                this.newContainer(event);

            }.bind(this));

        // クローン
        document
            .getElementById("library-menu-content-shape-clone")
            .addEventListener("click", function ()
            {
                if (this._$libraryTarget) {

                    const workSpace = Util.$currentWorkSpace();

                    const instance = workSpace.getLibrary(
                        this._$libraryTarget.dataset.libraryId | 0
                    );

                    if (instance.type === "shape") {

                        workSpace.temporarilySaved();

                        const id = workSpace.nextLibraryId;

                        const shape = workSpace.addLibrary(
                            this.createContainer(instance.type, `Shape_${id}`, id)
                        );

                        instance.copyFrom(shape);
                    }
                }

            }.bind(this));

        const searchElement = document
            .getElementById("library-search");

        searchElement.addEventListener("focusin", () =>
        {
            Util.$keyLock = true;
        });
        searchElement.addEventListener("focusout", () =>
        {
            Util.$keyLock = false;
        });

        searchElement.addEventListener("input", function (event)
        {
            const searchText = event.target.value;

            const children = document
                .getElementById("library-list-box")
                .children;

            const length = children.length;
            for (let idx = 0; idx < length; ++idx) {

                const node = children[idx];

                if (!searchText
                    || node.children[0].innerText.indexOf(searchText) > -1
                    || node.children[1].innerText.indexOf(searchText) > -1
                ) {
                    node.style.display = "";
                    continue;
                }

                node.style.display = "none";
            }

        }.bind(this));

        // Delete
        const deleteElement = document
            .getElementById("library-menu-delete");

        /**
         * 削除処理
         * @param {Event|KeyboardEvent} event
         */
        const deleteFunction = function (event)
        {
            if (Util.$keyLock) {
                return false;
            }

            if (this._$inputMode) {
                return false;
            }

            if (this._$deleteTarget
                && this._$deleteTarget.dataset.type === "pointer"
            ) {

                const workSpace = Util.$currentWorkSpace();

                workSpace.temporarilySaved();

                const layerElement = Util.$timeline._$targetLayer;
                if (!layerElement) {
                    return ;
                }

                const layerId = layerElement.dataset.layerId | 0;

                const layer = Util
                    .$currentWorkSpace()
                    .scene
                    .getLayer(layerId);

                const character = layer.getActiveCharacter(
                    document.getElementById("current-frame").textContent | 0
                )[0];

                const tween  = character.getTween();
                const index  = this._$deleteTarget.dataset.index | 0;
                tween.custom.splice(index - 1, 3);

                const children = document
                    .getElementById("ease-cubic-pointer-area")
                    .children;

                children[index].remove();
                children[index - 1].remove();
                children[index - 2].remove();

                for (let idx = 0; idx < children.length; ++idx) {
                    const child = children[idx];
                    child.dataset.index = `${idx + 1}`;
                }

                this.createEasingGraph();
                Util.$screen.executeTween(layer);
                Util.$screen.createTweenMarker();

                // end
                this._$deleteTarget = null;
                event.stopImmediatePropagation();
            }

            if (this._$libraryTarget) {

                let deleteFlag = false;
                if (event.type === "keydown") {

                    if (!this._$menuMode
                        && (event.code === "Backspace" || event.code === "Delete")
                    ) {
                        deleteFlag = true;
                    }

                } else {

                    deleteFlag = true;

                }

                if (deleteFlag) {

                    const workSpace = Util.$currentWorkSpace();

                    workSpace.temporarilySaved();

                    const libraryId = this._$libraryTarget.dataset.libraryId | 0;

                    const instance = workSpace.getLibrary(libraryId);
                    if (instance.type === "folder") {
                        for (const value of workSpace._$libraries.values()) {

                            if (!value.folderId
                                || value.folderId !== instance.id
                            ) {
                                continue;
                            }

                            document
                                .getElementById(`library-child-id-${value.id}`)
                                .remove();

                            workSpace.removeLibrary(value.id);
                        }
                    }

                    workSpace.removeLibrary(libraryId);

                    // remove child
                    this._$libraryTarget.remove();

                    // clear
                    this._$libraryTarget = null;

                    // remove
                    const previewElement = document
                        .getElementById("library-preview-area");

                    while (previewElement.children.length) {
                        previewElement.children[0].remove();
                    }

                    Util.$screen.clearActiveCharacter();

                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    workSpace.scene.changeFrame(frame);

                }

            }

        }.bind(this);

        deleteElement.addEventListener("click", deleteFunction);
        window.addEventListener("keydown", deleteFunction);

        /**
         * コピー/ペースト処理
         * @param {Event|KeyboardEvent} event
         */
        const commandFunction = function (event)
        {
            switch (event.code) {

                case "KeyC": // copy

                    if (!this._$libraryTarget) {
                        return false;
                    }

                    if (event.ctrlKey && !event.metaKey
                        || !event.ctrlKey && event.metaKey
                    ) {
                        Util.$copyLibrary   = null;
                        Util.$copyLayer     = null;
                        Util.$copyCharacter = null;
                        if (!Util.$keyLock && !Util.$activeScript) {

                            event.preventDefault();

                            Util.$copyWorkSpaceId = Util.$activeWorkSpaceId;

                            const libraryId = this._$libraryTarget.dataset.libraryId | 0;
                            Util.$copyLibrary = Util
                                .$currentWorkSpace()
                                .getLibrary(libraryId);

                            const element = document.getElementById("detail-modal");
                            element.textContent = "copy";
                            element.style.left  = `${this._$libraryTarget.offsetLeft + 5}px`;
                            element.style.top   = `${this._$libraryTarget.offsetTop  + 9}px`;
                            element.setAttribute("class", "fadeIn");

                            element.dataset.timerId = setTimeout(function ()
                            {
                                if (!this.classList.contains("fadeOut")) {
                                    this.setAttribute("class", "fadeOut");
                                }
                            }.bind(element), 1500);

                            return false;
                        }
                    }
                    break;

                case "KeyV": // paste
                    if (event.ctrlKey && !event.metaKey // windows
                        || !event.ctrlKey && event.metaKey // mac
                    ) {

                        if (!Util.$keyLock && !Util.$activeScript) {

                            if (Util.$copyWorkSpaceId !== Util.$activeWorkSpaceId
                                && Util.$copyLibrary
                            ) {

                                event.preventDefault();

                                const workSpace = Util.$currentWorkSpace();
                                const object    = Util.$copyLibrary.toObject();
                                if (object.type === "container") {

                                    const dup = new Map();
                                    Util.$copyContainer(object, dup);

                                } else {
                                    object.id = workSpace.nextLibraryId;
                                    workSpace.addLibrary(object);
                                }

                                workSpace.initializeLibrary();

                                Util.$copyWorkSpaceId = -1;
                                Util.$copyLibrary     = null;
                            }
                            return false;
                        }
                    }
                    break;

                default:
                    break;

            }

        }.bind(this);
        window.addEventListener("keydown", commandFunction);

        // ファイル読み込み
        const fileElement = document
            .getElementById("library-menu-file");

        fileElement.addEventListener("click", function (event)
        {
            const input = document.getElementById("library-menu-file-input");
            input.click();

            event.preventDefault();
        });

        const fileInput = document
            .getElementById("library-menu-file-input");

        fileInput.addEventListener("change", function (event)
        {
            Util.$currentWorkSpace().temporarilySaved();

            const files = event.target.files;
            for (let idx = 0; idx < files.length; ++idx) {
                this.loadFile(files[idx]);
            }

            event.target.value = "";
        }.bind(this));

        // ファイルドロップ
        element.addEventListener("dragstart", function (event)
        {
            const element = event.target;
            const scene   = Util.$currentWorkSpace().scene;

            Util.$dragElement = scene.id !== (element.dataset.libraryId | 0)
                ? element
                : null;

            const children = document.getElementById("stage-area").children;
            for (let idx = 1; idx < children.length; ++idx) {
                children[idx].style.pointerEvents = "none";
            }
        });
        element.addEventListener("dragend", function ()
        {
            Util.$dragElement = null;

            const children = document.getElementById("stage-area").children;
            for (let idx = 1; idx < children.length; ++idx) {
                children[idx].style.pointerEvents = "";
            }
        });

        element.addEventListener("dragover", function (event)
        {
            event.preventDefault();
        });

        element.addEventListener("drop", function (event)
        {
            event.preventDefault();

            const files = event.dataTransfer.files;
            for (let idx = 0; idx < files.length; ++idx) {
                this.loadFile(files[idx]);
            }

        }.bind(this));

    }

    /**
     * @param  {Event} event
     * @return {void}
     * @public
     */
    newContainer (event)
    {
        const type = event.currentTarget.dataset.containerType;
        const name = type === "container" ? "MovieClip" : "Folder";

        const workSpace = Util.$currentWorkSpace();

        const id = workSpace.nextLibraryId;
        workSpace.addLibrary(
            this.createContainer(type, `${name}_${id}`, id)
        );
    }

    /**
     * @param  {File} file
     * @return {void}
     * @public
     */
    loadFile (file)
    {
        switch (file.type) {

            case "image/svg+xml":
                file
                    .text()
                    .then((value) =>
                    {
                        const movieClip = Util
                            .$currentWorkSpace()
                            .addLibrary(this.createContainer(
                                "container",
                                file.name,
                                Util.$currentWorkSpace().nextLibraryId
                            ));

                        SVGToShape.parse(value, movieClip);

                        this.addInstanceSelectOption(
                            movieClip.id, movieClip.name
                        );
                    });
                break;

            case "image/png":
            case "image/jpeg":
            case "image/gif":
                {
                    const object = {
                        "name": file.name,
                        "type": file.type,
                        "image": new Image(),
                        "callback": this.createContainer.bind(this),
                        "addSelect": this.addInstanceSelectOption.bind(this)
                    };

                    file
                        .arrayBuffer()
                        .then(function (buffer)
                        {

                            const blob = new Blob([buffer], {
                                "type": this.type
                            });

                            this.image.src = URL.createObjectURL(blob);
                            this
                                .image
                                .decode()
                                .then(function ()
                                {
                                    const width   = this.image.width;
                                    const height  = this.image.height;

                                    const canvas  = document.createElement("canvas");
                                    canvas.width  = width;
                                    canvas.height = height;
                                    const context = canvas.getContext("2d");

                                    context.drawImage(this.image, 0, 0, width, height);
                                    const buffer = new Uint8Array(
                                        context.getImageData(0, 0, width, height).data
                                    );

                                    const bitmap = this.callback(
                                        "bitmap",
                                        this.name,
                                        Util.$currentWorkSpace().nextLibraryId
                                    );

                                    bitmap.width     = this.image.width;
                                    bitmap.height    = this.image.height;
                                    bitmap.imageType = this.type;
                                    bitmap.buffer    = new Uint8Array(buffer);

                                    Util
                                        .$currentWorkSpace()
                                        .addLibrary(bitmap);

                                    this.addSelect(
                                        bitmap.id, bitmap.name
                                    );

                                    this.addSelect = null;
                                    this.callback  = null;
                                    this.image     = null;

                                }.bind(this));

                        }.bind(object));

                }
                break;

            case "video/mp4":
                {
                    const object = {
                        "name": file.name,
                        "type": file.type,
                        "video": document.createElement("video"),
                        "callback": this.createContainer.bind(this),
                        "addSelect": this.addInstanceSelectOption.bind(this)
                    };

                    file
                        .arrayBuffer()
                        .then(function (buffer)
                        {
                            const blob = new Blob([buffer], {
                                "type": this.type
                            });

                            this.video.onloadedmetadata = function ()
                            {
                                const video = this.callback(
                                    "video",
                                    this.name,
                                    Util.$currentWorkSpace().nextLibraryId
                                );

                                video.width  = this.video.videoWidth;
                                video.height = this.video.videoHeight;
                                video.buffer = new Uint8Array(buffer);

                                Util
                                    .$currentWorkSpace()
                                    .addLibrary(video);

                                this.addSelect(
                                    video.id, video.name
                                );

                                this.addSelect = null;
                                this.callback  = null;
                                this.video     = null;

                            }.bind(this);

                            this.video.src = URL.createObjectURL(blob);
                            this.video.load();

                        }.bind(object));

                }
                break;

            case "audio/mpeg":
                file
                    .arrayBuffer()
                    .then(function (buffer)
                    {
                        const object = this
                            .createContainer(
                                "sound",
                                file.name,
                                Util.$currentWorkSpace().nextLibraryId
                            );

                        object.buffer = new Uint8Array(buffer);

                        Util
                            .$currentWorkSpace()
                            .addLibrary(object);

                    }.bind(this));
                break;

            case "application/x-shockwave-flash":
                file
                    .arrayBuffer()
                    .then((buffer) =>
                    {
                        new ReComposition()
                            .setData(new Uint8Array(buffer))
                            .run(function (parent)
                            {
                                console.log(parent);
                            });
                    });
                break;

            default:
                break;

        }
    }

    /**
     * @param  {string} type
     * @param  {string} name
     * @param  {uint}   id
     * @param  {string} [symbol=""]
     * @return {object}
     * @public
     */
    createContainer (type, name, id, symbol = "")
    {
        const htmlTag = `
<div draggable="true" class="library-list-box-child" id="library-child-id-${id}" data-library-id="${id}">
    <div class="library-list-box-name">
        <i class="library-type-${type}" id="${type}-${id}" data-library-id="${id}"></i>
        <p>
            <span id="library-name-${id}" class="view-text" data-library-id="${id}">${name}</span>
            <input type="text" id="library-name-input-${id}" data-library-id="${id}" value="${name}" style="display: none;">
        </p>
    </div>
    <div class="library-list-box-symbol">
        <p>
            <span id="library-symbol-name-${id}" class="view-symbol-text" data-library-id="${id}"></span>
            <input type="text" id="library-symbol-name-input-${id}" data-library-id="${id}" value="" style="display: none;">
        </p>
    </div>
</div>`;

        const element = document.getElementById("library-list-box");
        element.insertAdjacentHTML("beforeend", htmlTag);

        if (type === "container") {
            const typeIcon = document.getElementById(`${type}-${id}`);
            typeIcon.addEventListener("dblclick", Util.$changeScene);
        }

        const child = document
            .getElementById(`library-child-id-${id}`);

        if (type === "folder") {

            const typeIcon = document.getElementById(`${type}-${id}`);
            typeIcon.addEventListener("dblclick", function (event)
            {
                const workSpace = Util.$currentWorkSpace();

                const target = event.target;
                const folder = workSpace
                    .getLibrary(target.dataset.libraryId | 0);

                if (folder.mode === Util.FOLDER_OPEN) {
                    folder.mode = Util.FOLDER_CLOSE;
                    target.classList.remove("library-type-folder-open");
                    target.classList.add("library-type-folder-close");
                } else {
                    folder.mode = Util.FOLDER_OPEN;
                    target.classList.remove("library-type-folder-close");
                    target.classList.add("library-type-folder-open");
                }

                this.updateFolderStyle(folder, folder.mode);

            }.bind(this));

            child.addEventListener("drop", function (event)
            {
                if (this._$libraryTarget) {

                    event.preventDefault();

                    const workSpace = Util.$currentWorkSpace();

                    const target = this._$libraryTarget;
                    const instance  = workSpace
                        .getLibrary(target.dataset.libraryId | 0);

                    const folderElement = event.currentTarget;
                    const folder = workSpace
                        .getLibrary(folderElement.dataset.libraryId | 0);

                    instance.folderId = folder.id;

                    this.reAppendFolderChildren(folderElement, target);

                    this.updateFolderStyle(folder, folder.mode);

                    this._$libraryTarget = null;
                }

            }.bind(this));

            typeIcon.classList.remove("library-type-folder");
            typeIcon.classList.add("library-type-folder-close");
        }

        if (type === "sound") {

            const option = document.createElement("option");
            option.value     = `${id}`;
            option.innerHTML = name;

            document
                .getElementById("sound-select")
                .appendChild(option);

        }

        if (type !== "folder") {

            child.addEventListener("mousedown", function (event)
            {

                this._$libraryHit = true;

                const children = document
                    .getElementById("library-list-box")
                    .children;

                for (let idx = 0; idx < children.length; ++idx) {

                    const node = children[idx];
                    node.classList.remove("active");

                }

                this._$libraryTarget = null;
                if (this._$inputMode || this._$menuMode) {
                    return ;
                }

                const element = event.currentTarget;
                element
                    .classList
                    .remove("active");

                element
                    .classList
                    .add("active");

                this._$libraryTarget = element;

                const workSpace = Util.$currentWorkSpace();
                const instance  = workSpace.getLibrary(element.dataset.libraryId | 0);

                // remove
                const previewElement = document.getElementById("library-preview-area");
                while (previewElement.children.length) {
                    previewElement.children[0].remove();
                }

                previewElement.appendChild(instance.preview);

            }.bind(this));

        } else {

            child.addEventListener("mousedown", function (event)
            {

                this._$libraryHit = true;

                const children = document
                    .getElementById("library-list-box")
                    .children;

                for (let idx = 0; idx < children.length; ++idx) {

                    const node = children[idx];
                    node.classList.remove("active");

                }

                this._$libraryTarget = null;
                if (this._$inputMode || this._$menuMode) {
                    return ;
                }

                const element = event.currentTarget;
                element
                    .classList
                    .remove("active");

                element
                    .classList
                    .add("active");

                this._$libraryTarget = element;

            }.bind(this));
        }

        const textElement = document
            .getElementById(`library-name-${id}`);

        textElement.addEventListener("dblclick", function (event)
        {
            Util.$keyLock = true;

            this._$inputMode = true;

            const libraryId = event.target.dataset.libraryId | 0;

            const parent = document
                .getElementById(`library-child-id-${libraryId}`);

            parent
                .classList
                .remove("active");

            parent.draggable = false;

            const input = document
                .getElementById(`library-name-input-${libraryId}`);

            input.value = event.target.textContent;
            input.style.display = "";
            input.focus();

            event.target.style.display = "none";

        }.bind(this));

        const input = document
            .getElementById(`library-name-input-${id}`);

        /**
         * @param {Event|KeyboardEvent} event
         */
        const editEnd = function (event)
        {
            if (event.code === "Enter") {
                event.target.blur();
                return ;
            }

            if (event.type === "focusout") {

                const libraryId = event.target.dataset.libraryId | 0;

                const textElement = document
                    .getElementById(`library-name-${libraryId}`);

                const workSpace = Util.$currentWorkSpace();
                const library   = workSpace.getLibrary(libraryId);
                library.name    = event.target.value;

                textElement.textContent    = event.target.value;
                textElement.style.display  = "";
                event.target.style.display = "none";

                const parent = document
                    .getElementById(`library-child-id-${libraryId}`);

                parent.draggable = true;
                Util.$keyLock    = false;
                this._$inputMode = false;
            }

        }.bind(this);

        input.addEventListener("focusout", editEnd);
        input.addEventListener("keypress", editEnd);

        if (type !== "folder") {

            const symbolElement = document
                .getElementById(`library-symbol-name-${id}`);
            symbolElement.textContent = symbol;

            symbolElement.addEventListener("dblclick", function (event)
            {
                Util.$keyLock = true;

                this._$libraryTarget = null;

                this._$inputMode = true;

                const libraryId = event.target.dataset.libraryId | 0;

                const parent = document
                    .getElementById(`library-child-id-${libraryId}`);

                parent
                    .classList
                    .remove("active");

                parent.draggable = false;

                const input = document
                    .getElementById(`library-symbol-name-input-${libraryId}`);

                input.value = event.target.textContent;
                input.style.display = "";
                input.focus();

                event.target.style.display = "none";

            }.bind(this));

            const symbolInput = document
                .getElementById(`library-symbol-name-input-${id}`);
            symbolInput.value = symbol;

            /**
             * @param {Event|KeyboardEvent} event
             */
            const symbolEditEnd = function (event)
            {
                if (event.code === "Enter") {
                    event.target.blur();
                    return ;
                }

                if (event.type === "focusout") {

                    const libraryId = event.target.dataset.libraryId | 0;

                    const symbolElement = document
                        .getElementById(`library-symbol-name-${libraryId}`);

                    const workSpace = Util.$currentWorkSpace();
                    const library   = workSpace.getLibrary(libraryId);
                    library.symbol  = event.target.value;

                    symbolElement.textContent   = event.target.value;
                    symbolElement.style.display = "";
                    event.target.style.display  = "none";

                    const parent = document
                        .getElementById(`library-child-id-${libraryId}`);

                    parent.draggable = true;
                    Util.$keyLock    = false;
                    this._$inputMode = false;
                }

            }.bind(this);

            symbolInput.addEventListener("focusout", symbolEditEnd);
            symbolInput.addEventListener("keypress", symbolEditEnd);
        }

        return {
            "id": id,
            "type": type,
            "name": name,
            "symbol": symbol
        };
    }

    /**
     * @param  {HTMLDivElement} parent
     * @param  {HTMLDivElement} child
     * @return {void}
     * @public
     */
    reAppendFolderChildren (parent, child)
    {
        child.remove();

        if (!parent) {

            document
                .getElementById("library-list-box")
                .appendChild(child);

        } else {

            parent.parentNode.insertBefore(
                child, parent.nextElementSibling
            );

        }

        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace.getLibrary(child.dataset.libraryId | 0);

        if (instance.type === "folder") {

            const element = document
                .getElementById(`library-child-id-${instance.id}`);

            for (const value of workSpace._$libraries.values()) {

                if (!value.id) {
                    continue;
                }

                if (!value.folderId || value.folderId !== instance.id) {
                    continue;
                }

                const child = document
                    .getElementById(`library-child-id-${value.id}`);

                this.reAppendFolderChildren(element, child);
            }
        }
    }

    /**
     * @param  {Folder} folder
     * @param  {string} mode
     * @return {void}
     * @public
     */
    updateFolderStyle (folder, mode)
    {
        const workSpace = Util.$currentWorkSpace();

        const children = document
            .getElementById("library-list-box")
            .children;

        let depth = 20;
        let instanceId = folder.folderId;
        if (instanceId) {
            for (;;) {

                const instance = workSpace.getLibrary(instanceId);
                if (!instance) {
                    break;
                }

                depth += 20;

                instanceId = instance.folderId;
                if (!instanceId) {
                    break;
                }

            }
        }

        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];

            const instance = workSpace
                .getLibrary(node.dataset.libraryId | 0);

            if (!instance.folderId) {
                continue;
            }

            if (instance.folderId !== folder.id) {
                continue;
            }

            node.style.paddingLeft = `${depth}px`;
            node.style.display = mode === Util.FOLDER_OPEN
                ? ""
                : "none";

            if (instance.type === "folder") {
                this.updateFolderStyle(
                    instance,
                    mode === Util.FOLDER_OPEN ? instance.mode : mode
                );
            }
        }
    }



    /**
     * @return {void}
     * @public
     */
    initializeSoundSetting ()
    {
        document
            .getElementById("sound-setting-title")
            .addEventListener("mousedown", function (event)
            {
                const element = document
                    .getElementById("sound-setting-view-area");

                const i = event.target.children.length
                    ? event.target.children[0]
                    : event.target;

                if (element.style.display === "none") {
                    element.style.display = "";
                    i.setAttribute("class", "active");
                } else {
                    element.style.display = "none";
                    i.setAttribute("class", "disable");
                }

            });

        document
            .getElementById("sound-add")
            .addEventListener("mousedown", function ()
            {
                const element = document.getElementById("sound-select");
                if (element.options.length) {
                    this.addSound();
                }
            }.bind(this));

    }

    /**
     * @return {void}
     * @public
     */
    createSoundListArea ()
    {
        const element = document
            .getElementById("sound-list-area");

        while (element.children.length) {
            element.children[0].remove();
        }

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const scene = Util.$currentWorkSpace().scene;
        if (scene._$sounds.has(frame)) {

            const sounds = scene._$sounds.get(frame);
            for (let idx = 0; idx < sounds.length; ++idx) {
                this.addSound(sounds[idx], idx);
            }

        }
    }

    /**
     * @param  {object} object
     * @param  {number} id
     * @return {void}
     * @public
     */
    addSound (object = null, id = null)
    {
        if (!object) {

            const element = document.getElementById("sound-select");
            const option  = element.options[element.selectedIndex];

            const frame = document
                .getElementById("current-frame")
                .textContent | 0;

            const scene = Util.$currentWorkSpace().scene;
            if (!scene._$sounds.has(frame)) {
                scene._$sounds.set(frame, []);
            }

            const sounds = scene._$sounds.get(frame);
            id = sounds.length;

            object = {
                "characterId": element.value | 0,
                "name":        option.textContent,
                "volume":      100,
                "autoPlay":    false
            };

            sounds.push(object);

            const label = document
                .getElementById(`frame-label-sound-${frame}`);

            if (!label.classList.contains("frame-border-box-sound")) {
                label.setAttribute("class", "frame-border-box-sound");
            }
        }

        const htmlTag = `
<div id="sound-id-${id}" class="sound-border">
    <div class="sound-title">
      <span id="sound-name-${id}" data-sound-id="${id}">${object.name}</span>
      <i class="trash" id="sound-trash-${id}" data-sound-id="${id}" data-detail="サウンドを削除"></i>
    </div>

    <div class="sound-container">
        <div class="sound-setting-container">
            <div class="sound-text">Volume</div>
            <div><input type="text" id="sound-volume-${id}" data-sound-id="${id}" data-name="volume" value="100" data-detail="音量設定"></div>
        
            <div class="sound-text">Loop</div>
            <select id="sound-loop-select-${id}" data-sound-id="${id}" data-detail="ループ">
                <option value="0">Off</option>
                <option value="1">On</option>
            </select>
        </div>
    </div>
</div>
`;
        document
            .getElementById("sound-list-area")
            .insertAdjacentHTML("beforeend", htmlTag);

        const volume = document.getElementById(`sound-volume-${id}`);

        volume.addEventListener("mouseover", this.mouseOver.bind(this));
        volume.addEventListener("mouseout",  this.mouseOut.bind(this));
        volume.addEventListener("mousedown", this.mouseDown.bind(this));
        volume.addEventListener("focusin", function (event)
        {
            this._$focus        = true;
            this._$currentValue = event.target.value | 0;
            Util.$keyLock       = true;
        }.bind(this));

        volume.addEventListener("focusout", this.objectVolumeSizeOut.bind(this));
        volume.addEventListener("keypress", this.objectVolumeSizeOut.bind(this));
        volume.value = `${object.volume}`;

        document
            .getElementById(`sound-trash-${id}`)
            .addEventListener("click", function (event)
            {
                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                const scene  = Util.$currentWorkSpace().scene;
                const sounds = scene._$sounds.get(frame);

                const index = event.target.dataset.soundId | 0;
                sounds.splice(index, 1);

                if (!sounds.length) {

                    scene._$sounds.delete(frame);

                    document
                        .getElementById(`frame-label-sound-${frame}`)
                        .setAttribute("class", "frame-border-box");

                }

                this.createSoundListArea();

            }.bind(this));

        const loop = document
            .getElementById(`sound-loop-select-${id}`);

        loop.addEventListener("change", function (event)
        {
            const frame = document
                .getElementById("current-frame")
                .textContent | 0;

            const scene  = Util.$currentWorkSpace().scene;
            const index  = event.target.dataset.soundId | 0;
            const object = scene._$sounds.get(frame)[index];

            object.loop = event.target.value === "1";
        });
        loop.children[object.loop ? 1 : 0].selected = true;
    }

    /**
     * {HTMLInputElement} element
     * @return {void}
     * @public
     */
    updateSoundVolume (element)
    {
        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const scene  = Util.$currentWorkSpace().scene;
        const index  = element.dataset.soundId | 0;
        const object = scene._$sounds.get(frame)[index];

        object.volume = element.value | 0;
    }

    /**
     * @return {void}
     * @public
     */
    initializeGradient ()
    {
        if (!Util.$hitColor) {
            return ;
        }

        const children = document
            .getElementById("color-pointer-list")
            .children;

        while (children.length) {
            children[0].remove();
        }

        const length = Util.$hitColor.ratios.length;
        for (let idx = 0; idx < length; ++idx) {

            const color = Util.$hitColor.ratios[idx];
            const R = color.R.toString(16).padStart(2, "0");
            const G = color.G.toString(16).padStart(2, "0");
            const B = color.B.toString(16).padStart(2, "0");

            this.addGradientColorPointer(
                idx, color.ratio * 255, `#${R}${G}${B}`, color.A / 255 * 100
            );

            if (idx + 1 === length) {
                document
                    .getElementById("fill-color-value")
                    .value = `#${R}${G}${B}`;

                document
                    .getElementById("fill-alpha-value")
                    .value = color.A / 255 * 100;
            }
        }

        this.updateGradientCanvas();
    }
}

Util.$controller = new Controller();

/**
 * @class
 */
class Publish
{
    /**
     * @return {object}
     * @method
     * @static
     */
    static toObject ()
    {
        const workSpace = Util.$currentWorkSpace();

        const stage = workSpace.stage;
        const libraries = workSpace._$libraries;

        const characters = [];

        // character publish
        for (let [id, instance] of libraries) {

            switch (true) {

                case id === 0: // root
                case instance.symbol !== "": // symbol instance
                case Util.$useIds.has(id): // use character
                    {
                        const object = instance.toPublish();
                        if (object.symbol) {
                            Util.$symbols.set(object.symbol, characters.length);
                        }

                        characters[id] = object;
                    }
                    break;

                default:
                    characters[id] = null;
                    break;

            }

        }

        let size = Util.$useIds.size;
        for (;;) {

            for (let [id, instance] of libraries) {

                if (characters[id]) {
                    continue;
                }

                if (!Util.$useIds.has(id)) {
                    continue;
                }

                const object = instance.toPublish();
                if (object.symbol) {
                    Util.$symbols.set(object.symbol, characters.length);
                }

                characters[id] = object;
            }

            if (size === Util.$useIds.size) {
                break;
            }

            // update
            size = Util.$useIds.size;
        }

        return {
            "stage": {
                "width": stage.width,
                "height": stage.height,
                "fps": stage.fps,
                "bgColor": stage.bgColor
            },
            "characters": characters
        };
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static toJSON ()
    {
        if (Util.$symbols.size) {
            Util.$symbols.clear();
        }

        const object   = Publish.toObject();
        object.symbols = Array.from(Util.$symbols);
        object.type    = "json";

        return JSON.stringify(object);
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static toZlib ()
    {
        if (Util.$symbols.size) {
            Util.$symbols.clear();
        }

        const object   = Publish.toObject();
        object.symbols = Array.from(Util.$symbols);

        const postData = {
            "object": JSON.stringify(object),
            "type": "json"
        };

        if (Util.$zlibWorkerActive) {

            Util.$zlibQueues.push(postData);

        } else {

            Util.$zlibWorkerActive = true;
            Util.$zlibWorker.postMessage(postData);

        }
    }

    /**
     * @return {array}
     * @method
     * @static
     */
    static toWebM ()
    {
        const canvas = document.getElementById("__next2d__").children[0];
        const stream = canvas.captureStream(
            document.getElementById("stage-fps").value | 0
        );

        const chunks   = [];
        const mimeType = "video/webm;codecs=h264";
        const recorder = new MediaRecorder(stream, { "mimeType" : mimeType });

        recorder.addEventListener("dataavailable", (event) =>
        {
            chunks.push(event.data);
        });

        recorder.addEventListener("stop", () =>
        {
            Util.$hidePreview();

            const anchor    = document.getElementById("save-anchor");
            anchor.download = `${Util.$currentWorkSpace().name}.webm`;
            anchor.href     = URL.createObjectURL(new Blob(chunks, { "type" : mimeType }));
            anchor.click();
        });

        const watch = function ()
        {
            if (!Util.$root.numChildren) {
                requestAnimationFrame(watch);
                return ;
            }

            if (Util.$root.currentFrame >= Util.$root.totalFrames) {
                return recorder.stop();
            }

            requestAnimationFrame(watch);
        };
        watch();

        Util.$showPreview();
        recorder.start(0);
    }

    /**
     * @param  {number} [repeat=0]
     * @return {void}
     * @method
     * @static
     */
    static toGIF (repeat = 0)
    {
        const gif = new GIF({
            "repeat": repeat,
            "workerScript": "./assets/js/gif.worker.js"
        });

        gif.on("finished", (blob) =>
        {
            const anchor    = document.getElementById("save-anchor");
            anchor.download = `${Util.$currentWorkSpace().name}.gif`;
            anchor.href     = URL.createObjectURL(blob);
            anchor.click();
        });

        const watch = function ()
        {
            if (!Util.$root.numChildren) {
                requestAnimationFrame(watch);
                return ;
            }

            const canvas = document.getElementById("__next2d__").children[0];

            const cloneCanvas  = document.createElement("canvas");
            cloneCanvas.width  = canvas.width;
            cloneCanvas.height = canvas.height;

            const context = cloneCanvas.getContext("2d");
            context.drawImage(canvas, 0, 0, canvas.width, canvas.height);

            gif.addFrame(context.canvas, { "delay": 20 });

            if (Util.$root.currentFrame >= Util.$root.totalFrames) {
                Util.$hidePreview();
                gif.render();
                return;
            }

            requestAnimationFrame(watch);
        };
        watch();

        Util.$showPreview();
    }

    /**
     * @return {void}
     * @method
     * @static
     */
    static toPng ()
    {
        const snapshot = () =>
        {
            if (!Util.$root.numChildren) {
                requestAnimationFrame(snapshot);
                return ;
            }

            const stage = Util.$root.stage;
            if (!stage) {
                requestAnimationFrame(snapshot);
                return ;
            }

            const player = stage._$player;
            if (player._$stopFlag) {
                requestAnimationFrame(snapshot);
                return ;
            }

            const canvas    = document.getElementById("__next2d__").children[0];
            const anchor    = document.getElementById("save-anchor");
            anchor.download = `${Util.$currentWorkSpace().name}.png`;
            anchor.href     = canvas.toDataURL();
            anchor.click();

            Util.$hidePreview();
        };
        snapshot();

        Util.$showPreview();
    }

    /**
     * @param  {boolean} [loop = true]
     * @return {void}
     * @method
     * @static
     */
    static toApng (loop = true)
    {
        const buffer = [];
        let currentFrame = 0;
        const watch = () =>
        {
            const player = Util.$root.stage._$player;
            if (player._$stopFlag
                || !Util.$root.numChildren
                || currentFrame === Util.$root.currentFrame
            ) {
                requestAnimationFrame(watch);
                return ;
            }

            currentFrame = Util.$root.currentFrame;
            const canvas = document.getElementById("__next2d__").children[0];

            const cloneCanvas  = document.createElement("canvas");
            cloneCanvas.width  = canvas.width;
            cloneCanvas.height = canvas.height;

            const context = cloneCanvas.getContext("2d");
            context.drawImage(canvas, 0, 0, canvas.width, canvas.height);
            canvas.toBlob((blob) => { buffer.push(blob) });

            if (buffer.length + 1 === Util.$root.totalFrames) {

                Util.$hidePreview();

                return new ApngEncoder(
                    buffer, canvas.width, canvas.height,
                    document.getElementById("stage-fps").value | 0,
                    loop
                )
                    .encode()
                    .then((blob) =>
                    {
                        const anchor    = document.getElementById("save-anchor");
                        anchor.download = `${Util.$currentWorkSpace().name}.apng`;
                        anchor.href     = URL.createObjectURL(blob);
                        anchor.click();
                    });

            }

            requestAnimationFrame(watch);
        };
        watch();

        Util.$showPreview();
    }

}

/**
 * @class
 */
class Screen
{
    /**
     * @constructor
     */
    constructor()
    {
        this._$handler = this.initialize.bind(this);
        window.addEventListener("DOMContentLoaded", this._$handler);

        // params
        this.clear();
    }

    /**
     * @return {void}
     * @public
     */
    clear ()
    {
        this.clearActiveCharacter();

        this._$dropTab            = null;
        this._$rectPosition       = null;
        this._$offsetPosition     = null;
        this._$menuMode           = false;
        this._$objectClicked      = false;
        this._$inputMode          = false;
        this._$penMode            = false;
        this._$bucketMode         = false;
        this._$rectMode           = false;
        this._$drawMode           = false;
        this._$drawType           = null;
        this._$textMode           = false;
        this._$multiMode          = false;
        this._$moveMode           = false;
        this._$saved              = true;
        this._$selectId           = 0;
        this._$gridMode           = 0;
        this._$transformMode      = 0;
        this._$positionX          = null;
        this._$positionY          = null;
        this._$baseX              = null;
        this._$baseY              = null;
        this._$baseRotate         = null;
        this._$moveTargets        = [];
        this._$instances          = [];
        this._$tweenMode          = false;
        this._$tweenController    = null;
        this._$tweenDelete        = null;
        this._$cursorCache        = null;
        this._$shapeTransformMode = false;
        this._$shapeMovePointer   = false;
        this._$shapeMoveTarget    = null;
        this._$shapeAddPointer    = false;
        this._$currentZoom        = 0;
    }

    /**
     * @return {void}
     * @public
     */
    initialize ()
    {
        Util.$setCursor("auto");

        // end event
        window.removeEventListener("DOMContentLoaded", this._$handler);

        // drop event
        const screen = document.getElementById("screen");

        screen.addEventListener("dragover", function (event)
        {
            event.preventDefault();
        });

        screen.addEventListener("drop", function (event)
        {
            event.preventDefault();

            if (Util.$dragElement) {
                this.dropObject(event);
            }

        }.bind(this));

        screen.addEventListener("mousedown", function (event)
        {
            this._$shapeAddPointer = false;
            Util.$canCopyLayer = false;

            Util.$endMenu();
            if (this._$inputMode) {
                return ;
            }

            if (this._$objectClicked) {

                this._$objectClicked = false;

            } else {

                Util.$keyLock      = false;
                Util.$activeScript = false;
                Util.$controller.showStageSetting();

                document.getElementById("object-name").blur();
                document.getElementById("object-symbol").blur();

                if (this._$tweenMode) {

                    this._$offsetPosition = {
                        "x": event.offsetX,
                        "y": event.offsetY
                    };

                    return ;
                }

                if (Util.$tools._$activeTool) {

                    switch (Util.$tools._$activeTool.dataset.name) {

                        case "arrow":
                            this._$rectMode = true;
                            break;

                        case "draw-rectangle":
                        case "draw-circle":
                        case "draw-round-rect":

                            this._$drawMode = true;
                            this._$drawType = Util.$tools._$activeTool.dataset.name;
                            break;

                        case "draw-text":
                            this._$textMode = true;
                            break;

                        case "transform":
                            this._$shapeTransformMode = true;
                            break;

                        case "draw-pen":
                            this._$penMode = true;
                            break;

                        case "color-bucket":
                            this._$bucketMode = true;
                            break;

                        default:
                            break;

                    }

                    if (this._$rectMode || this._$drawMode || this._$textMode) {

                        this._$rectPosition = {
                            "x": event.pageX,
                            "y": event.pageY
                        };

                        let offsetX = event.offsetX;
                        let offsetY = event.offsetY;
                        if (event.target.id !== "stage-area") {
                            offsetX += event.target.offsetLeft;
                            offsetY += event.target.offsetTop;
                        }

                        this._$offsetPosition = {
                            "x": offsetX,
                            "y": offsetY
                        };

                        // init
                        let element = null;
                        switch (true) {

                            case this._$rectMode:
                                element = document.getElementById("stage-rect");
                                break;

                            case this._$drawMode:
                                element = document.getElementById("draw-rect");
                                break;

                            case this._$textMode:
                                element = document.getElementById("draw-text");
                                break;

                            default:
                                break;

                        }

                        element.style.left    = `${event.pageX}px`;
                        element.style.top     = `${event.pageY}px`;
                        element.style.width   = "0px";
                        element.style.height  = "0px";
                        element.style.display = "";

                        if (this._$textMode) {
                            element.style.border = "1px dashed gray";
                        }

                        if (this._$drawMode) {

                            // fill color
                            element.style.background = document.getElementById("fill-color").value;

                            // stroke reset
                            element.style.borderRadius = "";
                            element.style.border       = "";

                            const strokeSize = document.getElementById("stroke-size").value | 0;
                            if (strokeSize) {
                                element.style.borderRadius = `${strokeSize}px`;
                                element.style.border       = `${strokeSize}px solid ${document.getElementById("stroke-color").value}`;
                            }

                        }
                    }

                    if (this._$penMode) {

                        Util.$clearPenPointer();

                        let offsetX = event.offsetX;
                        let offsetY = event.offsetY;
                        if (event.target.id !== "stage-area") {
                            offsetX += event.target.offsetLeft;
                            offsetY += event.target.offsetTop;
                        }

                        this._$offsetPosition = {
                            "x": offsetX,
                            "y": offsetY
                        };
                    }
                }

                if (this._$drawMode
                    || this._$textMode
                    || this._$shapeTransformMode
                    || this._$penMode
                    || this._$bucketMode
                ) {
                    return ;
                }

                // end multi mode
                if (!this._$multiMode) {

                    this.clearActiveCharacter();

                    Util.$controller.hideObjectArea();
                    Util.$controller.showObjectSetting([
                        "object-setting",
                        "color-setting",
                        "blend-setting",
                        "filter-setting"
                    ]);

                    const scene = Util.$currentWorkSpace().scene;

                    document
                        .getElementById("object-name")
                        .value = scene.name;

                    document
                        .getElementById("object-symbol")
                        .value = scene.symbol;

                }

                Util.$timeline.resetFrames();

                const layerElement = Util.$timeline._$targetLayer;
                if (layerElement) {
                    layerElement
                        .classList
                        .remove("active");
                }
                Util.$timeline._$targetLayer = null;

            }

        }.bind(this));

        screen.addEventListener("dblclick", function (event)
        {
            if (this._$inputMode) {
                return ;
            }

            if (this._$shapeTransformMode && !this._$shapeAddPointer) {

                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                let target = null;
                let minDistance = Number.MAX_VALUE;

                const children = document
                    .getElementById("stage-area")
                    .children;

                const workSpace = Util.$currentWorkSpace();
                const scene     = workSpace.scene;

                let px = event.offsetX;
                let py = event.offsetY;
                if (event.target.id !== "stage-area") {

                    const layerId     = event.target.dataset.layerId | 0;
                    const characterId = event.target.dataset.characterId | 0;
                    const layer       = scene.getLayer(layerId);
                    const character   = layer.getCharacter(characterId);

                    px = character.screenX + Util.$offsetLeft + event.offsetX;
                    py = character.screenY + Util.$offsetTop  + event.offsetY;
                }

                for (let idx = 0; idx < children.length; ++idx) {

                    const node = children[idx];
                    if (!node.dataset.shapePointer) {
                        continue;
                    }

                    if (node.dataset.curve === "true") {
                        continue;
                    }

                    const distance = Math.sqrt(
                        Math.pow(node.offsetLeft - px, 2)
                        + Math.pow(node.offsetTop - py, 2)
                    );

                    if (minDistance > distance) {
                        target = node;
                    }
                    minDistance = Math.min(minDistance, distance);
                }

                if (!target) {
                    return ;
                }

                const instance = workSpace.getLibrary(
                    target.dataset.libraryId | 0
                );
                if (!instance) {
                    return ;
                }

                const targets  = [];
                const position = target.dataset.position | 0;

                for (let idx = position + 1; idx < children.length; ++idx) {

                    const node = children[idx];
                    if (node.dataset.curve === "true") {
                        continue;
                    }

                    targets.push(node);
                    break;
                }

                if (!targets.length) {

                    for (let idx = 0; idx < children.length; ++idx) {

                        const node = children[idx];
                        if (!node.dataset.shapePointer) {
                            continue;
                        }

                        if (node.dataset.curve === "true") {
                            continue;
                        }

                        targets.push(node);
                        break;
                    }

                }

                for (let idx = position - 1; ; --idx) {

                    const node = children[idx];
                    if (!node.dataset.shapePointer) {
                        break;
                    }

                    if (node.dataset.curve === "true") {
                        continue;
                    }

                    targets.push(node);
                    break;
                }

                if (targets.length === 1) {
                    for (let idx = children.length - 1; ; --idx) {

                        const node = children[idx];
                        if (!node.dataset.shapePointer) {
                            break;
                        }

                        if (node.dataset.curve === "true") {
                            continue;
                        }

                        targets.push(node);
                        break;
                    }
                }

                let nextTarget = null;
                minDistance = Number.MAX_VALUE;
                for (let idx = 0; idx < targets.length; ++idx) {

                    const node = targets[idx];

                    const distance = Math.sqrt(
                        Math.pow(node.offsetLeft - px, 2)
                        + Math.pow(node.offsetTop - py, 2)
                    );

                    if (minDistance > distance) {
                        nextTarget = node;
                    }
                    minDistance = Math.min(minDistance, distance);
                }

                const { Graphics } = window.next2d.display;
                const layerId      = target.dataset.layerId | 0;
                const characterId  = target.dataset.characterId | 0;
                const layer        = scene.getLayer(layerId);
                const character    = layer.getCharacter(characterId);
                const matrix       = character.getPlace(frame).matrix;

                const xScale = Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
                const yScale = Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

                const index     = target.dataset.index | 0;
                const nextIndex = nextTarget.dataset.index | 0;
                if (nextIndex > index) {

                    instance._$recodes.splice(index + 2, 0,
                        Graphics.LINE_TO,
                        (px - Util.$offsetLeft - character.screenX + instance._$bounds.xMin) / xScale,
                        (py - Util.$offsetTop  - character.screenY + instance._$bounds.yMin) / yScale
                    );

                } else {

                    instance._$recodes.splice(nextIndex + 2, 0,
                        Graphics.LINE_TO,
                        (px - Util.$offsetLeft - character.screenX + instance._$bounds.xMin) / xScale,
                        (py - Util.$offsetTop  - character.screenY + instance._$bounds.yMin) / yScale
                    );

                }

                // pointer remove
                for (let idx = 0; idx < children.length; ++idx) {

                    const node = children[idx];
                    if (!node.dataset.shapePointer) {
                        continue;
                    }

                    if (node.dataset.curve === "true") {
                        continue;
                    }

                    node.remove();
                    --idx;
                }

                const bounds = instance.reloadBounds(
                    Util.$hitColor ? Util.$hitColor.width | 0 : 0
                );
                instance._$bounds.xMin = bounds.xMin;
                instance._$bounds.xMax = bounds.xMax;
                instance._$bounds.yMin = bounds.yMin;
                instance._$bounds.yMax = bounds.yMax;
                instance.cacheClear();

                scene.changeFrame(frame);

                if (character) {
                    const matrix = character.getPlace(frame).matrix;
                    instance.createPointer(matrix, layerId, characterId);
                }

                return ;
            }

            if (this._$objectClicked) {
                this._$objectClicked = false;
                return ;
            }

            if (this._$moveTargets.length) {
                return ;
            }

            const node = document
                .getElementById("scene-name-menu-list")
                .lastElementChild;

            if (node) {

                const frame = node.dataset.frame | 0;

                document
                    .getElementById("current-frame")
                    .textContent = `${frame}`;

                const workSpace = Util.$currentWorkSpace();
                workSpace.scene = workSpace.getLibrary(
                    node.dataset.libraryId | 0
                );

                const moveX = (frame - 1) * 13;
                document
                    .getElementById("timeline-marker")
                    .style
                    .left = `${moveX}px`;

                const base = document
                    .getElementById("timeline-controller-base");

                const x = moveX > base.offsetWidth / 2
                    ? moveX - base.offsetWidth / 2
                    : 0;
                Util.$timeline.moveTimeLine(x);

                node.remove();
            }

        }.bind(this));

        screen.addEventListener("mouseover", function ()
        {
            if (this._$cursorCache) {
                Util.$setCursor(this._$cursorCache);
            }
        }.bind(this));

        screen.addEventListener("mouseleave", function ()
        {
            this._$cursorCache        = Util.$currentCursor === "auto" ? null : Util.$currentCursor;
            this._$rectMode           = false;
            this._$drawMode           = false;
            this._$textMode           = false;
            this._$shapeTransformMode = false;
            this._$rectPosition       = null;
            this._$offsetPosition     = null;
            document.getElementById("stage-rect").style.display = "none";
            document.getElementById("draw-rect").style.display  = "none";
            Util.$setCursor("auto");
        }.bind(this));

        screen.addEventListener("mousewheel", function (event)
        {
            if (event.ctrlKey && !event.metaKey // windows
                || !event.ctrlKey && event.metaKey // mac
            ) {

                event.preventDefault();

                const delta = event.deltaX || event.deltaY;
                if (delta) {
                    window.requestAnimationFrame(
                        this.executeZoom.bind(this, delta / 100 * -1)
                    );
                }

                return false;

            }

        }.bind(this), { "passive" : false });

        window.addEventListener("mousemove", function (event)
        {
            if (this._$rectMode) {

                window.requestAnimationFrame(function (event)
                {
                    if (!this._$rectPosition) {
                        return ;
                    }

                    event.preventDefault();

                    const x = event.pageX;
                    const y = event.pageY;

                    const element = document.getElementById("stage-rect");

                    if (this._$rectPosition.x > x) {
                        element.style.left = `${x}px`;
                    }
                    if (this._$rectPosition.y > y) {
                        element.style.top = `${y}px`;
                    }

                    element.style.width  = `${Math.abs(x - this._$rectPosition.x)}px`;
                    element.style.height = `${Math.abs(y - this._$rectPosition.y)}px`;

                }.bind(this, event));

            }

            if (this._$textMode) {

                window.requestAnimationFrame(function (event)
                {
                    if (!this._$rectPosition) {
                        return ;
                    }

                    event.preventDefault();

                    const x = event.pageX;
                    const y = event.pageY;

                    const element = document.getElementById("draw-text");

                    if (this._$rectPosition.x > x) {
                        this._$offsetPosition.x = event.offsetX;
                        element.style.left = `${x}px`;
                    }
                    if (this._$rectPosition.y > y) {
                        this._$offsetPosition.y = event.offsetY;
                        element.style.top = `${y}px`;
                    }

                    element.style.width  = `${Math.abs(x - this._$rectPosition.x)}px`;
                    element.style.height = `${Math.abs(y - this._$rectPosition.y)}px`;

                }.bind(this, event));

            }

            if (this._$drawMode) {

                window.requestAnimationFrame(function (event)
                {
                    if (!this._$rectPosition) {
                        return ;
                    }

                    event.preventDefault();

                    const x = event.pageX;
                    const y = event.pageY;

                    const element = document.getElementById("draw-rect");
                    if (Util.$tools._$activeTool.dataset.name === "draw-circle") {
                        element.style.borderRadius = "50%";
                    }

                    if (Util.$shiftKey) {

                        const max = Math.max(
                            Math.abs(x - this._$rectPosition.x),
                            Math.abs(y - this._$rectPosition.y)
                        );

                        if (this._$rectPosition.x < x) {
                            element.style.left = `${this._$rectPosition.x}px`;
                        }
                        if (this._$rectPosition.y < y) {
                            element.style.top = `${this._$rectPosition.y}px`;
                        }

                        if (this._$rectPosition.x > x) {
                            this._$offsetPosition.x = event.offsetX;
                            element.style.left = `${this._$rectPosition.x - max}px`;
                        }
                        if (this._$rectPosition.y > y) {
                            this._$offsetPosition.y = event.offsetY;
                            element.style.top = `${this._$rectPosition.y - max}px`;
                        }

                        element.style.width  = `${max}px`;
                        element.style.height = `${max}px`;

                    } else {

                        if (this._$rectPosition.x > x) {
                            this._$offsetPosition.x = event.offsetX;
                            element.style.left = `${x}px`;
                        }
                        if (this._$rectPosition.y > y) {
                            this._$offsetPosition.y = event.offsetY;
                            element.style.top = `${y}px`;
                        }

                        element.style.width  = `${Math.abs(x - this._$rectPosition.x)}px`;
                        element.style.height = `${Math.abs(y - this._$rectPosition.y)}px`;

                    }

                    if (Util.$tools._$activeTool.dataset.name === "draw-round-rect") {
                        const min = Math.min(
                            parseFloat(element.style.width),
                            parseFloat(element.style.height)
                        );
                        element.style.borderRadius = `${min / 8 | 0}px`;
                    }

                }.bind(this, event));

            }

            if (this._$gridMode) {

                window.requestAnimationFrame(function (event)
                {
                    if (!this._$saved) {
                        this._$saved = true;

                        Util
                            .$currentWorkSpace()
                            .temporarilySaved();
                    }

                    event.preventDefault();

                    const dx = event.pageX - this._$positionX;
                    const dy = event.pageY - this._$positionY;

                    let x = +document
                        .getElementById("nine-slice-setting-x")
                        .value;

                    let y = +document
                        .getElementById("nine-slice-setting-y")
                        .value;

                    let w = +document
                        .getElementById("nine-slice-setting-w")
                        .value;

                    let h = +document
                        .getElementById("nine-slice-setting-h")
                        .value;

                    switch (this._$gridMode) {

                        case 1:
                            x += dx;
                            w -= dx;
                            y += dy;
                            h -= dy;
                            break;

                        case 2:
                            w += dx;
                            y += dy;
                            break;

                        case 3:
                            x += dx;
                            w -= dx;
                            h += dy;
                            break;

                        case 4:
                            w += dx;
                            h += dy;
                            break;

                    }

                    document
                        .getElementById("nine-slice-setting-x")
                        .value = `${x}`;

                    document
                        .getElementById("nine-slice-setting-y")
                        .value = `${y}`;

                    document
                        .getElementById("nine-slice-setting-w")
                        .value = `${w}`;

                    document
                        .getElementById("nine-slice-setting-h")
                        .value = `${h}`;

                    this._$positionX = event.pageX;
                    this._$positionY = event.pageY;

                    this.updateShapeGrid();

                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    const scene = Util.$currentWorkSpace().scene;
                    scene.changeFrame(frame);

                }.bind(this, event));
            }

            if (this._$transformMode) {

                window.requestAnimationFrame(function (event)
                {

                    if (!this._$saved) {
                        this._$saved = true;

                        Util
                            .$currentWorkSpace()
                            .temporarilySaved();
                    }

                    event.preventDefault();

                    switch (this._$transformMode) {

                        // left top
                        // scaleX and scaleY
                        case 1:

                            if (Math.max(
                                this.updateLeftScaleX(event),
                                this.updateTopScaleY(event)
                            )) {

                                if (Util.$shiftKey) {
                                    this.adjustmentScale();
                                }

                                const frame = document
                                    .getElementById("current-frame")
                                    .textContent | 0;

                                const scene = Util.$currentWorkSpace().scene;
                                scene.changeFrame(frame);

                            }
                            break;

                        // left center
                        case 2:
                            if (this.updateLeftScaleX(event)) {
                                const frame = document
                                    .getElementById("current-frame")
                                    .textContent | 0;

                                const scene = Util.$currentWorkSpace().scene;
                                scene.changeFrame(frame);
                            }
                            break;

                        // left bottom
                        // scaleX and scaleY
                        case 3:

                            if (Math.max(
                                this.updateLeftScaleX(event),
                                this.updateBottomScaleY(event)
                            )) {

                                if (Util.$shiftKey) {
                                    this.adjustmentScale();
                                }

                                const frame = document
                                    .getElementById("current-frame")
                                    .textContent | 0;

                                const scene = Util.$currentWorkSpace().scene;
                                scene.changeFrame(frame);
                            }
                            break;

                        // top center
                        case 4:
                            if (this.updateTopScaleY(event)) {
                                const frame = document
                                    .getElementById("current-frame")
                                    .textContent | 0;

                                const scene = Util.$currentWorkSpace().scene;
                                scene.changeFrame(frame);
                            }
                            break;

                        // right top
                        // scaleX and scaleY
                        case 5:
                            if (Math.max(
                                this.updateRightScaleX(event),
                                this.updateTopScaleY(event)
                            )) {

                                if (Util.$shiftKey) {
                                    this.adjustmentScale();
                                }

                                const frame = document
                                    .getElementById("current-frame")
                                    .textContent | 0;

                                const scene = Util.$currentWorkSpace().scene;
                                scene.changeFrame(frame);

                            }
                            break;

                        // right center
                        case 6:
                            if (this.updateRightScaleX(event)) {
                                const frame = document
                                    .getElementById("current-frame")
                                    .textContent | 0;

                                const scene = Util.$currentWorkSpace().scene;
                                scene.changeFrame(frame);
                            }
                            break;

                        // right bottom
                        // scaleX and scaleY
                        case 7:
                            if (Math.max(
                                this.updateRightScaleX(event),
                                this.updateBottomScaleY(event)
                            )) {

                                if (Util.$shiftKey) {
                                    this.adjustmentScale();
                                }

                                const frame = document
                                    .getElementById("current-frame")
                                    .textContent | 0;

                                const scene = Util.$currentWorkSpace().scene;
                                scene.changeFrame(frame);

                            }
                            break;

                        // bottom center
                        case 8:
                            if (this.updateBottomScaleY(event)) {
                                const frame = document
                                    .getElementById("current-frame")
                                    .textContent | 0;

                                const scene = Util.$currentWorkSpace().scene;
                                scene.changeFrame(frame);
                            }
                            break;

                        case 9:
                            {
                                const minElement = document
                                    .getElementById("scale-top-left");

                                const xMin = minElement.offsetLeft;
                                const yMin = minElement.offsetTop;

                                const maxElement = document
                                    .getElementById("scale-bottom-right");

                                const xMax = maxElement.offsetLeft;
                                const yMax = maxElement.offsetTop;

                                const centerX = xMin + (xMax - xMin) / 2;
                                const centerY = yMin + (yMax - yMin) / 2;

                                const mouseX = this._$baseX + event.pageX - this._$positionX;
                                const mouseY = this._$baseY + event.pageY - this._$positionY;

                                const rotateX = Math.atan2(
                                    mouseY - centerY,
                                    mouseX - centerX
                                ) * 180 / Math.PI + 315;

                                if (rotateX) {

                                    let rotate = (this._$baseRotate + rotateX) % 360;
                                    if (0 > rotate) {
                                        rotate += 360;
                                    }

                                    this.updateRotate(rotate);

                                    document
                                        .getElementById("transform-rotate")
                                        .value = rotate;

                                    const frame = document
                                        .getElementById("current-frame")
                                        .textContent | 0;

                                    Util
                                        .$currentWorkSpace()
                                        .scene
                                        .changeFrame(frame);
                                }
                            }
                            break;

                    }

                }.bind(this, event));

            }

            if (this._$shapeMovePointer) {

                window.requestAnimationFrame(function (event)
                {
                    if (!this._$rectPosition || !this._$shapeMoveTarget) {
                        return ;
                    }

                    const element   = this._$shapeMoveTarget;
                    const workSpace = Util.$currentWorkSpace();
                    const instance  = workSpace.getLibrary(
                        element.dataset.libraryId | 0
                    );
                    if (!instance) {
                        this._$shapeMovePointer = false;
                        this._$shapeMoveTarget  = null;
                        Util.$clearShapePointer();
                        return ;
                    }

                    event.preventDefault();

                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    const layerId     = element.dataset.layerId | 0;
                    const characterId = element.dataset.characterId | 0;

                    const scene       = workSpace.scene;
                    const layer       = scene.getLayer(layerId);
                    const character   = layer.getCharacter(characterId);
                    const matrix      = character.getPlace(frame).matrix;

                    const x = event.pageX - this._$rectPosition.x;
                    const y = event.pageY - this._$rectPosition.y;

                    const angle  = Math.atan2(matrix[1], matrix[0]) * Util.$Rad2Deg;
                    const scaleX = Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
                    const scaleY = Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

                    let tx = (x - element.offsetLeft) / scaleX;
                    let ty = (y - element.offsetTop)  / scaleY;
                    if (angle) {
                        const rad = (360 - angle) * (Math.PI / 180);
                        tx *= Math.cos(rad);
                        ty *= Math.sin(rad);
                    }

                    const index = element.dataset.index | 0;
                    instance._$recodes[index    ] += tx;
                    instance._$recodes[index + 1] += ty;

                    const syncId = element.dataset.syncId | 0;
                    if (syncId) {
                        instance._$recodes[syncId    ] += tx;
                        instance._$recodes[syncId + 1] += ty;
                    }

                    element.style.left = `${x}px`;
                    element.style.top  = `${y}px`;

                    const bounds = instance.reloadBounds(
                        Util.$hitColor ? Util.$hitColor.width | 0 : 0
                    );
                    instance._$bounds.xMin = bounds.xMin;
                    instance._$bounds.xMax = bounds.xMax;
                    instance._$bounds.yMin = bounds.yMin;
                    instance._$bounds.yMax = bounds.yMax;
                    instance.cacheClear();

                    scene.changeFrame(frame);

                }.bind(this, event));

            }

            if (this._$tweenController) {
                window.requestAnimationFrame(function (event)
                {
                    if (!this._$rectPosition) {
                        return ;
                    }

                    event.preventDefault();

                    const element = this._$tweenController;

                    const x = event.pageX - this._$rectPosition.x;
                    const y = event.pageY - this._$rectPosition.y;

                    const layer = Util.$currentWorkSpace().scene.getLayer(
                        element.dataset.layerId | 0
                    );

                    const frame = element.dataset.tweenIndex | 0;
                    const character = layer.getActiveCharacter(frame)[0];

                    // set select
                    const matrix     = character.getPlace(frame).matrix;
                    const baseBounds = character.getBounds();
                    const bounds     = Util.$boundsMatrix(baseBounds, matrix);
                    const width      = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2);
                    const height     = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2);

                    const tween = character.getTween();
                    const point = tween.curve[element.dataset.index];

                    point.x = x - Util.$offsetLeft - width  - baseBounds.xMin;
                    point.y = y - Util.$offsetTop  - height - baseBounds.yMin;

                    element.style.left = `${Util.$offsetLeft + point.x + baseBounds.xMin + width}px`;
                    element.style.top  = `${Util.$offsetTop  + point.y + baseBounds.yMin + height}px`;

                    this.executeTween(layer);
                    this.createTweenMarker();

                    Util.$currentWorkSpace().scene.changeFrame(
                        document
                            .getElementById("current-frame")
                            .textContent | 0
                    );

                }.bind(this, event));
            }

            if (this._$penMode) {
                const width = document.getElementById("stroke-size").value | 0;
                if (width) {
                    window.requestAnimationFrame(function (event)
                    {
                        event.preventDefault();

                        let x = event.offsetX;
                        let y = event.offsetY;
                        if (event.target.id !== "stage-area") {
                            x += event.target.offsetLeft;
                            y += event.target.offsetTop;
                        }

                        const element = document.getElementById("stage-area");

                        const div = document.createElement("div");
                        div.dataset.penPointer = "true";
                        div.classList.add("pen-pointer");

                        div.style.width           = `${width}px`;
                        div.style.height          = `${width}px`;
                        div.style.left            = `${x}px`;
                        div.style.top             = `${y}px`;
                        div.style.backgroundColor = document.getElementById("stroke-color").value;
                        div.style.borderRadius    = `${width / 2}px`;

                        element.appendChild(div);

                    }.bind(this, event));
                }
            }

            if (!this._$moveMode) {
                return ;
            }

            if (!this._$multiMode && this._$moveTargets.length) {

                window.requestAnimationFrame(function (event)
                {

                    if (!this._$saved) {
                        this._$saved = true;

                        Util
                            .$currentWorkSpace()
                            .temporarilySaved();
                    }

                    Util.$setCursor("move");

                    event.preventDefault();

                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    const workSpace = Util.$currentWorkSpace();
                    const scene = workSpace.scene;

                    let xMin = Number.MAX_VALUE;
                    let yMin = Number.MAX_VALUE;
                    for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                        const object  = this._$moveTargets[idx];
                        const element = object.target;
                        const layerId = element.dataset.layerId | 0;

                        const layer = scene.getLayer(layerId);

                        const character = layer
                            .getCharacter(element.dataset.characterId | 0);

                        // fixed logic
                        this.initPlace(character, layerId, frame);

                        // calc
                        const dx = event.pageX - object.moveX;
                        const dy = event.pageY - object.moveY;

                        const matrix = character.getPlace(frame).matrix;

                        const tx = dx - parseFloat(element.style.left);
                        const ty = dy - parseFloat(element.style.top);

                        matrix[4] += tx;
                        matrix[5] += ty;
                        character.screenX += tx;
                        character.screenY += ty;

                        if (layer.maskId !== null) {
                            const maskLayer = scene.getLayer(layer.maskId);
                            if (maskLayer.lock && maskLayer._$characters.length) {
                                const maskCharacter = maskLayer._$characters[0];
                                const x = maskCharacter.screenX - character.screenX;
                                const y = maskCharacter.screenY - character.screenY;
                                element.style.webkitMaskPosition = `${x}px ${y}px`;
                            }
                        }

                        element.style.left = `${dx}px`;
                        element.style.top  = `${dy}px`;

                        // move resize rect
                        xMin = Math.min(xMin, character.x);
                        yMin = Math.min(yMin, character.y);

                        if (layer._$frame.hasClasses(frame)) {

                            const classes = layer
                                ._$frame
                                .getClasses(frame);

                            if (classes.indexOf("tween-frame") > -1) {
                                this.executeTween(layer);
                                this.createTweenMarker();

                                const onionElement = document
                                    .getElementById("timeline-onion-skin");
                                if (onionElement.classList.contains("onion-skin-active")) {
                                    Util.$currentWorkSpace().scene.changeFrame(frame);
                                }
                            }
                        }
                    }

                    document.getElementById("object-x").value = xMin;
                    document.getElementById("object-y").value = yMin;

                    this.placeTransformTarget();
                    this.placeGridTarget();

                }.bind(this, event));

            }

        }.bind(this));

        window.addEventListener("mouseup", function (event)
        {
            if (this._$rectMode) {

                this.clearTweenMarker();

                const element = document.getElementById("stage-rect");
                const left    = parseFloat(element.style.left);
                const top     = parseFloat(element.style.top);
                const right   = left + parseFloat(element.style.width);
                const bottom  = top + parseFloat(element.style.height);

                const children = document
                    .getElementById("stage-area")
                    .children;

                for (let idx = 0; idx < children.length; ++idx) {

                    const node = children[idx];
                    if (!node.dataset.child || node.dataset.child === "tween") {
                        continue;
                    }

                    const rect = node.getBoundingClientRect();
                    switch (true) {

                        case rect.bottom < top:
                        case rect.top    > bottom:
                        case rect.right  < left:
                        case rect.left   > right:
                            continue;

                        default:
                            break;

                    }

                    const layerId = node.dataset.layerId | 0;

                    const lockElement = document
                        .getElementById(`layer-lock-icon-${layerId}`);

                    if (lockElement.classList.contains("icon-active")) {
                        continue;
                    }

                    this.addTarget(node);

                }

                this._$rectMode       = false;
                this._$rectPosition   = null;
                this._$offsetPosition = null;
                element.style.display = "none";

                if (this._$moveTargets.length) {
                    Util.$controller.showObjectArea();
                    this.updatePropertyArea();
                }

            }

            if (this._$textMode) {

                if (!Util.$timeline._$targetLayer) {

                    const parent = document
                        .getElementById("timeline-content");

                    if (!parent.children.length) {
                        return ;
                    }

                    const node = parent.children[0];
                    const layerElement = document
                        .getElementById(`${node.dataset.layerId}-1`);

                    if (!layerElement) {
                        return ;
                    }

                    Util.$timeline._$targetLayer = layerElement;
                }

                const element = document.getElementById("draw-text");
                if (Util.$timeline._$targetLayer) {

                    const x      = this._$offsetPosition.x - Util.$offsetLeft;
                    const y      = this._$offsetPosition.y - Util.$offsetTop;
                    const width  = parseFloat(element.style.width);
                    const height = parseFloat(element.style.height);

                    const id =  Util.$currentWorkSpace().nextLibraryId;
                    this.addTextField({
                        "id": id,
                        "type": "text",
                        "name": `Text_${id}`,
                        "symbol": "",
                        "bounds": {
                            "xMin": 0,
                            "xMax": width,
                            "yMin": 0,
                            "yMax": height
                        },
                        "originBounds": {
                            "xMin": 0,
                            "xMax": width,
                            "yMin": 0,
                            "yMax": height
                        }
                    }, x, y);

                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    const scene = Util.$currentWorkSpace().scene;
                    scene.changeFrame(frame);
                }

                this._$textMode       = false;
                this._$rectPosition   = null;
                this._$offsetPosition = null;
                element.style.display = "none";

                // tool area reset
                Util.$tools.reset();
            }

            if (this._$drawMode) {

                if (!Util.$timeline._$targetLayer) {

                    const parent = document
                        .getElementById("timeline-content");

                    if (!parent.children.length) {
                        return ;
                    }

                    const node = parent.children[0];
                    const layerElement = document
                        .getElementById(`${node.dataset.layerId}-1`);

                    if (!layerElement) {
                        return ;
                    }

                    Util.$timeline._$targetLayer = layerElement;
                }

                const element = document.getElementById("draw-rect");
                if (Util.$timeline._$targetLayer) {

                    const { Graphics } =  window.next2d.display;

                    const strokeSize = document
                        .getElementById("stroke-size")
                        .value | 0;

                    const width  = parseFloat(element.style.width)  + strokeSize;
                    const height = parseFloat(element.style.height) + strokeSize;
                    if (width && height) {

                        // draw
                        const graphics = new Graphics();

                        graphics
                            .beginFill(document.getElementById("fill-color").value, 1);

                        switch (this._$drawType) {

                            case "draw-rectangle":
                                graphics.drawRect(0, 0, width, height);
                                break;

                            case "draw-circle":
                                graphics.drawEllipse(0, 0, width, height);
                                break;

                            case "draw-round-rect":
                                graphics.drawRoundRect(
                                    0, 0, width, height,
                                    Math.min(width, height) / 4
                                );
                                break;

                            default:
                                break;

                        }

                        graphics.endFill();

                        const x  = this._$offsetPosition.x - Util.$offsetLeft;
                        const y  = this._$offsetPosition.y - Util.$offsetTop;
                        const id = Util.$currentWorkSpace().nextLibraryId;

                        this.addShape({
                            "id": id,
                            "type": "shape",
                            "name": `Shape_${id}`,
                            "symbol": "",
                            "recodes": graphics._$recode ? graphics._$recode.slice(0) : [],
                            "bounds": {
                                "xMin": 0,
                                "xMax": width,
                                "yMin": 0,
                                "yMax": height
                            }
                        }, x + strokeSize / 2, y + strokeSize / 2);

                        if (strokeSize) {

                            const graphics = new Graphics();
                            graphics
                                .lineStyle(
                                    strokeSize,
                                    document.getElementById("stroke-color").value
                                );

                            switch (this._$drawType) {

                                case "draw-rectangle":
                                    graphics.drawRect(0, 0, width, height);
                                    break;

                                case "draw-circle":
                                    graphics.drawEllipse(0, 0, width, height);
                                    break;

                                case "draw-round-rect":
                                    graphics.drawRoundRect(
                                        0, 0, width, height,
                                        Math.min(width, height) / 4
                                    );
                                    break;

                                default:
                                    break;

                            }

                            graphics.endLine();

                            const offsetX = Math.abs(graphics._$xMax - graphics._$xMin) - width;
                            const offsetY = Math.abs(graphics._$yMax - graphics._$yMin) - height;

                            const x = this._$offsetPosition.x - Util.$offsetLeft;
                            const y = this._$offsetPosition.y - Util.$offsetTop;

                            const id = Util.$currentWorkSpace().nextLibraryId;

                            this.addShape({
                                "id": id,
                                "type": "shape",
                                "name": `Shape_${id}`,
                                "symbol": "",
                                "recodes": graphics._$recode ? graphics._$recode.slice(0) : [],
                                "bounds": {
                                    "xMin": -offsetX / 2,
                                    "xMax": width + offsetX / 2,
                                    "yMin": -offsetY / 2,
                                    "yMax": height + offsetY / 2
                                }
                            }, x + offsetX / 2, y + offsetY / 2);

                        }

                        const frame = document
                            .getElementById("current-frame")
                            .textContent | 0;

                        const scene = Util.$currentWorkSpace().scene;
                        scene.changeFrame(frame);
                    }
                }

                this._$drawMode       = false;
                this._$rectPosition   = null;
                this._$offsetPosition = null;
                element.style.display = "none";

                // tool area reset
                Util.$tools.reset();
            }

            if (this._$transformMode || this._$gridMode || this._$moveMode) {

                Util.$setCursor("auto");

                // cache clear
                if (this._$moveTargets.length) {

                    const scene = Util.$currentWorkSpace().scene;
                    for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                        const target = this._$moveTargets[idx].target;
                        const layer = scene.getLayer(target.dataset.layerId | 0);

                        const character = layer.getCharacter(target.dataset.characterId | 0);
                        character._$image = null;
                    }

                    this.updatePropertyArea();
                }
            }

            if (this._$penMode) {

                this._$penMode = false;

                if (!Util.$timeline._$targetLayer) {

                    const parent = document
                        .getElementById("timeline-content");

                    if (!parent.children.length) {
                        return ;
                    }

                    const node = parent.children[0];
                    const layerElement = document
                        .getElementById(`${node.dataset.layerId}-1`);

                    if (!layerElement) {
                        return ;
                    }

                    Util.$timeline._$targetLayer = layerElement;
                }

                if (Util.$timeline._$targetLayer) {

                    const { Shape } = window.next2d.display;

                    const thickness = document.getElementById("stroke-size").value | 0;
                    const shape = new Shape();
                    shape.graphics.lineStyle(
                        thickness,
                        document.getElementById("stroke-color").value
                    );

                    const x = this._$offsetPosition.x - Util.$offsetLeft;
                    const y = this._$offsetPosition.y - Util.$offsetTop;
                    shape.graphics.moveTo(0, 0);

                    const element  = document.getElementById("stage-area");
                    const children = element.children;
                    for (let idx = 0; children.length > idx; ++idx) {

                        const node = children[idx];
                        if (!node.dataset.penPointer) {
                            continue;
                        }

                        shape.graphics.lineTo(
                            node.offsetLeft - Util.$offsetLeft - x,
                            node.offsetTop  - Util.$offsetTop  - y
                        );

                        node.remove();
                        --idx;
                    }

                    shape.graphics.endLine();

                    const id = Util.$currentWorkSpace().nextLibraryId;
                    this.addShape({
                        "id": id,
                        "type": "shape",
                        "name": `Shape_${id}`,
                        "symbol": "",
                        "recodes": shape.graphics._$recode.slice(0),
                        "bounds": {
                            "xMin": shape.graphics._$xMin,
                            "xMax": shape.graphics._$xMax,
                            "yMin": shape.graphics._$yMin,
                            "yMax": shape.graphics._$yMax
                        }
                    }, x + thickness / 2, y + thickness / 2);
                }
            }

            if (this._$bucketMode) {

                this._$bucketMode = false;

                const element = event.target;
                if (element.dataset.instanceType === "shape") {

                    const { Graphics } = window.next2d.display;

                    const workSpace = Util.$currentWorkSpace();

                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    const instance = workSpace.getLibrary(
                        element.dataset.libraryId | 0
                    );

                    const color = Util.$intToRGB(
                        `0x${document.getElementById("fill-color").value.substr(1)}` | 0
                    );

                    switch (instance._$recodes[instance._$recodes.length - 1]) {

                        case Graphics.END_FILL:
                            instance._$recodes.splice(
                                instance._$recodes.length - 6,
                                6,
                                Graphics.FILL_STYLE,
                                color.R,
                                color.G,
                                color.B,
                                255,
                                Graphics.END_FILL
                            );
                            break;

                        case Graphics.END_STROKE:
                            instance._$recodes.push(
                                Graphics.FILL_STYLE,
                                color.R,
                                color.G,
                                color.B,
                                255,
                                Graphics.END_FILL
                            );
                            break;

                        default:
                            break;

                    }

                    instance.cacheClear();
                    workSpace.scene.changeFrame(frame);
                }
            }

            if (this._$tweenMode) {
                this._$tweenMode       = false;
                this._$tweenController = null;
                this._$rectPosition    = null;
                this._$offsetPosition  = null;
            }

            // reset
            this._$moveMode         = false;
            this._$gridMode         = 0;
            this._$transformMode    = 0;
            this._$shapeMovePointer = false;

        }.bind(this));

        window.addEventListener("keydown", this.keyCommandFunction.bind(this));

        window.addEventListener("keyup", function (event)
        {
            if (this._$multiMode && !event.shiftKey) {
                this._$multiMode = false;
            }
        }.bind(this));

        const copyElement = document.getElementById("screen-copy");

        copyElement
            .children[0]
            .classList
            .add(Util.$isMac ? "mac-icon" : "win-icon");

        copyElement.addEventListener("mousedown", function (event)
        {
            this.keyCommandFunction({
                "code": "KeyC",
                "ctrlKey": true,
                "metaKey": false,
                "preventDefault": function () { return this.preventDefault() }.bind(event)
            });
        }.bind(this));

        const pasteElement = document.getElementById("screen-paste");
        pasteElement
            .children[0]
            .classList
            .add(Util.$isMac ? "mac-icon" : "win-icon");

        pasteElement.addEventListener("mousedown", function (event)
        {
            this.keyCommandFunction({
                "code": "KeyV",
                "ctrlKey": true,
                "metaKey": false,
                "preventDefault": function () { return this.preventDefault() }.bind(event)
            });
        }.bind(this));

        document
            .getElementById("screen-delete")
            .addEventListener("mousedown", function ()
            {
                this.keyCommandFunction({
                    "code": "Delete"
                });
            }.bind(this));

        const previewElement = document.getElementById("screen-preview");

        previewElement
            .children[0]
            .classList
            .add(Util.$isMac ? "mac-icon" : "win-icon");

        previewElement.addEventListener("mousedown", function (event)
        {
            Util.$keyCommandFunction({
                "code": "Enter",
                "ctrlKey": true,
                "metaKey": false,
                "preventDefault": function () { return this.preventDefault() }.bind(event)
            });
        }.bind(this));

        // zoom event
        this.initializeZoom();

        // context menu event
        this.initializeContextMenu();

        // move resize rect
        this.initializeTransformTarget();

        // init grid
        this.initializeGridTarget();

        // end
        Util.$initializeEnd();
        this._$handler = null;
    }

    /**
     * @param  {number} delta
     * @return {void}
     * @public
     */
    executeZoom (delta)
    {
        Util.$zoomScale += delta;
        Util.$zoomScale = Math.min(3, Math.max(0.25, Util.$zoomScale));

        document
            .getElementById("screen-scale")
            .value = `${(Util.$zoomScale * 100) | 0}`;

        const area = document.getElementById("stage-area");
        area.style.transform = `scale(${Util.$zoomScale})`;

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;
        workSpace.scene = scene;
    }

    /**
     * @return {void}
     * @public
     */
    initializeZoom ()
    {
        const element = document
            .getElementById("screen-scale");

        element.addEventListener("focusin", function (event)
        {
            Util.$keyLock      = true;
            this._$currentZoom = event.target.value | 0;
        }.bind(this));

        element.addEventListener("keypress", function (event)
        {
            if (event.code === "Enter") {
                event.currentTarget.blur();
            }
        });

        element.addEventListener("blur", function (event)
        {
            this.executeZoom((this._$currentZoom - (event.target.value | 0)) / 100 * -1);

            // update
            Util.$keyLock      = false;
            this._$currentZoom = event.target.value | 0;

        }.bind(this));
    }

    /**
     * @param {Event|KeyboardEvent} event
     * @return {boolean}
     * @public
     */
    keyCommandFunction (event)
    {
        if (event.shiftKey) {

            this._$multiMode = true;

            return false;
        }

        if (Util.$keyLock) {
            return false;
        }

        switch (event.code) {

            case "ArrowRight":
                if (this._$moveTargets.length) {

                    const scene = Util.$currentWorkSpace().scene;
                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    let xMin =  Number.MAX_VALUE;
                    let xMax = -Number.MAX_VALUE;
                    let yMin = Number.MAX_VALUE;
                    let yMax = -Number.MAX_VALUE;
                    for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                        const object = this._$moveTargets[idx].target;

                        const left = parseFloat(object.style.left);
                        object.style.left = `${left + 1}px`;

                        const layerId = object.dataset.layerId | 0;
                        const layer   = scene.getLayer(layerId);

                        const characterId = object.dataset.characterId | 0;
                        const character   = layer.getCharacter(characterId);

                        // fixed logic
                        this.initPlace(character, layerId, frame);

                        const place = character.getPlace(frame);

                        place.matrix[4]++;

                        xMin = Math.min(xMin, character.x);
                        xMax = Math.max(xMax, character.x + character.width);
                        yMin = Math.min(yMin, character.y);
                        yMax = Math.max(yMax, character.y + character.height);

                        character._$image = null;
                    }

                    this.placeTransformTarget();
                    this.updatePropertyArea(false);
                }
                break;

            case "ArrowLeft":
                if (this._$moveTargets.length) {

                    const scene = Util.$currentWorkSpace().scene;
                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    let xMin =  Number.MAX_VALUE;
                    let xMax = -Number.MAX_VALUE;
                    let yMin = Number.MAX_VALUE;
                    let yMax = -Number.MAX_VALUE;
                    for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                        const object = this._$moveTargets[idx].target;

                        const left = parseFloat(object.style.left);
                        object.style.left = `${left - 1}px`;

                        const layerId = object.dataset.layerId | 0;
                        const layer   = scene.getLayer(layerId);

                        const characterId = object.dataset.characterId | 0;
                        const character   = layer.getCharacter(characterId);

                        // fixed logic
                        this.initPlace(character, layerId, frame);

                        const place = character.getPlace(frame);

                        place.matrix[4]--;

                        xMin = Math.min(xMin, character.x);
                        xMax = Math.max(xMax, character.x + character.width);
                        yMin = Math.min(yMin, character.y);
                        yMax = Math.max(yMax, character.y + character.height);

                        character._$image = null;
                    }

                    this.placeTransformTarget();
                    this.updatePropertyArea(false);
                }
                break;

            case "ArrowDown":
                if (this._$moveTargets.length) {

                    const scene = Util.$currentWorkSpace().scene;
                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    let xMin =  Number.MAX_VALUE;
                    let xMax = -Number.MAX_VALUE;
                    let yMin = Number.MAX_VALUE;
                    let yMax = -Number.MAX_VALUE;
                    for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                        const object = this._$moveTargets[idx].target;

                        const top = parseFloat(object.style.top);
                        object.style.top = `${top + 1}px`;

                        const layerId = object.dataset.layerId | 0;
                        const layer   = scene.getLayer(layerId);

                        const characterId = object.dataset.characterId | 0;
                        const character   = layer.getCharacter(characterId);

                        this.initPlace(character, layerId, frame);

                        const place = character.getPlace(frame);

                        place.matrix[5]++;

                        xMin = Math.min(xMin, character.x);
                        xMax = Math.max(xMax, character.x + character.width);
                        yMin = Math.min(yMin, character.y);
                        yMax = Math.max(yMax, character.y + character.height);

                        character._$image = null;
                    }

                    this.placeTransformTarget();
                    this.updatePropertyArea(false);
                }
                break;

            case "ArrowUp":
                if (this._$moveTargets.length) {

                    const scene = Util.$currentWorkSpace().scene;
                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    let xMin =  Number.MAX_VALUE;
                    let xMax = -Number.MAX_VALUE;
                    let yMin = Number.MAX_VALUE;
                    let yMax = -Number.MAX_VALUE;
                    for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                        const object = this._$moveTargets[idx].target;

                        const top = parseFloat(object.style.top);
                        object.style.top = `${top - 1}px`;

                        const layerId = object.dataset.layerId | 0;
                        const layer   = scene.getLayer(layerId);

                        const characterId = object.dataset.characterId | 0;
                        const character   = layer.getCharacter(characterId);

                        this.initPlace(character, layerId, frame);

                        const place = character.getPlace(frame);

                        place.matrix[5]--;

                        xMin = Math.min(xMin, character.x);
                        xMax = Math.max(xMax, character.x + character.width);
                        yMin = Math.min(yMin, character.y);
                        yMax = Math.max(yMax, character.y + character.height);

                        character._$image = null;
                    }

                    this.placeTransformTarget();
                    this.updatePropertyArea(false);
                }
                break;

            case "Backspace":
            case "Delete":
                {
                    const scene = Util.$currentWorkSpace().scene;

                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    if (this._$tweenDelete) {

                        const element = this._$tweenDelete;

                        const layer = scene.getLayer(
                            element.dataset.layerId | 0
                        );

                        const character = layer.getActiveCharacter(frame)[0];

                        // set select
                        const tween = character.getTween();
                        tween.curve.splice(element.dataset.index | 0, 1);

                        element.remove();
                        this.clearTweenMarker();
                        if (tween.method === "custom") {
                            Util.$controller.showEaseCanvasArea();
                        }
                        this.executeTween(layer);
                        this.createTweenMarker(false);

                        scene.changeFrame(frame);

                        return ;
                    }

                    if (this._$moveTargets.length) {

                        Util
                            .$currentWorkSpace()
                            .temporarilySaved();

                        for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                            const object = this._$moveTargets[idx];

                            const element = object.target;

                            const layerId = element.dataset.layerId | 0;
                            const layer   = scene.getLayer(layerId);

                            const characterId = element.dataset.characterId | 0;
                            const character   = layer.getCharacter(characterId);

                            if (!character) {
                                continue;
                            }

                            for (let [frame, place] of character._$places) {

                                const depth = place.depth;
                                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                                    const char = layer._$characters[idx];
                                    if (char.id === character.id) {
                                        continue;
                                    }

                                    if (char.hasPlace(frame)) {
                                        const place = char.getPlace(frame);
                                        if (place.depth > depth) {
                                            place.depth--;
                                        }
                                    }
                                }
                            }

                            let done = false;
                            let startFrame = frame;
                            for (;;) {

                                const frameElement = document
                                    .getElementById(`${layerId}-${startFrame}`);

                                if (frameElement.dataset.frameState === "key-frame") {
                                    done = true;
                                }

                                if (done) {
                                    break;
                                }

                                startFrame--;
                            }

                            done = false;
                            let endFrame = frame;
                            for (;;) {

                                const frameElement = document
                                    .getElementById(`${layerId}-${++endFrame}`);

                                switch (frameElement.dataset.frameState) {

                                    case "empty":
                                    case "empty-key-frame":
                                    case "key-frame":
                                        done = true;
                                        break;

                                    case "key-space-frame-end":
                                        done = true;
                                        endFrame++;
                                        break;

                                }

                                if (done) {
                                    break;
                                }

                            }

                            switch (true) {

                                case character.startFrame !== startFrame:

                                    if (character.endFrame !== endFrame) {
                                        const clone = character.clone();
                                        clone.startFrame = endFrame;

                                        for (const frame of clone._$places.keys()) {
                                            if (endFrame > frame) {
                                                clone.deletePlace(frame);
                                            }
                                        }

                                        layer.addCharacter(clone);
                                    }

                                    character.endFrame = startFrame;
                                    for (const frame of character._$places.keys()) {
                                        if (frame >= startFrame) {
                                            character.deletePlace(frame);
                                        }
                                    }
                                    break;

                                case character.endFrame !== endFrame:
                                    {
                                        const place = character.getPlace(character.startFrame);
                                        character.deletePlace(character.startFrame);

                                        character.startFrame = endFrame;

                                        if (!character.hasPlace(endFrame)) {
                                            character.setPlace(endFrame, place);
                                        }
                                    }
                                    break;

                                default:
                                    layer.deleteCharacter(characterId);
                                    element.remove();
                                    break;

                            }

                            if (!layer.getActiveCharacter(startFrame).length) {
                                this.clearFrames(layer, startFrame, endFrame);
                            }
                        }

                        this.clearActiveCharacter();
                        Util.$controller.setDefaultController();

                        scene.changeFrame(frame);
                    }

                    if (this._$shapeMoveTarget) {

                        const stageArea = document.getElementById("stage-area");

                        let count = 0;
                        const children = stageArea.children;
                        for (let idx = 0; children.length > idx; ++idx) {

                            const node = children[idx];
                            if (!node.dataset.shapePointer) {
                                continue;
                            }

                            if (node.dataset.curve === "false") {
                                count++;
                            }
                        }

                        const element = this._$shapeMoveTarget;
                        const curve   = element.dataset.curve === "true";
                        if (!element.dataset.syncId && (count > 2 || curve)) {

                            Util
                                .$currentWorkSpace()
                                .temporarilySaved();

                            const { Graphics } = window.next2d.display;

                            const workSpace = Util.$currentWorkSpace();
                            const instance  = workSpace.getLibrary(
                                element.dataset.libraryId | 0
                            );

                            const index = element.dataset.index | 0;
                            const type  = element.dataset.type | 0;
                            switch (type) {

                                case Graphics.MOVE_TO:
                                    break;

                                case Graphics.LINE_TO:
                                    instance._$recodes.splice(index - 1, 3);
                                    break;

                                case Graphics.CUBIC:
                                    {
                                        let deletePos = index;
                                        for (;;) {
                                            if (instance._$recodes[--deletePos] === Graphics.CUBIC) {
                                                break;
                                            }
                                        }

                                        if (curve) {

                                            instance._$recodes[deletePos] = Graphics.CURVE_TO;
                                            instance._$recodes.splice(index, 2);

                                        } else {

                                            instance._$recodes.splice(deletePos, 7);

                                        }
                                    }
                                    break;

                                case Graphics.CURVE_TO:
                                    {
                                        let deletePos = index;
                                        for (;;) {
                                            if (instance._$recodes[--deletePos] === Graphics.CURVE_TO) {
                                                break;
                                            }
                                        }

                                        if (curve) {

                                            instance._$recodes[deletePos] = Graphics.LINE_TO;
                                            instance._$recodes.splice(index, 2);

                                        } else {

                                            instance._$recodes.splice(deletePos, 5);

                                        }
                                    }
                                    break;

                            }

                            const bounds = instance.reloadBounds(
                                Util.$hitColor ? Util.$hitColor.width | 0 : 0
                            );
                            instance._$bounds.xMin = bounds.xMin;
                            instance._$bounds.xMax = bounds.xMax;
                            instance._$bounds.yMin = bounds.yMin;
                            instance._$bounds.yMax = bounds.yMax;
                            instance.cacheClear();

                            // reload
                            scene.changeFrame(frame);

                            const layerId     = element.dataset.layerId | 0;
                            const characterId = element.dataset.characterId | 0;
                            const layer       = scene.getLayer(layerId);
                            const character   = layer.getCharacter(characterId);
                            if (character) {
                                const matrix = character.getPlace(frame).matrix;
                                instance.createPointer(matrix, layerId, characterId);
                            }
                        }
                        this._$shapeMoveTarget = null;
                    }
                }
                break;

            case "KeyC": // copy

                if (!Util.$canCopyCharacter || !this._$moveTargets) {
                    return false;
                }

                if (event.ctrlKey && !event.metaKey
                    || !event.ctrlKey && event.metaKey
                ) {
                    Util.$copyLibrary   = null;
                    Util.$copyLayer     = null;
                    Util.$copyCharacter = null;
                    if (!Util.$keyLock && !Util.$activeScript) {

                        event.preventDefault();

                        // reset
                        Util.$copyCharacter = [];

                        const scene = Util.$currentWorkSpace().scene;

                        Util.$copyWorkSpaceId = Util.$activeWorkSpaceId;
                        for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                            const element = this._$moveTargets[idx].target;

                            const layer = scene.getLayer(
                                element.dataset.layerId | 0
                            );

                            const character = layer.getCharacter(
                                element.dataset.characterId | 0
                            );

                            const dx = character.x + character.width  / 2;
                            const dy = character.y + character.height / 2;
                            Util.$copyCharacter.push({
                                "offsetX": dx + Util.$offsetLeft,
                                "offsetY": dy + Util.$offsetTop,
                                "target" : element
                            });
                        }

                        return false;
                    }
                }
                break;

            case "KeyV": // paste
                if (event.ctrlKey && !event.metaKey // windows
                    || !event.ctrlKey && event.metaKey // mac
                ) {

                    if (!Util.$keyLock
                        && !Util.$activeScript
                        && Util.$copyCharacter
                    ) {

                        event.preventDefault();

                        const frame = document
                            .getElementById("current-frame")
                            .textContent | 0;

                        const workSpace = Util.$currentWorkSpace();
                        const scene = workSpace.scene;

                        if (Util.$copyWorkSpaceId === Util.$activeWorkSpaceId) {

                            for (let idx = 0; idx < Util.$copyCharacter.length; ++idx) {

                                const object = Util.$copyCharacter[idx];

                                Util.$dragElement = object.target;

                                this.dropObject({
                                    "offsetX": object.offsetX,
                                    "offsetY": object.offsetY
                                });

                            }

                        }
                        Util.$dragElement = null;

                        scene.changeFrame(frame);

                        return false;
                    }
                }
                break;

            default:
                break;

        }
    }

    /**
     * @return {void}
     * @public
     */
    initializeContextMenu ()
    {
        // context menu
        document
            .getElementById("screen-front")
            .addEventListener("mousedown", function ()
            {
                this.changeDepth("up");
            }.bind(this));

        document
            .getElementById("screen-front-one")
            .addEventListener("mousedown", function ()
            {
                this.changeDepthOne("up");
            }.bind(this));

        document
            .getElementById("screen-back-one")
            .addEventListener("mousedown", function ()
            {
                this.changeDepthOne("down");
            }.bind(this));

        document
            .getElementById("screen-back")
            .addEventListener("mousedown", function ()
            {
                this.changeDepth("down");
            }.bind(this));

        document
            .getElementById("screen-position-left")
            .addEventListener("mousedown", function ()
            {
                this.alignment("left");
            }.bind(this));

        document
            .getElementById("screen-position-right")
            .addEventListener("mousedown", function ()
            {
                this.alignment("right");
            }.bind(this));

        document
            .getElementById("screen-position-center")
            .addEventListener("mousedown", function ()
            {
                this.alignment("center");
            }.bind(this));

        document
            .getElementById("screen-position-top")
            .addEventListener("mousedown", function ()
            {
                this.alignment("top");
            }.bind(this));

        document
            .getElementById("screen-position-middle")
            .addEventListener("mousedown", function ()
            {
                this.alignment("middle");
            }.bind(this));

        document
            .getElementById("screen-position-bottom")
            .addEventListener("mousedown", function ()
            {
                this.alignment("bottom");
            }.bind(this));

        document
            .getElementById("screen-distribute-to-layers")
            .addEventListener("mousedown", function ()
            {
                const layerElement = Util.$timeline._$targetLayer;
                if (!layerElement) {
                    return ;
                }

                Util
                    .$currentWorkSpace()
                    .temporarilySaved();

                const scene = Util.$currentWorkSpace().scene;
                const layer = scene.getLayer(
                    layerElement.dataset.layerId | 0
                );

                const currentFrame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                const classes  = [];
                const states   = [];
                let totalFrame = 1;
                for (;;) {

                    const frameElement = document
                        .getElementById(`${layer.id}-${totalFrame}`);

                    const frameState = frameElement.dataset.frameState;
                    if (totalFrame > currentFrame && frameState === "empty") {
                        break;
                    }

                    // pool
                    states.push(frameState);

                    classes.push(frameElement
                        .classList
                        .toString()
                        .replace("frame-active", "")
                        .replace("frame", "")
                        .trim()
                    );

                    totalFrame++;
                }

                let keyFrame = currentFrame;
                for (;;) {

                    const frameElement = document
                        .getElementById(`${layer.id}-${keyFrame}`);

                    if (frameElement.dataset.frameState === "key-frame") {
                        break;
                    }

                    --keyFrame;
                }

                const length = this._$moveTargets.length;
                for (let idx = 0; idx < length; ++idx) {

                    const newLayer = new Layer();
                    scene.addLayer(newLayer);

                    const element = this._$moveTargets[idx].target;

                    const character = layer.getCharacter(
                        element.dataset.characterId | 0
                    );

                    const cloneCharacter = character.clone();
                    if (cloneCharacter._$places.size > 1) {
                        const place = cloneCharacter.getPlace(keyFrame);
                        cloneCharacter._$places.clear();
                        cloneCharacter.setPlace(keyFrame, place);
                    }

                    if (keyFrame - 1 > 0) {

                        Util.$timeline._$targetFrames = [
                            document.getElementById(`${newLayer.id}-${keyFrame - 1}`)
                        ];

                        Util.$timeline.addSpaceFrame(false);
                        Util.$timeline._$targetFrames.length = 0;

                    }

                    // update
                    cloneCharacter.startFrame = keyFrame;
                    cloneCharacter.endFrame   = totalFrame;
                    newLayer.addCharacter(cloneCharacter);

                    for (let frame = keyFrame; frame <= totalFrame; ++frame) {

                        const index = frame - 1;
                        if (!(index in classes)) {
                            break;
                        }

                        if (states[index] === "key-frame" && frame !== keyFrame) {
                            cloneCharacter.endFrame = frame;
                            Util.$timeline._$targetFrames = [
                                document.getElementById(`${newLayer.id}-${totalFrame - 1}`)
                            ];

                            Util.$timeline.addSpaceFrame(false);
                            Util.$timeline._$targetFrames.length = 0;
                            break;
                        }

                        const frameElement = document
                            .getElementById(`${newLayer.id}-${frame}`);

                        frameElement.setAttribute("class", `frame ${classes[index]}`);
                        frameElement.dataset.frameState = states[index];
                        newLayer._$frame.setClasses(frame, classes[index].split(" "));
                    }
                }

                this.keyCommandFunction({
                    "code": "Delete"
                });

                this._$moveTargets.length = 0;
                this.hideTransformTarget();
                this.hideGridTarget();

                document
                    .getElementById(`${layer.id}-${currentFrame}`)
                    .classList.remove("frame-active");

            }.bind(this));

        document
            .getElementById("screen-distribute-to-keyframes")
            .addEventListener("mousedown", function ()
            {
                const layerElement = Util.$timeline._$targetLayer;
                if (!layerElement) {
                    return ;
                }

                const scene = Util.$currentWorkSpace().scene;
                const layer = scene.getLayer(
                    layerElement.dataset.layerId | 0
                );

                const currentFrame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                let keyFrame = currentFrame;
                for (;;) {

                    const frameElement = document
                        .getElementById(`${layer.id}-${keyFrame}`);

                    if (frameElement.dataset.frameState === "key-frame") {
                        break;
                    }

                    --keyFrame;
                }


                const characters = [];
                const length = this._$moveTargets.length;
                for (let idx = 0; idx < length; ++idx) {

                    const element = this._$moveTargets[idx].target;

                    const character = layer.getCharacter(
                        element.dataset.characterId | 0
                    );

                    const cloneCharacter = character.clone();

                    const place = cloneCharacter.getPlace(keyFrame);
                    cloneCharacter._$places.clear();
                    cloneCharacter.setPlace(keyFrame + idx, place);

                    characters.push(cloneCharacter);
                }

                this.keyCommandFunction({
                    "code": "Delete"
                });

                this._$moveTargets.length = 0;
                this.hideTransformTarget();
                this.hideGridTarget();

                let endFrame = keyFrame + 1;
                for (;;) {

                    const frameElement = document
                        .getElementById(`${layer.id}-${endFrame}`);

                    if (frameElement.dataset.frameState === "key-frame"
                        || frameElement.dataset.frameState === "empty-key-frame"
                        || frameElement.dataset.frameState === "empty"
                    ) {
                        break;
                    }

                    ++endFrame;
                }

                const totalFrame = endFrame - keyFrame;
                switch (true) {

                    case totalFrame > characters.length:
                        {
                            const length = totalFrame - characters.length;
                            const targetFrames = [];
                            for (let idx = 0; idx < length; ++idx) {
                                targetFrames.push(
                                    document.getElementById(`${layer.id}-${keyFrame + 1 + idx}`)
                                );
                            }
                            Util.$timeline._$targetFrames = targetFrames;

                            Util.$timeline.deleteFrame(false);
                            for (let idx = 0; idx < targetFrames.length; ++idx) {
                                const element = targetFrames[idx];
                                element.classList.remove("frame-active");
                            }

                            Util.$timeline._$targetFrames.length = 0;
                        }
                        break;

                    case characters.length > totalFrame:
                        Util.$timeline._$targetFrames = [
                            document.getElementById(`${layer.id}-${characters.length - totalFrame}`)
                        ];

                        Util.$timeline.addSpaceFrame(false);
                        Util.$timeline._$targetFrames.length = 0;
                        break;

                    default:
                        break;

                }

                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    const element = document
                        .getElementById(`${layer.id}-${keyFrame}`);

                    // update
                    Util.$timeline.removeFrameClass(element);
                    element.classList.add("key-frame");
                    element.dataset.frameState = "key-frame";
                    layer._$frame.setClasses(keyFrame, ["key-frame"]);

                    character.startFrame = keyFrame++;
                    character.endFrame   = keyFrame;

                    layer.addCharacter(character);
                }

                scene.changeFrame(currentFrame);

            }.bind(this));

        document
            .getElementById("screen-integrating-paths")
            .addEventListener("mousedown", function ()
            {
                if (2 > this._$moveTargets.length) {
                    return ;
                }

                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                const workSpace = Util.$currentWorkSpace();
                workSpace
                    .temporarilySaved();

                const scene = workSpace.scene;

                let baseShape     = null;
                let baseCharacter = null;
                let index = 0;
                for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                    const element = this._$moveTargets[idx].target;
                    if (element.dataset.instanceType !== "shape") {
                        continue;
                    }

                    const instance = workSpace.getLibrary(
                        element.dataset.libraryId | 0
                    );

                    const layer = scene.getLayer(
                        element.dataset.layerId | 0
                    );

                    const character = layer.getCharacter(
                        element.dataset.characterId | 0
                    );

                    const { Graphics } = window.next2d.display;
                    if (!baseShape) {

                        baseCharacter = character;

                        baseShape = instance;
                        for (let idx = 0; baseShape._$recodes.length > idx;) {

                            switch (baseShape._$recodes[idx++]) {

                                case Graphics.BEGIN_PATH:
                                    break;

                                case Graphics.MOVE_TO:
                                    idx += 2;
                                    break;

                                case Graphics.LINE_TO:
                                    idx += 2;
                                    break;

                                case Graphics.CURVE_TO:
                                    idx += 4;
                                    break;

                                case Graphics.CUBIC:
                                    idx += 6;
                                    break;

                                case Graphics.FILL_STYLE:
                                case Graphics.GRADIENT_FILL:
                                case Graphics.STROKE_STYLE:
                                case Graphics.GRADIENT_STROKE:
                                    index = idx - 1;
                                    break;

                                case Graphics.CLOSE_PATH:
                                case Graphics.END_STROKE:
                                case Graphics.END_FILL:
                                    break;

                                default:
                                    break;

                            }

                            if (index) {
                                break;
                            }
                        }

                        continue;
                    }

                    const tx = baseCharacter.screenX - baseShape._$bounds.xMin - character.screenX;
                    const ty = baseCharacter.screenY - baseShape._$bounds.yMin - character.screenY;

                    const matrix  = character.getPlace(frame).matrix;
                    const recodes = [];

                    let done = false;
                    for (let idx = 0; instance._$recodes.length > idx;) {

                        switch (instance._$recodes[idx++]) {

                            case Graphics.BEGIN_PATH:
                                break;

                            case Graphics.MOVE_TO:
                                {
                                    const x = instance._$recodes[idx++];
                                    const y = instance._$recodes[idx++];
                                    recodes.push(
                                        Graphics.MOVE_TO,
                                        x * matrix[0] + y * matrix[2] - tx,
                                        x * matrix[1] + y * matrix[3] - ty
                                    );
                                }
                                break;

                            case Graphics.LINE_TO:
                                {
                                    const x = instance._$recodes[idx++];
                                    const y = instance._$recodes[idx++];
                                    recodes.push(
                                        Graphics.LINE_TO,
                                        x * matrix[0] + y * matrix[2] - tx,
                                        x * matrix[1] + y * matrix[3] - ty
                                    );
                                }
                                break;

                            case Graphics.CURVE_TO:
                                {
                                    const cx = instance._$recodes[idx++];
                                    const cy = instance._$recodes[idx++];
                                    const x  = instance._$recodes[idx++];
                                    const y  = instance._$recodes[idx++];
                                    recodes.push(
                                        Graphics.CURVE_TO,
                                        cx * matrix[0] + cy * matrix[2] - tx,
                                        cx * matrix[1] + cy * matrix[3] - ty,
                                        x  * matrix[0] + y  * matrix[2] - tx,
                                        x  * matrix[1] + y  * matrix[3] - ty
                                    );
                                }
                                break;

                            case Graphics.CUBIC:
                                {
                                    const ctx1 = instance._$recodes[idx++];
                                    const cty1 = instance._$recodes[idx++];
                                    const ctx2 = instance._$recodes[idx++];
                                    const cty2 = instance._$recodes[idx++];
                                    const x    = instance._$recodes[idx++];
                                    const y    = instance._$recodes[idx++];
                                    recodes.push(
                                        Graphics.CUBIC,
                                        ctx1 * matrix[0] + cty1 * matrix[2] - tx,
                                        ctx1 * matrix[1] + cty1 * matrix[3] - ty,
                                        ctx2 * matrix[0] + cty2 * matrix[2] - tx,
                                        ctx2 * matrix[1] + cty2 * matrix[3] - ty,
                                        x * matrix[0] + y * matrix[2] - tx,
                                        x * matrix[1] + y * matrix[3] - ty
                                    );
                                }
                                break;

                            case Graphics.FILL_STYLE:
                            case Graphics.GRADIENT_FILL:
                            case Graphics.STROKE_STYLE:
                            case Graphics.GRADIENT_STROKE:
                                done = true;

                                Array
                                    .prototype
                                    .splice
                                    .apply(
                                        baseShape._$recodes,
                                        [index, 0].concat(recodes)
                                    );

                                index += recodes.length;
                                break;

                            case Graphics.CLOSE_PATH:
                            case Graphics.END_STROKE:
                            case Graphics.END_FILL:
                                break;

                            default:
                                break;

                        }

                        if (done) {
                            break;
                        }
                    }
                }

                if (baseShape) {

                    const bounds = baseShape.reloadBounds();
                    baseShape._$bounds.xMin = bounds.xMin;
                    baseShape._$bounds.xMax = bounds.xMax;
                    baseShape._$bounds.yMin = bounds.yMin;
                    baseShape._$bounds.yMax = bounds.yMax;
                    baseShape.cacheClear();

                    scene.changeFrame(frame);
                }

            }.bind(this));

        document
            .getElementById("screen-tween-curve-pointer")
            .addEventListener("mousedown", function ()
            {
                this.addTweenPointer();
            }.bind(this));
    }

    /**
     * @param  {string} mode
     * @return {void}
     * @public
     */
    alignment (mode)
    {
        if (this._$moveTargets.length === 1) {
            return ;
        }

        const scene = Util.$currentWorkSpace().scene;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin = Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        const characters = [];
        for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

            const element = this._$moveTargets[idx].target;

            const layer = scene.getLayer(element.dataset.layerId | 0);

            const character = layer.getCharacter(element.dataset.characterId | 0);

            xMin = Math.min(xMin, character.x);
            xMax = Math.max(xMax, character.x + character.width);
            yMin = Math.min(yMin, character.y);
            yMax = Math.max(yMax, character.y + character.height);

            characters.push(character);
        }

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        for (let idx = 0; idx < characters.length; ++idx) {

            const character = characters[idx];

            switch (mode) {

                case "left":
                    character.x = xMin;
                    break;

                case "right":
                    character.x = xMax - character.width;
                    break;

                case "center":
                    character.x = xMin + (xMax - xMin) / 2 - character.width / 2;
                    break;

                case "top":
                    character.y = yMin;
                    break;

                case "bottom":
                    character.y = yMax - character.height;
                    break;

                case "middle":
                    character.y = yMin + (yMax - yMin) / 2 - character.height / 2;
                    break;

            }

            const matrix = character.getPlace(frame).matrix;
            const bounds = Util.$boundsMatrix(character.getBounds(), matrix);

            const element = this._$moveTargets[idx].target;
            element.style.left = `${Util.$offsetLeft + bounds.xMin}px`;
            element.style.top  = `${Util.$offsetTop  + bounds.yMin}px`;
        }

        this.updatePropertyArea(false);
        this.placeTransformTarget();

        Util.$endMenu();
    }

    /**
     * @param  {string} [mode="up"]
     * @return {void}
     * @public
     */
    changeDepthOne (mode = "up")
    {
        if (mode === "up") {
            this._$moveTargets.sort(function (a, b)
            {
                switch (true) {

                    case a.depth > b.depth:
                        return -1;

                    case a.depth < b.depth:
                        return 1;

                    default:
                        return 0;

                }
            });
        } else {
            this._$moveTargets.sort(function (a, b)
            {
                switch (true) {

                    case a.depth > b.depth:
                        return 1;

                    case a.depth < b.depth:
                        return -1;

                    default:
                        return 0;

                }
            });
        }

        const scene = Util.$currentWorkSpace().scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const poolPlaces = new Map();
        for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

            const element = this._$moveTargets[idx].target;

            const layer = scene.getLayer(element.dataset.layerId | 0);

            if (!poolPlaces.has(layer.id)) {

                const places = [];

                const characters = layer._$characters;
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    places.push(character.getPlace(frame));
                }

                poolPlaces.set(layer.id, places);
            }

            const places = poolPlaces.get(layer.id);
            if (places.length === 1) {
                continue;
            }

            if (mode === "up") {

                places.sort(function (a, b)
                {
                    switch (true) {

                        case a.depth > b.depth:
                            return -1;

                        case a.depth < b.depth:
                            return 1;

                        default:
                            return 0;

                    }
                });

            } else {

                places.sort(function (a, b)
                {
                    switch (true) {

                        case a.depth > b.depth:
                            return 1;

                        case a.depth < b.depth:
                            return -1;

                        default:
                            return 0;

                    }
                });

            }

            const character   = layer.getCharacter(element.dataset.characterId | 0);
            const targetPlace = character.getPlace(frame);
            for (let idx = 0; idx < places.length; ++idx) {

                const place = places[idx];

                if (place.depth === targetPlace.depth) {
                    if (mode === "up") {
                        if (place.depth !== places.length - 1) {
                            place.depth++;
                            places[idx - 1].depth--;
                        }
                    } else {
                        if (place.depth) {
                            place.depth--;
                            if (idx) {
                                places[idx - 1].depth++;
                            }
                        }
                    }
                }

            }
        }

        poolPlaces.clear();

        scene.changeFrame(frame);
        Util.$endMenu();
    }

    /**
     * @param  {string} [mode="up"]
     * @return {void}
     * @public
     */
    changeDepth (mode = "up")
    {
        const scene = Util.$currentWorkSpace().scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const layers = new Map();
        for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

            const element = this._$moveTargets[idx].target;

            const layer = scene.getLayer(element.dataset.layerId | 0);
            if (!layers.has(layer.id)) {
                layers.set(layer.id, []);
            }

            layers.get(layer.id).push(element);
        }

        const places = [];
        const ignoreCharacterMap = new Map();
        for (let [id, values] of layers) {

            const layer = scene.getLayer(id);
            const characters = layer._$characters;
            if (characters.length === 1) {
                continue;
            }

            let index = mode === "up" ? characters.length - 1 : 0;
            for (let idx = 0; idx < values.length; ++idx) {

                const element = values[idx];

                const character = layer
                    .getCharacter(element.dataset.characterId | 0);

                ignoreCharacterMap.set(character.id, true);

                const place = character.getPlace(frame);
                if (mode === "up") {

                    if (place.depth === characters.length - 1) {
                        index--;
                        continue;
                    }

                    place.depth = index--;

                } else {

                    if (place.depth === index) {
                        index++;
                        continue;
                    }

                    place.depth = index++;

                }

            }

            for (let idx = 0; idx < characters.length; ++idx) {

                const character = characters[idx];
                if (ignoreCharacterMap.has(character.id)) {
                    continue;
                }

                places.push(character.getPlace(frame));
            }

            if (places.length) {

                if (mode === "up") {

                    places.sort(function (a, b)
                    {
                        switch (true) {

                            case a.depth > b.depth:
                                return -1;

                            case a.depth < b.depth:
                                return 1;

                            default:
                                return 0;

                        }
                    });

                } else {

                    places.sort(function (a, b)
                    {
                        switch (true) {

                            case a.depth > b.depth:
                                return 1;

                            case a.depth < b.depth:
                                return -1;

                            default:
                                return 0;

                        }
                    });

                }

                for (let idx = 0; idx < places.length; ++idx) {

                    const place = places[idx];
                    if (mode === "up") {
                        place.depth = index--;
                    } else {
                        place.depth = index++;
                    }
                }
            }

            places.length = 0;
            ignoreCharacterMap.clear();
        }

        scene.changeFrame(frame);
        Util.$endMenu();
    }

    /**
     * @return {void}
     * @public
     */
    adjustmentScale ()
    {
        const xScale = +document
            .getElementById("transform-scale-x")
            .value;

        const yScale = +document
            .getElementById("transform-scale-y")
            .value;

        if (xScale > yScale) {

            this.updateScaleX(yScale / 100);
            document
                .getElementById("transform-scale-x")
                .value = yScale;

        } else {

            this.updateScaleY(xScale / 100);
            document
                .getElementById("transform-scale-y")
                .value = xScale;

        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {number}
     * @public
     */
    updateLeftScaleX (event)
    {
        const updateScaleX = this._$positionX - event.pageX;
        if (updateScaleX) {
            const xScale = +document
                .getElementById("transform-scale-x")
                .value;

            const addScaleX = Util.$clamp(
                xScale + updateScaleX,
                Util.MIN_INT,
                Util.MAX_INT
            );

            document
                .getElementById("transform-scale-x")
                .value = addScaleX;

            this.updateScaleX(addScaleX / 100);

            this._$positionX = event.pageX;

            return 1;
        }

        return 0;
    }

    /**
     * @param  {MouseEvent} event
     * @return {number}
     * @public
     */
    updateTopScaleY (event)
    {
        const updateScaleY = this._$positionY - event.pageY;
        if (updateScaleY) {

            const yScale = +document
                .getElementById("transform-scale-y")
                .value;

            const addScaleY = Util.$clamp(
                yScale + updateScaleY,
                Util.MIN_INT,
                Util.MAX_INT
            );

            document
                .getElementById("transform-scale-y")
                .value = addScaleY;

            this.updateScaleY(addScaleY / 100);

            this._$positionY = event.pageY;

            return 1;
        }

        return 0;
    }

    /**
     * @param  {MouseEvent} event
     * @return {number}
     * @public
     */
    updateRightScaleX (event)
    {
        const updateScaleX = event.pageX - this._$positionX;
        if (updateScaleX) {

            const xScale = +document
                .getElementById("transform-scale-x")
                .value;

            const addScaleX = Util.$clamp(
                xScale + updateScaleX,
                Util.MIN_INT,
                Util.MAX_INT
            );

            document
                .getElementById("transform-scale-x")
                .value = addScaleX;

            this.updateScaleX(addScaleX / 100);

            this._$positionX = event.pageX;

            return 1;
        }

        return 0;
    }

    /**
     * @param  {MouseEvent} event
     * @return {number}
     * @public
     */
    updateBottomScaleY (event)
    {
        const updateScaleY = event.pageY - this._$positionY;
        if (updateScaleY) {

            const yScale = +document
                .getElementById("transform-scale-y")
                .value;

            const addScaleY = Util.$clamp(
                yScale + updateScaleY,
                Util.MIN_INT,
                Util.MAX_INT
            );

            document
                .getElementById("transform-scale-y")
                .value = addScaleY;

            this.updateScaleY(addScaleY / 100);

            this._$positionY = event.pageY;

            return 1;
        }

        return 0;
    }

    /**
     * @return {void}
     * @public
     */
    initializeGridTarget ()
    {
        this.hideGridTarget();

        document
            .getElementById("grid-top-left")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$gridMode  = 1;
                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
            }.bind(this));

        document
            .getElementById("grid-top-right")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$gridMode  = 2;
                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
            }.bind(this));

        document
            .getElementById("grid-bottom-left")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$gridMode  = 3;
                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
            }.bind(this));

        document
            .getElementById("grid-bottom-right")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$gridMode  = 4;
                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
            }.bind(this));
    }

    /**
     * @return {void}
     * @public
     */
    initializeTransformTarget ()
    {
        this.hideTransformTarget();

        document
            .getElementById("scale-top-left")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$transformMode = 1;
                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
            }.bind(this));

        document
            .getElementById("scale-center-left")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$transformMode = 2;
                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
            }.bind(this));

        document
            .getElementById("scale-bottom-left")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$transformMode = 3;
                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
            }.bind(this));

        document
            .getElementById("scale-center-top")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$transformMode = 4;
                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
            }.bind(this));

        document
            .getElementById("scale-top-right")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$transformMode = 5;
                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
            }.bind(this));

        document
            .getElementById("scale-center-right")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$transformMode = 6;
                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
            }.bind(this));

        document
            .getElementById("scale-bottom-right")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$transformMode = 7;
                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
            }.bind(this));

        document
            .getElementById("scale-center-bottom")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$transformMode = 8;
                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
            }.bind(this));

        document
            .getElementById("target-rotation")
            .addEventListener("mousedown", function (event)
            {
                this._$objectClicked = true;
                this._$transformMode = 9;

                const element = document
                    .getElementById("scale-bottom-right");

                this._$baseX = element.offsetLeft;
                this._$baseY = element.offsetTop;

                this._$baseRotate = document
                    .getElementById("transform-rotate").value | 0;

                this._$positionX = event.pageX;
                this._$positionY = event.pageY;
                Util.$setCursor("ew-resize");
            }.bind(this));

    }

    /**
     * @param  {Character} character
     * @param  {number} layer_id
     * @param  {number} frame
     * @return {void}
     * @public
     */
    initPlace (character, layer_id, frame)
    {
        let prevFrame = frame;
        while (prevFrame > 0) {

            const frameElement = document
                .getElementById(`${layer_id}-${prevFrame}`);

            if (frameElement.dataset.frameState === "key-frame") {

                if (!character._$places.has(prevFrame)) {
                    character.setPlace(prevFrame,
                        character.clonePlace(prevFrame, prevFrame)
                    );
                }

                break;
            }

            prevFrame--;
        }
    }

    /**
     * @param  {Layer} layer
     * @param  {number} start_frame
     * @param  {number} end_frame
     * @return {void}
     * @public
     */
    clearFrames (layer, start_frame, end_frame)
    {
        const layerId = layer.id;
        for (let frame = start_frame; end_frame > frame; ++frame) {

            const element = document
                .getElementById(`${layerId}-${frame}`);

            switch (element.dataset.frameState) {

                case "key-frame":
                    {
                        const classes = ["empty-key-frame"];

                        element
                            .classList
                            .remove(
                                "key-frame",
                                "tween-frame",
                                "tween-key-frame",
                                "morph-frame",
                                "morph-key-frame"
                            );

                        element
                            .classList
                            .add("empty-key-frame");

                        if (element
                            .classList
                            .contains("key-frame-join")
                        ) {

                            element
                                .classList
                                .remove("key-frame-join");

                            element
                                .classList
                                .add("empty-key-frame-join");

                            classes.push("empty-key-frame-join");
                        }

                        element
                            .dataset
                            .frameState = "empty-key-frame";

                        layer
                            ._$frame
                            .setClasses(frame, classes);
                    }
                    break;

                case "key-space-frame":

                    element
                        .classList
                        .remove("key-space-frame");

                    element
                        .classList
                        .remove("tween-frame", "morph-frame");

                    element
                        .classList
                        .add("empty-space-frame");

                    element
                        .dataset
                        .frameState = "empty-space-frame";

                    layer
                        ._$frame
                        .setClasses(frame, [
                            "empty-space-frame"
                        ]);

                    break;

                case "key-space-frame-end":

                    element
                        .classList
                        .remove(
                            "key-space-frame-end",
                            "tween-frame",
                            "tween-frame-end",
                            "morph-frame",
                            "morph-frame-end"
                        );

                    element
                        .classList
                        .add("empty-space-frame-end");

                    element
                        .dataset
                        .frameState = "empty-space-frame-end";

                    layer
                        ._$frame
                        .setClasses(frame, [
                            "empty-space-frame-end"
                        ]);

                    break;

                default:
                    break;

            }
        }

        this.clearTweenMarker();
    }

    /**
     * @return {void}
     * @public
     */
    initializeTab ()
    {
        for (let idx = 0; idx < Util.$workSpaces.length; ++idx) {
            this.addTab(Util.$workSpaces[idx], idx);
        }

        const button = document.getElementById("view-tab-add");
        button.addEventListener("click", function ()
        {
            const id = Util.$workSpaces.length;
            const workSpace = new WorkSpace();

            Util.$workSpaces.push(workSpace);
            this.addTab(workSpace, id);

            Util.$updated = true;

        }.bind(this));

        const tabList = document.getElementById("view-tab-list");
        tabList.addEventListener("mousedown", function (event)
        {

            const element = document.getElementById("tab-name-menu");
            if (!this._$menuMode) {

                this._$menuMode = true;

                const target = event.currentTarget;
                element.style.left = `${target.offsetLeft + target.offsetWidth}px`;
                element.style.top  = `${target.offsetTop + 10}px`;
                element.setAttribute("class", "fadeIn");

                Util.$endMenu("tab-name-menu");

            } else {

                this._$menuMode = false;
                if (element.classList.contains("fadeIn")) {
                    element.setAttribute("class", "fadeOut");
                }

            }

        }.bind(this));

        document.body.addEventListener("click", function (event)
        {
            if (!this._$menuMode) {
                return ;
            }

            let target = event.target;
            switch (target.id) {

                case "view-tab-list":
                case "tab-name-menu":
                    return ;

                default:

                    for (;;) {

                        target = target.parentNode;
                        if (!target) {

                            this._$menuMode = false;

                            const element = document
                                .getElementById("tab-name-menu");

                            if (element.classList.contains("fadeIn")) {
                                element.setAttribute("class", "fadeOut");
                            }

                            break;
                        }

                        if (target.id === "tab-name-menu") {
                            break;
                        }
                    }

                    break;

            }

        }.bind(this));
    }

    /**
     * @param  {WorkSpace} work_space
     * @param  {number}    id
     * @return {void}
     * @public
     */
    addTab (work_space, id)
    {
        if (!work_space.name) {
            work_space.name = `Untitled-${id + 1}`;
        }

        const htmlTag = `
<div draggable="true" id="tab-id-${id}" data-tab-id="${id}" class="tab">
    <p id="tab-text-id-${id}" data-tab-id="${id}" data-detail="{{タブの移動・名前を変更}}">${work_space.name}</p>
    <input type="text" id="tab-input-id-${id}" data-tab-id="${id}" value="${work_space.name}">
    <i id="tab-delete-id-${id}" data-tab-id="${id}" data-detail="{{プロジェクトを閉じる}}"></i>
</div>`;

        const element = document.getElementById("view-tab-area");
        element.insertAdjacentHTML("beforeend", htmlTag);

        const div = document.getElementById(`tab-id-${id}`);

        Util.$addModalEvent(div);

        if (Util.$activeWorkSpaceId === id) {
            div
                .classList
                .add("active");
        } else {
            div
                .classList
                .add("disable");
        }

        div.addEventListener("click", function (event)
        {

            const tabId = event.currentTarget.dataset.tabId | 0;
            const element = document
                .getElementById(`tab-id-${tabId}`);

            // 削除されてる場合があるので、スキップ処理
            if (element) {

                const activeElement = document
                    .getElementById(`tab-id-${Util.$activeWorkSpaceId}`);

                // to disable
                activeElement
                    .classList
                    .remove("active");

                activeElement
                    .classList
                    .add("disable");

                // to active
                element
                    .classList
                    .remove("disable");

                element
                    .classList
                    .add("active");

                // work space run
                if (Util.$activeWorkSpaceId !== tabId) {
                    Util.$changeWorkSpace(tabId);
                }

            }

        });

        // drop event
        div.addEventListener("dragstart", function (event)
        {
            this._$dropTab = event.currentTarget;
        }.bind(this));

        div.addEventListener("dragover", function (event)
        {
            event.preventDefault();

            const element = event.currentTarget;
            if (!element.classList.contains("drop-target")) {
                element
                    .classList
                    .add("drop-target");
            }

        });
        div.addEventListener("dragleave", function (event)
        {
            event.preventDefault();

            event
                .currentTarget
                .classList
                .remove("drop-target");

        });

        div.addEventListener("drop", function (event)
        {
            event.preventDefault();

            event
                .currentTarget
                .classList
                .remove("drop-target");

            const nextElement = event
                .currentTarget
                .nextElementSibling;

            const element = document.getElementById("view-tab-area");
            if (this._$dropTab === nextElement) {
                element
                    .insertBefore(this._$dropTab, event.currentTarget);
            } else {
                element
                    .insertBefore(this._$dropTab, nextElement);
            }

            this._$dropTab = null;

        }.bind(this));

        // delete icon
        const i = document.getElementById(`tab-delete-id-${id}`);
        i.addEventListener("click", function (event)
        {
            const message = Util.$currentLanguage.replace(
                "{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}"
            );

            if (!window.confirm(message)) {
                return ;
            }

            const tabId = event.currentTarget.dataset.tabId | 0;

            Util.$workSpaces[tabId] = null;

            document
                .getElementById(`tab-id-${tabId}`)
                .remove();

            document
                .getElementById(`tab-menu-id-${tabId}`)
                .remove();

            // remove
            const previewElement = document
                .getElementById("library-preview-area");

            while (previewElement.children.length) {
                previewElement.children[0].remove();
            }

            const parent = document.getElementById("view-tab-area");
            if (!parent.children.length) {

                // reset
                Util.$workSpaces.length = 0;
                Util.$activeWorkSpaceId = 0;

                // new WorkSpace
                const workSpace = new WorkSpace();
                Util.$workSpaces.push(workSpace);

                // create tab
                this.addTab(workSpace, 0);

                // start
                workSpace.run();

                const element = parent.children[0];
                element.setAttribute("class", "tab active");

                return ;
            }

            if (Util.$activeWorkSpaceId === tabId) {

                const element = parent.children[0];
                element.setAttribute("class", "tab active");

                Util.$activeWorkSpaceId = element.dataset.tabId | 0;

                Util.$currentWorkSpace().run();
            }

        }.bind(this));

        // text
        const p = document.getElementById(`tab-text-id-${id}`);
        p.addEventListener("dblclick", function (event)
        {
            Util.$keyLock = true;

            const element = event.currentTarget;
            const tabId   = element.dataset.tabId | 0;

            const input = document
                .getElementById(`tab-input-id-${tabId}`);

            if (input.style.display === "none") {
                input.style.width     = `${element.offsetWidth}px`;
                input.style.display   = "";
                element.style.display = "none";
                input.focus();

                const parent = document
                    .getElementById(`tab-id-${tabId}`);

                parent.draggable = false;
            }
        });

        // hidden input
        const input = document.getElementById(`tab-input-id-${id}`);
        input.style.display = "none";

        /**
         * @param {Event|KeyboardEvent} event
         */
        const editEnd = function (event)
        {
            if (event.type === "focusout" || event.code === "Enter") {

                const element = event.currentTarget;
                element.style.display = "none";

                const tabId = element.dataset.tabId | 0;

                const p = document
                    .getElementById(`tab-text-id-${tabId}`);

                const menu = document.getElementById(`tab-menu-id-${tabId}`);
                const workSpace = Util.$workSpaces[tabId];

                workSpace.name   = element.value;
                menu.textContent = element.value;
                p.textContent    = element.value;
                p.style.display  = "";

                const parent = document
                    .getElementById(`tab-id-${tabId}`);

                parent.draggable = true;
            }
        };
        input.addEventListener("focusout", editEnd);
        input.addEventListener("keypress", editEnd);

        // add menu
        const menuHtml = `
<div id="tab-menu-id-${id}" data-tab-id="${id}">${work_space.name}</div>
        `;

        document
            .getElementById("tab-name-menu-list")
            .insertAdjacentHTML("beforeend", menuHtml);

        const menu = document.getElementById(`tab-menu-id-${id}`);

        menu.addEventListener("click", function (event)
        {
            const tabId = event.currentTarget.dataset.tabId | 0;
            const tab = document
                .getElementById(`tab-id-${tabId}`);

            const activeElement = document
                .getElementById(`tab-id-${Util.$activeWorkSpaceId}`);

            // to disable
            activeElement
                .classList
                .remove("active");

            activeElement
                .classList
                .add("disable");

            // to active
            tab
                .classList
                .remove("disable");

            tab
                .classList
                .add("active");

            const area = document.getElementById("view-tab-area");
            tab.remove();

            area.prepend(tab);

            // menu end
            this._$menuMode = false;

            document
                .getElementById("tab-name-menu")
                .setAttribute("class", "fadeOut");

            // work space run
            if (Util.$activeWorkSpaceId !== tabId) {
                Util.$changeWorkSpace(tabId);
            }

        }.bind(this));

    }

    /**
     * @param  {Layer}   layer
     * @param  {boolean} [change=false]
     * @return {void}
     * @public
     */
    executeTween (layer, change = false)
    {
        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        let startFrame = frame;
        while (startFrame > 1) {

            const element = document
                .getElementById(`${layer.id}-${startFrame}`);

            if (element.classList.contains("key-frame")) {
                break;
            }

            --startFrame;
        }

        let endFrame = frame;
        for (;;) {

            ++endFrame;

            const element = document
                .getElementById(`${layer.id}-${endFrame}`);

            if (!element.classList.contains("tween-frame")
                || element.classList.contains("key-frame")
            ) {
                --endFrame;
                break;
            }

            if (element.classList.contains("key-space-frame-end")) {
                break;
            }
        }

        // setup
        const characters = layer.getActiveCharacter(frame);
        if (!characters.length) {
            return ;
        }

        const character = characters[0];

        // place check
        for (let frame = startFrame; frame <= endFrame; ++frame) {
            if (!character.hasPlace(frame)) {
                character.setPlace(frame,
                    character.clonePlace(endFrame, frame)
                );
            }
        }

        // translate
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(character.libraryId)
            .createInstance(character.getPlace(frame));

        const w = instance.width  / 2;
        const h = instance.height / 2;

        const rectangle  = instance.getBounds();
        const baseMatrix = [1, 0, 0, 1, -w - rectangle.x, -h - rectangle.y];

        // start params
        const startPlace  = character.getPlace(startFrame);
        const startMatrix = startPlace.matrix;

        const startScaleX = Math.sqrt(
            startMatrix[0] * startMatrix[0]
            + startMatrix[1] * startMatrix[1]
        );
        const startScaleY = Math.sqrt(
            startMatrix[2] * startMatrix[2]
            + startMatrix[3] * startMatrix[3]
        );

        let startRotate = Math.atan2(startMatrix[1], startMatrix[0]) * Util.$Rad2Deg;
        if (0 > startRotate) {
            startRotate += 360;
        }

        const startMultiMatrix = Util.$multiplicationMatrix(
            [startMatrix[0], startMatrix[1], startMatrix[2], startMatrix[3], 0, 0],
            baseMatrix
        );

        const startX = startMatrix[4] - (startMultiMatrix[4] + w + rectangle.x);
        const startY = startMatrix[5] - (startMultiMatrix[5] + h + rectangle.y);

        // end params
        const endPlace  = character.getPlace(endFrame);
        const endMatrix = endPlace.matrix;
        const endScaleX = Math.sqrt(
            endMatrix[0] * endMatrix[0]
            + endMatrix[1] * endMatrix[1]
        );
        const endScaleY = Math.sqrt(
            endMatrix[2] * endMatrix[2]
            + endMatrix[3] * endMatrix[3]
        );

        let endRotate = Math.atan2(endMatrix[1], endMatrix[0]) * Util.$Rad2Deg;
        if (0 > endRotate) {
            endRotate += 360;
        }

        const endMultiMatrix = Util.$multiplicationMatrix(
            [endMatrix[0], endMatrix[1], endMatrix[2], endMatrix[3], 0, 0],
            baseMatrix
        );

        const endX = endMatrix[4] - (endMultiMatrix[4] + w + rectangle.x);
        const endY = endMatrix[5] - (endMultiMatrix[5] + h + rectangle.y);

        if (!character.hasTween()) {
            character.setTween({
                "method": "linear",
                "curve": [],
                "custom": Util.$controller.createEasingObject()
            });
        }

        if (change) {
            character._$tween.get(startFrame).method =
                document.getElementById("ease-select").value;
        }

        const tween = character.getTween();
        const functionName = tween.method;

        // (fixed logic)
        const totalFrame = endFrame - startFrame;
        startFrame++;

        // diff
        const diffX = endX - startX;
        const diffY = endY - startY;

        // scale
        const diffScaleX = endScaleX - startScaleX;
        const diffScaleY = endScaleY - startScaleY;

        // rotate
        const diffRotate = endRotate - startRotate;

        // ColorTransform
        const startColorTransform = startPlace.colorTransform;
        const endColorTransform   = endPlace.colorTransform;
        const ct0 = endColorTransform[0] - startColorTransform[0];
        const ct1 = endColorTransform[1] - startColorTransform[1];
        const ct2 = endColorTransform[2] - startColorTransform[2];
        const ct3 = endColorTransform[3] - startColorTransform[3];
        const ct4 = endColorTransform[4] - startColorTransform[4];
        const ct5 = endColorTransform[5] - startColorTransform[5];
        const ct6 = endColorTransform[6] - startColorTransform[6];
        const ct7 = endColorTransform[7] - startColorTransform[7];

        const { Easing } = window.next2d.ui;

        let time = 1;
        for (let frame = startFrame; frame < endFrame; ++frame) {

            const place = character.getPlace(frame);
            if (place.fixed) {
                continue;
            }

            const t = time / totalFrame;
            let customValue = 0;
            if (functionName === "custom") {
                for (let idx = 0; idx < tween.custom.length; idx += 3) {

                    const curve1 = tween.custom[idx + 1];

                    let pointer = tween.custom[idx + 3];
                    if (pointer.off) {
                        idx += 3;
                        for (;;) {
                            pointer = tween.custom[idx + 3];
                            if (pointer.fixed || !pointer.off) {
                                break;
                            }
                            idx += 3;
                        }
                    }

                    if (pointer.x / Util.EASE_RANGE > t) {

                        const curve2 = tween.custom[idx + 2];

                        customValue = Util.$controller.cubicBezier(
                            curve1.x / Util.EASE_RANGE,
                            curve1.y / Util.EASE_RANGE,
                            curve2.x / Util.EASE_RANGE,
                            curve2.y / Util.EASE_RANGE
                        )(t);

                        break;
                    }
                }
            }

            const matrix = place.matrix;

            // scale
            const xScale = !diffScaleX
                ? startScaleX
                : functionName === "custom"
                    ? diffScaleX * customValue + startScaleX
                    : Easing[functionName](time, startScaleX, diffScaleX, totalFrame);

            const yScale = !diffScaleY
                ? startScaleY
                : functionName === "custom"
                    ? diffScaleY * customValue + startScaleY
                    : Easing[functionName](time, startScaleY, diffScaleY, totalFrame);

            const rotation = !diffRotate
                ? startRotate
                : functionName === "custom"
                    ? diffRotate * customValue + startRotate
                    : Easing[functionName](time, startRotate, diffRotate, totalFrame) % 360;

            // rotation
            let radianX  = Math.atan2(matrix[1],  matrix[0]);
            let radianY  = Math.atan2(-matrix[2], matrix[3]);
            const radian = rotation * Util.$Deg2Rad;
            radianY      = radianY + radian - radianX;
            radianX      = radian;

            // new matrix
            matrix[0] = xScale * Math.cos(radianX);
            matrix[1] = xScale * Math.sin(radianX);
            matrix[2] = -yScale * Math.sin(radianY);
            matrix[3] = yScale * Math.cos(radianY);

            matrix[4] = !diffX
                ? startX
                : functionName === "custom"
                    ? customValue * diffX + startX
                    : Easing[functionName](time, startX, diffX, totalFrame);

            matrix[5] = !diffY
                ? startY
                : functionName === "custom"
                    ? customValue * diffY + startY
                    : Easing[functionName](time, startY, diffY, totalFrame);

            if (tween.curve.length) {

                const baseDistance = Math.sqrt(
                    Math.pow(diffX, 2)
                    + Math.pow(diffY, 2)
                );

                const distance = Math.sqrt(
                    Math.pow(matrix[4] - startX, 2)
                    + Math.pow(matrix[5] - startY, 2)
                );

                if (distance && baseDistance) {

                    const curvePoint = Util.$getCurvePoint(
                        distance / baseDistance,
                        startX, startY, endX, endY,
                        tween.curve
                    );

                    if (curvePoint) {
                        matrix[4] = curvePoint.x;
                        matrix[5] = curvePoint.y;
                    }
                }
            }

            const multiMatrix = Util.$multiplicationMatrix(
                [matrix[0], matrix[1], matrix[2], matrix[3], 0, 0],
                baseMatrix
            );

            matrix[4] += multiMatrix[4] + w + rectangle.x;
            matrix[5] += multiMatrix[5] + h + rectangle.y;

            // ColorTransform
            const colorTransform = place.colorTransform;
            if (ct0) {
                colorTransform[0] = Util.$clamp(
                    functionName === "custom"
                        ? ct0 * customValue + startColorTransform[0]
                        : Easing[functionName](time, startColorTransform[0], ct0, totalFrame),
                    Util.COLOR_MIN_MULTIPLIER,
                    Util.COLOR_MAX_MULTIPLIER
                );
            }

            if (ct1) {
                colorTransform[1] = Util.$clamp(
                    functionName === "custom"
                        ? ct1 * customValue + startColorTransform[1]
                        : Easing[functionName](time, startColorTransform[1], ct1, totalFrame),
                    Util.COLOR_MIN_MULTIPLIER,
                    Util.COLOR_MAX_MULTIPLIER
                );
            }

            if (ct2) {
                colorTransform[2] = Util.$clamp(
                    functionName === "custom"
                        ? ct2 * customValue + startColorTransform[2]
                        : Easing[functionName](time, startColorTransform[2], ct2, totalFrame),
                    Util.COLOR_MIN_MULTIPLIER,
                    Util.COLOR_MAX_MULTIPLIER
                );
            }

            if (ct3) {
                colorTransform[3] = Util.$clamp(
                    functionName === "custom"
                        ? ct3 * customValue + startColorTransform[3]
                        : Easing[functionName](time, startColorTransform[3], ct3, totalFrame),
                    Util.COLOR_MIN_MULTIPLIER,
                    Util.COLOR_MAX_MULTIPLIER
                );
            }

            if (ct4) {
                colorTransform[4] = Util.$clamp(
                    functionName === "custom"
                        ? ct4 * customValue + startColorTransform[4]
                        : Easing[functionName](time, startColorTransform[4], ct4, totalFrame),
                    Util.COLOR_MIN_OFFSET,
                    Util.COLOR_MAX_OFFSET
                );
            }

            if (ct5) {
                colorTransform[5] = Util.$clamp(
                    functionName === "custom"
                        ? ct5 * customValue + startColorTransform[5]
                        : Easing[functionName](time, startColorTransform[5], ct5, totalFrame),
                    Util.COLOR_MIN_OFFSET,
                    Util.COLOR_MAX_OFFSET
                );
            }

            if (ct6) {
                colorTransform[6] = Util.$clamp(
                    functionName === "custom"
                        ? ct6 * customValue + startColorTransform[6]
                        : Easing[functionName](time, startColorTransform[6], ct6, totalFrame),
                    Util.COLOR_MIN_OFFSET,
                    Util.COLOR_MAX_OFFSET
                );
            }

            if (ct7) {
                colorTransform[7] = Util.$clamp(
                    functionName === "custom"
                        ? ct7 * customValue + startColorTransform[7]
                        : Easing[functionName](time, startColorTransform[7], ct7, totalFrame),
                    Util.COLOR_MIN_OFFSET,
                    Util.COLOR_MAX_OFFSET
                );
            }

            time++;
        }

        // filter
        const startFilters = startPlace.filter;
        const endFilters   = endPlace.filter;
        if (startFilters.length && endFilters.length) {

            const params = [
                "blurX",
                "blurY",
                "quality",
                "color",
                "alpha",
                "distance",
                "angle",
                "highlightColor",
                "highlightAlpha",
                "shadowColor",
                "shadowAlpha",
                "strength"
            ];

            const length = startFilters.length;
            for (let idx = 0; idx < length; ++idx) {

                const startFilter = startFilters[idx];
                const endFilter   = endFilters[idx];

                if (startFilter.name !== endFilter.name) {
                    continue;
                }

                let time = 1;
                for (let frame = startFrame; endFrame > frame; ++frame) {

                    const filters = character.getPlace(frame).filter;
                    if (!filters[idx]) {
                        filters[idx] = new Util.$filterClasses[startFilter.name]();
                    }

                    const filter = filters[idx];
                    for (let idx = 0; idx < params.length; ++idx) {

                        const name = params[idx];

                        if (name in filter) {

                            const diff = endFilter[name] - startFilter[name];
                            if (!diff) {
                                continue;
                            }

                            filter[name] = functionName === "custom"
                                ? diff * customValue + startFilter[name]
                                : Easing[functionName](time, startFilter[name], diff, totalFrame);

                        }

                    }

                    time++;
                }
            }
        }

        character._$image = null;
    }

    /**
     * @param  {HTMLElement} element
     * @param  {number}      [move_x=0]
     * @param  {number}      [move_y=0]
     * @param  {boolean}     [check=false]
     * @return {void}
     * @public
     */
    addTarget (element, move_x = 0, move_y = 0, check = false)
    {
        if (check) {

            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const object = this._$moveTargets[idx];

                if (object.target === element) {
                    return ;
                }
            }

        }

        this._$moveTargets.push({
            "target": element,
            "moveX": move_x,
            "moveY": move_y
        });
        Util.$canCopyCharacter = true;

        this.activeFrame(element);
        this.setTransformTarget();
    }

    /**
     * @return {void}
     * @public
     */
    setTransformTarget ()
    {
        this.showTransformTarget();
        this.placeTransformTarget();
    }

    /**
     * @public
     */
    placeTransformTarget ()
    {
        if (!this._$moveTargets.length) {
            return;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin = Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;
        for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

            const target = this._$moveTargets[idx].target;

            const layer = scene.getLayer(target.dataset.layerId | 0);
            if (!layer || layer.lock || layer.disable) {
                continue;
            }

            const characterId = target.dataset.characterId | 0;

            const element = document
                .getElementById(`character-${characterId}`);

            if (!element) {
                continue;
            }

            const x = element.offsetLeft;
            const y = element.offsetTop;
            xMin = Math.min(xMin, x);
            xMax = Math.max(xMax, x + element.offsetWidth);
            yMin = Math.min(yMin, y);
            yMax = Math.max(yMax, y + element.offsetHeight);

        }

        const width  = xMax - xMin;
        const height = yMax - yMin;

        const targetRect = document
            .getElementById("target-rect");

        targetRect.style.width  = `${width  - 2}px`;
        targetRect.style.height = `${height - 2}px`;
        targetRect.style.left   = `${xMin}px`;
        targetRect.style.top    = `${yMin}px`;

        const topLeft = document
            .getElementById("scale-top-left");

        topLeft.style.left = `${xMin - 5}px`;
        topLeft.style.top  = `${yMin - 5}px`;

        const topRight = document
            .getElementById("scale-top-right");

        topRight.style.left = `${xMax - 4}px`;
        topRight.style.top  = `${yMin - 5}px`;

        const bottomLeft = document
            .getElementById("scale-bottom-left");

        bottomLeft.style.left = `${xMin - 5}px`;
        bottomLeft.style.top  = `${yMax - 5}px`;

        const bottomRight = document
            .getElementById("scale-bottom-right");

        bottomRight.style.left = `${xMax - 4}px`;
        bottomRight.style.top  = `${yMax - 4}px`;

        const targetRotation = document
            .getElementById("target-rotation");

        targetRotation.style.left = `${xMax + 5}px`;
        targetRotation.style.top  = `${yMax + 5}px`;

        const centerLeft = document
            .getElementById("scale-center-left");

        centerLeft.style.left = `${xMin - 5}px`;
        centerLeft.style.top  = `${yMin + height / 2 - 5}px`;

        const centerTop = document
            .getElementById("scale-center-top");

        centerTop.style.left = `${xMin + width / 2 - 5}px`;
        centerTop.style.top  = `${yMin - 5}px`;

        const centerRight = document
            .getElementById("scale-center-right");

        centerRight.style.left = `${xMax - 4}px`;
        centerRight.style.top  = `${yMin + height / 2 - 6}px`;

        const centerBottom = document
            .getElementById("scale-center-bottom");

        centerBottom.style.left = `${xMin + width / 2 - 5}px`;
        centerBottom.style.top  = `${yMax - 4}px`;
    }

    /**
     * @public
     */
    placeGridTarget ()
    {
        if (this._$moveTargets.length !== 1) {
            this.hideGridTarget();
            return;
        }

        const target      = this._$moveTargets[0].target;
        const characterId = target.dataset.characterId | 0;

        const element = document
            .getElementById(`character-${characterId}`);

        if (!element) {
            this.hideGridTarget();
            return;
        }

        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace.getLibrary(
            target.dataset.libraryId | 0
        );

        if (!instance || instance.type !== "shape") {
            this.hideGridTarget();
            return;
        }

        const grid = instance._$grid;
        if (!grid) {
            this.hideGridTarget();
            return;
        }

        const layerId   = target.dataset.layerId | 0;
        const layer     = workSpace.scene.getLayer(layerId);
        const character = layer.getCharacter(
            target.dataset.characterId | 0
        );

        if (character.rotation) {
            this.hideGridTarget();
            return;
        }

        const bounds = character.getBounds();
        const w = character.width  - Math.abs(bounds.xMax - bounds.xMin);
        const h = character.height - Math.abs(bounds.yMax - bounds.yMin);

        const x = element.offsetLeft;
        const y = element.offsetTop;

        const topLeft = document.getElementById("grid-top-left");
        topLeft.style.left = `${x + grid.x - 4}px`;
        topLeft.style.top  = `${y + grid.y - 4}px`;

        const topRight = document.getElementById("grid-top-right");
        topRight.style.left = `${x + grid.x + grid.w + w - 4}px`;
        topRight.style.top  = `${y + grid.y - 4}px`;

        const bottomLeft = document.getElementById("grid-bottom-left");
        bottomLeft.style.left = `${x + grid.x - 4}px`;
        bottomLeft.style.top  = `${y + grid.y + grid.h + h - 4}px`;

        const bottomRight = document.getElementById("grid-bottom-right");
        bottomRight.style.left = `${x + grid.x + grid.w + w - 4}px`;
        bottomRight.style.top  = `${y + grid.y + grid.h + h - 4}px`;
    }

    /**
     * @return {void}
     * @public
     */
    showGridTarget ()
    {
        for (let idx = 0; idx < Util.$gridTargets.length; ++idx) {

            document
                .getElementById(Util.$gridTargets[idx])
                .style
                .display = "";

        }
    }

    /**
     * @return {void}
     * @public
     */
    hideGridTarget ()
    {
        for (let idx = 0; idx < Util.$gridTargets.length; ++idx) {

            document
                .getElementById(Util.$gridTargets[idx])
                .style
                .display = "none";

        }
    }

    /**
     * @return {void}
     * @public
     */
    showTransformTarget ()
    {
        for (let idx = 0; idx < Util.$transformTargets.length; ++idx) {

            document
                .getElementById(Util.$transformTargets[idx])
                .style
                .display = "";

        }
    }

    /**
     * @return {void}
     * @public
     */
    hideTransformTarget ()
    {
        for (let idx = 0; idx < Util.$transformTargets.length; ++idx) {

            document
                .getElementById(Util.$transformTargets[idx])
                .style
                .display = "none";

        }
    }

    /**
     * @param  {number} width
     * @return {void}
     * @public
     */
    updateWidth (width)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        if (this._$moveTargets.length > 1) {

            let xMin =  Number.MAX_VALUE;
            let xMax = -Number.MAX_VALUE;
            let yMin =  Number.MAX_VALUE;
            let yMax = -Number.MAX_VALUE;

            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const target  = this._$moveTargets[idx].target;
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const place  = character.getPlace(frame);
                const bounds = Util.$boundsMatrix(character.getBounds(), place.matrix);
                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);
            }

            this.updateScaleX(width / Math.abs(xMax - xMin));

        } else {

            const target  = this._$moveTargets[0].target;
            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            const bounds = character.getBounds();
            this.updateScaleX(
                width / Math.abs(bounds.xMax - bounds.xMin)
            );

            document
                .getElementById("transform-scale-x")
                .value = character.scaleX * 100;

        }

    }

    /**
     * @param  {number} height
     * @return {void}
     * @public
     */
    updateHeight (height)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        if (this._$moveTargets.length > 1) {

            let xMin =  Number.MAX_VALUE;
            let xMax = -Number.MAX_VALUE;
            let yMin =  Number.MAX_VALUE;
            let yMax = -Number.MAX_VALUE;

            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const target  = this._$moveTargets[idx].target;
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const place  = character.getPlace(frame);
                const bounds = Util.$boundsMatrix(character.getBounds(), place.matrix);
                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);
            }

            this.updateScaleY(height / Math.abs(yMax - yMin));

        } else {

            const target  = this._$moveTargets[0].target;
            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            const bounds = character.getBounds();
            this.updateScaleY(
                height / Math.abs(bounds.yMax - bounds.yMin)
            );

            document
                .getElementById("transform-scale-y")
                .value = character.scaleY * 100;

        }
    }

    /**
     * @param {number} x
     * @public
     */
    updateX (x)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

            const target  = this._$moveTargets[idx].target;
            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            character.x += x;
            character.screenX += x;

            document
                .getElementById(`character-${characterId}`)
                .style
                .left = `${Util.$offsetLeft + character.screenX}px`;

            if (document
                .getElementById(`${layerId}-${frame}`)
                .classList
                .contains("tween-frame")
            ) {
                this.executeTween(layer);
                this.createTweenMarker();
            }
        }
    }

    /**
     * @param {number} y
     * @public
     */
    updateY (y)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

            const target  = this._$moveTargets[idx].target;
            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            character.y += y;
            character.screenY += y;

            document
                .getElementById(`character-${characterId}`)
                .style
                .top = `${Util.$offsetTop + character.screenY}px`;

            if (document
                .getElementById(`${layerId}-${frame}`)
                .classList
                .contains("tween-frame")
            ) {
                this.executeTween(layer);
                this.createTweenMarker();
            }
        }
    }

    /**
     * @param  {number} scale_x
     * @return {void}
     * @public
     */
    updateScaleX (scale_x)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        let tx = Number.MAX_VALUE;
        let ty = Number.MAX_VALUE;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        const multiple = this._$moveTargets.length > 1;
        if (multiple)  {

            let baseXMin =  Number.MAX_VALUE;
            let baseXMax = -Number.MAX_VALUE;
            let baseYMin =  Number.MAX_VALUE;
            let baseYMax = -Number.MAX_VALUE;
            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const target  = this._$moveTargets[idx].target;
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const bounds = Util.$boundsMatrix(
                    character.getBounds(),
                    character.getPlace(frame).matrix
                );

                baseXMin = Math.min(baseXMin, bounds.xMin);
                baseXMax = Math.max(baseXMax, bounds.xMax);
                baseYMin = Math.min(baseYMin, bounds.yMin);
                baseYMax = Math.max(baseYMax, bounds.yMax);

            }

            const w = Math.abs(baseXMax - baseXMin) / 2;
            const h = Math.abs(baseYMax - baseYMin) / 2;

            const parentMatrix = Util.$multiplicationMatrix(
                [scale_x, 0, 0, 1, 0, 0],
                [1, 0, 0, 1, -w - baseXMin, -h - baseYMin]
            );

            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const target  = this._$moveTargets[idx].target;
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const place = character.getPlace(frame);

                const multiMatrix = Util.$multiplicationMatrix(
                    parentMatrix, place.matrix
                );

                place.matrix[0] = multiMatrix[0];
                place.matrix[1] = multiMatrix[1];
                place.matrix[2] = multiMatrix[2];
                place.matrix[3] = multiMatrix[3];
                place.matrix[4] = multiMatrix[4] + w + baseXMin;
                place.matrix[5] = multiMatrix[5] + h + baseYMin;

                const bounds = Util.$boundsMatrix(character.getBounds(), place.matrix);
                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);

                character._$image = null;
            }

            document
                .getElementById("transform-scale-y")
                .value = 100;

            document
                .getElementById("transform-scale-x")
                .value = 100;

        } else {

            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const target  = this._$moveTargets[idx].target;
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const instance = workSpace
                    .getLibrary(character.libraryId)
                    .createInstance(character.getPlace(frame));

                const rectangle = instance.getBounds();

                const bounds = character.getBounds();
                const w = Math.abs(bounds.xMax - bounds.xMin) / 2;
                const h = Math.abs(bounds.yMax - bounds.yMin) / 2;

                const place      = character.getPlace(frame);
                const baseMatrix = [1, 0, 0, 1, -w - rectangle.x, -h - rectangle.y];

                const beforeMatrix  = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    w + rectangle.x, h + rectangle.y
                ], baseMatrix);

                character.x -= beforeMatrix[4];
                character.y -= beforeMatrix[5];

                character.scaleX = scale_x;

                const afterMatrix = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    w + rectangle.x, h + rectangle.y
                ], baseMatrix);

                character.x += afterMatrix[4];
                character.y += afterMatrix[5];

                character._$image = null;

                tx = Math.min(tx, character.x);
                ty = Math.min(ty, character.y);

                const afterBounds = Util.$boundsMatrix(
                    character.getBounds(),
                    place.matrix
                );

                xMin = Math.min(xMin, afterBounds.xMin);
                xMax = Math.max(xMax, afterBounds.xMax);
                yMin = Math.min(yMin, afterBounds.yMin);
                yMax = Math.max(yMax, afterBounds.yMax);

                if (document
                    .getElementById(`${layerId}-${frame}`)
                    .classList
                    .contains("tween-frame")
                ) {
                    this.executeTween(layer);
                    this.createTweenMarker();
                }

            }

        }

        document
            .getElementById("object-x")
            .value = tx;

        document
            .getElementById("object-y")
            .value = ty;

        document
            .getElementById("object-width")
            .value = Math.abs(xMax - xMin);

        document
            .getElementById("object-height")
            .value = Math.abs(yMax - yMin);

    }

    /**
     * @param  {number} scale_y
     * @return {void}
     * @public
     */
    updateScaleY (scale_y)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        let tx = Number.MAX_VALUE;
        let ty = Number.MAX_VALUE;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        const multiple = this._$moveTargets.length > 1;
        if (multiple) {

            let baseXMin =  Number.MAX_VALUE;
            let baseXMax = -Number.MAX_VALUE;
            let baseYMin =  Number.MAX_VALUE;
            let baseYMax = -Number.MAX_VALUE;
            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const target  = this._$moveTargets[idx].target;
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const bounds = Util.$boundsMatrix(
                    character.getBounds(),
                    character.getPlace(frame).matrix
                );

                baseXMin = Math.min(baseXMin, bounds.xMin);
                baseXMax = Math.max(baseXMax, bounds.xMax);
                baseYMin = Math.min(baseYMin, bounds.yMin);
                baseYMax = Math.max(baseYMax, bounds.yMax);

            }

            const w = Math.abs(baseXMax - baseXMin) / 2;
            const h = Math.abs(baseYMax - baseYMin) / 2;

            const parentMatrix = Util.$multiplicationMatrix(
                [1, 0, 0, scale_y, 0, 0],
                [1, 0, 0, 1, -w - baseXMin, -h - baseYMin]
            );

            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const target  = this._$moveTargets[idx].target;
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const place = character.getPlace(frame);

                const multiMatrix = Util.$multiplicationMatrix(
                    parentMatrix, place.matrix
                );

                place.matrix[0] = multiMatrix[0];
                place.matrix[1] = multiMatrix[1];
                place.matrix[2] = multiMatrix[2];
                place.matrix[3] = multiMatrix[3];
                place.matrix[4] = multiMatrix[4] + w + baseXMin;
                place.matrix[5] = multiMatrix[5] + h + baseYMin;

                const bounds = Util.$boundsMatrix(character.getBounds(), place.matrix);
                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);

                character._$image = null;
            }

            document
                .getElementById("transform-scale-y")
                .value = 100;

            document
                .getElementById("transform-scale-x")
                .value = 100;

        } else {

            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const target  = this._$moveTargets[idx].target;
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const instance = workSpace
                    .getLibrary(character.libraryId)
                    .createInstance(character.getPlace(frame));

                const rectangle = instance.getBounds();

                const bounds = character.getBounds();
                const w = Math.abs(bounds.xMax - bounds.xMin) / 2;
                const h = Math.abs(bounds.yMax - bounds.yMin) / 2;

                const place      = character.getPlace(frame);
                const baseMatrix = [1, 0, 0, 1, -w - rectangle.x, -h - rectangle.y];

                const beforeMatrix  = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    w + rectangle.x, h + rectangle.y
                ], baseMatrix);

                character.x -= beforeMatrix[4];
                character.y -= beforeMatrix[5];

                character.scaleY  = scale_y;

                const afterMatrix = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    w + rectangle.x, h + rectangle.y
                ], baseMatrix);

                character.x += afterMatrix[4];
                character.y += afterMatrix[5];

                character._$image = null;

                tx = Math.min(tx, character.x);
                ty = Math.min(ty, character.y);

                const afterBounds = Util.$boundsMatrix(
                    character.getBounds(),
                    place.matrix
                );

                xMin = Math.min(xMin, afterBounds.xMin);
                xMax = Math.max(xMax, afterBounds.xMax);
                yMin = Math.min(yMin, afterBounds.yMin);
                yMax = Math.max(yMax, afterBounds.yMax);

                if (document
                    .getElementById(`${layerId}-${frame}`)
                    .classList
                    .contains("tween-frame")
                ) {
                    this.executeTween(layer);
                    this.createTweenMarker();
                }
            }

        }

        document
            .getElementById("object-x")
            .value = tx;

        document
            .getElementById("object-y")
            .value = ty;

        document
            .getElementById("object-width")
            .value = Math.abs(xMax - xMin);

        document
            .getElementById("object-height")
            .value = Math.abs(yMax - yMin);

    }

    /**
     * @param  {number} rotate
     * @return {void}
     * @public
     */
    updateRotate (rotate)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        let tx = Number.MAX_VALUE;
        let ty = Number.MAX_VALUE;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        const multiple = this._$moveTargets.length > 1;
        if (multiple) {

            let baseXMin =  Number.MAX_VALUE;
            let baseXMax = -Number.MAX_VALUE;
            let baseYMin =  Number.MAX_VALUE;
            let baseYMax = -Number.MAX_VALUE;
            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const target  = this._$moveTargets[idx].target;
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const bounds = Util.$boundsMatrix(
                    character.getBounds(),
                    character.getPlace(frame).matrix
                );

                baseXMin = Math.min(baseXMin, bounds.xMin);
                baseXMax = Math.max(baseXMax, bounds.xMax);
                baseYMin = Math.min(baseYMin, bounds.yMin);
                baseYMax = Math.max(baseYMax, bounds.yMax);

            }

            const w = Math.abs(baseXMax - baseXMin) / 2;
            const h = Math.abs(baseYMax - baseYMin) / 2;

            const radian = rotate * Util.$Deg2Rad;
            const parentMatrix = Util.$multiplicationMatrix(
                [Math.cos(radian), Math.sin(radian), -Math.sin(radian), Math.cos(radian), 0, 0],
                [1, 0, 0, 1, -w - baseXMin, -h - baseYMin]
            );

            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const target  = this._$moveTargets[idx].target;
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const place = character.getPlace(frame);

                const multiMatrix = Util.$multiplicationMatrix(
                    parentMatrix, place.matrix
                );

                place.matrix[0] = multiMatrix[0];
                place.matrix[1] = multiMatrix[1];
                place.matrix[2] = multiMatrix[2];
                place.matrix[3] = multiMatrix[3];
                place.matrix[4] = multiMatrix[4] + w + baseXMin;
                place.matrix[5] = multiMatrix[5] + h + baseYMin;

                const bounds = Util.$boundsMatrix(character.getBounds(), place.matrix);
                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);

                character._$image = null;
            }

        } else {

            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const target = this._$moveTargets[idx].target;

                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                if (character.rotation === rotate) {
                    return ;
                }

                const bounds = character.getBounds();
                const w = Math.abs(bounds.xMax - bounds.xMin) / 2;
                const h = Math.abs(bounds.yMax - bounds.yMin) / 2;

                const instance = workSpace
                    .getLibrary(character.libraryId)
                    .createInstance(character.getPlace(frame));

                const rectangle  = instance.getBounds();

                const place      = character.getPlace(frame);
                const baseMatrix = [1, 0, 0, 1, -w - rectangle.x , -h - rectangle.y];

                const beforeMatrix  = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    w + rectangle.x, h + rectangle.y
                ], baseMatrix);

                character.x -= beforeMatrix[4];
                character.y -= beforeMatrix[5];

                // fixed
                character.rotation = rotate;

                const afterMatrix = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    w + rectangle.x, h + rectangle.y
                ], baseMatrix);

                character.x += afterMatrix[4];
                character.y += afterMatrix[5];

                // clear
                character._$image = null;

                let xScale = character.scaleX;
                if (Math.atan2(place.matrix[1], place.matrix[0]) >= Math.PI) {
                    xScale *= -1;
                }

                document
                    .getElementById("transform-scale-x")
                    .value = xScale * 100;

                document
                    .getElementById("transform-scale-y")
                    .value = character.scaleY * 100;

                tx = Math.min(tx, character.x);
                ty = Math.min(ty, character.y);

                const afterBounds = Util.$boundsMatrix(
                    character.getBounds(),
                    place.matrix
                );

                xMin = Math.min(xMin, afterBounds.xMin);
                xMax = Math.max(xMax, afterBounds.xMax);
                yMin = Math.min(yMin, afterBounds.yMin);
                yMax = Math.max(yMax, afterBounds.yMax);

                if (document
                    .getElementById(`${layerId}-${frame}`)
                    .classList
                    .contains("tween-frame")
                ) {
                    this.executeTween(layer);
                    this.createTweenMarker();
                }

            }

        }

        document
            .getElementById("object-x")
            .value = tx;

        document
            .getElementById("object-y")
            .value = ty;

        document
            .getElementById("object-width")
            .value = Math.abs(xMax - xMin);

        document
            .getElementById("object-height")
            .value = Math.abs(yMax - yMin);

        if (multiple) {

            document
                .getElementById("transform-scale-y")
                .value = 100;

            document
                .getElementById("transform-scale-x")
                .value = 100;

        }
    }

    /**
     * @param  {number} value
     * @param  {number} index
     * @return {void}
     * @public
     */
    updateColorMultiplier(value, index)
    {

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const target  = this._$moveTargets[0].target;
        const layerId = target.dataset.layerId | 0;
        const layer   = scene.getLayer(layerId);

        const characterId = target.dataset.characterId | 0;
        const character   = layer.getCharacter(characterId);

        // update
        const place = character.getPlace(frame);

        place.colorTransform[index] = Util.$clamp(
            value,
            Util.COLOR_MIN_MULTIPLIER,
            Util.COLOR_MAX_MULTIPLIER
        ) / 100;

        // clear
        character._$image = null;

        if (document
            .getElementById(`${layerId}-${frame}`)
            .classList
            .contains("tween-frame")
        ) {
            this.executeTween(layer);
            this.createTweenMarker();
        }
    }

    /**
     * @param  {number} value
     * @param  {number} index
     * @return {void}
     * @public
     */
    updateColorOffset(value, index)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const target  = this._$moveTargets[0].target;
        const layerId = target.dataset.layerId | 0;
        const layer   = scene.getLayer(layerId);

        const characterId = target.dataset.characterId | 0;
        const character   = layer.getCharacter(characterId);

        // update
        const place = character.getPlace(frame);

        place.colorTransform[index] = Util.$clamp(
            value | 0,
            Util.COLOR_MIN_OFFSET,
            Util.COLOR_MAX_OFFSET
        );

        // clear
        character._$image = null;

        if (document
            .getElementById(`${layerId}-${frame}`)
            .classList
            .contains("tween-frame")
        ) {
            this.executeTween(layer);
            this.createTweenMarker();
        }
    }

    /**
     * @param {string} blend_mode
     * @return {void}
     * @public
     */
    updateBlendMode (blend_mode)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const target  = this._$moveTargets[0].target;
        const layerId = target.dataset.layerId | 0;
        const layer   = scene.getLayer(layerId);

        const characterId = target.dataset.characterId | 0;
        const character   = layer.getCharacter(characterId);

        // update
        const place = character.getPlace(frame);
        place.blendMode = blend_mode;

        // clear
        character._$image = null;

        // reload
        scene.changeFrame(frame);
    }

    /**
     * @param  {HTMLInputElement} element
     * @return {void}
     * @public
     */
    updateVideoVolume (element)
    {
        const target = this._$moveTargets[0].target;

        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace.getLibrary(
            target.dataset.libraryId | 0
        );

        instance.volume = element.value | 0;
    }

    /**
     * @return {void}
     * @public
     */
    updateShapeGrid ()
    {
        const target    = this._$moveTargets[0].target;
        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace.getLibrary(
            target.dataset.libraryId | 0
        );

        const x = +document.getElementById("nine-slice-setting-x").value;
        const y = +document.getElementById("nine-slice-setting-y").value;
        const w = +document.getElementById("nine-slice-setting-w").value;
        const h = +document.getElementById("nine-slice-setting-h").value;

        switch (0) {

            case x:
            case y:
                instance._$grid = null;
                this.hideGridTarget();
                break;

            default:
                instance._$grid = { "x": x, "y": y, "w": w, "h": h };
                this.showGridTarget();
                this.placeGridTarget();
                break;

        }

        instance.cacheClear();
    }

    /**
     * @param  {object} object
     * @return {void}
     * @public
     */
    updateText (object)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const target  = this._$moveTargets[0].target;
        const layerId = target.dataset.layerId | 0;
        const layer   = scene.getLayer(layerId);

        const characterId = target.dataset.characterId | 0;
        const character   = layer.getCharacter(characterId);
        const instance    = workSpace.getLibrary(character.libraryId);

        // update
        instance[object.name] = object.value;

        // clear
        character._$image = null;

        // reload
        scene.changeFrame(frame);
    }

    /**
     * @param  {HTMLElement} element
     * @return {void}
     * @public
     */
    activeFrame (element)
    {
        const layerId = element.dataset.layerId | 0;
        const layerElement = document
            .getElementById(`layer-id-${layerId}`);

        const timeline = Util.$timeline;
        if (timeline._$targetLayer) {
            timeline
                ._$targetLayer
                .classList
                .remove("active");
        }

        if (!layerElement.classList.contains("active")) {
            layerElement.classList.add("active");
        }
        timeline._$targetLayer = layerElement;

        const frame = document
            .getElementById("current-frame")
            .textContent;

        const frameElement = document
            .getElementById(`${layerId}-${frame}`);

        if (!frameElement.classList.contains("frame-active")) {

            frameElement.classList.add("frame-active");

            timeline._$targetFrame = frameElement;
            timeline._$targetFrames.push(frameElement);
        }
    }

    /**
     * @param  {boolean} [recycle=false]
     * @return {void}
     * @public
     */
    createTweenMarker (recycle = true)
    {
        const layerElement = Util.$timeline._$targetLayer;
        if (!layerElement) {
            return ;
        }
        const layerId = layerElement.dataset.layerId | 0;

        const currentFrame = document
            .getElementById("current-frame")
            .textContent | 0;

        let startFrame = currentFrame;
        while (startFrame > 1) {

            const element = document
                .getElementById(`${layerId}-${startFrame}`);

            if (element.classList.contains("key-frame")) {
                break;
            }

            --startFrame;
        }

        let endFrame = currentFrame;
        for (;;) {

            const element = document
                .getElementById(`${layerId}-${endFrame}`);

            if (element.classList.contains("tween-frame-end")) {
                break;
            }

            ++endFrame;
        }

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(layerId);

        const character = layer.getActiveCharacter(currentFrame)[0];

        // set select
        const tween = character.getTween();
        const functionName = tween.method;

        const children = document
            .getElementById("ease-select")
            .children;

        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];
            if (node.value !== functionName) {
                continue;
            }

            node.selected = true;
            break;
        }

        const stageAreaElement = document.getElementById("stage-area");

        const elements = [];
        if (recycle) {
            const children = stageAreaElement.children;
            for (let idx = 0; idx < children.length; ++idx) {
                const node = children[idx];
                if (node.dataset.child !== "tween") {
                    continue;
                }
                if (node.dataset.curve === "true") {
                    continue;
                }
                elements.push(node);
            }
        }

        if (!elements.length) {
            for (let frame = startFrame; frame < endFrame; ++frame) {
                elements.push(document.createElement("div"));
            }
        }

        const baseBounds = character.getBounds();
        let index = 0;
        for (let frame = startFrame; frame < endFrame; ++frame) {

            const div = elements[index++];

            if (!recycle) {
                stageAreaElement.appendChild(div);
                div.classList.add("tween-marker");
                div.dataset.child = "tween";
            }

            const matrix = character.getPlace(frame).matrix;
            const bounds = Util.$boundsMatrix(baseBounds, matrix);
            const width  = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2);
            const height = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2);
            div.style.left = `${Util.$offsetLeft + bounds.xMin + width  - 2}px`;
            div.style.top  = `${Util.$offsetTop  + bounds.yMin + height - 2}px`;
        }

        if (!recycle) {
            for (let idx = 0; idx < tween.curve.length; ++idx) {

                const pointer = tween.curve[idx];

                const div = this.createTweenCurveElement(pointer, idx);

                stageAreaElement.appendChild(div);

            }
        }

        document
            .getElementById("ease-setting")
            .style.display = "";
    }

    /**
     * @param  {object} pointer
     * @param  {number} index
     * @return {HTMLDivElement|null}
     */
    createTweenCurveElement (pointer, index)
    {
        const layerElement = Util.$timeline._$targetLayer;
        if (!layerElement) {
            return null;
        }
        const layerId = layerElement.dataset.layerId | 0;

        const div = document.createElement("div");

        div.classList.add(
            "tween-pointer-marker",
            "tween-pointer-disabled"
        );

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        div.textContent        = `${index + 1}`;
        div.dataset.child      = "tween";
        div.dataset.curve      = "true";
        div.dataset.layerId    = `${layerId}`;
        div.dataset.tweenIndex = `${frame}`;
        div.dataset.index      = `${index}`;
        div.dataset.detail     = "{{カーブポインター(ダブルクリックでON/OFF)}}";

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(layerId);

        const character = layer.getActiveCharacter(frame)[0];
        if (!character) {
            return null;
        }

        const matrix     = character.getPlace(frame).matrix;
        const baseBounds = character.getBounds();
        const bounds     = Util.$boundsMatrix(baseBounds, matrix);

        const width  = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2);
        const height = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2);

        div.style.left = `${Util.$offsetLeft + pointer.x + baseBounds.xMin + width}px`;
        div.style.top  = `${Util.$offsetTop  + pointer.y + baseBounds.yMin + height}px`;

        if (pointer.usePoint) {
            div.classList.remove("tween-pointer-disabled");
            div.classList.add("tween-pointer-active");
        } else {
            div.classList.add("tween-pointer-disabled");
            div.classList.remove("tween-pointer-active");
        }

        div.addEventListener("mousedown", function (event)
        {
            this._$tweenMode       = true;
            this._$tweenController = event.target;
            this._$tweenDelete     = event.target;

            this._$rectPosition = {
                "x": event.pageX - event.target.offsetLeft,
                "y": event.pageY - event.target.offsetTop
            };

            if (!Util.$timeline._$targetLayer) {
                Util.$timeline._$targetLayer = document
                    .getElementById(`layer-id-${event.target.dataset.layerId}`);
            }

            this._$moveTargets.length = 0;
            this.hideTransformTarget();
            this.hideGridTarget();

        }.bind(this));

        div.addEventListener("dblclick", function (event)
        {
            const element = event.target;

            const scene = Util.$currentWorkSpace().scene;
            const layer = scene.getLayer(element.dataset.layerId | 0);

            const frame = element.dataset.tweenIndex | 0;
            const character = layer.getActiveCharacter(frame)[0];

            const tween = character.getTween();
            const pointer = tween.curve[element.dataset.index];

            pointer.usePoint = !pointer.usePoint;

            if (pointer.usePoint) {

                element.classList.remove("tween-pointer-disabled");
                element.classList.add("tween-pointer-active");

            } else {

                element.classList.add("tween-pointer-disabled");
                element.classList.remove("tween-pointer-active");

            }

            if (!Util.$timeline._$targetLayer) {
                Util.$timeline._$targetLayer = document
                    .getElementById(`layer-id-${event.target.dataset.layerId}`);
            }

            this.executeTween(layer);
            this.createTweenMarker();

            const onionElement = document
                .getElementById("timeline-onion-skin");
            if (onionElement.classList.contains("onion-skin-active")) {
                Util.$currentWorkSpace().scene.changeFrame(frame);
            }

        }.bind(this));

        div.addEventListener("mouseover", function (event)
        {
            const object = Util.$tools.getUserPublishSetting();
            if ("modal" in object && !object.modal) {
                return ;
            }

            const element = document.getElementById("detail-modal");

            element.textContent = Util.$currentLanguage.replace(
                event.currentTarget.dataset.detail
            );
            element.style.left  = `${event.pageX - 20}px`;
            element.style.top   = `${event.pageY + 20}px`;
            element.setAttribute("class", "fadeIn");

            element.dataset.timerId = setTimeout(function ()
            {
                if (!this.classList.contains("fadeOut")) {
                    this.setAttribute("class", "fadeOut");
                }
            }.bind(element), 1500);
        });

        div.addEventListener("mouseout", function ()
        {
            this._$tweenDelete = null;
            Util.$setCursor("auto");

            const object = Util.$tools.getUserPublishSetting();
            if ("modal" in object && !object.modal) {
                return ;
            }

            const element = document.getElementById("detail-modal");
            clearTimeout(element.dataset.timerId | 0);
            element.setAttribute("class", "fadeOut");
        }.bind(this));

        return div;
    }

    /**
     * @return {void}
     * @public
     */
    addTweenPointer ()
    {
        const layerElement = Util.$timeline._$targetLayer;
        if (!layerElement) {
            return ;
        }
        const layerId = layerElement.dataset.layerId | 0;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(layerId);

        const characters = layer.getActiveCharacter(frame);
        if (characters.length > 1) {
            return ;
        }

        const character = characters[0];
        if (!character.hasTween()) {
            return ;
        }

        const tween      = character.getTween();
        const index      = tween.curve.length;
        const matrix     = character.getPlace(character.startFrame).matrix;
        const baseBounds = character.getBounds();
        const bounds     = Util.$boundsMatrix(baseBounds, matrix);

        const pointer = {
            "usePoint": true,
            "x": bounds.xMin - baseBounds.xMin - 5,
            "y": bounds.yMin - baseBounds.yMin - 5
        };
        tween.curve.push(pointer);

        const div = this.createTweenCurveElement(pointer, index);
        if (div) {
            document
                .getElementById("stage-area")
                .appendChild(div);
        }

        this.executeTween(layer);
        this.createTweenMarker();

    }

    /**
     * @return {void}
     * @public
     */
    clearTweenMarker ()
    {
        const stageArea = document.getElementById("stage-area");

        let idx = 0;
        while (stageArea.children.length > idx) {

            const node = stageArea.children[idx];
            if (node.dataset.child !== "tween") {
                idx++;
                continue;
            }

            node.remove();
        }

        document
            .getElementById("ease-setting")
            .style.display = "none";

        Util.$controller.hideEaseCanvasArea();
    }

    /**
     * @param  {HTMLElement} element
     * @return {void}
     * @public
     */
    clearActiveFrame (element)
    {
        const layerId = element.dataset.layerId | 0;

        const layerElement = document
            .getElementById(`layer-id-${layerId}`);

        if (!layerElement) {
            return ;
        }

        if (layerElement.classList.contains("active")) {
            layerElement.classList.remove("active");
        }
        Util.$timeline._$targetLayer = null;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const frameElement = document
            .getElementById(`${layerId}-${frame}`);

        if (Util.$timeline._$targetFrames.indexOf(frameElement) > -1) {
            if (frameElement.classList.contains("frame-active")) {
                frameElement.classList.remove("frame-active");
            }
        }
    }

    /**
     * @return {void}
     * @public
     */
    clearActiveCharacter ()
    {
        if (this._$moveTargets && this._$moveTargets.length) {

            for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                const element = this._$moveTargets[idx].target;

                this.clearActiveFrame(element);

            }

            this._$moveTargets.length = 0;

            this.hideTransformTarget();
            this.hideGridTarget();

            Util.$controller.clearFilters();
        }
    }

    /**
     * @param  {object} object
     * @param  {number} x
     * @param  {number} y
     * @return {void}
     * @public
     */
    addTextField (object, x = 0, y = 0)
    {
        const scene   = Util.$currentWorkSpace().scene;
        const target  = Util.$timeline._$targetLayer;
        const layerId = target.dataset.layerId | 0;

        const layer = scene.getLayer(layerId | 0);
        if (layer.lock) {
            return ;
        }

        Util
            .$controller
            .createContainer("text", object.name, object.id);

        const workSpace = Util.$currentWorkSpace();
        const textField = workSpace.addLibrary(object);

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const frameElement = document
            .getElementById(`${layerId}-${frame}`); // fixed

        // add frame
        Util
            .$timeline
            .dropKeyFrame(frameElement);

        // pointer
        const character = new Character();
        character.libraryId  = textField.id;
        character.startFrame = frame;
        character.endFrame   = layer.getEndFrame(frame + 1);
        character.setPlace(frame, {
            "frame": frame,
            "matrix": [1, 0, 0, 1, x, y],
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": [],
            "depth": layer._$characters.length
        });

        // added
        layer.addCharacter(character);
        this.appendCharacter(character, frame, layerId | 0, "none");
    }

    /**
     * @param  {object} object
     * @param  {number} x
     * @param  {number} y
     * @return {void}
     * @public
     */
    addShape (object, x = 0, y = 0)
    {
        const scene   = Util.$currentWorkSpace().scene;
        const target  = Util.$timeline._$targetLayer;
        const layerId = target.dataset.layerId | 0;

        const layer = scene.getLayer(layerId | 0);
        if (layer.lock) {
            return ;
        }

        Util
            .$controller
            .createContainer("shape", object.name, object.id);

        const workSpace = Util.$currentWorkSpace();
        const shape = workSpace.addLibrary(object);

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const frameElement = document
            .getElementById(`${layerId}-${frame}`); // fixed

        // add frame
        Util
            .$timeline
            .dropKeyFrame(frameElement);

        // pointer
        const character = new Character();
        character.libraryId  = shape.id;
        character.startFrame = frame;
        character.endFrame   = layer.getEndFrame(frame + 1);
        character.setPlace(frame, {
            "frame": frame,
            "matrix": [1, 0, 0, 1, x, y],
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": [],
            "depth": layer._$characters.length
        });

        // added
        layer.addCharacter(character);
        this.appendCharacter(character, frame, layerId | 0, "none");
    }

    /**
     * @param  {DragEvent} event
     * @return {void}
     * @public
     */
    dropObject (event)
    {
        const libraryId = Util.$dragElement.dataset.libraryId | 0;
        const instance  = Util.$currentWorkSpace().getLibrary(libraryId);
        switch (instance.type) {

            case "folder":
            case "sound":
                return ;

            default:
                break;

        }

        if (!Util.$timeline._$targetLayer) {

            const parent = document
                .getElementById("timeline-content");

            if (!parent.children.length) {
                return ;
            }

            const node = parent.children[0];
            const layerElement = document
                .getElementById(`${node.dataset.layerId}-1`);

            if (!layerElement) {
                return ;
            }

            Util.$timeline._$targetLayer = layerElement;
        }

        const scene   = Util.$currentWorkSpace().scene;
        const target  = Util.$timeline._$targetLayer;
        const layerId = target.dataset.layerId | 0;

        const layer = scene.getLayer(layerId | 0);
        if (layer.lock) {
            return ;
        }

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const frameElement = document
            .getElementById(`${layerId}-${frame}`); // fixed

        if (frameElement.classList.contains("tween-frame")) {
            return ;
        }
        if (frameElement.classList.contains("morph-frame")) {
            return ;
        }

        // add frame
        Util
            .$timeline
            .dropKeyFrame(frameElement);

        const x = event.offsetX - Util.$offsetLeft;
        const y = event.offsetY - Util.$offsetTop;

        const endFrame = layer.getEndFrame(frame + 1);

        const join = {
            "start": null,
            "end": null
        };

        const characters = layer._$characters;
        for (let idx = 0; idx < characters.length; ++idx) {

            const character = characters[idx];
            if (character.libraryId !== libraryId) {
                continue;
            }

            switch (true) {

                case frame > 1 && character.endFrame === frame:
                    join.start = character;
                    break;

                case character.startFrame === endFrame:
                    join.end = character;
                    break;

            }
        }

        const place = {
            "frame": frame,
            "matrix": [1, 0, 0, 1, x, y],
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": [],
            "depth": layer._$characters.length
        };

        let character = null;
        if (join.start) {
            character = join.start;
            character.endFrame = endFrame;
        }

        if (join.end) {

            if (character) {

                character.endFrame = join.end.endFrame;

                for (let [frame, place] of join.end._$places) {
                    character.setPlace(frame, place);
                }

                layer.deleteCharacter(join.end.id);

            } else {

                character = join.end;
                character.startFrame = frame;

            }
        }

        // new character
        if (!character) {

            character = new Character();
            character.libraryId  = libraryId;
            character.startFrame = frame;
            character.endFrame   = endFrame;

            if (instance.type === "container") {
                place.loop = {
                    "type": 0,
                    "start": 1,
                    "end": 0
                };
            }

            character.setPlace(frame, place);

            let width = character.width;
            if (!width) {
                width = 10;
            }

            let height = character.height;
            if (!height) {
                height = 10;
            }

            const bounds = character.getBounds();
            place.matrix[4] -= bounds.xMin + width  / 2;
            place.matrix[5] -= bounds.yMin + height / 2;

            // added
            layer.addCharacter(character);
            this.appendCharacter(character, frame, layerId | 0);

        } else {

            if (instance.type === "container") {
                place.loop = {
                    "type": 0,
                    "start": 1,
                    "end": 0
                };
            }

            // add place
            character.setPlace(frame, place);

            let width = character.width;
            if (!width) {
                width = 10;
            }

            let height = character.height;
            if (!height) {
                height = 10;
            }

            const bounds = character.getBounds();
            place.matrix[4] -= bounds.xMin + width  / 2;
            place.matrix[5] -= bounds.yMin + height / 2;

        }

        // 描画リセット
        scene.changeFrame(frame);

        // param clear
        if (Util.$controller._$libraryTarget) {

            Util
                .$controller
                ._$libraryTarget
                .classList
                .remove("active");

            Util
                .$controller
                ._$libraryTarget = null;

        }
    }

    /**
     * @param  {Character} character
     * @param  {number} layer_id
     * @return {void}
     * @public
     */
    appendOnionCharacter (character, layer_id)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        // create image
        const image = character.image.cloneNode(true);
        image.style.left = `${character.offsetX}px`;
        image.style.top  = `${character.offsetY}px`;

        // create div
        const div = document.createElement("div");

        div.dataset.child = "true";
        div.appendChild(image);

        // mask attach
        const layer = scene.getLayer(layer_id);
        if (layer.maskId !== null) {

            const maskLayer = scene.getLayer(layer.maskId);
            if (!maskLayer) {
                layer.maskId = null;
            }

            if (maskLayer && maskLayer.lock && maskLayer._$characters.length) {

                const maskCharacter = maskLayer._$characters[0];
                const maskImage     = maskCharacter.image;

                const x = maskCharacter.screenX - character.screenX;
                const y = maskCharacter.screenY - character.screenY;

                div.style.webkitMask         = `url(${maskImage.src}), none`;
                div.style.webkitMaskSize     = `${maskImage.width}px ${maskImage.height}px`;
                div.style.webkitMaskRepeat   = "no-repeat";
                div.style.webkitMaskPosition = `${x}px ${y}px`;

            } else {

                div.style.webkitMask         = "";
                div.style.webkitMaskSize     = "";
                div.style.webkitMaskRepeat   = "";
                div.style.webkitMaskPosition = "";

            }
        }

        div.style.position      = "absolute";
        div.style.left          = `${Util.$offsetLeft + character.screenX}px`;
        div.style.top           = `${Util.$offsetTop  + character.screenY}px`;
        div.style.pointerEvents = "none";
        div.style.opacity       = "0.25";

        document
            .getElementById("stage-area")
            .appendChild(div);
    }

    /**
     * @param  {Character} character
     * @param  {number}    frame
     * @param  {number}    layer_id
     * @param  {string}    [event="auto"]
     * @return {void}
     * @public
     */
    appendCharacter (
        character, frame, layer_id, event = "auto"
    ) {

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        // setup
        const place    = character.getPlace(frame);
        const instance = workSpace.getLibrary(character.libraryId);

        let doUpdate = !character._$currentPlace;
        switch (instance.type) {

            case "container":
                if (instance.totalFrame > 1 && character._$currentFrame !== frame) {
                    doUpdate = true;
                    character._$currentFrame = frame;
                }
                break;

            case "video":
                if (character._$currentFrame !== frame) {
                    doUpdate = true;
                    character._$currentFrame = frame;
                }
                break;

            default:
                break;

        }

        if (place !== character._$currentPlace) {

            if (character._$currentPlace) {

                // check matrix
                const nextMatrix    = place.matrix;
                const currentMatrix = character._$currentPlace.matrix;
                switch (true) {

                    case nextMatrix[0] !== currentMatrix[0]:
                    case nextMatrix[1] !== currentMatrix[1]:
                    case nextMatrix[2] !== currentMatrix[2]:
                    case nextMatrix[3] !== currentMatrix[3]:
                        doUpdate = true;
                        break;

                    default:
                        character._$screenX += -currentMatrix[4] + nextMatrix[4];
                        character._$screenY += -currentMatrix[5] + nextMatrix[5];
                        break;
                }

                // check color transform
                if (!doUpdate) {
                    const nextColorTransform    = place.colorTransform;
                    const currentColorTransform = character._$currentPlace.colorTransform;
                    switch (true) {

                        case nextColorTransform[0] !== currentColorTransform[0]:
                        case nextColorTransform[1] !== currentColorTransform[1]:
                        case nextColorTransform[2] !== currentColorTransform[2]:
                        case nextColorTransform[3] !== currentColorTransform[3]:
                        case nextColorTransform[4] !== currentColorTransform[4]:
                        case nextColorTransform[5] !== currentColorTransform[5]:
                        case nextColorTransform[6] !== currentColorTransform[6]:
                        case nextColorTransform[7] !== currentColorTransform[7]:
                            doUpdate = true;
                            break;

                        default:
                            break;
                    }
                }

                // check blend mode
                if (!doUpdate
                    && place.blendMode !== character._$currentPlace.blendMode
                ) {
                    doUpdate = true;
                }

                // check filter
                if (!doUpdate) {

                    if (character._$currentPlace.filter.length !== place.filter.length) {
                        doUpdate = true;
                    }

                    if (!doUpdate) {

                        for (let idx = 0; idx < place.filter.length; ++idx) {

                            const nextFilter    = place.filter[idx];
                            const currentFilter = character._$currentPlace[idx];

                            if (!nextFilter || !currentFilter) {
                                doUpdate = true;
                                break;
                            }

                            if (currentFilter.constructor !== nextFilter.constructor) {
                                doUpdate = true;
                                break;
                            }

                            if (!currentFilter.isSame(nextFilter)) {
                                doUpdate = true;
                                break;
                            }

                        }
                    }
                }
            }

            // update
            character._$currentPlace = place;
        }

        // cache delete
        if (doUpdate) {
            character._$image = null;
        }

        // create image
        const image = character.image;
        image.style.left = `${character.offsetX}px`;
        image.style.top  = `${character.offsetY}px`;

        // create div
        const div = document.createElement("div");
        div.appendChild(image);

        // mask attach
        const layer = scene.getLayer(layer_id);
        if (layer.maskId !== null) {

            const maskLayer = scene.getLayer(layer.maskId);
            if (!maskLayer) {
                layer.maskId = null;
            }

            if (maskLayer && maskLayer.lock && maskLayer._$characters.length) {

                const maskCharacter = maskLayer._$characters[0];
                const maskImage     = maskCharacter.image;

                const x = maskCharacter.screenX - character.screenX;
                const y = maskCharacter.screenY - character.screenY;

                div.style.webkitMask         = `url(${maskImage.src}), none`;
                div.style.webkitMaskSize     = `${maskImage.width}px ${maskImage.height}px`;
                div.style.webkitMaskRepeat   = "no-repeat";
                div.style.webkitMaskPosition = `${x}px ${y}px`;
                div.style.mixBlendMode       = image.style.mixBlendMode;
                div.style.filter             = image.style.filter;

            } else {

                div.style.webkitMask         = "";
                div.style.webkitMaskSize     = "";
                div.style.webkitMaskRepeat   = "";
                div.style.webkitMaskPosition = "";
                div.style.mixBlendMode       = "";
                div.style.filter             = "";

            }
        }

        div.id = `character-${character.id}`;
        div.dataset.characterId  = `${character.id}`;
        div.dataset.layerId      = `${layer_id}`;
        div.dataset.instanceType = instance.type;
        div.dataset.libraryId    = `${character.libraryId}`;
        div.dataset.child        = "true";

        let tx = Util.$offsetLeft + character.screenX;
        let ty = Util.$offsetTop  + character.screenY;

        div.style.position = "absolute";
        div.style.left     = `${tx}px`;
        div.style.top      = `${ty}px`;

        let width = character.width;
        if (!width) {
            width = 10;
        }

        let height = character.height;
        if (!height) {
            height = 10;
        }

        div.style.width  = `${width}px`;
        div.style.height = `${height}px`;
        div.style.pointerEvents = event;

        div.addEventListener("contextmenu", function (event)
        {
            this._$objectClicked = true;

            const element = document.getElementById("screen-menu");

            element.style.left = `${event.pageX + 5}px`;
            element.style.top  = `${event.pageY - element.clientHeight / 2}px`;

            if (0 > element.offsetTop) {
                element.style.top = "10px";
            }

            if (event.pageY + element.clientHeight / 2 > window.innerHeight) {
                element.style.top = `${window.innerHeight - event.pageY}px`;
            }

            element.setAttribute("class", "fadeIn");

            Util.$endMenu("screen-menu");

        }.bind(this));

        div.addEventListener("mouseover", function (event)
        {
            if (Util.$tools._$activeTool
                && Util.$tools._$activeTool.dataset.name !== "arrow"
            ) {
                return ;
            }

            if (this._$moveMode) {
                return ;
            }

            const target  = event.currentTarget;
            const layerId = target.dataset.layerId | 0;

            const lockElement = document
                .getElementById(`layer-lock-icon-${layerId}`);

            if (lockElement.classList.contains("icon-active")) {
                return ;
            }

            Util.$setCursor("move");

        }.bind(this));

        div.addEventListener("mouseout", function ()
        {
            if (Util.$tools._$activeTool
                && Util.$tools._$activeTool.dataset.name !== "arrow"
            ) {
                return ;
            }

            Util.$setCursor("auto");
        });

        div.addEventListener("mousedown", function (event)
        {
            Util.$endMenu();
            if (Util.$tools._$activeTool) {

                switch (Util.$tools._$activeTool.dataset.name) {

                    case "arrow":
                    case "transform":
                        break;

                    default:
                        return ;

                }

            }

            this._$objectClicked = true;

            const target  = event.currentTarget;
            const layerId = target.dataset.layerId | 0;

            if (Util.$tools._$activeTool.dataset.name === "transform"
                && target.dataset.instanceType === "shape"
            ) {

                this._$shapeTransformMode = true;
                this.clearActiveCharacter();

                const frame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                const workSpace   = Util.$currentWorkSpace();
                const layerId     = target.dataset.layerId | 0;
                const characterId = target.dataset.characterId | 0;

                const scene     = workSpace.scene;
                const layer     = scene.getLayer(layerId);
                const character = layer.getCharacter(characterId);
                const instance  = workSpace.getLibrary(target.dataset.libraryId | 0);
                const matrix    = character.getPlace(frame).matrix;

                const cacheColor = Util.$hitColor;
                instance.setHitColor(event.offsetX, event.offsetY, matrix);
                if (Util.$hitColor) {
                    instance.createPointer(matrix, layerId, characterId);
                } else {
                    Util.$hitColor = cacheColor;
                }

                return ;
            }

            if (this._$shapeTransformMode) {
                return ;
            }

            const lockElement = document
                .getElementById(`layer-lock-icon-${layerId}`);

            if (lockElement.classList.contains("icon-active")) {
                return ;
            }

            const frame = document
                .getElementById("current-frame")
                .textContent | 0;

            let frameElement = Util.$timeline._$targetFrame;
            if (frameElement) {

                switch (frameElement.dataset.frameState) {

                    case "empty":
                    case "empty-key-frame":
                    case "empty-space-frame":
                    case "empty-space-frame-end":
                        this.clearActiveFrame(frameElement);
                        break;

                    default:
                        break;

                }

            } else {

                frameElement = document.getElementById(`${layerId}-${frame}`);

            }

            this._$moveMode = true;
            if (this._$multiMode) {

                let skip = false;
                for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                    const object = this._$moveTargets[idx];

                    if (object.target === target) {
                        this._$moveTargets.splice(idx, 1);
                        this.clearActiveFrame(target);
                        skip = true;
                        break;
                    }

                }

                if (!this._$moveTargets.length) {
                    Util.$controller.hideObjectArea();
                    return ;

                }

                if (!skip) {
                    this.addTarget(target);
                }

                if (frameElement.classList.contains("tween-frame")) {
                    this.clearTweenMarker();
                }

            } else {

                let change = true;
                for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

                    const object = this._$moveTargets[idx];

                    const element = object.target;
                    if (element === target) {
                        change = false;
                    }

                    object.moveX = event.pageX - object.target.offsetLeft;
                    object.moveY = event.pageY - object.target.offsetTop;
                }

                if (change) {

                    // reset
                    this.clearActiveCharacter();

                    // add
                    this.addTarget(target,
                        event.pageX - target.offsetLeft,
                        event.pageY - target.offsetTop
                    );

                }

                const workSpace = Util.$currentWorkSpace();

                const scene = workSpace.scene;
                const layer = scene.getLayer(layerId);

                const character = layer.getCharacter(target.dataset.characterId | 0);
                document.getElementById("object-name").value = character.name;

                if (frameElement.classList.contains("tween-frame")) {
                    this.clearTweenMarker();

                    const tween = character.getTween();
                    if (tween && tween.method === "custom") {
                        Util.$controller.showEaseCanvasArea();
                    }

                    this.executeTween(layer);
                    this.createTweenMarker(false);
                }

                const instance = workSpace.getLibrary(character.libraryId);
                if (instance.type === "shape") {
                    const matrix = character.getPlace(frame).matrix;
                    instance.setHitColor(event.offsetX, event.offsetY, matrix);
                }

            }

            this.updatePropertyArea(false);
            this._$saved = false;

        }.bind(this));

        switch (instance._$type) {

            case "container":
                div.addEventListener("dblclick", function (event)
                {
                    const workSpace = Util.$currentWorkSpace();

                    // add scene
                    workSpace.scene.addSceneName();

                    // fixed logic
                    document
                        .getElementById("current-frame")
                        .textContent = "1";

                    document
                        .getElementById("timeline-marker")
                        .style
                        .left = "0px";

                    const base = document
                        .getElementById("timeline-controller-base");

                    if (base.scrollLeft) {
                        Util.$timeline.moveTimeLine(0);
                    }

                    // update
                    workSpace.scene = workSpace.getLibrary(
                        event.currentTarget.dataset.libraryId | 0
                    );
                });
                break;

            case "text":
                {
                    const borderDiv = document.createElement("div");

                    borderDiv.style.width  = `${width  - 2}px`;
                    borderDiv.style.height = `${height - 2}px`;
                    borderDiv.style.pointerEvents = "none";

                    borderDiv.style.position = "absolute";
                    borderDiv.style.left     = "0px";
                    borderDiv.style.top      = "0px";

                    borderDiv.style.border = instance._$border
                        ? "1px solid gray"
                        : "1px dashed gray";

                    div.appendChild(borderDiv);

                    div.addEventListener("dblclick", function (event)
                    {
                        this._$inputMode     = true;
                        this._$objectClicked = true;
                        this.hideTransformTarget();
                        this.hideGridTarget();

                        const children = document
                            .getElementById("stage-area")
                            .children;

                        for (let idx = 0; idx < children.length; ++idx) {

                            const node = children[idx];
                            node.style.pointerEvents = "none";

                        }

                        const element = event.currentTarget;
                        element.style.pointerEvents = "";

                        const image = element.firstChild;
                        image.remove();

                        const textarea = window.document.createElement("textarea");
                        element.style.display = "none";
                        element.parentNode.appendChild(textarea);

                        const scene       = Util.$currentWorkSpace().scene;
                        const layerId     = element.dataset.layerId | 0;
                        const layer       = scene.getLayer(layerId);
                        const characterId = element.dataset.characterId | 0;
                        const character   = layer.getCharacter(characterId);
                        const instance    = workSpace.getLibrary(character.libraryId);

                        textarea.value = instance._$text;

                        textarea.style.border = instance._$border
                            ? "1px solid gray"
                            : "1px dashed gray";

                        textarea.style.fontSize      = `${instance._$size}px`;
                        textarea.style.fontFamily    = instance._$font;
                        textarea.style.width         = `${image.width - 4}px`;
                        textarea.style.height        = `${image.height}px`;
                        textarea.style.position      = "absolute";
                        textarea.style.left          = element.style.left;
                        textarea.style.top           = element.style.top;
                        textarea.style.pointerEvents = "auto";

                        if (!instance._$border) {
                            textarea.style.backgroundColor = "transparent";
                        }

                        // set params
                        textarea.dataset.characterId = `${character.id}`;
                        textarea.dataset.layerId     = `${layer_id}`;
                        textarea.dataset.libraryId   = `${character.libraryId}`;
                        textarea.dataset.child       = "true";

                        if (!instance._$multiline) {
                            textarea.addEventListener("keydown", function (event)
                            {
                                if (event.code === "Enter") {
                                    event.preventDefault();
                                    return false;
                                }
                            });
                        }

                        textarea.addEventListener("focusin", function ()
                        {
                            Util.$keyLock = true;
                        });

                        textarea.addEventListener("focusout", function (event)
                        {
                            const element     = event.target;
                            const scene       = Util.$currentWorkSpace().scene;
                            const layerId     = element.dataset.layerId | 0;
                            const layer       = scene.getLayer(layerId);
                            const characterId = element.dataset.characterId | 0;
                            const character   = layer.getCharacter(characterId);
                            const instance    = workSpace.getLibrary(character.libraryId);

                            // update
                            instance._$text = element.value;

                            // clear
                            character._$image = null;
                            Util.$keyLock     = false;
                            this._$inputMode  = false;

                            const children = document
                                .getElementById("stage-area")
                                .children;

                            for (let idx = 0; idx < children.length; ++idx) {
                                const node = children[idx];
                                node.style.pointerEvents = "";
                            }

                            const frame = document
                                .getElementById("current-frame")
                                .textContent | 0;

                            scene.changeFrame(frame);

                        }.bind(this));

                        textarea.focus();

                    }.bind(this));
                }
                break;

        }

        document
            .getElementById("stage-area")
            .appendChild(div);

    }

    /**
     * @param  {boolean} reload
     * @return {void}
     * @public
     */
    updatePropertyArea (reload = true)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        let tx   = Number.MAX_VALUE;
        let ty   = Number.MAX_VALUE;
        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;
        for (let idx = 0; idx < this._$moveTargets.length; ++idx) {

            const moveTarget = this._$moveTargets[idx].target;

            const layerId = moveTarget.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = moveTarget.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            tx = Math.min(tx, character.x);
            ty = Math.min(ty, character.y);

            const matrix = character.getPlace(frame).matrix;
            const bounds = Util.$boundsMatrix(character.getBounds(), matrix);
            xMin = Math.min(xMin, bounds.xMin);
            xMax = Math.max(xMax, bounds.xMax);
            yMin = Math.min(yMin, bounds.yMin);
            yMax = Math.max(yMax, bounds.yMax);
        }

        // property and matrix
        Util.$controller.showObjectArea();
        Util.$controller.hideStageSetting();

        document.getElementById("object-width").value  = Math.abs(xMax - xMin);
        document.getElementById("object-height").value = Math.abs(yMax - yMin);
        document.getElementById("object-x").value = tx;
        document.getElementById("object-y").value = ty;

        if (this._$moveTargets.length > 1) {

            Util.$controller.hideObjectSetting([
                "object-setting",
                "color-setting",
                "blend-setting",
                "loop-setting",
                "filter-setting",
                "video-setting",
                "instance-setting",
                "text-setting",
                "fill-color-setting",
                "nine-slice-setting"
            ]);

            document
                .getElementById("transform-scale-x")
                .value = 100;

            document
                .getElementById("transform-scale-y")
                .value = 100;

            document
                .getElementById("transform-rotate")
                .value = 0;

        } else {

            const target = this._$moveTargets[0].target;

            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            const instance = workSpace.getLibrary(character.libraryId);

            Util.$controller.showObjectSetting([
                "object-setting",
                "color-setting",
                "blend-setting",
                "filter-setting",
                "instance-setting"
            ]);

            Util.$controller.createInstanceSelect(instance);

            let place = character.getPlace(frame);
            switch (instance.type) {

                case "container":
                    {
                        Util.$controller.hideObjectSetting([
                            "text-setting",
                            "video-setting",
                            "fill-color-setting",
                            "nine-slice-setting"
                        ]);

                        Util.$controller.showObjectSetting([
                            "loop-setting"
                        ]);

                        const types = [
                            "loop-repeat",
                            "loop-no-repeat",
                            "fixed-one",
                            "loop-no-repeat-reversal",
                            "loop-repeat-reversal"
                        ];

                        const children = document
                            .getElementById("loop-setting-view-area")
                            .firstElementChild.children;

                        for (let idx = 0; idx < children.length; ++idx) {
                            children[idx].classList.remove("active");
                        }

                        if (place.loop.referenceFrame) {
                            place = character.getPlace(
                                place.loop.referenceFrame
                            );
                        }

                        document
                            .getElementById(types[place.loop.type])
                            .classList.add("active");

                        document
                            .getElementById("loop-start-frame")
                            .value = `${place.loop.start}`;

                        document
                            .getElementById("loop-end-frame")
                            .value = `${place.loop.end ? place.loop.end : "-"}`;

                        if (reload) {
                            const element = document
                                .getElementById("loop-image-list");

                            const children = element.children;
                            while (children.length) {
                                children[0].remove();
                            }

                            element.style.display = "none";
                        }
                    }
                    break;

                case "text":
                    {
                        Util.$controller.hideObjectSetting([
                            "video-setting",
                            "loop-setting",
                            "fill-color-setting",
                            "nine-slice-setting"
                        ]);

                        Util.$controller.showObjectSetting([
                            "text-setting"
                        ]);

                        document
                            .getElementById("object-name")
                            .value = place.name ? place.name : "";

                        const fontSelect = document
                            .getElementById("font-select");

                        // font
                        fontSelect.children[0].selected = true;
                        for (let idx = 0; idx < fontSelect.children.length; ++idx) {

                            const node = fontSelect.children[idx];

                            if (node.value !== instance._$font) {
                                continue;
                            }

                            node.selected = true;
                            break;
                        }

                        const fontStyleSelect = document
                            .getElementById("font-style-select");

                        for (let idx = 0; idx < fontStyleSelect.children.length; ++idx) {

                            const node = fontStyleSelect.children[idx];

                            if ((node.value | 0) !== instance._$fontType) {
                                continue;
                            }

                            node.selected = true;
                            break;
                        }

                        const fontAlignSelect = document
                            .getElementById("font-align-select");

                        for (let idx = 0; idx < fontAlignSelect.children.length; ++idx) {

                            const node = fontAlignSelect.children[idx];

                            if (node.value !== instance._$align) {
                                continue;
                            }

                            node.selected = true;
                            break;
                        }

                        const fontWrapSelect = document
                            .getElementById("font-wrap-select");

                        switch (true) {

                            case !instance._$wordWrap && !instance._$multiline:
                                fontWrapSelect.children[0].selected = true;
                                break;

                            case !instance._$wordWrap && instance._$multiline:
                                fontWrapSelect.children[1].selected = true;
                                break;

                            case instance._$wordWrap && instance._$multiline:
                                fontWrapSelect.children[2].selected = true;
                                break;

                        }

                        const fontInputSelect = document
                            .getElementById("font-input-select");

                        switch (instance._$inputType) {

                            case "static":
                                fontInputSelect.children[0].selected = true;
                                break;

                            case "input":
                                fontInputSelect.children[1].selected = true;
                                break;

                        }

                        document
                            .getElementById("font-size")
                            .value = `${instance._$size}`;

                        document
                            .getElementById("font-color")
                            .value = `#${instance._$color.toString(16).padStart(6, "0")}`;

                        document
                            .getElementById("font-stroke-size")
                            .value = `${instance._$thickness}`;

                        document
                            .getElementById("font-stroke-color")
                            .value = `#${instance._$thicknessColor.toString(16).padStart(6, "0")}`;

                        const params = [
                            "font-leading",
                            "font-letterSpacing",
                            "font-leftMargin",
                            "font-rightMargin"
                        ];

                        for (let idx = 0; idx < params.length; ++idx) {

                            const name = params[idx];

                            document
                                .getElementById(name)
                                .value = `${instance[name.split("-")[1]]}`;

                        }

                        document
                            .getElementById("font-auto-size-select")
                            .children[instance._$autoSize].selected = true;

                        if (instance._$border) {
                            document
                                .getElementById("font-border-select")
                                .children[1].selected = true;
                        }

                        if (instance._$scroll) {
                            document
                                .getElementById("font-scroll-select")
                                .children[0].selected = true;
                        }
                    }
                    break;

                case "video":

                    Util.$controller.hideObjectSetting([
                        "text-setting",
                        "loop-setting",
                        "fill-color-setting",
                        "nine-slice-setting"
                    ]);

                    Util.$controller.showObjectSetting([
                        "video-setting"
                    ]);

                    document
                        .getElementById("video-volume")
                        .value = instance.volume;

                    document
                        .getElementById("video-loop-select")
                        .children[instance.loop ? 1 : 0]
                        .selected = true;

                    document
                        .getElementById("video-auto-select")
                        .children[instance.autoPlay ? 1 : 0]
                        .selected = true;

                    break;

                case "shape":

                    document
                        .getElementById("nine-slice-setting-x")
                        .value = "0";

                    document
                        .getElementById("nine-slice-setting-y")
                        .value = "0";

                    document
                        .getElementById("nine-slice-setting-w")
                        .value = "0";

                    document
                        .getElementById("nine-slice-setting-h")
                        .value = "0";

                    Util.$controller.hideObjectSetting([
                        "text-setting",
                        "loop-setting",
                        "video-setting",
                        "fill-color-setting",
                        "nine-slice-setting"
                    ]);

                    if (Util.$hitColor) {

                        Util.$controller.showObjectSetting([
                            "fill-color-setting",
                            "nine-slice-setting"
                        ]);

                        const grid = instance._$grid;
                        if (grid && grid.x && grid.y) {

                            document
                                .getElementById("nine-slice-setting-x")
                                .value = `${instance._$grid.x}`;

                            document
                                .getElementById("nine-slice-setting-y")
                                .value = `${instance._$grid.y}`;

                            document
                                .getElementById("nine-slice-setting-w")
                                .value = `${instance._$grid.w}`;

                            document
                                .getElementById("nine-slice-setting-h")
                                .value = `${instance._$grid.h}`;

                            this.showGridTarget();
                            this.placeGridTarget();
                        }

                    }

                    break;

                default:
                    Util.$controller.hideObjectSetting([
                        "text-setting",
                        "loop-setting",
                        "video-setting",
                        "fill-color-setting",
                        "nine-slice-setting"
                    ]);
                    break;

            }

            document
                .getElementById("object-name")
                .value = character.name ? character.name : "";

            document
                .getElementById("object-symbol")
                .value = instance.symbol ? instance.symbol : "";

            const matrix  = place.matrix;
            const xScale  = Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
            const yScale  = Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);
            const radianX = Math.atan2( matrix[1], matrix[0]) * Util.$Rad2Deg;
            const radianY = Math.atan2(-matrix[2], matrix[3]) * Util.$Rad2Deg;

            document
                .getElementById("transform-scale-x")
                .value = Math.abs(Math.ceil(radianX - radianY)) >= 180
                    ? xScale * -100
                    : xScale * 100;

            document
                .getElementById("transform-scale-y")
                .value = yScale * 100;

            document
                .getElementById("transform-rotate")
                .value = radianX;

            const colorTransform = place.colorTransform;

            document
                .getElementById("color-red-multiplier")
                .value = colorTransform[0] * 100;
            document
                .getElementById("color-green-multiplier")
                .value = colorTransform[1] * 100;
            document
                .getElementById("color-blue-multiplier")
                .value = colorTransform[2] * 100;
            document
                .getElementById("color-alpha-multiplier")
                .value = colorTransform[3] * 100;

            document
                .getElementById("color-red-offset")
                .value = colorTransform[4];
            document
                .getElementById("color-green-offset")
                .value = colorTransform[5];
            document
                .getElementById("color-blue-offset")
                .value = colorTransform[6];
            document
                .getElementById("color-alpha-offset")
                .value = colorTransform[7];

            // blend mode
            const children = document
                .getElementById("blend-select")
                .children;

            for (let idx = 0; idx < children.length; ++idx) {

                const node = children[idx];

                if (node.value !== place.blendMode) {
                    continue;
                }

                node.selected = true;
                break;
            }

            Util.$controller.clearFilters();

            // filter
            const filterElement = document
                .getElementById("filter-setting-list");

            const length = place.filter.length;
            if (length) {
                document
                    .querySelectorAll(".filter-none")[0]
                    .style.display = "none";
            }

            for (let idx = 0; idx < length; ++idx) {
                const filter = place.filter[idx];
                Util.$controller[`add${filter.name}`](filterElement, filter, reload);
            }
        }
    }
}

Util.$screen = new Screen();

/**
 * @class
 */
class Stage
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor(object = null)
    {
        if (object) {
            this._$width   = object.width;
            this._$height  = object.height;
            this._$fps     = object.fps;
            this._$bgColor = object.bgColor;
            this._$lock    = object.lock;
        } else {
            this._$width   = Util.STAGE_DEFAULT_WIDTH;
            this._$height  = Util.STAGE_DEFAULT_HEIGHT;
            this._$fps     = Util.STAGE_DEFAULT_FPS;
            this._$bgColor = "#ffffff";
            this._$lock    = false;
        }
    }

    /**
     * @return {void}
     * @public
     */
    initialize ()
    {
        // canvas
        const stage = document.getElementById("stage");
        stage.style.width           = `${this.width}px`;
        stage.style.height          = `${this.height}px`;
        stage.style.backgroundColor = this.bgColor;

        document
            .getElementById("library-preview-area")
            .style.backgroundColor = this.bgColor;

        // stage area
        const area = document.getElementById("stage-area");
        area.style.transformOrigin = "50% 50%";
        area.style.width  = `${this.width  + window.screen.width}px`;
        area.style.height = `${this.height + window.screen.height}px`;

        // DOM
        document
            .getElementById("label-name")
            .value = "";

        document
            .getElementById("stage-width")
            .value = this.width;

        document
            .getElementById("stage-height")
            .value = this.height;

        document
            .getElementById("stage-fps")
            .value = this.fps;

        document
            .getElementById("stage-bgColor")
            .value = this.bgColor;

        const element = document
            .getElementById("stage-lock")
            .childNodes[1];

        element
            .setAttribute("class", this.lock ? "active" : "disable");

        Util.$controller._$stageLock = this.lock;

        // set xy
        const screen = document.getElementById("screen");
        screen.scrollLeft = window.screen.width  / 2 - (screen.clientWidth  - this.width)  / 2;
        screen.scrollTop  = window.screen.height / 2 - (screen.clientHeight - this.height) / 2;

        Util.$offsetLeft = stage.offsetLeft;
        Util.$offsetTop  = stage.offsetTop;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "width": this.width,
            "height": this.height,
            "fps": this.fps,
            "bgColor": this.bgColor,
            "lock": this.lock
        };
    }

    /**
     * @return {number}
     * @public
     */
    get width ()
    {
        return this._$width;
    }

    /**
     * @param  {number} width
     * @return {void}
     * @public
     */
    set width (width)
    {
        this._$width = width;
    }

    /**
     * @return {number}
     * @public
     */
    get height ()
    {
        return this._$height;
    }

    /**
     * @param  {number} height
     * @return {void}
     * @public
     */
    set height (height)
    {
        this._$height = height;
    }

    /**
     * @return {number}
     * @public
     */
    get fps ()
    {
        return this._$fps;
    }

    /**
     * @param  {number} fps
     * @return {void}
     * @public
     */
    set fps (fps)
    {
        this._$fps = fps;
    }

    /**
     * @return {string}
     * @public
     */
    get bgColor ()
    {
        return this._$bgColor;
    }

    /**
     * @param  {string} color
     * @return {void}
     * @public
     */
    set bgColor (color)
    {
        this._$bgColor = color;
    }

    /**
     * @return {boolean}
     * @public
     */
    get lock ()
    {
        return this._$lock;
    }

    /**
     * @param  {boolean} lock
     * @return {void}
     * @public
     */
    set lock (lock)
    {
        this._$lock = lock;
    }
}
/**
 * @class
 */
class Timeline
{
    /**
     * @constructor
     */
    constructor()
    {
        this.initializeParams();

        // bind function
        this._$editor                  = null;
        this._$run                     = this.run.bind(this);
        this._$showLayerMenu           = this.showLayerMenu.bind(this);
        this._$showTimeLineContextMenu = this.showTimeLineContextMenu.bind(this);

        this._$previewTimerId = -1;

        this._$handler = this.initialize.bind(this);
        window.addEventListener("DOMContentLoaded", this._$handler);
    }

    /**
     * @return {void}
     * @public
     */
    initialize ()
    {
        // end event
        window.removeEventListener("DOMContentLoaded", this._$handler);

        this.initializeTool();

        // グルーピング機能
        const targetGroup = document
            .getElementById("target-group");

        // default
        targetGroup.style.display = "none";

        targetGroup.addEventListener("mousemove", function (event)
        {

            const target = event.currentTarget;

            const offsetLeft = target.offsetLeft;

            let layerId = target.dataset.layerId | 0;
            let frame = target.dataset.frame | 0;

            const layerElement = document
                .getElementById(`frame-scroll-id-${layerId}`);

            const positionL = target.dataset.positionL | 0;
            const moveL = event.clientX - positionL;
            if (moveL > 13) {

                if (target.offsetLeft + target.offsetWidth + 13 >
                    layerElement.offsetLeft + layerElement.offsetWidth
                ) {
                    return ;
                }

                target.style.left = `${offsetLeft + 13}px`;

                target.dataset.positionL = `${positionL + 13}`;
                target.dataset.positionR = `${positionL + 26}`;
                target.dataset.frame     = `${++frame}`;

                return ;
            }

            const positionR = target.dataset.positionR | 0;
            const moveR = positionR - event.clientX;
            if (moveR > 13) {

                if (layerElement.offsetLeft > target.offsetLeft - 13) {
                    return ;
                }

                target.style.left = `${offsetLeft - 13}px`;

                target.dataset.positionL = `${positionR - 26}`;
                target.dataset.positionR = `${positionR - 13}`;
                target.dataset.frame     = `${--frame}`;
            }

        }.bind(this));

        targetGroup.addEventListener("mouseup", function (event)
        {

            // sort
            this._$targetFrames.sort(this.frameSort);

            // display none
            const target = event.currentTarget;
            target.style.display = "none";

            const frame = target.dataset.frame | 0;

            const firstElement = this._$targetFrames[0];
            const firstFrame   = firstElement.dataset.frame | 0;
            if (frame === firstFrame) {
                return ;
            }

            Util
                .$currentWorkSpace()
                .temporarilySaved();

            // clone
            const targets  = [];

            let position = 0;
            let targetStartFrame = 0;
            const frames = [];

            for (let idx = 0; idx < this._$targetFrames.length; ++idx) {

                const frameElement = this._$targetFrames[idx];
                switch (frameElement.dataset.frameState) {

                    case "empty":
                        continue;

                    case "key-frame":
                        if (!targetStartFrame) {
                            targetStartFrame = frameElement.dataset.frame | 0;
                            frames[position] = {
                                "move": true,
                                "beforeStartFrame": targetStartFrame,
                                "afterStartFrame": frame + idx
                            };
                        }
                        break;

                    case "key-space-frame":
                        if (!targetStartFrame) {
                            targetStartFrame = frameElement.dataset.frame | 0;
                            frames[position] = {
                                "copy": true,
                                "beforeStartFrame": targetStartFrame,
                                "afterStartFrame": frame + idx
                            };
                        }
                        break;

                    case "key-space-frame-end":
                        if (!targetStartFrame) {
                            targetStartFrame = frameElement.dataset.frame | 0;
                            frames[position] = {
                                "copy": true,
                                "beforeStartFrame": targetStartFrame,
                                "afterStartFrame": frame + idx
                            };
                        }
                        break;

                    case "empty-key-frame":
                        frames[position].beforeEndFrame = frameElement.dataset.frame | 0;
                        frames[position].afterEndFrame  = frame + idx;
                        position++;
                        targetStartFrame = 0;
                        break;

                    default:
                        break;

                }

                if (targetStartFrame) {
                    frames[position].beforeEndFrame = (frameElement.dataset.frame | 0) + 1;
                    frames[position].afterEndFrame  = frame + idx + 1;
                }

                const length = frameElement.classList.length;
                const values = [];
                for (let idx = 0; idx < length; ++idx) {

                    const value = frameElement.classList[idx];

                    switch (value) {

                        case "frame":
                        case "frame-active":
                        case "frame-pointer":
                            continue;

                        default:
                            values.push(value);
                            break;
                    }

                }

                targets.push({
                    "afterFrame": frame + idx,
                    "frameState": frameElement.dataset.frameState,
                    "values": values
                });

            }

            if (!targets.length) {
                return ;
            }

            const layerId = target.dataset.layerId | 0;
            const scene   = Util.$currentWorkSpace().scene;
            const layer   = scene.getLayer(layerId);

            for (let idx = 0; idx < frames.length; ++idx) {

                const frameObject = frames[idx];

                const diffFrame = frameObject.afterStartFrame
                    - frameObject.beforeStartFrame;

                const targets = [];
                for (let frame = frameObject.beforeStartFrame; frame < frameObject.beforeEndFrame; ++frame) {

                    const characters = layer.getActiveCharacter(frame);

                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];

                        if (targets.indexOf(character) > -1) {
                            continue;
                        }

                        targets.push(character);
                    }

                }

                // clone character
                const clones = [];
                for (let idx = 0; idx < targets.length; ++idx) {

                    const character = targets[idx];

                    const clone = character.clone();

                    if (frameObject.beforeStartFrame > clone.startFrame) {

                        clone.startFrame = frameObject.afterStartFrame;

                    } else {

                        clone.startFrame =
                            character.startFrame
                            - frameObject.beforeStartFrame
                            + frameObject.afterStartFrame;

                    }

                    clone.endFrame =
                        character.endFrame
                            - frameObject.beforeStartFrame
                            + frameObject.afterStartFrame;

                    const places = [];
                    const keys = clone._$places.keys();
                    for (const frame of keys) {

                        if (frame < frameObject.beforeStartFrame) {
                            continue;
                        }

                        if (frameObject.beforeEndFrame <= frame) {
                            continue;
                        }

                        places.push(
                            clone.clonePlace(frame, frame + diffFrame)
                        );
                        clone.deletePlace(frame);
                    }

                    for (let idx = 0; idx < places.length; ++idx) {
                        const place = places[idx];
                        clone.setPlace(place.frame, place);
                    }

                    clones.push(clone);
                }

                for (let frame = frameObject.afterStartFrame;
                    frame < frameObject.afterEndFrame; ++frame
                ) {

                    const characters = layer.getActiveCharacter(frame);

                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];
                        if (targets.indexOf(character) > -1) {
                            continue;
                        }

                        if (character.startFrame === frame) {

                            for (let keyFrame = frame; keyFrame < character.endFrame; ++keyFrame) {

                                const frameElement = document
                                    .getElementById(`${layerId}-${keyFrame}`);

                                const state = frameElement.dataset.frameState;

                                // reset
                                this.removeFrameClass(frameElement);

                                switch (state) {

                                    case "key-frame":
                                        {
                                            const classes = ["empty-key-frame"];

                                            frameElement
                                                .classList
                                                .add("empty-key-frame");

                                            if (character.endFrame - character.startFrame > 1) {

                                                classes.push("empty-key-frame-join");

                                                frameElement
                                                    .classList
                                                    .add("empty-key-frame-join");

                                            }

                                            frameElement
                                                .dataset
                                                .frameState = "empty-key-frame";

                                            layer
                                                ._$frame
                                                .setClasses(keyFrame, classes);

                                        }
                                        break;

                                    case "key-space-frame":

                                        frameElement
                                            .classList
                                            .add("empty-space-frame");

                                        frameElement
                                            .dataset
                                            .frameState = "empty-space-frame";

                                        layer
                                            ._$frame
                                            .setClasses(keyFrame, [
                                                "empty-space-frame"
                                            ]);

                                        break;

                                    case "key-space-frame-end":

                                        frameElement
                                            .classList
                                            .add("empty-space-frame-end");

                                        frameElement
                                            .dataset
                                            .frameState = "empty-space-frame-end";

                                        layer
                                            ._$frame
                                            .setClasses(keyFrame, [
                                                "empty-space-frame-end"
                                            ]);

                                        break;

                                }

                            }

                            layer.deleteCharacter(character.id);

                        } else {

                            if (character.endFrame - frame === 1) {

                                const frameElement = document
                                    .getElementById(`${layerId}-${frame}`);

                                this.removeFrameClass(frameElement);

                                frameElement
                                    .classList
                                    .add("empty-key-frame");

                                frameElement
                                    .dataset
                                    .frameState = "empty-key-frame";

                                layer
                                    ._$frame
                                    .setClasses(frame, [
                                        "empty-key-frame"
                                    ]);

                            } else {

                                const frameElement = document
                                    .getElementById(`${layerId}-${frame}`);

                                this.removeFrameClass(frameElement);

                                frameElement
                                    .classList
                                    .add("empty-key-frame");

                                frameElement
                                    .classList
                                    .add("empty-key-frame-join");

                                frameElement
                                    .dataset
                                    .frameState = "empty-key-frame";

                                layer
                                    ._$frame
                                    .setClasses(frame, [
                                        "empty-key-frame",
                                        "empty-key-frame-join"
                                    ]);

                                for (let keyFrame = frame + 1; keyFrame < character.endFrame; ++keyFrame) {

                                    const frameElement = document
                                        .getElementById(`${layerId}-${keyFrame}`);

                                    // reset
                                    this.removeFrameClass(frameElement);

                                    if (character.endFrame === keyFrame + 1) {

                                        frameElement
                                            .classList
                                            .add("empty-space-frame-end");

                                        frameElement
                                            .dataset
                                            .frameState = "empty-space-frame-end";

                                        layer
                                            ._$frame
                                            .setClasses(keyFrame, [
                                                "empty-space-frame-end"
                                            ]);

                                    } else {

                                        frameElement
                                            .classList
                                            .add("empty-space-frame");

                                        frameElement
                                            .dataset
                                            .frameState = "empty-space-frame";

                                        layer
                                            ._$frame
                                            .setClasses(keyFrame, [
                                                "empty-space-frame"
                                            ]);

                                    }
                                }
                            }

                            const keys = character._$places.keys();
                            for (const keyFrame of keys) {
                                if (frame > keyFrame) {
                                    continue;
                                }
                                character.deletePlace(keyFrame);
                            }

                            character.endFrame = frame;
                        }

                    }

                }

                for (let idx = 0; idx < clones.length; ++idx) {

                    let character = clones[idx];

                    let done = false;

                    // 前の確認
                    const startFrame = character.startFrame - 1;
                    if (startFrame) {

                        const characters = layer.getActiveCharacter(startFrame);
                        for (let idx = 0; idx < characters.length; ++idx) {

                            const char = characters[idx];

                            if (char.libraryId !== character.libraryId) {
                                continue;
                            }

                            if (char.endFrame !== character.startFrame) {
                                continue;
                            }

                            char.endFrame = character.endFrame;
                            for (let [frame, place] of character._$places) {
                                char.setPlace(frame, place);
                            }

                            character = char;

                            done = true;
                            break;
                        }

                    }

                    // 後ろの確認
                    const endFrame = character.endFrame;
                    const characters = layer.getActiveCharacter(endFrame);
                    for (let idx = 0; idx < characters.length; ++idx) {

                        const char = characters[idx];
                        if (char.libraryId !== character.libraryId) {
                            continue;
                        }

                        if (char.startFrame !== endFrame) {
                            continue;
                        }

                        char.startFrame = character.startFrame;
                        for (let [frame, place] of character._$places) {
                            char.setPlace(frame, place);
                        }

                        done = true;
                        layer.deleteCharacter(character.id);
                        break;
                    }

                    if (done) {
                        continue;
                    }

                    layer.addCharacter(character);
                }
            }

            // paste
            const afterStartFrame = targets[0].afterFrame | 0;
            for (let idx = 0; idx < targets.length; ++idx) {

                const targetObject = targets[idx];

                const targetFrame = document
                    .getElementById(`${layerId}-${targetObject.afterFrame}`);

                this.removeFrameClass(targetFrame);

                targetFrame.dataset.frameState = targetObject.frameState;

                const length = targetObject.values.length;
                for (let idx = 0; idx < length; ++idx) {

                    targetFrame
                        .classList
                        .add(targetObject.values[idx]);

                }

                layer
                    ._$frame
                    .setClasses(
                        targetObject.afterFrame,
                        targetObject.values
                    );

            }

            // 開始補正
            const afterFirstElement = document
                .getElementById(`${layerId}-${afterStartFrame}`);

            switch (afterFirstElement.dataset.frameState) {

                case "key-frame":
                case "empty-key-frame":
                    break;

                case "key-space-frame":
                case "key-space-frame-end":
                    {
                        this.removeFrameClass(afterFirstElement);

                        afterFirstElement
                            .classList
                            .add("key-frame");

                        afterFirstElement
                            .dataset
                            .frameState = "key-frame";

                        const afterNextElement = document
                            .getElementById(`${layerId}-${afterStartFrame + 1}`);

                        switch (afterNextElement.dataset.frameState) {

                            case "key-space-frame":
                            case "key-space-frame-end":
                                afterFirstElement
                                    .classList
                                    .add("key-frame-join");

                                layer
                                    ._$frame
                                    .setClasses(afterStartFrame, [
                                        "key-frame",
                                        "key-frame-join"
                                    ]);

                                break;

                            default:

                                layer
                                    ._$frame
                                    .setClasses(afterStartFrame, [
                                        "key-frame"
                                    ]);

                                break;

                        }
                    }
                    break;

                case "empty-space-frame":
                case "empty-space-frame-end":
                    {
                        this.removeFrameClass(afterFirstElement);

                        afterFirstElement
                            .classList
                            .add("empty-key-frame");

                        afterFirstElement
                            .dataset
                            .frameState = "empty-key-frame";

                        const afterNextElement = document
                            .getElementById(`${layerId}-${afterStartFrame + 1}`);

                        switch (afterNextElement.dataset.frameState) {

                            case "empty-space-frame":
                            case "empty-space-frame-end":

                                afterFirstElement
                                    .classList
                                    .add("empty-key-frame-join");

                                layer
                                    ._$frame
                                    .setClasses(afterStartFrame, [
                                        "empty-key-frame",
                                        "empty-key-frame-join"
                                    ]);
                                break;

                            default:

                                layer
                                    ._$frame
                                    .setClasses(afterStartFrame, [
                                        "empty-key-frame"
                                    ]);

                                break;

                        }
                    }
                    break;

            }

            // 終了補正
            const lastFrame = targets[targets.length - 1].afterFrame | 0;

            const lastElement = document
                .getElementById(`${layerId}-${lastFrame}`);

            switch (lastElement.dataset.frameState) {

                case "key-frame":

                    lastElement
                        .classList
                        .remove("key-frame-join");

                    layer
                        ._$frame
                        .setClasses(lastFrame, [
                            "key-frame"
                        ]);

                    break;

                case "empty-key-frame":

                    lastElement
                        .classList
                        .remove("empty-key-frame-join");

                    layer
                        ._$frame
                        .setClasses(lastFrame, [
                            "empty-key-frame"
                        ]);

                    break;

                case "empty-space-frame":

                    this.removeFrameClass(lastElement);

                    lastElement
                        .classList
                        .add("empty-space-frame-end");

                    lastElement
                        .dataset
                        .frameState = "empty-space-frame-end";

                    layer
                        ._$frame
                        .setClasses(lastFrame, [
                            "empty-space-frame-end"
                        ]);

                    break;

                case "key-space-frame":

                    this.removeFrameClass(lastElement);

                    lastElement
                        .classList
                        .add("key-space-frame-end");

                    lastElement
                        .dataset
                        .frameState = "key-space-frame-end";

                    layer
                        ._$frame
                        .setClasses(lastFrame, [
                            "key-space-frame-end"
                        ]);

                    break;

            }

            // 後続補正
            const nextElement = document
                .getElementById(`${layerId}-${lastFrame + 1}`);

            switch (nextElement.dataset.frameState) {

                case "empty-space-frame-end":

                    this.removeFrameClass(nextElement);

                    nextElement
                        .classList
                        .add("empty-key-frame");

                    nextElement
                        .dataset
                        .frameState = "empty-key-frame";

                    layer
                        ._$frame
                        .setClasses(lastFrame + 1, [
                            "empty-key-frame"
                        ]);

                    break;

                case "empty-space-frame":

                    this.removeFrameClass(nextElement);

                    nextElement
                        .classList
                        .add("empty-key-frame");

                    nextElement
                        .classList
                        .add("empty-key-frame-join");

                    nextElement
                        .dataset
                        .frameState = "empty-key-frame";

                    layer
                        ._$frame
                        .setClasses(lastFrame + 1, [
                            "empty-key-frame",
                            "empty-key-frame-join"
                        ]);

                    break;

                case "key-space-frame-end":

                    this.removeFrameClass(nextElement);

                    nextElement
                        .classList
                        .add("key-frame");

                    nextElement
                        .dataset
                        .frameState = "key-frame";

                    layer
                        ._$frame
                        .setClasses(lastFrame + 1, [
                            "key-frame"
                        ]);

                    break;

                case "key-space-frame":

                    this.removeFrameClass(nextElement);

                    nextElement
                        .classList
                        .add("key-frame");

                    nextElement
                        .classList
                        .add("key-frame-join");

                    nextElement
                        .dataset
                        .frameState = "key-frame";

                    layer
                        ._$frame
                        .setClasses(lastFrame + 1, [
                            "key-frame",
                            "key-frame-join"
                        ]);

                    break;

                default:
                    break;

            }

            // 前衛補正
            if (afterStartFrame > 1) {

                const prevElement = document
                    .getElementById(`${layerId}-${afterStartFrame - 1}`);

                switch (prevElement.dataset.frameState) {

                    case "empty":
                        {
                            this.removeFrameClass(prevElement);

                            let prevFrame = afterStartFrame - 1;
                            if (prevFrame === 1) {

                                prevElement
                                    .classList
                                    .add("empty-key-frame");

                                prevElement
                                    .dataset
                                    .frameState = "empty-key-frame";

                                layer
                                    ._$frame
                                    .setClasses(prevFrame, [
                                        "empty-key-frame"
                                    ]);

                            } else {

                                prevElement
                                    .classList
                                    .add("empty-space-frame-end");

                                prevElement
                                    .dataset
                                    .frameState = "empty-space-frame-end";

                                layer
                                    ._$frame
                                    .setClasses(prevFrame, [
                                        "empty-space-frame-end"
                                    ]);

                                for (;;) {

                                    const frameElement = document
                                        .getElementById(`${layerId}-${--prevFrame}`);

                                    if (!frameElement) {
                                        break;
                                    }

                                    if (frameElement.dataset.frameState === "empty") {

                                        if (prevFrame === 1) {

                                            frameElement
                                                .classList
                                                .add("empty-key-frame");

                                            frameElement
                                                .classList
                                                .add("empty-key-frame-join");

                                            frameElement
                                                .dataset
                                                .frameState = "empty-key-frame";

                                            layer
                                                ._$frame
                                                .setClasses(prevFrame, [
                                                    "empty-key-frame",
                                                    "empty-key-frame-join"
                                                ]);

                                            break;

                                        } else {

                                            frameElement
                                                .classList
                                                .add("empty-space-frame");

                                            frameElement
                                                .dataset
                                                .frameState = "empty-space-frame";

                                            layer
                                                ._$frame
                                                .setClasses(prevFrame, [
                                                    "empty-space-frame"
                                                ]);

                                        }

                                    } else {

                                        const frameElement = document
                                            .getElementById(`${layerId}-${++prevFrame}`);

                                        this.removeFrameClass(frameElement);

                                        const classes = ["empty-key-frame"];

                                        frameElement
                                            .classList
                                            .add("empty-key-frame");

                                        if (prevFrame !== afterStartFrame - 1) {

                                            frameElement
                                                .classList
                                                .add("empty-key-frame-join");

                                            classes.push("empty-key-frame-join");

                                        }

                                        frameElement
                                            .dataset
                                            .frameState = "empty-key-frame";

                                        layer
                                            ._$frame
                                            .setClasses(prevFrame, classes);

                                        break;

                                    }
                                }
                            }
                        }
                        break;

                    case "key-frame":

                        prevElement
                            .classList
                            .remove("key-frame-join");

                        layer
                            ._$frame
                            .setClasses(afterStartFrame - 1, [
                                "key-frame"
                            ]);

                        break;

                    case "empty-key-frame":

                        prevElement
                            .classList
                            .remove("empty-key-frame-join");

                        layer
                            ._$frame
                            .setClasses(afterStartFrame - 1, [
                                "empty-key-frame"
                            ]);

                        break;

                    case "key-space-frame":

                        this.removeFrameClass(prevElement);

                        prevElement
                            .classList
                            .add("key-space-frame-end");

                        prevElement
                            .dataset
                            .frameState = "key-space-frame-end";

                        layer
                            ._$frame
                            .setClasses(afterStartFrame - 1, [
                                "key-space-frame-end"
                            ]);

                        break;

                    case "empty-space-frame":

                        this.removeFrameClass(prevElement);

                        prevElement
                            .classList
                            .add("empty-space-frame-end");

                        prevElement
                            .dataset
                            .frameState = "empty-space-frame-end";

                        layer
                            ._$frame
                            .setClasses(afterStartFrame - 1, [
                                "empty-space-frame-end"
                            ]);

                        break;

                    default:
                        break;

                }
            }

            scene.changeFrame(firstFrame);

        }.bind(this));

        // 右クリック解除
        document.body.addEventListener("click", function (event)
        {
            if (this._$menuMode) {

                this._$menuMode = false;
                document
                    .getElementById("timeline-menu")
                    .setAttribute("class", "fadeOut");

                return ;
            }

            if (this._$layerMenuMode) {

                this._$layerMenuMode = false;

                const element = document
                    .getElementById("timeline-layer-menu");

                if (element.classList.contains("fadeIn")) {
                    element.setAttribute("class", "fadeOut");
                }

                return ;
            }

            let target = event.target;
            switch (target.id) {

                case "scene-list":
                case "scene-name-menu":
                    return ;

                default:

                    for (;;) {

                        target = target.parentNode;
                        if (!target) {

                            this._$sceneMode = false;

                            const element = document
                                .getElementById("scene-name-menu");

                            if (element.classList.contains("fadeIn")) {
                                element.setAttribute("class", "fadeOut");
                            }

                            break;
                        }

                        if (target.id === "scene-name-menu") {
                            break;
                        }
                    }

                    break;

            }

        }.bind(this));

        // シーン一覧
        const sceneList = document.getElementById("scene-list");
        sceneList.addEventListener("mousedown", function (event)
        {

            if (!document
                .getElementById("scene-name-menu-list")
                .children.length
            ) {
                return ;
            }

            const element = document.getElementById("scene-name-menu");
            if (!this._$sceneMode) {

                this._$sceneMode = true;

                const target = event.currentTarget;
                element.style.left = `${target.offsetLeft + target.offsetWidth}px`;
                element.style.top  = `${target.offsetTop + 10}px`;
                element.setAttribute("class", "fadeIn");

                Util.$endMenu("scene-name-menu");

            } else {

                this._$sceneMode = false;
                if (element.classList.contains("fadeIn")) {
                    element.setAttribute("class", "fadeOut");
                }

            }

        }.bind(this));

        // レイヤー移動
        window.addEventListener("mouseup", function ()
        {

            if (this._$moveTarget) {

                this
                    ._$moveTarget
                    .classList
                    .remove("move-target");

                const scene = Util.$currentWorkSpace().scene;
                if (this._$moveTarget !== this._$moveLayer) {

                    const targetLayer = scene.getLayer(this._$moveTarget.dataset.layerId | 0);

                    const layerId   = this._$moveLayer.dataset.layerId | 0;
                    const moveLayer = scene.getLayer(layerId);

                    if (moveLayer._$mode === Util.LAYER_MODE_MASK
                        && (targetLayer._$mode === Util.LAYER_MODE_MASK
                            || targetLayer._$mode === Util.LAYER_MODE_MASK_IN
                        )
                    ) {
                        return ;
                    }

                    if (targetLayer.mode === Util.LAYER_MODE_MASK
                        || targetLayer.mode === Util.LAYER_MODE_MASK_IN
                    ) {

                        if (moveLayer.mode !== Util.LAYER_MODE_MASK_IN
                            && moveLayer.mode === Util.LAYER_MODE_NORMAL
                        ) {

                            moveLayer.maskId = targetLayer.maskId === null
                                ? targetLayer.id
                                : targetLayer.maskId;

                            moveLayer.mode   = Util.LAYER_MODE_MASK_IN;
                            moveLayer.showIcon();

                        }

                    } else {

                        if (moveLayer.mode === Util.LAYER_MODE_MASK_IN) {

                            moveLayer.maskId = null;
                            moveLayer.mode   = Util.LAYER_MODE_NORMAL;
                            moveLayer.showIcon();

                        }

                    }

                    let maskInstances = null;

                    const element = document.getElementById("timeline-content");
                    if (moveLayer._$mode === Util.LAYER_MODE_MASK) {

                        const children = element.children;
                        for (let idx = 0; idx < children.length; ++idx) {

                            const child = children[idx];
                            if (moveLayer.id === (child.dataset.layerId | 0)) {
                                maskInstances = [];
                                continue;
                            }

                            if (!maskInstances) {
                                continue;
                            }

                            const layer = scene.getLayer(child.dataset.layerId | 0);
                            if (layer._$mode !== Util.LAYER_MODE_MASK_IN) {
                                break;
                            }

                            maskInstances.push(child);
                        }

                        if (maskInstances) {

                            for (let idx = 0; idx < maskInstances.length; ++idx) {
                                element.removeChild(maskInstances[idx]);
                            }

                        }

                    }

                    if (this._$moveLayer === this._$moveTarget.nextElementSibling) {

                        if (targetLayer._$mode === Util.LAYER_MODE_MASK) {
                            return ;
                        }

                        element
                            .insertBefore(this._$moveLayer, this._$moveTarget);

                    } else {

                        element
                            .insertBefore(this._$moveLayer, this._$moveTarget.nextElementSibling);

                    }

                    if (maskInstances) {

                        for (let idx = 0; idx < maskInstances.length; ++idx) {

                            element
                                .insertBefore(maskInstances[idx], this._$moveLayer.nextElementSibling);

                        }
                    }

                    this._$moveLayer.lastElementChild.scrollLeft
                        = this._$moveTarget.lastElementChild.scrollLeft;

                    const layers   = [];
                    const children = element.children;
                    for (let idx = 0; idx < children.length; ++idx) {
                        layers.push(
                            scene.getLayer(children[idx].dataset.layerId | 0)
                        );
                    }

                    scene.clearLayer();
                    for (let idx = 0; idx < layers.length; ++idx) {
                        const layer = layers[idx];
                        scene.setLayer(layer.id, layer);
                    }

                    scene.changeFrame(
                        document
                            .getElementById("current-frame")
                            .textContent | 0
                    );
                }

            }

            // reset
            this._$moveId          = -1;
            this._$moveLayer       = null;
            this._$moveTarget      = null;
            this._$moveScriptModal = false;
            Util.$setCursor("auto");

        }.bind(this));

        // レイヤー変更
        document
            .getElementById("timeline-layer-normal")
            .addEventListener("click", function ()
            {
                if (this._$targetLayer) {

                    const scene   = Util.$currentWorkSpace().scene;
                    const layerId = this._$targetLayer.dataset.layerId | 0;

                    let changeNormal = false;
                    for (const layer of scene._$layers.values()) {

                        if (layer.id === layerId) {

                            const mode = layer.mode;

                            // change
                            layer.mode = Util.LAYER_MODE_NORMAL;
                            layer.showIcon();

                            if (mode !== Util.LAYER_MODE_MASK) {
                                break;
                            }

                            changeNormal = true;

                            continue;
                        }

                        if (changeNormal) {

                            if (layer.mode !== Util.LAYER_MODE_MASK_IN) {
                                break;
                            }

                            layer.maskId = null;
                            layer.mode   = Util.LAYER_MODE_NORMAL;
                            layer.showIcon();
                        }

                    }
                }
            }.bind(this));

        document
            .getElementById("timeline-layer-mask")
            .addEventListener("click", function ()
            {
                if (this._$targetLayer) {

                    const scene = Util.$currentWorkSpace().scene;

                    const layerId = this._$targetLayer.dataset.layerId | 0;
                    const layer   = scene.getLayer(layerId);

                    layer.mode = Util.LAYER_MODE_MASK;
                    layer.showIcon();
                }
            }.bind(this));

        /**
         * コピー/ペースト処理
         * @param {Event|KeyboardEvent} event
         */
        const commandFunction = function (event)
        {
            if (Util.$keyLock || Util.$activeScript) {
                return false;
            }

            if (Util.$shiftKey) {
                event.preventDefault();
                return false;
            }

            switch (event.code) {

                case "Semicolon":
                    if (event.ctrlKey && !event.metaKey
                        || !event.ctrlKey && event.metaKey
                    ) {
                        event.preventDefault();

                        Util
                            .$currentWorkSpace()
                            .scene
                            .addLayer();

                        return false;
                    }
                    break;

                case "Minus":
                    if (event.ctrlKey && !event.metaKey
                        || !event.ctrlKey && event.metaKey
                    ) {
                        event.preventDefault();
                        this.removeLayer();
                        return false;
                    }
                    break;

                case "KeyC": // copy

                    if (!Util.$canCopyLayer || !this._$targetLayer) {
                        return false;
                    }

                    if (event.ctrlKey && !event.metaKey
                        || !event.ctrlKey && event.metaKey
                    ) {
                        Util.$copyLibrary   = null;
                        Util.$copyLayer     = null;
                        Util.$copyCharacter = null;
                        if (!Util.$keyLock && !Util.$activeScript) {

                            event.preventDefault();

                            Util.$copyWorkSpaceId = Util.$activeWorkSpaceId;

                            const layerId = this._$targetLayer.dataset.layerId | 0;
                            Util.$copyLayer = Util
                                .$currentWorkSpace()
                                .scene
                                .getLayer(layerId);

                            const element = document.getElementById("detail-modal");
                            element.textContent = "copy";
                            element.style.left  = `${this._$targetLayer.offsetLeft + 5}px`;
                            element.style.top   = `${this._$targetLayer.offsetTop  + 5}px`;
                            element.setAttribute("class", "fadeIn");

                            element.dataset.timerId = setTimeout(function ()
                            {
                                if (!this.classList.contains("fadeOut")) {
                                    this.setAttribute("class", "fadeOut");
                                }
                            }.bind(element), 1500);

                            return false;
                        }
                    }
                    break;

                case "KeyV": // paste
                    if (event.ctrlKey && !event.metaKey // windows
                        || !event.ctrlKey && event.metaKey // mac
                    ) {

                        if (!Util.$keyLock && !Util.$activeScript && Util.$copyLayer) {

                            event.preventDefault();

                            const frame = document
                                .getElementById("current-frame")
                                .textContent | 0;

                            const workSpace = Util.$currentWorkSpace();

                            const scene = workSpace.scene;
                            if (Util.$copyWorkSpaceId === Util.$activeWorkSpaceId) {

                                const object = Util.$copyLayer.toObject();
                                for (let idx = 0; idx < object.characters.length; ++idx) {
                                    const character = object.characters[idx];
                                    character.id    = workSpace._$characterId++;
                                }

                                scene.addLayer(new Layer(object));

                            } else {

                                const targetWorkSpace = Util.$workSpaces[Util.$copyWorkSpaceId];

                                const dup    = new Map();
                                const object = Util.$copyLayer.toObject();
                                for (let idx = 0; idx < object.characters.length; ++idx) {

                                    const character = object.characters[idx];
                                    character.id    = workSpace._$characterId++;

                                    const instance = targetWorkSpace
                                        .getLibrary(character.libraryId)
                                        .toObject();

                                    if (instance.type === "container") {

                                        Util.$copyContainer(instance, dup);

                                    } else {

                                        if (!dup.has(character.libraryId)) {
                                            dup.set(character.libraryId, workSpace.nextLibraryId);
                                            instance.id = dup.get(character.libraryId);
                                            targetWorkSpace.addLibrary(instance);
                                        }

                                    }

                                    character.libraryId = dup.get(character.libraryId);
                                }

                                scene.addLayer(new Layer(object));
                                workSpace.initializeLibrary();
                            }

                            Util.$copyWorkSpaceId = -1;
                            Util.$copyLayer       = null;

                            scene.changeFrame(frame);

                            return false;
                        }
                    }
                    break;

                default:
                    break;

            }

        }.bind(this);
        window.addEventListener("keydown", commandFunction);

        // end
        Util.$initializeEnd();
        this._$handler = null;
    }

    /**
     * @return {void}
     * @public
     */
    initializeTool ()
    {
        document
            .documentElement
            .style
            .setProperty("--timeline-height", `${Util.TIMELINE_DEFAULT_SIZE}px`);

        const adjElement = document.getElementById("timeline-adjustment");

        adjElement.addEventListener("mousedown", function (event)
        {
            this._$resizeMode = true;
            this._$pointY     = event.screenY;
            Util.$setCursor("row-resize");
        }.bind(this));

        window.addEventListener("mouseup", function ()
        {
            if (this._$resizeMode) {
                this._$resizeMode = false;
                this._$pointY     = 0;

                // reset
                Util.$setCursor("auto");
            }

            if (this._$markerMode) {
                this._$markerMode = false;

                // reset
                Util.$setCursor("ew-resize");
            }

        }.bind(this));

        window.addEventListener("mousemove", function (event)
        {
            if (this._$resizeMode) {

                const diff = this._$pointY - event.screenY;

                const value = document
                    .documentElement
                    .style
                    .getPropertyValue("--timeline-height")
                    .split("px")[0] | 0;

                document
                    .documentElement
                    .style
                    .setProperty(
                        "--timeline-height",
                        `${Math.max(Util.TIMELINE_MIN_SIZE, value + diff)}px`
                    );

                this._$pointY = event.screenY;
            }

            if (this._$moveScriptModal) {

                const element = document.getElementById("editor-modal");
                element.style.left = `${parseFloat(element.style.left) + (event.screenX - this._$pointX)}px`;
                element.style.top  = `${parseFloat(element.style.top)  + (event.screenY - this._$pointY)}px`;

                this._$pointX = event.screenX;
                this._$pointY = event.screenY;

            }

        }.bind(this));

        // IDEの設定
        this._$editor = ace.edit("editor");
        this._$editor.setOptions({
            "enableBasicAutocompletion": true,
            "enableSnippets": true,
            "enableLiveAutocompletion": true
        });
        this._$editor.setTheme("ace/theme/monokai");
        this._$editor.session.setMode("ace/mode/javascript");

        const words = [
            { "word": "next2d", "meta": "window.next2d" },
            { "word": "toString",  "value": "toString()",  "meta": "common method" },
            { "word": "namespace", "meta": "common property" }
        ];

        const level1 = Object.keys(window.next2d);
        for (let idx = 1; idx < level1.length; ++idx) {

            const name = level1[idx];
            words.push({
                "word": `next2d.${name}`,
                "meta": `next2d.${name}`
            });

            const level2 = Object.keys(window.next2d[name]);
            for (let idx = 0; idx < level2.length; ++idx) {

                const className = level2[idx];
                words.push(
                    {
                        "word": className,
                        "meta": `next2d.${name}.${className}`
                    }
                );

                const Class = window.next2d[name][className];

                const staticMethods = Object.getOwnPropertyDescriptors(Class);
                const staticNames   = Object.getOwnPropertyNames(Class);
                for (let idx = 0; idx < staticNames.length; ++idx) {

                    const name = staticNames[idx];
                    switch (name) {

                        case "length":
                        case "prototype":
                        case "toString":
                        case "namespace":
                        case "name":
                            continue;

                        default:
                            {
                                const object = staticMethods[name];
                                if ("value" in object) {

                                    const args = object
                                        .value
                                        .toString()
                                        .replace(/ |\n/g, "")
                                        .split("{")[0]
                                        .split("(")[1];

                                    words.push({
                                        "word": name,
                                        "value": `${name}()`,
                                        "meta": `${className}.${name}(${args}`
                                    });

                                } else {

                                    words.push({
                                        "word": name,
                                        "meta": `${className}.${name}`
                                    });

                                }
                            }
                            break;

                    }
                }

                const publicMethods = Object.getOwnPropertyDescriptors(Class.prototype);
                const publicNames   = Object.getOwnPropertyNames(Class.prototype);
                for (let idx = 0; idx < publicNames.length; ++idx) {

                    const name = publicNames[idx];
                    switch (name) {

                        case "constructor":
                        case "toString":
                        case "namespace":
                        case "name":
                            continue;

                        default:
                            {
                                if (name.indexOf("_$") > -1) {
                                    continue;
                                }

                                const object = publicMethods[name];
                                if ("value" in object) {

                                    const args = object
                                        .value
                                        .toString()
                                        .replace(/ |\n/g, "")
                                        .split("{")[0]
                                        .split("(")[1];

                                    words.push({
                                        "word": name,
                                        "value": `${name}()`,
                                        "meta": `${className}.${name}(${args}`
                                    });

                                } else {

                                    words.push({
                                        "word": name,
                                        "meta": `${className}.${name}`
                                    });

                                }
                            }
                            break;

                    }
                }
            }
        }

        ace
            .require("ace/ext/language_tools")
            .addCompleter({
                "getCompletions": function (editor, session, pos, prefix, callback)
                {
                    callback(null, words.map(function (object)
                    {
                        return {
                            "caption": object.word,
                            "value":   object.value || object.word,
                            "meta":    object.meta,
                            "score":   0
                        };
                    }));
                }
            });

        // スクリプトの追加
        document
            .getElementById("timeline-script-add")
            .addEventListener("mousedown", this.showScriptArea.bind(this));
        document
            .getElementById("context-menu-script-add")
            .addEventListener("mousedown", this.showScriptArea.bind(this));

        document
            .getElementById("editor-hide-icon")
            .addEventListener("mousedown", this.hideScriptArea.bind(this));

        document
            .documentElement
            .style
            .setProperty("--script-modal-width", `${Util.SCRIPT_MODAL_WIDTH}px`);

        document
            .documentElement
            .style
            .setProperty("--script-modal-height", `${Util.SCRIPT_MODAL_HEIGHT}px`);

        document
            .documentElement
            .style
            .setProperty("--script-modal-bar-height", `${Util.SCRIPT_MODAL_BAR_HEIGHT}px`);

        //要素のリサイズイベント取得
        const observer = new ResizeObserver(function (entries)
        {
            entries.forEach(function (entry)
            {
                const element = entry.target;

                const modalWidth = parseFloat(document
                    .documentElement
                    .style
                    .getPropertyValue("--script-modal-width"));

                const modalHeight = parseFloat(document
                    .documentElement
                    .style
                    .getPropertyValue("--script-modal-height"));

                if (modalWidth !== element.clientWidth) {
                    document
                        .documentElement
                        .style
                        .setProperty("--script-modal-width", `${element.clientWidth}px`);
                }

                if (modalHeight !== element.clientHeight) {
                    document
                        .documentElement
                        .style
                        .setProperty("--script-modal-height",
                            `${element.clientHeight + Util.SCRIPT_MODAL_BAR_HEIGHT}px`);
                }
            });

            this._$editor.resize();

        }.bind(this));

        observer.observe(
            document.getElementById("editor-modal")
        );

        document
            .getElementById("editor-bar")
            .addEventListener("mousedown", function (event)
            {
                this._$pointX = event.screenX;
                this._$pointY = event.screenY;
                this._$moveScriptModal = true;
            }.bind(this));

        // フレームの追加
        document
            .getElementById("timeline-frame-add")
            .addEventListener("mousedown", this.addSpaceFrame.bind(this));
        document
            .getElementById("context-menu-frame-add")
            .addEventListener("mousedown", this.addSpaceFrame.bind(this));

        // キーフレームの追加
        document
            .getElementById("timeline-key-add")
            .addEventListener("mousedown", this.addKeyFrame.bind(this));
        document
            .getElementById("context-menu-key-frame-add")
            .addEventListener("mousedown", this.addKeyFrame.bind(this));

        // 空のキーフレームの追加
        document
            .getElementById("timeline-empty-add")
            .addEventListener("mousedown", this.addEmptyFrame.bind(this));
        document
            .getElementById("context-menu-empty-key-frame-add")
            .addEventListener("mousedown", this.addEmptyFrame.bind(this));

        // フレームの削除
        document
            .getElementById("timeline-frame-delete")
            .addEventListener("click", this.deleteFrame.bind(this));
        document
            .getElementById("context-menu-frame-delete")
            .addEventListener("click", this.deleteFrame.bind(this));

        document
            .getElementById("timeline-onion-skin")
            .addEventListener("click", function (event)
            {
                const scene = Util.$currentWorkSpace().scene;

                const element = event.target;
                if (element.classList.contains("onion-skin-active")) {

                    element.classList.remove("onion-skin-active");
                    for (const layer of scene._$layers.values()) {
                        for (let idx = 0; idx < layer._$characters.length; ++idx) {
                            const character = layer._$characters[idx];
                            character._$image = null;
                        }
                    }

                } else {

                    element.classList.add("onion-skin-active");

                }

                scene.changeFrame(
                    document.getElementById("current-frame").textContent | 0
                );
            }.bind(this));

        document
            .getElementById("timeline-preview")
            .addEventListener("click", function (event)
            {
                const element = event.target;
                if (element.classList.contains("timeline-preview-active")) {
                    element.classList.remove("timeline-preview-active");
                } else {
                    element.classList.add("timeline-preview-active");
                }
            }.bind(this));

        const labelElement = document
            .getElementById("label-name");

        labelElement.addEventListener("focusin", function ()
        {
            Util.$keyLock = true;
            this._$labelFrame = document
                .getElementById("current-frame")
                .textContent | 0;

        }.bind(this));
        labelElement.addEventListener("keypress", this.setLabelMarker.bind(this));
        labelElement.addEventListener("blur", function ()
        {
            Util.$keyLock = false;
        });

        // レイヤーの追加
        document
            .getElementById("timeline-layer-add")
            .addEventListener("mousedown", function ()
            {
                const workSpace = Util.$currentWorkSpace();
                workSpace.temporarilySaved();
                workSpace.scene.addLayer();
            });

        // レイヤーの削除
        document
            .getElementById("timeline-layer-trash")
            .addEventListener("click", this.removeLayer.bind(this));

        // 全てのレイヤーをライトアップ
        document
            .getElementById("timeline-layer-light-all")
            .addEventListener("mousedown", function ()
            {
                this._$lightAll = !this._$lightAll;

                const element = document.getElementById("timeline-content");

                const workSpace = Util.$currentWorkSpace();
                const scene = workSpace.scene;

                const length = element.children.length;
                for (let idx = 0; idx < length; ++idx) {

                    const child   = element.children[idx];
                    const layerId = child.dataset.layerId | 0;

                    const lightIcon = document
                        .getElementById(`layer-light-icon-${layerId}`);

                    const layer = scene.getLayer(layerId);
                    if (this._$lightAll) {

                        lightIcon
                            .classList
                            .remove("icon-disable");

                        lightIcon
                            .classList
                            .add("icon-active");

                        child.classList.add("light-active");

                        layer.light = true;

                    } else {

                        lightIcon
                            .classList
                            .remove("icon-active");

                        lightIcon
                            .classList
                            .add("icon-disable");

                        child.classList.remove("light-active");

                        layer.light = false;

                    }

                }

            }.bind(this));

        // 全てのレイヤーを非表示
        document
            .getElementById("timeline-layer-disable-all")
            .addEventListener("mousedown", function ()
            {
                this._$disableAll = !this._$disableAll;

                const element = document.getElementById("timeline-content");

                const scene = Util.$currentWorkSpace().scene;

                const length = element.children.length;
                for (let idx = 0; idx < length; ++idx) {

                    const child   = element.children[idx];
                    const layerId = child.dataset.layerId | 0;

                    const disableIcon = document
                        .getElementById(`layer-disable-icon-${layerId}`);

                    const layer = scene.getLayer(layerId);
                    if (this._$disableAll) {

                        disableIcon
                            .classList
                            .remove("icon-disable");

                        disableIcon
                            .classList
                            .add("icon-active");

                        layer.disable = true;

                    } else {

                        disableIcon
                            .classList
                            .remove("icon-active");

                        disableIcon
                            .classList
                            .add("icon-disable");

                        layer.disable = false;

                    }

                }

                scene.changeFrame(
                    document.getElementById("current-frame").textContent | 0
                );
                Util.$screen.hideTransformTarget();
                Util.$screen.hideGridTarget();

            }.bind(this));

        // 全てのレイヤーをロック
        document
            .getElementById("timeline-layer-lock-all")
            .addEventListener("mousedown", function ()
            {
                this._$lockAll = !this._$lockAll;

                const element = document.getElementById("timeline-content");

                const workSpace = Util.$currentWorkSpace();
                const scene = workSpace.scene;

                const length = element.children.length;
                for (let idx = 0; idx < length; ++idx) {

                    const child   = element.children[idx];
                    const layerId = child.dataset.layerId | 0;

                    const lockIcon = document
                        .getElementById(`layer-lock-icon-${layerId}`);

                    const layer = scene.getLayer(layerId);
                    if (this._$lockAll) {

                        lockIcon
                            .classList
                            .remove("icon-disable");

                        lockIcon
                            .classList
                            .add("icon-active");

                        layer.lock = true;

                    } else {

                        lockIcon
                            .classList
                            .remove("icon-active");

                        lockIcon
                            .classList
                            .add("icon-disable");

                        layer.lock = false;

                    }

                }

                scene.changeFrame(
                    document.getElementById("current-frame").textContent | 0
                );
                Util.$screen.hideTransformTarget();
                Util.$screen.hideGridTarget();

            }.bind(this));

        // 上部のタイムラインの動作イベント
        const element = document
            .getElementById("timeline-controller-base");

        element.addEventListener("wheel", function (event)
        {

            const delta = event.deltaX || event.deltaY;
            if (!delta) {
                return false;
            }

            event.preventDefault();

            this._$scrollX += delta | 0;
            this.moveTimeLine(this._$scrollX);

        }.bind(this), { "passive" : false });

        const marker = document
            .getElementById("timeline-marker");

        marker.addEventListener("mousedown", function (event)
        {
            // class reset
            for (let idx = 0; idx < this._$targetFrames.length; ++idx) {

                this
                    ._$targetFrames[idx]
                    .classList
                    .remove("frame-active");

            }

            Util.$screen.clearActiveCharacter();
            Util.$controller.setDefaultController();

            // clear
            this._$targetFrames.length = 0;

            this._$markerMode = true;
            this._$pointX     = event.pageX;

            Util.$setCursor("ew-resize");

        }.bind(this));

        // 再生ボタン
        document
            .getElementById("timeline-play")
            .addEventListener("mousedown", this.play.bind(this));

        document
            .getElementById("timeline-stop")
            .addEventListener("mousedown", this.stop.bind(this));

        document
            .getElementById("timeline-repeat")
            .addEventListener("mousedown", function (event)
            {
                event.target.style.display = "none";

                document
                    .getElementById("timeline-no-repeat")
                    .style.display = "";

                this._$repeat = false;

            }.bind(this));

        document
            .getElementById("timeline-no-repeat")
            .addEventListener("mousedown", function (event)
            {
                event.target.style.display = "none";

                document
                    .getElementById("timeline-repeat")
                    .style.display = "";

                this._$repeat = true;

            }.bind(this));

        // display none
        document
            .getElementById("timeline-stop")
            .style.display = "none";

        document
            .getElementById("timeline-repeat")
            .style.display = "none";

        // モーショントゥイーンを追加
        document
            .getElementById("context-menu-tween-add")
            .addEventListener("mousedown", function ()
            {
                Util.$endMenu();

                if (this._$targetLayer) {

                    const scene = Util.$currentWorkSpace().scene;

                    const layerElement = this._$targetLayer;
                    const layerId = layerElement.dataset.layerId | 0;

                    const layer = scene.getLayer(layerId);

                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    const characters = layer.getActiveCharacter(frame);
                    if (!characters.length) {
                        return ;
                    }

                    if (characters.length > 1) {
                        alert(
                            "If you want to add motion tweening to multiple objects, please do so in a single MovieClip."
                        );
                        return ;
                    }

                    let endFrame = frame;
                    for (;;) {

                        ++endFrame;

                        const element = document
                            .getElementById(`${layerId}-${endFrame}`);

                        if (element.dataset.frameState === "empty") {
                            --endFrame;
                            break;
                        }

                        if (element.classList.contains("key-frame")
                            || element.classList.contains("empty-key-frame")
                        ) {
                            --endFrame;
                            break;
                        }

                        if (element.classList.contains("key-space-frame-end")) {
                            break;
                        }
                    }

                    let startFrame = frame;
                    while (startFrame > 0) {

                        const element = document
                            .getElementById(`${layerId}-${startFrame}`);

                        if (element.classList.contains("key-frame")) {
                            break;
                        }

                        --startFrame;
                    }

                    const startElement = document
                        .getElementById(`${layerId}-${startFrame}`);

                    if (startElement.classList.contains("tween-key-frame")) {
                        return ;
                    }

                    Util
                        .$currentWorkSpace()
                        .temporarilySaved();

                    startElement.classList.add("tween-key-frame");

                    let tweenEndFrame = startFrame;
                    const character = characters[0];
                    for (; endFrame >= tweenEndFrame; ++tweenEndFrame) {

                        const element = document
                            .getElementById(`${layerId}-${tweenEndFrame}`);

                        if (element.classList.contains("frame-active")) {
                            element.classList.remove("frame-active");
                        }

                        if (!element.classList.contains("tween-frame")) {
                            element.classList.add("tween-frame");

                            layer
                                ._$frame
                                .getClasses(tweenEndFrame)
                                .push("tween-frame");

                        }

                        if (tweenEndFrame > startFrame) {
                            const clone = character.clonePlace(startFrame, tweenEndFrame);
                            clone.loop.referenceFrame = startFrame;
                            clone.loop.tweenFrame     = tweenEndFrame + 1;
                            character.setPlace(tweenEndFrame, clone);
                        }

                        if (element.classList.contains("key-space-frame-end")) {
                            break;
                        }
                    }

                    const startPlace = character.getPlace(startFrame);
                    startPlace.loop.tweenFrame = startFrame + 1;

                    const endPlace = character.getPlace(tweenEndFrame);
                    endPlace.loop.tweenFrame = startFrame;

                    layer
                        ._$frame
                        .getClasses(startFrame)
                        .push("tween-key-frame");

                    const endElement = document
                        .getElementById(`${layerId}-${endFrame}`);

                    endElement.classList.add("tween-frame-end");

                    layer
                        ._$frame
                        .getClasses(endFrame)
                        .push("tween-frame-end");

                    character._$image = null;
                }

            }.bind(this));

        // モーショントゥイーンを削除
        document
            .getElementById("context-menu-tween-delete")
            .addEventListener("mousedown", function ()
            {
                Util.$endMenu();

                if (this._$targetLayer) {

                    const scene = Util.$currentWorkSpace().scene;

                    const layerElement = this._$targetLayer;
                    const layerId = layerElement.dataset.layerId | 0;

                    const layer = scene.getLayer(layerId);

                    const frame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    const characters = layer.getActiveCharacter(frame);
                    if (!characters.length) {
                        return ;
                    }

                    Util
                        .$currentWorkSpace()
                        .temporarilySaved();

                    let startFrame = document
                        .getElementById("current-frame")
                        .textContent | 0;

                    while (startFrame > 0) {

                        const element = document
                            .getElementById(`${layerId}-${startFrame}`);

                        if (element.classList.contains("key-frame")) {
                            break;
                        }

                        --startFrame;
                    }

                    const character = characters[0];
                    const endFrame  = character.endFrame - 1;
                    for (let frame = startFrame; endFrame >= frame; ++frame) {

                        const element = document
                            .getElementById(`${layerId}-${frame}`);

                        if (element.classList.contains("frame-active")) {
                            element.classList.remove("frame-active");
                        }

                        if (!element.classList.contains("tween-frame")) {
                            continue;
                        }
                        if (frame !== startFrame
                            && element.classList.contains("ket-frame")
                        ) {
                            break;
                        }

                        element
                            .classList
                            .remove(
                                "tween-frame",
                                "tween-key-frame",
                                "tween-frame-end"
                            );

                        let classes = layer
                            ._$frame
                            .getClasses(frame);

                        const names = [
                            "tween-frame",
                            "tween-key-frame",
                            "tween-frame-end"
                        ];
                        for (let idx = 0; names.length > idx; ++idx) {
                            const index = classes.indexOf(names[idx]);
                            if (index === -1) {
                                continue;
                            }
                            classes.splice(index, 1);
                        }

                        layer
                            ._$frame
                            .setClasses(frame, classes);

                        if (frame > startFrame) {
                            character.deletePlace(frame);
                        }

                        if (element.classList.contains("key-space-frame-end")) {
                            break;
                        }
                    }

                    const startPlace = character.getPlace(startFrame);
                    delete startPlace.loop.tweenFrame;

                    character._$image = null;

                    character._$tween.delete(startFrame);

                    document
                        .getElementById("ease-select")[0]
                        .selected = true;

                    Util.$controller.hideEaseCanvasArea();
                    Util.$screen.clearTweenMarker();

                    scene.changeFrame(frame);
                }

            }.bind(this));

        // // シェイプモーフィングを追加
        // document
        //     .getElementById("context-menu-morph-add")
        //     .addEventListener("mousedown", function ()
        //     {
        //         Util.$endMenu();
        //
        //         if (this._$targetLayer) {
        //
        //             const workSpace = Util.$currentWorkSpace();
        //             const scene = workSpace.scene;
        //
        //             const layerElement = this._$targetLayer;
        //             const layerId = layerElement.dataset.layerId | 0;
        //
        //             const layer = scene.getLayer(layerId);
        //
        //             const frame = document
        //                 .getElementById("current-frame")
        //                 .textContent | 0;
        //
        //             const characters = layer.getActiveCharacter(frame);
        //             if (!characters.length) {
        //                 return ;
        //             }
        //
        //             for (let idx = 0; idx < characters.length; ++idx) {
        //
        //                 const character = characters[idx];
        //                 const instance  = workSpace.getLibrary(character.libraryId);
        //
        //                 if (instance.type !== "shape") {
        //                     alert("Morphing only applies to shapes.");
        //                     return ;
        //                 }
        //
        //             }
        //
        //             let endFrame = frame;
        //             for (;;) {
        //
        //                 ++endFrame;
        //
        //                 const element = document
        //                     .getElementById(`${layerId}-${endFrame}`);
        //
        //                 if (element.dataset.frameState === "empty") {
        //                     --endFrame;
        //                     break;
        //                 }
        //
        //                 if (element.classList.contains("key-frame")
        //                     || element.classList.contains("empty-key-frame")
        //                 ) {
        //                     --endFrame;
        //                     break;
        //                 }
        //
        //                 if (element.classList.contains("key-space-frame-end")) {
        //                     break;
        //                 }
        //             }
        //
        //             let startFrame = frame;
        //             while (startFrame > 0) {
        //
        //                 const element = document
        //                     .getElementById(`${layerId}-${startFrame}`);
        //
        //                 if (element.classList.contains("key-frame")) {
        //                     break;
        //                 }
        //
        //                 --startFrame;
        //             }
        //
        //             const startElement = document
        //                 .getElementById(`${layerId}-${startFrame}`);
        //
        //             if (startElement.classList.contains("morph-key-frame")) {
        //                 return ;
        //             }
        //
        //             Util
        //                 .$currentWorkSpace()
        //                 .temporarilySaved();
        //
        //             startElement.classList.add("morph-key-frame");
        //
        //             const character = characters[0];
        //             for (let frame = startFrame; endFrame >= frame; ++frame) {
        //
        //                 const element = document
        //                     .getElementById(`${layerId}-${frame}`);
        //
        //                 if (element.classList.contains("frame-active")) {
        //                     element.classList.remove("frame-active");
        //                 }
        //
        //                 if (!element.classList.contains("morph-frame")) {
        //                     element.classList.add("morph-frame");
        //
        //                     layer
        //                         ._$frame
        //                         .getClasses(frame)
        //                         .push("morph-frame");
        //
        //                 }
        //
        //                 if (element.classList.contains("key-space-frame-end")) {
        //                     break;
        //                 }
        //             }
        //
        //             layer
        //                 ._$frame
        //                 .getClasses(startFrame)
        //                 .push("morph-key-frame");
        //
        //             const endElement = document
        //                 .getElementById(`${layerId}-${endFrame}`);
        //
        //             endElement.classList.add("morph-frame-end");
        //
        //             layer
        //                 ._$frame
        //                 .getClasses(endFrame)
        //                 .push("morph-frame-end");
        //
        //             character._$image = null;
        //         }
        //
        //     }.bind(this));
        //
        // // シェイプモーフィングを削除
        // document
        //     .getElementById("context-menu-morph-delete")
        //     .addEventListener("mousedown", function ()
        //     {
        //         Util.$endMenu();
        //
        //         if (this._$targetLayer) {
        //
        //             const scene = Util.$currentWorkSpace().scene;
        //
        //             const layerElement = this._$targetLayer;
        //             const layerId = layerElement.dataset.layerId | 0;
        //
        //             const layer = scene.getLayer(layerId);
        //
        //             const frame = document
        //                 .getElementById("current-frame")
        //                 .textContent | 0;
        //
        //             const characters = layer.getActiveCharacter(frame);
        //             if (!characters.length) {
        //                 return ;
        //             }
        //
        //             Util
        //                 .$currentWorkSpace()
        //                 .temporarilySaved();
        //
        //             let startFrame = document
        //                 .getElementById("current-frame")
        //                 .textContent | 0;
        //
        //             while (startFrame > 0) {
        //
        //                 const element = document
        //                     .getElementById(`${layerId}-${startFrame}`);
        //
        //                 if (element.classList.contains("key-frame")) {
        //                     break;
        //                 }
        //
        //                 --startFrame;
        //             }
        //
        //             const character = characters[0];
        //             const endFrame  = character.endFrame - 1;
        //             for (let frame = startFrame; endFrame >= frame; ++frame) {
        //
        //                 const element = document
        //                     .getElementById(`${layerId}-${frame}`);
        //
        //                 if (element.classList.contains("frame-active")) {
        //                     element.classList.remove("frame-active");
        //                 }
        //
        //                 if (!element.classList.contains("morph-frame")) {
        //                     continue;
        //                 }
        //
        //                 if (frame !== startFrame
        //                     && element.classList.contains("ket-frame")
        //                 ) {
        //                     break;
        //                 }
        //
        //                 element
        //                     .classList
        //                     .remove(
        //                         "morph-frame",
        //                         "morph-key-frame",
        //                         "morph-frame-end"
        //                     );
        //
        //                 const classes = layer
        //                     ._$frame
        //                     .getClasses(frame);
        //
        //                 const index = classes.indexOf("morph-frame");
        //                 if (index > -1) {
        //                     classes.splice(index, 1);
        //                     layer
        //                         ._$frame
        //                         .setClasses(frame, classes);
        //                 }
        //
        //                 if (element.classList.contains("key-space-frame-end")) {
        //                     break;
        //                 }
        //             }
        //
        //             character._$image = null;
        //             scene.changeFrame(frame);
        //         }
        //
        //     }.bind(this));
    }

    /**
     * @return {void}
     * @public
     */
    play ()
    {
        if (this._$stopFlag) {

            Util.$endMenu();

            // update total frame
            this._$totalFrame = Util.$currentWorkSpace().scene.totalFrame;

            // params
            if (this._$totalFrame > 1) {

                this._$stopFlag = false;

                if (this._$timerId > -1) {
                    window.cancelAnimationFrame(this._$timerId);
                }

                const element = document.getElementById("current-frame");
                let frame = (element.textContent | 0) + 1;
                if (frame > this._$totalFrame) {

                    element.textContent = "1";

                    document
                        .getElementById("timeline-marker")
                        .style.left = "0px";

                    const base = document
                        .getElementById("timeline-controller-base");

                    if (base.scrollLeft) {
                        this.moveTimeLine(0);
                    }

                    Util.$currentWorkSpace().scene.changeFrame(1);
                }

                document
                    .getElementById("timeline-play")
                    .style.display = "none";

                document
                    .getElementById("timeline-stop")
                    .style.display = "";

                document
                    .getElementById("target-group")
                    .style.display = "none";

                this.resetFrames();
                Util.$screen.clearActiveCharacter();
                Util.$controller.setDefaultController();

                this._$startTime = window.performance.now();
                this._$fps       = 1000 / (document.getElementById("stage-fps").value | 0);
                this._$timerId   = window.requestAnimationFrame(this._$run);
            }
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    stop ()
    {
        window.cancelAnimationFrame(this._$timerId);
        this._$stopFlag = true;
        this._$timerId  = -1;

        document
            .getElementById("timeline-play")
            .style.display = "";

        document
            .getElementById("timeline-stop")
            .style.display = "none";

        const onionElement = document
            .getElementById("timeline-onion-skin");
        if (onionElement.classList.contains("onion-skin-active")) {
            Util.$currentWorkSpace().scene.changeFrame(
                document.getElementById("current-frame").textContent | 0
            );
        }
    }

    /**
     * @param  {number} timestamp
     * @return {void}
     * @method
     * @public
     */
    run (timestamp = 0)
    {
        if (this._$stopFlag) {
            return ;
        }

        let delta = timestamp - this._$startTime;
        if (delta > this._$fps) {

            const element = document.getElementById("current-frame");

            const base = document
                .getElementById("timeline-controller-base");

            let frame = (element.textContent | 0) + 1;
            if (frame > this._$totalFrame) {

                if (!this._$repeat) {
                    return this.stop();
                }

                frame = 1;

                if (base.scrollLeft) {
                    this.moveTimeLine(0);
                }
            }

            // fixed logic
            element.textContent = `${frame}`;

            // update
            this._$startTime = timestamp - delta % this._$fps;
            Util.$currentWorkSpace().scene.changeFrame(frame);

            const moveX = (frame - 1) * 13;
            const marker = document.getElementById("timeline-marker");
            marker.style.left = `${moveX}px`;

            if (moveX > base.offsetWidth / 2) {
                this.moveTimeLine(moveX - base.offsetWidth / 2);
            }

        }

        this._$timerId = window.requestAnimationFrame(this._$run);
    }

    /**
     * @return {void}
     * @public
     */
    initializeParams ()
    {
        this._$scrollX         = 0;
        this._$pointX          = 0;
        this._$pointY          = 0;
        this._$moveId          = -1;
        this._$targetFrame     = null;
        this._$targetLayer     = null;
        this._$moveLayer       = null;
        this._$moveTarget      = null;
        this._$lightAll        = false;
        this._$disableAll      = false;
        this._$lockAll         = false;
        this._$multiMode       = false;
        this._$menuMode        = false;
        this._$sceneMode       = false;
        this._$resizeMode      = false;
        this._$markerMode      = false;
        this._$stopFlag        = true;
        this._$repeat          = false;
        this._$timerId         = -1;
        this._$startTime       = -1;
        this._$fps             = -1;
        this._$totalFrame      = 1;
        this._$layerMenuMode   = false;
        this._$labelFrame      = 0;
        this._$targetFrames    = [];
        this._$actionFrame     = -1;
        this._$actionScene     = null;
        this._$moveScriptModal = false;
    }

    /**
     * @param  {object|KeyboardEvent} event
     * @return {void}
     * @public
     */
    setLabelMarker (event)
    {
        if (this._$labelFrame && event.code === "Enter") {

            const label = event.currentTarget.value;
            const classValue = label
                ? "frame-border-box-marker"
                : "frame-border-box";

            const element = document
                .getElementById(`frame-label-marker-${this._$labelFrame}`);

            element.setAttribute("class", classValue);

            const workSpace = Util.$currentWorkSpace();
            if (label) {
                workSpace.scene.setLabel(this._$labelFrame, label);
            } else {
                workSpace.scene.deleteLabel(this._$labelFrame);
            }

            // end
            this._$labelFrame = 0;
            if (event.type === "keypress") {
                event.currentTarget.blur();
            }

        }
    }

    /**
     * @param  {HTMLElement} element
     * @return {void}
     * @public
     */
    removeFrameClass (element)
    {
        const classes = [
            "key-frame",
            "empty-key-frame",
            "key-space-frame",
            "empty-space-frame",
            "key-space-frame-end",
            "empty-space-frame-end",
            "empty-key-frame-join",
            "key-frame-join",
            "tween-frame",
            "tween-key-frame",
            "tween-frame-end",
            "morph-frame",
            "morph-key-frame",
            "morph-frame-end"
        ];

        for (let idx = 0; idx < classes.length; ++idx) {

            element
                .classList
                .remove(classes[idx]);

        }

        element.dataset.frameState = "empty";
    }

    /**
     * @param  {HTMLElement} a
     * @param  {HTMLElement} b
     * @return {number}
     * @public
     */
    frameSort (a, b)
    {
        const aFrame = a.dataset.frame | 0;
        const bFrame = b.dataset.frame | 0;

        switch (true) {

            case aFrame > bFrame:
                return 1;

            case aFrame < bFrame:
                return -1;

            default:
                return 0;

        }
    }

    /**
     * @param  {MouseEvent} [event=null]
     * @return {void}
     * @public
     */
    showScriptArea (event = null)
    {
        Util.$keyLock      = true;
        Util.$activeScript = true;

        this._$actionFrame = document
            .getElementById("current-frame")
            .textContent | 0;

        // reset
        this._$editor.setValue("", -1);

        const scene = Util.$currentWorkSpace().scene;
        if (scene.hasAction(this._$actionFrame)) {
            this._$editor.setValue(scene.getAction(this._$actionFrame), -1);
        }

        document
            .getElementById("editor-title")
            .textContent = `${scene.name} / frame[${this._$actionFrame}]`;

        if (event) {
            const element = document.getElementById("editor-modal");
            element.style.display = "";
            element.style.left = `${event.pageX + 5}px`;
            element.style.top  = `${event.pageY - element.clientHeight / 2}px`;

            element.setAttribute("class", "fadeIn");
            Util.$endMenu("editor-modal");
        }

        this._$editor.focus();
    }

    /**
     * @return {void}
     * @public
     */
    hideScriptArea ()
    {
        this.saveActionScript();

        this._$editor.setValue("", 0);

        // clear
        this._$actionFrame = -1;
        this._$actionScene = null;
        Util.$keyLock      = false;
        Util.$activeScript = false;
        Util.$endMenu();
    }

    /**
     * @return {void}
     * @public
     */
    saveActionScript ()
    {
        if (this._$actionFrame === -1) {
            return ;
        }

        const script = this._$editor.getValue(0);

        const element = document
            .getElementById(`frame-label-action-${this._$actionFrame}`);

        const scene = this._$actionScene || Util.$currentWorkSpace().scene;
        if (script) {
            scene.setAction(this._$actionFrame, script.trim());
            if (!this._$actionScene  && !element.classList.contains("frame-border-box-action")) {
                element.setAttribute("class", "frame-border-box-action");
            }
        } else {
            scene.deleteAction(this._$actionFrame);
            if (!this._$actionScene ) {
                element.setAttribute("class", "frame-border-box");
            }
        }
    }

    /**
     * @param  {boolean} [redraw=true]
     * @return {void}
     * @public
     */
    addSpaceFrame (redraw = true)
    {
        const length = this._$targetFrames.length;
        if (!length) {
            return ;
        }

        Util
            .$currentWorkSpace()
            .temporarilySaved();

        this._$targetFrames.sort(this.frameSort);

        const moveFrames = [];

        // first data
        const firstElement = this._$targetFrames[0];
        const layerId      = firstElement.dataset.layerId | 0;
        let startFrame     = firstElement.dataset.frame | 0;

        // current layer class
        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(layerId);

        let count    = 0;
        let frame    = startFrame;
        let refFrame = startFrame;
        let addFrame = length;
        let keyFrame = false;
        let isTween  = firstElement.classList.contains("tween-frame");
        let isMorph  = firstElement.classList.contains("morph-frame");

        const frameState = firstElement.dataset.frameState;
        if (frameState === "empty") {

            if (startFrame === 1) {

                firstElement
                    .classList
                    .add("empty-key-frame");

                if (length > 1) {

                    firstElement
                        .classList
                        .add("empty-key-frame-join");

                    layer
                        ._$frame
                        .setClasses(frame, [
                            "empty-key-frame",
                            "empty-key-frame-join"
                        ]);

                } else {

                    layer
                        ._$frame
                        .setClasses(frame, [
                            "empty-key-frame"
                        ]);

                }

                firstElement
                    .dataset
                    .frameState = "empty-key-frame";

            } else {

                // 後方確認
                let done = false;
                while (frame) {

                    const prevElement = document
                        .getElementById(`${layerId}-${--frame}`);

                    switch (prevElement.dataset.frameState) {

                        case "empty":

                            if (frame === 1) {

                                prevElement
                                    .classList
                                    .add("empty-key-frame");

                                prevElement
                                    .classList
                                    .add("empty-key-frame-join");

                                prevElement
                                    .dataset
                                    .frameState = "empty-key-frame";

                                layer
                                    ._$frame
                                    .setClasses(frame, [
                                        "empty-key-frame",
                                        "empty-key-frame-join"
                                    ]);

                                done = true;

                            } else {

                                prevElement
                                    .classList
                                    .add("empty-space-frame");

                                prevElement
                                    .dataset
                                    .frameState = "empty-space-frame";

                                layer
                                    ._$frame
                                    .setClasses(frame, [
                                        "empty-space-frame"
                                    ]);

                            }
                            break;

                        case "empty-space-frame-end":

                            prevElement
                                .classList
                                .remove("empty-space-frame-end");

                            prevElement
                                .classList
                                .add("empty-space-frame");

                            prevElement
                                .dataset
                                .frameState = "empty-space-frame";

                            layer
                                ._$frame
                                .setClasses(frame, [
                                    "empty-space-frame"
                                ]);

                            done = true;
                            break;

                        case "empty-key-frame":

                            prevElement
                                .classList
                                .add("empty-key-frame-join");

                            layer
                                ._$frame
                                .setClasses(frame, [
                                    "empty-key-frame",
                                    "empty-key-frame-join"
                                ]);

                            done = true;
                            break;

                        case "key-frame":
                            {
                                isTween = prevElement
                                    .classList
                                    .contains("tween-frame");

                                isMorph = prevElement
                                    .classList
                                    .contains("morph-frame");

                                prevElement
                                    .classList
                                    .add("key-frame-join");

                                const classes = [
                                    "key-frame",
                                    "key-frame-join"
                                ];

                                if (isTween) {
                                    prevElement
                                        .classList
                                        .remove("tween-frame-end");

                                    classes.push("tween-frame");
                                }

                                if (isMorph) {
                                    prevElement
                                        .classList
                                        .remove("morph-frame-end");

                                    classes.push("morph-frame");
                                }

                                layer
                                    ._$frame
                                    .setClasses(frame, classes);

                                keyFrame = true;
                                done     = true;
                            }
                            break;

                        case "key-space-frame-end":
                            {
                                isTween = prevElement
                                    .classList
                                    .contains("tween-frame");

                                isMorph = prevElement
                                    .classList
                                    .contains("morph-frame");

                                this.removeFrameClass(prevElement);

                                prevElement
                                    .classList
                                    .add("key-space-frame");

                                prevElement
                                    .dataset
                                    .frameState = "key-space-frame";

                                const classes = ["key-space-frame"];
                                if (isTween) {
                                    prevElement
                                        .classList
                                        .add("tween-frame");

                                    classes.push("tween-frame");
                                }

                                if (isMorph) {
                                    prevElement
                                        .classList
                                        .add("morph-frame");

                                    classes.push("morph-frame");
                                }

                                layer
                                    ._$frame
                                    .setClasses(frame, classes);

                                keyFrame = true;
                                done     = true;
                            }
                            break;

                    }

                    if (done) {
                        break;
                    }

                }

                if (keyFrame) {

                    refFrame = frame;
                    addFrame = startFrame - refFrame;
                    if (length > 1) {
                        const lastElement = this._$targetFrames[this._$targetFrames.length - 1];
                        addFrame = (lastElement.dataset.frame | 0) - refFrame;
                    }

                    for (;;) {

                        const nextElement = document
                            .getElementById(`${layerId}-${++frame}`);

                        this.removeFrameClass(nextElement);

                        nextElement
                            .classList
                            .add("key-space-frame");

                        const classes = ["key-space-frame"];
                        if (isTween) {
                            nextElement
                                .classList
                                .add("tween-frame");

                            classes.push("tween-frame");
                        }

                        if (isMorph) {
                            nextElement
                                .classList
                                .add("morph-frame");

                            classes.push("morph-frame");
                        }

                        nextElement
                            .dataset
                            .frameState = "key-space-frame";

                        layer
                            ._$frame
                            .setClasses(frame, classes);

                        if (frame === startFrame) {

                            if (length === 1) {

                                this.removeFrameClass(nextElement);

                                nextElement
                                    .classList
                                    .add("key-space-frame-end");

                                const classes = ["key-space-frame-end"];
                                if (isTween) {
                                    nextElement
                                        .classList
                                        .add("tween-frame", "tween-frame-end");

                                    classes.push(
                                        "tween-frame",
                                        "tween-frame-end"
                                    );
                                }

                                if (isMorph) {
                                    nextElement
                                        .classList
                                        .add("morph-frame", "morph-frame-end");

                                    classes.push(
                                        "morph-frame",
                                        "morph-frame-end"
                                    );
                                }

                                nextElement
                                    .dataset
                                    .frameState = "key-space-frame-end";

                                layer
                                    ._$frame
                                    .setClasses(frame, classes);

                            }
                            break;

                        }
                    }
                }
            }

            const type = keyFrame ? "key" : "empty";
            for (let idx = startFrame === 1 ? 1 : 0; idx < length; ++idx) {

                const targetElement = this._$targetFrames[idx];

                const frame = targetElement.dataset.frame | 0;

                // last
                if (length === idx + 1) {

                    targetElement
                        .classList
                        .add(`${type}-space-frame-end`);

                    targetElement
                        .dataset
                        .frameState = `${type}-space-frame-end`;

                    const classes = [`${type}-space-frame-end`];
                    if (isTween) {
                        targetElement
                            .classList
                            .add("tween-frame", "tween-frame-end");

                        classes.push(
                            "tween-frame",
                            "tween-frame-end"
                        );
                    }

                    if (isMorph) {
                        targetElement
                            .classList
                            .add("morph-frame", "morph-frame-end");

                        classes.push(
                            "morph-frame",
                            "morph-frame-end"
                        );
                    }

                    layer
                        ._$frame
                        .setClasses(frame, classes);

                    break;
                }

                targetElement
                    .classList
                    .add(`${type}-space-frame`);

                targetElement
                    .dataset
                    .frameState = `${type}-space-frame`;

                const classes = [`${type}-space-frame`];
                if (isTween) {
                    targetElement
                        .classList
                        .add("tween-frame");

                    classes.push("tween-frame");
                }

                if (isMorph) {
                    targetElement
                        .classList
                        .add("morph-frame");

                    classes.push("morph-frame");
                }

                layer
                    ._$frame
                    .setClasses(frame, classes);

            }

        } else {

            switch (frameState) {

                case "key-frame":

                    count++;

                    isTween = firstElement
                        .classList
                        .contains("tween-frame");

                    isMorph = firstElement
                        .classList
                        .contains("morph-frame");

                    if (!firstElement.classList.contains("key-frame-join")) {

                        firstElement
                            .classList
                            .add("key-frame-join");

                        const classes = [
                            "key-frame",
                            "key-frame-join"
                        ];

                        if (isTween) {
                            firstElement
                                .classList
                                .add("tween-frame");

                            firstElement
                                .classList
                                .remove("tween-frame-end");

                            classes.push("tween-frame");
                        }

                        if (isMorph) {
                            firstElement
                                .classList
                                .add("morph-frame");

                            firstElement
                                .classList
                                .remove("morph-frame-end");

                            classes.push("morph-frame");
                        }

                        layer
                            ._$frame
                            .setClasses(startFrame, classes);

                    }
                    break;

                case "empty-key-frame":
                    count++;
                    if (!firstElement.classList.contains("empty-key-frame-join")) {

                        firstElement
                            .classList
                            .add("empty-key-frame-join");

                        layer
                            ._$frame
                            .setClasses(startFrame, [
                                "empty-key-frame",
                                "empty-key-frame-join"
                            ]);

                    }
                    break;

                default:
                    break;

            }

            let done    = false;
            let endFlag = false;
            let frame   = startFrame + count;
            for (;;) {

                const targetElement = document
                    .getElementById(`${layerId}-${frame++}`);

                switch (targetElement.dataset.frameState) {

                    case "empty":
                    case "key-frame":
                    case "empty-key-frame":
                        done = true;
                        break;

                    case "key-space-frame-end":
                    case "empty-space-frame-end":
                        endFlag = true;
                        done    = true;
                        break;

                    default:
                        break;

                }

                if (done) {
                    break;
                }

            }

            let activeCount = this.getMoveFrames(
                layerId, startFrame + count, moveFrames
            );

            const type = frameState === "key-frame"
                || frameState === "key-space-frame"
                || frameState === "key-space-frame-end"
                ? "key" : "empty";

            let limit = 0;
            frame = startFrame + count;
            while (length > limit) {

                limit++;

                const targetElement = document
                    .getElementById(`${layerId}-${frame}`);

                if (activeCount) {

                    activeCount--;

                    targetElement
                        .classList
                        .add("frame-active");

                }

                if (!endFlag && length === limit) {

                    targetElement
                        .classList
                        .add(`${type}-space-frame-end`);

                    targetElement
                        .dataset
                        .frameState = `${type}-space-frame-end`;

                    const classes = [`${type}-space-frame-end`];
                    if (isTween) {
                        targetElement
                            .classList
                            .add("tween-frame", "tween-frame-end");

                        classes.push("tween-frame", "tween-frame-end");
                    }

                    if (isMorph) {
                        targetElement
                            .classList
                            .add("morph-frame", "morph-frame-end");

                        classes.push("morph-frame", "morph-frame-end");
                    }

                    layer
                        ._$frame
                        .setClasses(frame++, classes);

                    break;
                }

                targetElement
                    .classList
                    .add(`${type}-space-frame`);

                targetElement
                    .dataset
                    .frameState = `${type}-space-frame`;

                const classes = [`${type}-space-frame`];
                if (isTween) {
                    targetElement
                        .classList
                        .add("tween-frame");

                    classes.push("tween-frame");
                }

                if (isMorph) {
                    targetElement
                        .classList
                        .add("morph-frame");

                    classes.push("morph-frame");
                }

                layer
                    ._$frame
                    .setClasses(frame++, classes);

            }

            if (moveFrames.length) {
                this.moveFrames(layerId, startFrame + length + count, moveFrames);
            }

        }

        // update end frame
        const characters = layer._$characters;
        for (let idx = 0; idx < characters.length; ++idx) {

            const character = characters[idx];

            if (refFrame >= character.endFrame) {
                continue;
            }

            character.endFrame += addFrame;
            if (character.startFrame > refFrame) {
                character.startFrame += addFrame;
            }

            const places = [];
            for (let [frame, place] of character._$places) {

                if (refFrame >= frame) {
                    continue;
                }

                character.deletePlace(frame);
                place.frame += addFrame;
                places.push(place);
            }

            for (let idx = 0; idx < places.length; ++idx) {
                const place = places[idx];
                character.setPlace(place.frame, place);
            }
        }

        if (isTween) {
            Util.$screen.clearTweenMarker();
            Util.$screen.executeTween(layer);
        }

        this.adjTimeline();
        if (redraw) {
            scene.changeFrame(refFrame);
        }
    }

    /**
     * @return {void}
     * @public
     */
    adjTimeline ()
    {
        const scene = Util.$currentWorkSpace().scene;

        let baseLimit = Math.ceil(window.parent.screen.width * 1.5
            + (scene.totalFrame / 5 | 0) * Util.$frameWidth
        );

        const marker = document.getElementById("timeline-frame-marker");
        if (baseLimit > marker.scrollWidth) {

            let baseFrame = 1 + (marker
                .lastElementChild
                .lastElementChild
                .lastElementChild
                .dataset.frame | 0);

            const fps = document.getElementById("stage-fps").value | 0;

            let sec = Math.ceil(baseFrame / fps);
            const scrollWidth = marker.scrollWidth;

            let htmlTag = "";
            let frame   = baseFrame;
            let limit   = baseLimit - scrollWidth;
            while (limit > 0) {

                htmlTag += `
<div class="frame-group">
    <div class="frame-border-sec-group">
        <div class="frame-border" data-frame="${frame}">${frame % fps === 0 && fps > 4 ? sec++ + "s" : ""}</div>
        <div class="frame-border" data-frame="${frame + 1}">${(frame + 1) % fps === 0 && fps > 4 ? sec++ + "s" : ""}</div>
        <div class="frame-border" data-frame="${frame + 2}">${(frame + 2) % fps === 0 && fps > 4 ? sec++ + "s" : ""}</div>
        <div class="frame-border" data-frame="${frame + 3}">${(frame + 3) % fps === 0 && fps > 4 ? sec++ + "s" : ""}</div>
        <div class="frame-border" data-frame="${frame + 4}">${(frame + 4) % fps === 0 && fps > 4 ? sec++ + "s" : ""}</div>
    </div>
    <div class="frame-border-box-group">
        <div id="frame-label-marker-${frame}"     class="frame-border-box" data-frame="${frame}"></div>
        <div id="frame-label-marker-${frame + 1}" class="frame-border-box" data-frame="${frame + 1}"></div>
        <div id="frame-label-marker-${frame + 2}" class="frame-border-box" data-frame="${frame + 2}"></div>
        <div id="frame-label-marker-${frame + 3}" class="frame-border-box" data-frame="${frame + 3}"></div>
        <div id="frame-label-marker-${frame + 4}" class="frame-border-box" data-frame="${frame + 4}"></div>
    </div>
    <div class="frame-border-box-group">
        <div id="frame-label-action-${frame}"     class="frame-border-box" data-frame="${frame}"></div>
        <div id="frame-label-action-${frame + 1}" class="frame-border-box" data-frame="${frame + 1}"></div>
        <div id="frame-label-action-${frame + 2}" class="frame-border-box" data-frame="${frame + 2}"></div>
        <div id="frame-label-action-${frame + 3}" class="frame-border-box" data-frame="${frame + 3}"></div>
        <div id="frame-label-action-${frame + 4}" class="frame-border-box" data-frame="${frame + 4}"></div>
    </div>
        <div class="frame-border-box-group">
        <div id="frame-label-sound-${frame}"     class="frame-border-box" data-frame="${frame}"></div>
        <div id="frame-label-sound-${frame + 1}" class="frame-border-box" data-frame="${frame + 1}"></div>
        <div id="frame-label-sound-${frame + 2}" class="frame-border-box" data-frame="${frame + 2}"></div>
        <div id="frame-label-sound-${frame + 3}" class="frame-border-box" data-frame="${frame + 3}"></div>
        <div id="frame-label-sound-${frame + 4}" class="frame-border-box" data-frame="${frame + 4}"></div>
    </div>
    <div class="frame-number-group">
        <div class="frame-number-space" data-frame="${frame}"></div>
        <div class="frame-number-space" data-frame="${frame + 1}"></div>
        <div class="frame-number-space" data-frame="${frame + 2}"></div>
        <div class="frame-number-space" data-frame="${frame + 3}"></div>
        <div class="frame-number" data-frame="${frame + 4}">${frame + 4}</div>
    </div>
</div>`;

                frame += 5;
                limit -= Util.$frameWidth;
            }

            // add child
            marker.insertAdjacentHTML("beforeend", htmlTag);

            // target class
            const classes = [
                "frame-border",
                "frame-border-box",
                "frame-number-space",
                "frame-number"
            ];

            const markerOver = this.markerOver.bind(this);
            const markerMove = this.markerMove.bind(this);
            for (let idx = 0; idx < classes.length; ++idx) {

                const elements = marker.getElementsByClassName(classes[idx]);
                for (let idx = 0; idx < elements.length; ++idx) {

                    const element = elements[idx];

                    element.addEventListener("mouseover", markerOver);
                    element.addEventListener("mousedown", markerMove);

                }

            }

            for (const layerId of scene._$layers.keys()) {

                const element = document
                    .getElementById(`frame-scroll-id-${layerId}`);

                if (!element) {
                    continue;
                }

                let htmlTag = "";
                let frame   = baseFrame;
                let limit   = baseLimit - scrollWidth;
                while (limit > 0) {

                    htmlTag += `
<div class="timeline-frame-group">
    <div class="frame" data-click-type="frame" data-frame-state="empty" data-layer-id="${layerId}" id="${layerId}-${frame}" data-frame="${frame}"></div>
    <div class="frame" data-click-type="frame" data-frame-state="empty" data-layer-id="${layerId}" id="${layerId}-${frame + 1}" data-frame="${frame + 1}"></div>
    <div class="frame" data-click-type="frame" data-frame-state="empty" data-layer-id="${layerId}" id="${layerId}-${frame + 2}" data-frame="${frame + 2}"></div>
    <div class="frame" data-click-type="frame" data-frame-state="empty" data-layer-id="${layerId}" id="${layerId}-${frame + 3}" data-frame="${frame + 3}"></div>
    <div class="frame frame-pointer" data-click-type="frame-pointer" data-frame-state="empty" data-layer-id="${layerId}" id="${layerId}-${frame + 4}" data-frame="${frame + 4}"></div>
</div>`;

                    frame += 5;
                    limit -= Util.$frameWidth;

                }

                element
                    .firstElementChild
                    .insertAdjacentHTML("beforeend", htmlTag);

            }
        }
    }

    /**
     * @param  {number} layer_id
     * @param  {number} frame
     * @param  {array}  frames
     * @return {void}
     * @public
     */
    moveFrames (layer_id, frame, frames)
    {
        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layer_id);

        for (let idx = 0; idx < frames.length; ++idx) {

            const element = document
                .getElementById(`${layer_id}-${frame}`);

            const moveObject = frames[idx];

            const length = moveObject.classValues.length;
            for (let idx = 0; idx < length; ++idx) {

                element
                    .classList
                    .add(moveObject.classValues[idx]);

            }

            element
                .dataset
                .frameState = moveObject.frameState;

            layer
                ._$frame
                .setClasses(frame, moveObject.classValues);

            frame++;

        }
    }

    /**
     * @param  {number} layer_id
     * @param  {number} frame
     * @param  {array}  frames
     * @return {number}
     * @public
     */
    getMoveFrames (layer_id, frame, frames)
    {
        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layer_id);

        let activeCount = 0;
        for (;;) {

            const element = document
                .getElementById(`${layer_id}-${frame}`);

            const frameState = element.dataset.frameState;
            if (frameState === "empty") {
                return activeCount;
            }

            const classValues = [];
            const length = element.classList.length;
            for (let idx = 0; idx < length; ++idx) {

                const value = element.classList[idx];
                switch (value) {

                    case "frame":
                    case "frame-pointer":
                        continue;

                    case "frame-active":
                        activeCount++;
                        continue;

                    default:
                        classValues.push(value);
                        break;

                }

            }

            frames.push({
                "frame"       : frame,
                "frameState"  : frameState,
                "classValues" : classValues
            });

            this.removeFrameClass(element);

            layer
                ._$frame
                .deleteClasses(frame++);
        }
    }

    /**
     * @return {void}
     * @public
     */
    addEmptyFrame ()
    {
        const length = this._$targetFrames.length;
        if (length) {

            this._$targetFrames.sort(this.frameSort);

            // first data
            const firstElement = this._$targetFrames[0];
            if (firstElement.classList.contains("tween-frame")) {
                return ;
            }
            if (firstElement.classList.contains("morph-frame")) {
                return ;
            }

            Util
                .$currentWorkSpace()
                .temporarilySaved();

            const layerId  = firstElement.dataset.layerId | 0;
            let startFrame = firstElement.dataset.frame | 0;

            const scene = Util.$currentWorkSpace().scene;
            const layer = scene.getLayer(layerId);
            if (!layer) {
                return ;
            }

            const frameState = firstElement.dataset.frameState;
            switch (frameState) {

                case "empty-key-frame":
                case "key-frame":
                    break;

                case "key-space-frame-end":
                    {
                        this.removeFrameClass(firstElement);

                        firstElement
                            .classList
                            .add("empty-key-frame");

                        firstElement
                            .dataset
                            .frameState = "empty-key-frame";

                        layer
                            ._$frame
                            .setClasses(startFrame, [
                                "empty-key-frame"
                            ]);

                        const prevElement = document
                            .getElementById(`${layerId}-${startFrame - 1}`);

                        if (prevElement.dataset.frameState === "key-frame") {

                            prevElement
                                .classList
                                .remove("key-frame-join");

                            layer
                                ._$frame
                                .setClasses(startFrame - 1, [
                                    "key-frame"
                                ]);

                        } else {

                            this.removeFrameClass(prevElement);

                            prevElement
                                .classList
                                .add("key-space-frame-end");

                            prevElement
                                .dataset
                                .frameState = "key-space-frame-end";

                            layer
                                ._$frame
                                .setClasses(startFrame - 1, [
                                    "key-space-frame-end"
                                ]);

                        }

                        this.splitCharacters(
                            scene, layer,
                            firstElement.dataset.frame | 0,
                            startFrame
                        );
                    }
                    break;

                case "key-space-frame":
                    {
                        this.removeFrameClass(firstElement);

                        firstElement
                            .classList
                            .add("empty-key-frame");

                        firstElement
                            .classList
                            .add("empty-key-frame-join");

                        firstElement
                            .dataset
                            .frameState = "empty-key-frame";

                        layer
                            ._$frame
                            .setClasses(startFrame, [
                                "empty-key-frame",
                                "empty-key-frame-join"
                            ]);

                        const prevElement = document
                            .getElementById(`${layerId}-${startFrame - 1}`);

                        if (prevElement.dataset.frameState === "key-frame") {

                            prevElement
                                .classList
                                .remove("key-frame-join");

                            layer
                                ._$frame
                                .setClasses(startFrame - 1, [
                                    "key-frame"
                                ]);

                        } else {

                            this.removeFrameClass(prevElement);

                            prevElement
                                .classList
                                .add("key-space-frame-end");

                            prevElement
                                .dataset
                                .frameState = "key-space-frame-end";

                            layer
                                ._$frame
                                .setClasses(startFrame - 1, [
                                    "key-space-frame-end"
                                ]);

                        }

                        let done = false;
                        for (;;) {

                            const nextElement = document
                                .getElementById(`${layerId}-${++startFrame}`);

                            const frameState = nextElement.dataset.frameState;

                            // reset
                            this.removeFrameClass(nextElement);

                            if (frameState === "key-space-frame-end") {

                                nextElement
                                    .classList
                                    .add("empty-space-frame-end");

                                nextElement
                                    .dataset
                                    .frameState = "empty-space-frame-end";

                                layer
                                    ._$frame
                                    .setClasses(startFrame, [
                                        "empty-space-frame-end"
                                    ]);

                                done = true;

                            } else {

                                nextElement
                                    .classList
                                    .add("empty-space-frame");

                                nextElement
                                    .dataset
                                    .frameState = "empty-space-frame";

                                layer
                                    ._$frame
                                    .setClasses(startFrame, [
                                        "empty-space-frame"
                                    ]);

                            }

                            if (done) {
                                break;
                            }
                        }

                        this.splitCharacters(
                            scene, layer,
                            firstElement.dataset.frame | 0,
                            startFrame
                        );

                    }
                    break;

                case "empty-space-frame-end":
                    {
                        this.removeFrameClass(firstElement);

                        firstElement
                            .classList
                            .add("empty-key-frame");

                        firstElement
                            .dataset
                            .frameState = "empty-key-frame";

                        layer
                            ._$frame
                            .setClasses(startFrame, [
                                "empty-key-frame"
                            ]);

                        const prevElement = document
                            .getElementById(`${layerId}-${startFrame - 1}`);

                        if (prevElement.dataset.frameState === "empty-key-frame") {

                            prevElement
                                .classList
                                .remove("empty-key-frame-join");

                            layer
                                ._$frame
                                .setClasses(startFrame - 1, [
                                    "empty-key-frame",
                                    "empty-key-frame-join"
                                ]);

                        } else {

                            this.removeFrameClass(prevElement);

                            prevElement
                                .classList
                                .add("empty-space-frame-end");

                            prevElement
                                .dataset
                                .frameState = "empty-space-frame-end";

                            layer
                                ._$frame
                                .setClasses(startFrame - 1, [
                                    "empty-space-frame-end"
                                ]);

                        }
                    }
                    break;

                case "empty-space-frame":
                    {
                        this.removeFrameClass(firstElement);

                        firstElement
                            .classList
                            .add("empty-key-frame");

                        firstElement
                            .classList
                            .add("empty-key-frame-join");

                        firstElement
                            .dataset
                            .frameState = "empty-key-frame";

                        layer
                            ._$frame
                            .setClasses(startFrame, [
                                "empty-key-frame",
                                "empty-key-frame-join"
                            ]);

                        const prevElement = document
                            .getElementById(`${layerId}-${startFrame - 1}`);

                        if (prevElement.dataset.frameState === "empty-key-frame") {

                            prevElement
                                .classList
                                .remove("empty-key-frame-join");

                            layer
                                ._$frame
                                .setClasses(startFrame - 1, [
                                    "empty-key-frame",
                                    "empty-key-frame-join"
                                ]);

                        } else {

                            this.removeFrameClass(prevElement);

                            prevElement
                                .classList
                                .add("empty-space-frame-end");

                            prevElement
                                .dataset
                                .frameState = "empty-space-frame-end";

                            layer
                                ._$frame
                                .setClasses(startFrame - 1, [
                                    "empty-space-frame-end"
                                ]);

                        }
                    }
                    break;

                case "empty":

                    this.removeFrameClass(firstElement);

                    firstElement
                        .classList
                        .add("empty-key-frame");

                    firstElement
                        .dataset
                        .frameState = "empty-key-frame";

                    layer
                        ._$frame
                        .setClasses(startFrame, [
                            "empty-key-frame"
                        ]);

                    if (startFrame === 1) {
                        return ;
                    }

                    // 後方調整
                    let keyFrame = false;
                    let done     = false;
                    let frameEnd = false;
                    let frame    = startFrame;
                    while (frame) {

                        const prevElement = document
                            .getElementById(`${layerId}-${--frame}`);

                        switch (prevElement.dataset.frameState) {

                            case "empty":

                                if (frame === 1) {

                                    done = true;

                                    prevElement
                                        .classList
                                        .add("empty-key-frame");

                                    prevElement
                                        .dataset
                                        .frameState = "empty-key-frame";

                                    if (frameEnd) {

                                        prevElement
                                            .classList
                                            .add("empty-key-frame-join");

                                        layer
                                            ._$frame
                                            .setClasses(frame, [
                                                "empty-key-frame",
                                                "empty-key-frame-join"
                                            ]);

                                    } else {

                                        layer
                                            ._$frame
                                            .setClasses(frame, [
                                                "empty-key-frame"
                                            ]);

                                    }

                                } else {

                                    if (frameEnd) {

                                        prevElement
                                            .classList
                                            .add("empty-space-frame");

                                        prevElement
                                            .dataset
                                            .frameState = "empty-space-frame";

                                        layer
                                            ._$frame
                                            .setClasses(frame, [
                                                "empty-space-frame"
                                            ]);

                                    } else {

                                        frameEnd = true;

                                        prevElement
                                            .classList
                                            .add("empty-space-frame-end");

                                        prevElement
                                            .dataset
                                            .frameState = "empty-space-frame-end";

                                        layer
                                            ._$frame
                                            .setClasses(frame, [
                                                "empty-space-frame-end"
                                            ]);

                                    }

                                }

                                break;

                            case "empty-key-frame":

                                done = true;
                                if (frameEnd) {

                                    if (!prevElement.classList.contains("empty-key-frame-join")) {
                                        prevElement
                                            .classList
                                            .add("empty-key-frame-join");

                                        layer
                                            ._$frame
                                            .setClasses(frame, [
                                                "empty-key-frame",
                                                "empty-key-frame-join"
                                            ]);

                                    }

                                } else {

                                    prevElement
                                        .classList
                                        .remove("empty-key-frame-join");

                                    layer
                                        ._$frame
                                        .setClasses(frame, [
                                            "empty-key-frame"
                                        ]);

                                }

                                break;

                            case "empty-space-frame-end":

                                done = true;
                                if (frameEnd) {

                                    prevElement
                                        .classList
                                        .remove("empty-space-frame-end");

                                    prevElement
                                        .classList
                                        .add("empty-space-frame");

                                    prevElement
                                        .dataset
                                        .frameState = "empty-space-frame";

                                    layer
                                        ._$frame
                                        .setClasses(frame, [
                                            "empty-space-frame"
                                        ]);

                                }

                                break;

                            case "key-frame":

                                done = true;
                                if (frameEnd) {

                                    if (!prevElement.classList.contains("key-frame-join")) {
                                        prevElement
                                            .classList
                                            .add("key-frame-join");

                                        layer
                                            ._$frame
                                            .setClasses(frame, [
                                                "key-frame",
                                                "key-frame-join"
                                            ]);

                                    }

                                    keyFrame = true;

                                } else {

                                    prevElement
                                        .classList
                                        .remove("key-frame-join");

                                    layer
                                        ._$frame
                                        .setClasses(frame, [
                                            "key-frame"
                                        ]);

                                }

                                break;

                            case "key-space-frame-end":

                                done = true;
                                if (frameEnd) {

                                    prevElement
                                        .classList
                                        .remove("key-space-frame-end");

                                    prevElement
                                        .classList
                                        .add("key-space-frame");

                                    prevElement
                                        .dataset
                                        .frameState = "key-space-frame";

                                    layer
                                        ._$frame
                                        .setClasses(frame, [
                                            "key-space-frame"
                                        ]);

                                    keyFrame = true;

                                }
                                break;

                        }

                        if (done) {
                            break;
                        }

                    }

                    if (keyFrame) {

                        const characters = layer.getActiveCharacter(frame);
                        for (let idx = 0; idx < characters.length; ++idx) {
                            const character = characters[idx];
                            character.endFrame = startFrame;
                        }

                        while (true) {

                            const nextElement = document
                                .getElementById(`${layerId}-${++frame}`);

                            const frameState = nextElement
                                .dataset
                                .frameState;

                            this.removeFrameClass(nextElement);
                            if (frameState === "empty-space-frame-end") {

                                nextElement
                                    .classList
                                    .add("key-space-frame-end");

                                nextElement
                                    .dataset
                                    .frameState = "key-space-frame-end";

                                layer
                                    ._$frame
                                    .setClasses(frame, [
                                        "key-space-frame-end"
                                    ]);

                                break;

                            } else {

                                nextElement
                                    .classList
                                    .add("key-space-frame");

                                nextElement
                                    .dataset
                                    .frameState = "key-space-frame";

                                layer
                                    ._$frame
                                    .setClasses(frame, [
                                        "key-space-frame"
                                    ]);

                            }
                        }
                    }

                    break;

                default:
                    break;

            }

            this.adjTimeline();
        }
    }

    /**
     * @param  {MovieClip} scene
     * @param  {Layer}     layer
     * @param  {number}    first_frame
     * @param  {number}    end_frame
     * @return {void}
     * @public
     */
    splitCharacters (scene, layer, first_frame, end_frame)
    {
        const characters = layer.getActiveCharacter(first_frame);
        for (let idx = 0; idx < characters.length; ++idx) {

            const character = characters[idx];
            if (end_frame + 1 === character.endFrame) {

                // update
                for (const frame of character._$places.keys()) {

                    if (first_frame > frame) {
                        continue;
                    }

                    character.deletePlace(frame);
                }

                character.endFrame = first_frame;

                continue;
            }

            const clone = character.clone();
            clone.startFrame = end_frame + 1;

            for (const frame of clone._$places.keys()) {

                if (frame > end_frame) {
                    continue;
                }

                clone.deletePlace(frame);
            }

            if (!clone._$places.size) {
                clone.setPlace(
                    clone.startFrame,
                    character.clonePlace(first_frame, clone.startFrame)
                );
            }
            layer.addCharacter(clone);

            // update
            for (const frame of character._$places.keys()) {

                if (first_frame > frame) {
                    continue;
                }

                character.deletePlace(frame);
            }
            character.endFrame = first_frame;
        }

        if (characters.length) {
            scene.changeFrame(first_frame);
        }
    }

    /**
     * @param  {boolean} [redraw=true]
     * @return {void}
     * @public
     */
    deleteFrame (redraw = true)
    {
        const length = this._$targetFrames.length;
        if (length) {

            Util
                .$currentWorkSpace()
                .temporarilySaved();

            this._$targetFrames.sort(this.frameSort);

            // first data
            const firstElement = this._$targetFrames[0];
            const layerId      = firstElement.dataset.layerId | 0;
            const startFrame   = firstElement.dataset.frame | 0;
            let moveFrame      = startFrame;
            let keyCheck       = false;
            const isTween      = firstElement.classList.contains("tween-frame");
            const isMorph      = firstElement.classList.contains("morph-frame");

            const scene = Util.$currentWorkSpace().scene;
            const layer = scene.getLayer(layerId);

            let deleteEnd = false;
            let done = false;
            for (let idx = 0; idx < length; ++idx) {

                const element = this._$targetFrames[idx];
                const currentFrame = element.dataset.frame | 0;
                const frameState = element.dataset.frameState;
                switch (frameState) {

                    case "empty-key-frame":

                        if (!deleteEnd) {
                            keyCheck  = true;
                            deleteEnd = true;
                            if (!element.classList.contains("empty-key-frame-join")) {
                                done = true;
                            }
                            this.removeFrameClass(element);

                            layer
                                ._$frame
                                .deleteClasses(currentFrame);

                        } else {
                            done = true;
                        }

                        break;

                    case "key-frame":
                        if (!deleteEnd) {

                            keyCheck  = true;
                            deleteEnd = true;

                            this.removeFrameClass(element);

                            layer
                                ._$frame
                                .deleteClasses(currentFrame);

                        } else {
                            done = true;
                        }

                        break;

                    case "key-space-frame-end":
                    case "empty-space-frame-end":

                        done = true;
                        let frame = currentFrame;

                        while (true) {

                            const prevElement = document
                                .getElementById(`${layerId}-${--frame}`);

                            if (!prevElement) {
                                break;
                            }

                            let done = false;

                            switch (prevElement.dataset.frameState) {

                                case "empty-key-frame":
                                    done = true;
                                    prevElement
                                        .classList
                                        .remove("empty-key-frame-join");

                                    layer
                                        ._$frame
                                        .setClasses(frame, [
                                            "empty-key-frame"
                                        ]);

                                    break;

                                case "key-frame":
                                    {
                                        done = true;
                                        prevElement
                                            .classList
                                            .remove("key-frame-join");

                                        const classes = ["key-frame"];
                                        if (isTween) {
                                            prevElement
                                                .classList
                                                .add("tween-frame-end");

                                            classes.push(
                                                "tween-frame",
                                                "tween-frame-end"
                                            );
                                        }

                                        if (isMorph) {
                                            prevElement
                                                .classList
                                                .add("morph-frame-end");

                                            classes.push(
                                                "morph-frame",
                                                "morph-frame-end"
                                            );
                                        }


                                        layer
                                            ._$frame
                                            .setClasses(frame, classes);

                                    }
                                    break;

                                case "empty-space-frame":
                                    done = true;
                                    prevElement
                                        .classList
                                        .remove("empty-space-frame");

                                    prevElement
                                        .classList
                                        .add("empty-space-frame-end");

                                    prevElement
                                        .dataset
                                        .frameState = "empty-space-frame-end";

                                    layer
                                        ._$frame
                                        .setClasses(frame, [
                                            "empty-space-frame-end"
                                        ]);

                                    break;

                                case "key-space-frame":
                                    {
                                        done = true;
                                        prevElement
                                            .classList
                                            .remove("key-space-frame");

                                        prevElement
                                            .classList
                                            .add("key-space-frame-end");

                                        prevElement
                                            .dataset
                                            .frameState = "key-space-frame-end";

                                        const classes = ["key-space-frame-end"];
                                        if (isTween) {
                                            prevElement
                                                .classList
                                                .add("tween-frame-end");

                                            classes.push(
                                                "tween-frame",
                                                "tween-frame-end"
                                            );
                                        }

                                        if (isMorph) {
                                            prevElement
                                                .classList
                                                .add("morph-frame-end");

                                            classes.push(
                                                "morph-frame",
                                                "morph-frame-end"
                                            );
                                        }

                                        layer
                                            ._$frame
                                            .setClasses(frame, classes);

                                    }
                                    break;

                                case "key-space-frame-end":
                                case "empty-space-frame-end":
                                    done = true;
                                    break;

                                default:
                                    break;

                            }

                            if (done) {
                                break;
                            }

                        }

                        this.removeFrameClass(element);

                        layer
                            ._$frame
                            .deleteClasses(currentFrame);

                        break;

                    default:

                        this.removeFrameClass(element);

                        layer
                            ._$frame
                            .deleteClasses(currentFrame);

                        break;

                }

                ++moveFrame;
                if (done) {
                    break;
                }

            }

            const frames = [];
            this.getMoveFrames(layerId, moveFrame, frames);
            if (frames.length) {

                const prevElement = document
                    .getElementById(`${layerId}-${startFrame - 1}`);

                if (prevElement) {

                    switch (prevElement.dataset.frameState) {

                        case "key-space-frame-end":
                        case "empty-space-frame-end":
                            keyCheck = true;
                            break;

                        default:
                            break;

                    }

                } else {

                    keyCheck = true;

                }

                if (keyCheck) {

                    const frameObject = frames[0];
                    switch (frameObject.frameState) {

                        case "empty-space-frame":
                        case "empty-space-frame-end":
                            frameObject.classValues[0] = "empty-key-frame";
                            frameObject.frameState = "empty-key-frame";
                            if (frames.length > 1
                                && frames[1].frameState !== "empty-key-frame"
                                && frames[1].frameState !== "key-frame"
                            ) {
                                frameObject
                                    .classValues
                                    .push("empty-key-frame-join");
                            }
                            break;

                        case "key-space-frame":
                        case "key-space-frame-end":
                            frameObject.classValues[0] = "key-frame";
                            frameObject.frameState = "key-frame";
                            if (frames.length > 1
                                && frames[1].frameState !== "key-frame"
                                && frames[1].frameState !== "empty-key-frame"
                            ) {
                                frameObject
                                    .classValues
                                    .push("key-frame-join");
                            }
                            break;

                    }
                }

                this.moveFrames(layerId, startFrame, frames);
            }

            for (let idx = 0; idx < length; ++idx) {

                const frame = this._$targetFrames[idx].dataset.frame | 0;

                const element = document
                    .getElementById(`${layerId}-${frame}`);

                if (!element.classList.contains("frame-active")) {
                    element
                        .classList
                        .add("frame-active");
                }
            }

            // update end frame
            const deleteCount = moveFrame - startFrame;
            const characters = layer._$characters;
            for (let idx = 0; idx < characters.length; ++idx) {

                const character = characters[idx];

                if (startFrame >= character.endFrame) {
                    continue;
                }

                // 完全に削除
                if (character.startFrame === startFrame
                    && character.endFrame === startFrame + deleteCount
                ) {

                    layer.deleteCharacter(character.id);

                    continue;
                }

                character.endFrame -= deleteCount;
                if (character.startFrame > startFrame) {
                    character.startFrame -= deleteCount;
                }

                // sort
                const places = Array.from(character._$places);
                places.sort(function (a, b)
                {
                    switch (true) {

                        case a[0] > b[0]:
                            return 1;

                        case a[0] < b[0]:
                            return -1;

                        default:
                            return 0;

                    }
                });

                const placeClone = [];
                for (let idx = 0; idx < places.length; ++idx) {

                    const place = places[idx][1];
                    if (startFrame > place.frame) {
                        continue;
                    }

                    character.deletePlace(place.frame);
                    if (startFrame !== place.frame) {
                        place.frame -= deleteCount;
                    }

                    if (character.endFrame > place.frame) {
                        placeClone.push(place);
                    }
                }

                for (let idx = 0; idx < placeClone.length; ++idx) {
                    const place = placeClone[idx];
                    character.setPlace(place.frame, place);
                }

            }

            // marge character
            if (startFrame > 1) {

                const prevCharacters = layer.getActiveCharacter(startFrame - 1);
                const characters = layer.getActiveCharacter(startFrame);
                for (let idx = 0; idx < prevCharacters.length; ++idx) {

                    const prevCharacter = prevCharacters[idx];
                    if (prevCharacter.endFrame !== startFrame) {
                        continue;
                    }

                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];
                        if (character.startFrame !== startFrame) {
                            continue;
                        }

                        if (prevCharacter.libraryId !== character.libraryId) {
                            continue;
                        }

                        prevCharacter.endFrame = character.endFrame;
                        for (let [frame, place] of character._$places) {
                            prevCharacter.setPlace(frame, place);
                        }

                        layer.deleteCharacter(character.id);
                        characters.splice(characters.indexOf(character), -1);
                        break;
                    }

                }
            }

            Util.$screen.clearTweenMarker();
            Util.$screen.hideTransformTarget();
            Util.$screen.hideGridTarget();

            if (redraw) {
                scene.changeFrame(startFrame);
            }
        }
    }

    /**
     * @param  {number} x
     * @return {number}
     * @public
     */
    moveTimeLine (x = 0)
    {
        if (0 > x) {
            x = 0;
        }

        const element = document
            .getElementById("timeline-controller-base");

        const limitX = element.scrollWidth - element.offsetWidth;
        if (x > limitX) {
            x = limitX;
        }

        const children = document
            .getElementById("timeline-content")
            .children;

        const length = children.length;
        for (let idx = 0; idx < length; ++idx) {

            document
                .getElementById(
                    `frame-scroll-id-${children[idx].dataset.layerId}`
                ).scrollLeft = x;

        }

        element.scrollLeft = x;

        this._$scrollX = x;
    }

    /**
     * @return {void}
     * @public
     */
    buildTimeline ()
    {
        // 描画エリアのサイズをセット
        const marker = document.getElementById("timeline-frame-marker");

        // remove all
        while (marker.children.length) {
            marker.children[0].remove();
        }

        const fps = document.getElementById("stage-fps").value | 0;

        let sec   = 1;
        let frame = 1;
        let limit = Math.ceil(window.parent.screen.width * 1.5
            + (Util.$currentWorkSpace().scene.totalFrame / 5 | 0) * Util.$frameWidth
        );
        while (limit > 0) {

            const htmlTag = `
<div class="frame-group">
    <div class="frame-border-sec-group">
        <div class="frame-border" data-frame="${frame    }">${frame       % fps === 0 && fps > 4 ? sec++ + "s" : ""}</div>
        <div class="frame-border" data-frame="${frame + 1}">${(frame + 1) % fps === 0 && fps > 4 ? sec++ + "s" : ""}</div>
        <div class="frame-border" data-frame="${frame + 2}">${(frame + 2) % fps === 0 && fps > 4 ? sec++ + "s" : ""}</div>
        <div class="frame-border" data-frame="${frame + 3}">${(frame + 3) % fps === 0 && fps > 4 ? sec++ + "s" : ""}</div>
        <div class="frame-border" data-frame="${frame + 4}">${(frame + 4) % fps === 0 && fps > 4 ? sec++ + "s" : ""}</div>
    </div>
    <div class="frame-border-box-group">
        <div id="frame-label-marker-${frame}"     class="frame-border-box" data-frame="${frame    }"></div>
        <div id="frame-label-marker-${frame + 1}" class="frame-border-box" data-frame="${frame + 1}"></div>
        <div id="frame-label-marker-${frame + 2}" class="frame-border-box" data-frame="${frame + 2}"></div>
        <div id="frame-label-marker-${frame + 3}" class="frame-border-box" data-frame="${frame + 3}"></div>
        <div id="frame-label-marker-${frame + 4}" class="frame-border-box" data-frame="${frame + 4}"></div>
    </div>
    <div class="frame-border-box-group">
        <div id="frame-label-action-${frame}"     class="frame-border-box" data-frame="${frame    }"></div>
        <div id="frame-label-action-${frame + 1}" class="frame-border-box" data-frame="${frame + 1}"></div>
        <div id="frame-label-action-${frame + 2}" class="frame-border-box" data-frame="${frame + 2}"></div>
        <div id="frame-label-action-${frame + 3}" class="frame-border-box" data-frame="${frame + 3}"></div>
        <div id="frame-label-action-${frame + 4}" class="frame-border-box" data-frame="${frame + 4}"></div>
    </div>
        <div class="frame-border-box-group">
        <div id="frame-label-sound-${frame}"     class="frame-border-box" data-frame="${frame    }"></div>
        <div id="frame-label-sound-${frame + 1}" class="frame-border-box" data-frame="${frame + 1}"></div>
        <div id="frame-label-sound-${frame + 2}" class="frame-border-box" data-frame="${frame + 2}"></div>
        <div id="frame-label-sound-${frame + 3}" class="frame-border-box" data-frame="${frame + 3}"></div>
        <div id="frame-label-sound-${frame + 4}" class="frame-border-box" data-frame="${frame + 4}"></div>
    </div>
    <div class="frame-number-group">
        <div class="frame-number-space" data-frame="${frame    }"></div>
        <div class="frame-number-space" data-frame="${frame + 1}"></div>
        <div class="frame-number-space" data-frame="${frame + 2}"></div>
        <div class="frame-number-space" data-frame="${frame + 3}"></div>
        <div class="frame-number" data-frame="${frame + 4}">${frame + 4}</div>
    </div>
</div>
`;
            frame += 5;

            // add child
            marker.insertAdjacentHTML("beforeend", htmlTag);

            // target class
            const classes = [
                "frame-border",
                "frame-border-box",
                "frame-number-space",
                "frame-number"
            ];

            const markerOver = this.markerOver.bind(this);
            const markerMove = this.markerMove.bind(this);
            for (let idx = 0; idx < classes.length; ++idx) {

                const elements = marker.getElementsByClassName(classes[idx]);
                for (let idx = 0; idx < elements.length; ++idx) {

                    const element = elements[idx];

                    element.addEventListener("mouseover", markerOver);
                    element.addEventListener("mousedown", markerMove);

                }

            }

            limit -= Util.$frameWidth;

        }

    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    markerMove (event)
    {
        const frame = event.currentTarget.dataset.frame | 0;

        const currentFrame = document
            .getElementById("current-frame");

        if ((currentFrame.textContent | 0) === frame) {
            return ;
        }
        currentFrame.textContent = `${frame}`;

        document
            .getElementById("timeline-marker")
            .style.left = `${(frame - 1) * 13}px`;

        // class reset
        this.resetFrames();
        this.changeTarget();
        Util.$screen.clearActiveCharacter();
        Util.$controller.setDefaultController();
        Util.$controller.createSoundListArea();

        const scene = Util.$currentWorkSpace().scene;

        scene.changeFrame(frame);

        const label = scene.gerLabel(frame);
        document
            .getElementById("label-name")
            .value = label ? label : "";

        if (!this._$markerMode) {
            this._$markerMode = true;
            Util.$setCursor("ew-resize");
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    markerOver (event)
    {
        if (this._$markerMode) {
            this.markerMove(event);
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    showLayerMenu (event)
    {
        Util.$endMenu("timeline-layer-menu");
        this._$layerMenuMode = true;

        const layerId = event.currentTarget.dataset.layerId | 0;
        this._$targetLayer = document
            .getElementById(`layer-id-${layerId}`);

        const element = document.getElementById("timeline-layer-menu");

        element.style.left = `${event.pageX + 5}px`;
        element.style.top  = `${event.pageY - element.offsetHeight}px`;
        element.setAttribute("class", "fadeIn");
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @public
     */
    layerNameEditEnd (event)
    {
        if (event.type === "focusout" || event.code === "Enter") {

            const layerId = event.target.dataset.layerId | 0;

            const text = document
                .getElementById(`layer-name-${layerId}`);

            const workSpace = Util.$currentWorkSpace();
            const layer = workSpace.scene.getLayer(layerId);

            layer.name         = event.target.value;
            text.textContent   = event.target.value;
            text.style.display = "";

            event.target.style.display = "none";

            Util.$keyLock = false;
        }
    }

    /**
     * @return {void}
     * @public
     */
    createChild ()
    {
        const scene   = Util.$currentWorkSpace().scene;
        const layerId = scene._$layerId;

        const element = document.getElementById("timeline-content");
        const marker  = document.getElementById("timeline-frame-marker");

        const lastFrame = marker
            .lastElementChild
            .lastElementChild
            .innerText | 0;

        let frame = 1;
        let htmlTag = `
<div class="timeline-content-child" id="layer-id-${layerId}" data-layer-id="${layerId}">

    <div class="timeline-layer-controller">
        <i class="timeline-layer-move-icon" id="move-id-${layerId}" data-layer-id="${layerId}" data-detail="{{上下に移動}}"></i>
        <i class="timeline-layer-icon" id="layer-icon-${layerId}" data-layer-id="${layerId}" data-detail="{{レイヤー変更(ダブルクリック)}}"></i>
        <i class="timeline-mask-icon" id="layer-mask-icon-${layerId}" data-layer-id="${layerId}" data-detail="{{レイヤー変更(ダブルクリック)}}"></i>
        <i class="timeline-mask-in-icon" id="layer-mask-in-icon-${layerId}"></i>
        <i class="timeline-sound-icon" id="layer-sound-icon-${layerId}" data-layer-id="${layerId}" data-detail="{{レイヤー変更(ダブルクリック)}}"></i>
        <div class="view-text" id="layer-name-${layerId}" data-layer-id="${layerId}">layer_${layerId}</div>
        <input type="text" class="view-text-input" id="layer-name-input-${layerId}" data-layer-id="${layerId}" value="layer_${layerId}" style="display: none;">
        <i class="timeline-layer-light-one icon-disable" id="layer-light-icon-${layerId}" data-click-type="light" data-layer-id="${layerId}" data-detail="{{レイヤーをハイライト}}"></i>
        <i class="timeline-layer-disable-one icon-disable" id="layer-disable-icon-${layerId}" data-click-type="disable" data-layer-id="${layerId}" data-detail="{{レイヤーを非表示}}"></i>
        <i class="timeline-layer-lock-one icon-disable" id="layer-lock-icon-${layerId}" data-click-type="lock" data-layer-id="${layerId}" data-detail="{{レイヤーをロック}}"></i>
    </div>

    <div class="timeline-frame-controller" id="frame-scroll-id-${layerId}">
        <div class="timeline-frame">
`;

        while (lastFrame > frame) {

            htmlTag += `
<div class="timeline-frame-group">
    <div class="frame" data-click-type="frame" data-frame-state="empty" data-layer-id="${layerId}" id="${layerId}-${frame}" data-frame="${frame++}"></div>
    <div class="frame" data-click-type="frame" data-frame-state="empty" data-layer-id="${layerId}" id="${layerId}-${frame}" data-frame="${frame++}"></div>
    <div class="frame" data-click-type="frame" data-frame-state="empty" data-layer-id="${layerId}" id="${layerId}-${frame}" data-frame="${frame++}"></div>
    <div class="frame" data-click-type="frame" data-frame-state="empty" data-layer-id="${layerId}" id="${layerId}-${frame}" data-frame="${frame++}"></div>
    <div class="frame frame-pointer" data-click-type="frame-pointer" data-frame-state="empty" data-layer-id="${layerId}" id="${layerId}-${frame}" data-frame="${frame++}"></div>
</div>
`;
        }

        htmlTag += `
        </div>
    </div>
</div>
`;

        element.insertAdjacentHTML("beforeend", htmlTag);

        document
            .getElementById(`move-id-${layerId}`)
            .addEventListener("mousedown", function (event)
            {

                this._$moveId = event.target.dataset.layerId | 0;

                this._$moveLayer = document
                    .getElementById(`layer-id-${this._$moveId}`);

            }.bind(this));

        document
            .getElementById(`layer-name-${layerId}`)
            .addEventListener("dblclick", function (event)
            {
                Util.$keyLock = true;

                const layerId = event.target.dataset.layerId | 0;

                const input = document
                    .getElementById(`layer-name-input-${layerId}`);

                input.value = event.target.textContent;
                input.style.display = "";
                input.focus();

                event.target.style.display = "none";

            }.bind(this));

        const input = document
            .getElementById(`layer-name-input-${layerId}`);
        input.addEventListener("focusout", this.layerNameEditEnd);
        input.addEventListener("keypress", this.layerNameEditEnd);

        document
            .getElementById(`layer-icon-${layerId}`)
            .addEventListener("dblclick", this._$showLayerMenu);

        document
            .getElementById(`layer-mask-icon-${layerId}`)
            .addEventListener("dblclick", this._$showLayerMenu);

        document
            .getElementById(`layer-sound-icon-${layerId}`)
            .addEventListener("dblclick", this._$showLayerMenu);

        // add modal event
        const layer = document.getElementById(`layer-id-${layerId}`);
        Util.$addModalEvent(layer);

        layer.addEventListener("wheel", function (event)
        {
            const deltaX = event.deltaX | 0;
            if (!deltaX) {
                return false;
            }

            event.preventDefault();

            this._$scrollX += deltaX;
            this.moveTimeLine(this._$scrollX);

        }.bind(this), { "passive" : false });

        layer.addEventListener("mouseover", function (event)
        {
            const layerId = event.currentTarget.dataset.layerId | 0;
            if (this._$moveId > -1 && this._$moveId !== layerId) {

                this._$moveTarget = event.currentTarget;

                if (!this
                    ._$moveTarget
                    .classList
                    .contains("move-target")
                ) {

                    this
                        ._$moveTarget
                        .classList
                        .add("move-target");

                }

            }

            const element = event.target;
            switch (element.dataset.clickType) {

                case "frame":
                case "frame-pointer":
                    if (document
                        .getElementById("timeline-preview")
                        .classList
                        .contains("timeline-preview-active")
                    ) {
                        window.requestAnimationFrame(() =>
                        {
                            const workSpace = Util.$currentWorkSpace();
                            const frame = element.dataset.frame | 0;
                            const layer = workSpace.scene.getLayer(layerId);

                            const currentFrame = document
                                .getElementById("current-frame")
                                .textContent | 0;

                            document
                                .getElementById("current-frame")
                                .textContent = `${frame}`;

                            const characters = layer.getActiveCharacter(frame);
                            if (characters.length) {

                                clearTimeout(this._$previewTimerId);

                                layer.sort(characters, frame);

                                const preview = document
                                    .getElementById("timeline-preview-modal");

                                const { Sprite, BitmapData } = window.next2d.display;
                                const { Matrix, ColorTransform } = window.next2d.geom;

                                const sprite = new Sprite();

                                let xMin = Number.MAX_VALUE;
                                let xMax = -Number.MAX_VALUE;
                                let yMin = Number.MAX_VALUE;
                                let yMax = -Number.MAX_VALUE;

                                // reset
                                for (let idx = 0; idx < characters.length; ++idx) {

                                    const character = characters[idx];

                                    const place  = character.getPlace(frame);
                                    const bounds = Util.$boundsMatrix(
                                        character.getBounds(),
                                        place.matrix
                                    );

                                    xMin = Math.min(xMin, bounds.xMin);
                                    xMax = Math.max(xMax, bounds.xMax);
                                    yMin = Math.min(yMin, bounds.yMin);
                                    yMax = Math.max(yMax, bounds.yMax);

                                    const instance = workSpace
                                        .getLibrary(character.libraryId)
                                        .createInstance(place);

                                    instance.transform.matrix = new Matrix(
                                        place.matrix[0], place.matrix[1],
                                        place.matrix[2], place.matrix[3],
                                        place.matrix[4], place.matrix[5]
                                    );
                                    instance.transform.colorTransform = new ColorTransform(
                                        place.colorTransform[0], place.colorTransform[1],
                                        place.colorTransform[2], place.colorTransform[3],
                                        place.colorTransform[4], place.colorTransform[5],
                                        place.colorTransform[6], place.colorTransform[7]
                                    );

                                    sprite.addChild(instance);
                                }

                                const width  = Math.ceil(Math.abs(xMax - xMin));
                                const height = Math.ceil(Math.abs(yMax - yMin));
                                const scale  = Math.min(120 / width, 120 / height);
                                const ratio  = window.devicePixelRatio;

                                const bitmapData = new BitmapData(
                                    width  * scale * ratio,
                                    height * scale * ratio,
                                    true, 0
                                );

                                const matrix = new Matrix(
                                    ratio, 0, 0, ratio, -xMin * ratio, -yMin * ratio
                                );

                                matrix.scale(scale, scale);
                                bitmapData.draw(sprite, matrix);

                                while (preview.children.length) {
                                    preview.children[0].remove();
                                }

                                const image  = bitmapData.toImage();
                                image.width  = image.width  / ratio;
                                image.height = image.height / ratio;
                                preview.appendChild(image);

                                preview.style.display = "";
                                preview.style.backgroundColor = document.getElementById("stage-bgColor").value;
                                preview.style.left    = `${event.pageX + 10}px`;
                                preview.style.top     = `${event.pageY - preview.offsetHeight - 10}px`;

                                if (!preview.classList.contains("fadeIn")) {
                                    preview.setAttribute("class", "fadeIn");
                                }
                            }

                            document
                                .getElementById("current-frame")
                                .textContent = `${currentFrame}`;

                        });
                    }
                    break;

                default:
                    break;

            }

        }.bind(this));

        layer.addEventListener("mouseout", function (event)
        {
            const layerId = event.currentTarget.dataset.layerId | 0;
            if (this._$moveId > -1 && this._$moveId !== layerId) {

                event
                    .currentTarget
                    .classList
                    .remove("move-target");

                this._$moveTarget = null;

            }

            const preview = document
                .getElementById("timeline-preview-modal");

            if (!preview.classList.contains("fadeOut")) {
                this._$previewTimerId = setTimeout(function ()
                {
                    if (!this.classList.contains("fadeOut")) {
                        this.setAttribute("class", "fadeOut");
                    }
                }.bind(preview), 1000);
            }

        }.bind(this));

        layer.addEventListener("mousedown", function (event)
        {
            if (event.button === 2) {
                return ;
            }

            const preview = document
                .getElementById("timeline-preview-modal");

            if (!preview.classList.contains("fadeOut")) {
                preview.setAttribute("class", "fadeOut");
            }

            if (event.currentTarget !== this._$targetLayer) {

                if (this._$targetLayer) {
                    this
                        ._$targetLayer
                        .classList
                        .remove("active");
                }
                Util.$screen.clearActiveCharacter();

                this._$targetLayer = event.currentTarget;
                this
                    ._$targetLayer
                    .classList
                    .add("active");

            }

            const type = event.target.dataset.clickType;
            switch (type) {

                case "frame":
                case "frame-pointer":
                    {
                        const labelInput = document
                            .getElementById("label-name");

                        const currentFrame = document
                            .getElementById("current-frame");

                        // ラベル情報更新
                        if (this._$labelFrame) {
                            this.setLabelMarker({
                                "code": "Enter",
                                "currentTarget": {
                                    "value": labelInput.value
                                }
                            });
                        }

                        // reset
                        labelInput.value = "";

                        // toolにframeを表示
                        const target = event.target;
                        const frame  = target.dataset.frame | 0;

                        // labelがあればセット
                        const scene = Util.$currentWorkSpace().scene;
                        const label = scene.gerLabel(frame);
                        if (label) {
                            labelInput.value = label;
                        }

                        if (target.classList.contains("key-frame")
                            || target.classList.contains("key-space-frame")
                            || target.classList.contains("key-space-frame-end")
                        ) {
                            Util.$controller.showObjectArea();
                        } else {
                            Util.$controller.hideObjectArea();
                        }

                        if (!target.classList.contains("tween-frame")) {
                            Util.$screen.clearTweenMarker();
                        }

                        if (target.classList.contains("frame-active")) {

                            this._$targetFrames.sort(this.frameSort);

                            const firstElement = this._$targetFrames[0];

                            const element = document
                                .getElementById("target-group");

                            let offsetLeft = firstElement.offsetLeft - this._$scrollX;

                            const parent = document
                                .getElementById("timeline-content");

                            element.style.display = "";
                            element.style.width   = `${this._$targetFrames.length * 13 - 5}px`;
                            element.style.left    = `${offsetLeft}px`;
                            element.style.top     = `${firstElement.offsetTop - parent.scrollTop}px`;

                            while (true) {

                                if (offsetLeft + 13 > event.clientX) {
                                    break;
                                }

                                offsetLeft += 13;
                            }

                            element.dataset.positionL = `${offsetLeft}`;
                            element.dataset.positionR = `${offsetLeft + 13}`;
                            element.dataset.layerId   = firstElement.dataset.layerId;
                            element.dataset.frame     = firstElement.dataset.frame;

                        } else {

                            // screen clear
                            Util.$screen.clear();

                            currentFrame.textContent = `${frame}`;

                            document
                                .getElementById("timeline-marker")
                                .style
                                .left = `${(frame - 1) * 13}px`;

                            // clear
                            this.resetFrames();

                            this._$multiMode   = true;
                            this._$targetFrames.push(event.target);

                            this._$targetFrame = event.target;
                            this
                                ._$targetFrame
                                .classList
                                .add("frame-active");

                            // set character
                            if (scene.currentFrame !== frame) {
                                scene.changeFrame(frame);
                            }

                        }

                        // clear
                        scene.clearActiveCharacter();

                        const characters = scene
                            .getLayer(event.target.dataset.layerId | 0)
                            .getActiveCharacter(frame);

                        for (let idx = 0; idx < characters.length; ++idx) {

                            const element = document
                                .getElementById(`character-${characters[idx].id}`);

                            if (!element) {
                                continue;
                            }

                            Util.$screen.addTarget(element, 0, 0, true);
                        }

                        // エディター更新
                        if (Util.$activeScript) {
                            if (scene.hasAction(this._$actionFrame)) {
                                this.saveActionScript();
                                this.showScriptArea();
                            }
                        }

                        // コントローラー
                        Util.$controller.setDefaultController();
                        Util.$controller.createSoundListArea();
                        Util.$canCopyLayer     = false;
                        Util.$canCopyCharacter = true;

                    }
                    break;

                default:
                    this.resetFrames();
                    this.changeTarget();
                    Util.$canCopyLayer     = true;
                    Util.$canCopyCharacter = false;
                    break;

            }

        }.bind(this));

        layer.addEventListener("mousemove", function (event)
        {

            if (this._$multiMode) {

                if (this._$targetLayer
                    && event.currentTarget.dataset.layerId
                    !== this._$targetLayer.dataset.layerId
                ) {
                    return ;
                }

                let targetNo = null;

                const type = event.target.dataset.clickType;
                if (type === "frame" || type === "frame-pointer") {
                    const classList = event.target.classList;
                    if (!classList.contains("frame-active")) {

                        this._$targetFrames.push(event.target);
                        classList.add("frame-active");

                    }

                    targetNo = event
                        .target
                        .id
                        .split("-")[1] | 0;
                }

                if (targetNo) {

                    const startNo = this
                        ._$targetFrame
                        .id
                        .split("-")[1] | 0;

                    const min = Math.min(startNo, targetNo);
                    const max = Math.max(startNo, targetNo) + 1;

                    const diff = max - min;
                    if (this._$targetFrames.length !== diff) {

                        // cache
                        const target = this._$targetFrame;

                        // reset
                        this.resetFrames();

                        const layerId = target.dataset.layerId;
                        for (let idx = min; idx < max; ++idx) {

                            const element = document.getElementById(`${layerId}-${idx}`);

                            element
                                .classList
                                .add("frame-active");

                            this._$targetFrames.push(element);
                        }

                        this._$targetFrame = target;
                    }
                }

            } else {

                const type = event.target.dataset.clickType;
                switch (type) {

                    case "frame":
                    case "frame-pointer":

                        const element = document
                            .getElementById("target-group");

                        if (element.style.display !== "none") {

                            const target = event.target;

                            let layerId = target.dataset.layerId | 0;

                            const layerElement = document
                                .getElementById(`frame-scroll-id-${layerId}`);

                            if (target.offsetLeft + target.offsetWidth >
                                layerElement.offsetLeft + layerElement.offsetWidth
                            ) {
                                return ;
                            }

                            if (layerElement.offsetLeft > target.offsetLeft - 13) {
                                return ;
                            }

                            const parent = document
                                .getElementById("timeline-content");

                            const offsetLeft = target.offsetLeft - this._$scrollX;

                            if ((element.dataset.layerId | 0) !== layerId) {

                                element.dataset.layerId = target.dataset.layerId;
                                element.dataset.frame   = target.dataset.frame;

                                // down y position
                                if (target.offsetTop + target.offsetHeight
                                    > parent.offsetTop + parent.offsetHeight
                                ) {

                                    parent.scrollTop +=
                                        target.offsetTop + target.offsetHeight
                                            - (parent.offsetTop + parent.offsetHeight)
                                                + 10;

                                }

                                // up y position
                                if (parent.offsetTop + parent.scrollTop > target.offsetTop) {
                                    parent.scrollTop = target.offsetTop - parent.offsetTop - 10;
                                }

                                element.style.top = `${target.offsetTop - parent.scrollTop}px`;

                                return ;
                            }

                            element.dataset.layerId = target.dataset.layerId;
                            element.dataset.frame   = target.dataset.frame;

                            element.style.left = `${offsetLeft}px`;
                            element.style.top  = `${target.offsetTop - parent.scrollTop}px`;

                            element.dataset.positionL = `${offsetLeft}`;
                            element.dataset.positionR = `${offsetLeft + 13}`;
                        }

                        break;

                    default:
                        break;

                }

            }

        }.bind(this));

        layer.addEventListener("mouseup", function (event)
        {
            if (!this._$multiMode && this._$moveId === -1) {

                const type      = event.target.dataset.clickType;
                const classList = event.target.classList;
                switch (type) {

                    case "light":
                    case "disable":
                    case "lock":

                        const layerId = event.target.dataset.layerId | 0;

                        const element = document
                            .getElementById(`layer-id-${layerId}`);

                        const scene = Util.$currentWorkSpace().scene;
                        const layer = scene.getLayer(layerId);

                        if (classList.contains("icon-disable")) {

                            classList.remove("icon-disable");
                            classList.add("icon-active");
                            element.classList.add(`${type}-active`);

                            layer[type] = true;

                        } else {

                            classList.remove("icon-active");
                            classList.add("icon-disable");
                            element.classList.remove(`${type}-active`);

                            layer[type] = false;

                        }

                        if (type !== "light") {
                            const frame = document
                                .getElementById("current-frame")
                                .textContent | 0;

                            scene.changeFrame(frame);
                            Util.$screen.hideTransformTarget();
                            Util.$screen.hideGridTarget();
                        }

                        break;

                }

            }

            this._$multiMode = false;

            document
                .getElementById("target-group")
                .style.display = "none";

        }.bind(this));

        const frameElement = document
            .getElementById(`frame-scroll-id-${layerId}`);

        frameElement.addEventListener("contextmenu", this._$showTimeLineContextMenu);
        frameElement.scrollLeft = this._$scrollX;

        // end
        scene._$layerId++;
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    showTimeLineContextMenu (event)
    {
        this._$multiMode = false;
        this._$menuMode  = true;

        const element = document.getElementById("timeline-menu");

        element.style.left = `${event.pageX + 5}px`;
        element.style.top  = `${event.pageY - element.clientHeight}px`;
        element.setAttribute("class", "fadeIn");

        Util.$endMenu("timeline-menu");
    }

    /**
     * @return {void}
     * @public
     */
    removeLayer ()
    {
        if (this._$targetLayer) {

            Util
                .$currentWorkSpace()
                .temporarilySaved();

            const scene = Util.$currentWorkSpace().scene;

            // setup
            const element = document.getElementById("timeline-content");
            const clone   = Array.from(element.children);
            const index   = clone.indexOf(this._$targetLayer);

            // マスクの対象となっているレイヤーを元に戻す
            const layerId = this._$targetLayer.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);
            if (layer._$mode === Util.LAYER_MODE_MASK) {

                const children = element.children;
                for (let idx = index + 1; idx < children.length; ++idx) {

                    const child = children[idx];

                    const layer = scene.getLayer(child.dataset.layerId | 0);
                    if (layer._$mode !== Util.LAYER_MODE_MASK_IN) {
                        break;
                    }

                    layer._$mode = Util.LAYER_MODE_NORMAL;
                    layer.showIcon();

                }

            }

            // execute remove
            this._$targetLayer.remove();

            // reset
            this._$targetLayer = null;

            if (element.children.length) {

                this._$targetLayer = element.children.length > index
                    ? element.children[index]
                    : element.children[index - 1];

                this
                    ._$targetLayer
                    .classList
                    .add("active");

            }

            Util.$screen.clearTweenMarker();

            scene.deleteLayer(layerId);
            scene.changeFrame(
                document.getElementById("current-frame").textContent | 0
            );
        }
    }

    /**
     * @return {void}
     * @public
     */
    resetFrames ()
    {
        const length = this._$targetFrames.length;
        if (length) {

            for (let idx = 0; idx < length; ++idx) {

                const element = this._$targetFrames[idx];

                element
                    .classList
                    .remove("frame-active");

            }

            // reset array
            this._$targetFrames.length = 0;
        }

        this._$targetFrame = null;
    }

    /**
     * @return {void}
     * @public
     */
    changeTarget ()
    {
        if (this._$targetLayer) {

            const frame = document
                .getElementById("current-frame").textContent | 0;

            const layerId = this._$targetLayer.dataset.layerId | 0;

            const element = document
                .getElementById(`${layerId}-${frame}`);

            element
                .classList
                .add("frame-active");

            // set
            this._$targetFrame = element;
            this._$targetFrames.push(element);
        }

    }

    /**
     * @return {void}
     * @public
     */
    addKeyFrame ()
    {
        if (this._$targetFrames.length) {

            this._$targetFrames.sort(this.frameSort);

            const element = this._$targetFrames[0];
            if (element.classList.contains("tween-frame")) {
                return ;
            }
            if (element.classList.contains("morph-frame")) {
                return ;
            }

            switch (element.dataset.frameState) {

                case "key-space-frame":
                case "key-space-frame-end":
                    this.dropKeyFrame(element);
                    break;

                default:
                    this.addEmptyFrame();
                    this.adjTimeline();
                    break;

            }
        }
    }

    /**
     * @param  {HTMLElement} element
     * @return {void}
     * @public
     */
    dropKeyFrame (element)
    {
        Util
            .$currentWorkSpace()
            .temporarilySaved();

        // setup
        const layerId    = element.dataset.layerId | 0;
        const startFrame = element.dataset.frame | 0;

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layerId);

        const frameState = element.dataset.frameState;
        switch (frameState) {

            case "empty":

                element
                    .classList
                    .add("key-frame");

                element
                    .dataset
                    .frameState = "key-frame";

                layer
                    ._$frame
                    .setClasses(startFrame, [
                        "key-frame"
                    ]);

                if (startFrame > 1) {

                    let frame = startFrame;
                    while (frame > 0) {

                        const prevElement = document
                            .getElementById(`${layerId}-${--frame}`);

                        switch (prevElement.dataset.frameState) {

                            case "empty":

                                if (frame === 1) {

                                    const classes = ["empty-key-frame"];

                                    prevElement
                                        .classList
                                        .add("empty-key-frame");

                                    if (startFrame > 2) {

                                        prevElement
                                            .classList
                                            .add("empty-key-frame-join");

                                        classes.push("empty-key-frame-join");
                                    }

                                    prevElement
                                        .dataset
                                        .frameState = "empty-key-frame";

                                    layer
                                        ._$frame
                                        .setClasses(frame, classes);

                                    frame = 0;

                                } else {

                                    prevElement
                                        .classList
                                        .add("empty-space-frame");

                                    prevElement
                                        .dataset
                                        .frameState = "empty-space-frame";

                                    layer
                                        ._$frame
                                        .setClasses(frame, [
                                            "empty-space-frame"
                                        ]);

                                }

                                break;

                            default:

                                ++frame;
                                if (startFrame !== frame) {

                                    const nextElement = document
                                        .getElementById(`${layerId}-${frame}`);

                                    this.removeFrameClass(nextElement);

                                    nextElement
                                        .classList
                                        .add("empty-key-frame");

                                    nextElement
                                        .dataset
                                        .frameState = "empty-key-frame";

                                    layer
                                        ._$frame
                                        .setClasses(frame, [
                                            "empty-key-frame"
                                        ]);

                                    const nextElement2 = document
                                        .getElementById(`${layerId}-${++frame}`);

                                    if (nextElement2
                                        .dataset
                                        .frameState
                                        .indexOf("empty-space-frame") > -1
                                    ) {

                                        nextElement
                                            .classList
                                            .add("empty-key-frame-join");

                                        layer
                                            ._$frame
                                            .setClasses(frame - 1, [
                                                "empty-key-frame",
                                                "empty-key-frame-join"
                                            ]);

                                    }
                                }

                                frame = 0;
                                break;

                        }

                    }

                    const prevElement = document
                        .getElementById(`${layerId}-${startFrame - 1}`);

                    if (prevElement.dataset.frameState === "empty-space-frame") {

                        this.removeFrameClass(prevElement);

                        prevElement
                            .classList
                            .add("empty-space-frame-end");

                        prevElement
                            .dataset
                            .frameState = "empty-space-frame-end";

                        layer
                            ._$frame
                            .setClasses(startFrame - 1, [
                                "empty-space-frame-end"
                            ]);

                    }
                }

                break;

            case "key-space-frame-end":
            case "key-space-frame":
                {
                    this.removeFrameClass(element);

                    element
                        .classList
                        .add("key-frame");

                    element
                        .dataset
                        .frameState = "key-frame";

                    if (frameState === "key-space-frame") {

                        element
                            .classList
                            .add("key-frame-join");

                        layer
                            ._$frame
                            .setClasses(startFrame, [
                                "key-frame",
                                "key-frame-join"
                            ]);

                    } else {

                        layer
                            ._$frame
                            .setClasses(startFrame, [
                                "key-frame"
                            ]);

                    }

                    let frame = startFrame;
                    const prevElement = document
                        .getElementById(`${layerId}-${--frame}`);

                    switch (prevElement.dataset.frameState) {

                        case "key-frame":

                            prevElement
                                .classList
                                .remove("key-frame-join");

                            layer
                                ._$frame
                                .setClasses(frame, [
                                    "key-frame"
                                ]);

                            break;

                        case "key-space-frame":

                            this.removeFrameClass(prevElement);

                            prevElement
                                .classList
                                .add("key-space-frame-end");

                            prevElement
                                .dataset
                                .frameState = "key-space-frame-end";

                            layer
                                ._$frame
                                .setClasses(frame, [
                                    "key-space-frame-end"
                                ]);

                            break;

                    }

                    // add place
                    const characters = layer.getActiveCharacter(startFrame);
                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];

                        character.setPlace(startFrame,
                            character.clonePlace(startFrame, startFrame)
                        );

                    }

                }
                break;

            case "empty-key-frame":
                {
                    this.removeFrameClass(element);

                    element
                        .classList
                        .add("key-frame");

                    element
                        .dataset
                        .frameState = "key-frame";

                    layer
                        ._$frame
                        .setClasses(startFrame, [
                            "key-frame"
                        ]);

                    let frame = startFrame;

                    const nextElement = document
                        .getElementById(`${layerId}-${frame + 1}`);

                    switch (nextElement.dataset.frameState) {

                        case "empty":
                        case "key-frame":
                        case "empty-key-frame":
                            break;

                        default:

                            element
                                .classList
                                .add("key-frame-join");

                            layer
                                ._$frame
                                .setClasses(frame, [
                                    "key-frame",
                                    "key-frame-join"
                                ]);

                            while (true) {

                                const nextElement = document
                                    .getElementById(`${layerId}-${++frame}`);

                                const state = nextElement.dataset.frameState === "empty-space-frame"
                                    ? "key-space-frame"
                                    : "key-space-frame-end";

                                this.removeFrameClass(nextElement);

                                nextElement
                                    .classList
                                    .add(state);

                                nextElement
                                    .dataset
                                    .frameState = state;

                                layer
                                    ._$frame
                                    .setClasses(frame, [
                                        state
                                    ]);

                                if (state === "key-space-frame-end") {
                                    break;
                                }
                            }

                            break;

                    }

                }
                break;

            case "empty-space-frame-end":
                {
                    this.removeFrameClass(element);

                    element
                        .classList
                        .add("key-frame");

                    element
                        .dataset
                        .frameState = "key-frame";

                    layer
                        ._$frame
                        .setClasses(startFrame, [
                            "key-frame"
                        ]);

                    let frame = startFrame;
                    const prevElement = document
                        .getElementById(`${layerId}-${--frame}`);

                    if (prevElement.dataset.frameState === "empty-space-frame") {

                        this.removeFrameClass(prevElement);

                        prevElement
                            .classList
                            .add("empty-space-frame-end");

                        prevElement
                            .dataset
                            .frameState = "empty-space-frame-end";

                        layer
                            ._$frame
                            .setClasses(frame, [
                                "empty-space-frame-end"
                            ]);

                    } else {

                        prevElement
                            .classList
                            .remove("empty-key-frame-join");

                        layer
                            ._$frame
                            .setClasses(frame, [
                                "empty-key-frame"
                            ]);

                    }

                }
                break;

            case "empty-space-frame":
                {
                    this.removeFrameClass(element);

                    element
                        .classList
                        .add("key-frame");

                    element
                        .dataset
                        .frameState = "key-frame";

                    layer
                        ._$frame
                        .setClasses(startFrame, [
                            "key-frame"
                        ]);

                    let frame = startFrame;
                    const prevElement = document
                        .getElementById(`${layerId}-${frame - 1}`);

                    switch (prevElement.dataset.frameState) {

                        case "key-frame":

                            prevElement
                                .classList
                                .remove("key-frame-join");

                            layer
                                ._$frame
                                .setClasses(frame - 1, [
                                    "key-frame"
                                ]);

                            break;

                        case "empty-key-frame":

                            prevElement
                                .classList
                                .remove("empty-key-frame-join");

                            layer
                                ._$frame
                                .setClasses(frame - 1, [
                                    "empty-key-frame"
                                ]);

                            break;

                        case "key-space-frame":

                            this.removeFrameClass(prevElement);

                            prevElement
                                .classList
                                .add("key-space-frame-end");

                            prevElement
                                .dataset
                                .frameState = "key-space-frame-end";

                            layer
                                ._$frame
                                .setClasses(frame - 1, [
                                    "key-space-frame-end"
                                ]);

                            break;

                        case "empty-space-frame":

                            this.removeFrameClass(prevElement);

                            prevElement
                                .classList
                                .add("empty-space-frame-end");

                            prevElement
                                .dataset
                                .frameState = "empty-space-frame-end";

                            layer
                                ._$frame
                                .setClasses(frame - 1, [
                                    "empty-space-frame-end"
                                ]);

                            break;

                    }

                    while (true) {

                        const nextElement = document
                            .getElementById(`${layerId}-${++frame}`);

                        const state = nextElement.dataset.frameState === "empty-space-frame"
                            ? "key-space-frame"
                            : "key-space-frame-end";

                        this.removeFrameClass(nextElement);

                        nextElement
                            .classList
                            .add(state);

                        nextElement
                            .dataset
                            .frameState = state;

                        layer
                            ._$frame
                            .setClasses(frame, [
                                state
                            ]);

                        if (state === "key-space-frame-end") {

                            element
                                .classList
                                .add("key-frame-join");

                            layer
                                ._$frame
                                .setClasses(startFrame, [
                                    "key-frame",
                                    "key-frame-join"
                                ]);

                            break;

                        }

                    }

                }
                break;

        }

        Util.$timeline.adjTimeline();
    }
}

Util.$timeline = new Timeline();

/**
 * @class
 */
class Tools
{
    /**
     * @constructor
     */
    constructor()
    {
        this._$handler = this.initialize.bind(this);
        window.addEventListener("DOMContentLoaded", this._$handler);

        // reset
        this._$activeTool  = null;
    }

    /**
     * @return {void}
     * @public
     */
    initialize ()
    {
        // end event
        window.removeEventListener("DOMContentLoaded", this._$handler);

        // modal event
        Util.$addModalEvent(document);

        const children = document
            .getElementById("tools")
            .children;

        for (let idx = 0; idx < children.length; ++idx) {

            const element = children[idx];

            if (element.dataset.mode !== "tool") {
                continue;
            }

            const span = element.getElementsByTagName("span")[0];
            if (!span) {
                continue;
            }

            // set active(init)
            if (!this._$activeTool) {

                span
                    .classList
                    .add("active");

                this._$activeTool = span;
            }

            span.addEventListener("mousedown", function (event)
            {
                // reset
                if (this._$activeTool) {

                    this._$activeTool
                        .classList
                        .remove("active");
                }

                // change active
                const element = event.target;

                element
                    .classList
                    .add("active");

                this._$activeTool = element;

            }.bind(this));

        }

        // 塗り
        const fillInput = document.getElementById("fill-color");
        fillInput.value = localStorage.getItem(`${Util.PREFIX}@fill-color`) || Util.TOOLS_FILL_DEFAULT_COLOR;
        fillInput.addEventListener("change", function (event)
        {
            localStorage
                .setItem(`${Util.PREFIX}@fill-color`, event.target.value);
        });

        // 線
        const strokeInput = document.getElementById("stroke-color");
        strokeInput.value = localStorage.getItem(`${Util.PREFIX}@stroke-color`) || Util.TOOLS_STROKE_DEFAULT_COLOR;
        strokeInput.addEventListener("change", function (event)
        {
            localStorage
                .setItem(`${Util.PREFIX}@stroke-color`, event.target.value);

            switch (Util.$tools._$activeTool.dataset.name) {

                case "draw-pen":
                    this.setPenColor();
                    break;

                case "color-bucket":
                    this.setBucketColor();
                    break;

            }

        }.bind(this));

        const strokeSize = document.getElementById("stroke-size");
        strokeSize.value = localStorage.getItem(`${Util.PREFIX}@stroke-size`) || Util.STROKE_MIN_SIZE;
        strokeSize.addEventListener("focusout", function (event)
        {
            localStorage
                .setItem(`${Util.PREFIX}@stroke-size`, event.target.value);

            switch (Util.$tools._$activeTool.dataset.name) {

                case "draw-pen":
                    this.setPenColor();
                    break;

                case "color-bucket":
                    this.setBucketColor();
                    break;

            }

        }.bind(this));

        // データの読込・保存
        this.initializeData();

        // 設定系の初期化
        this.initializeSetting();

        // ユーザー設定系の初期化
        this.initializeUserSetting();

        // end
        Util.$initializeEnd();
        this._$handler = null;
    }

    /**
     * @return {void}
     * @public
     */
    initializeSetting ()
    {
        document
            .getElementById("tools-discord")
            .addEventListener("click", function ()
            {
                const anchor  = document.createElement("a");
                anchor.href   = "https://discord.gg/6c9rv5Uns5";
                anchor.target = "_blank";
                anchor.rel    = "noopener noreferrer";
                anchor.click();
            });

        document
            .getElementById("tools-bug")
            .addEventListener("click", function ()
            {
                const anchor  = document.createElement("a");
                anchor.href   = "https://github.com/Next2D/tool.next2d.app/issues";
                anchor.target = "_blank";
                anchor.rel    = "noopener noreferrer";
                anchor.click();
            });

        document
            .getElementById("tools-usage")
            .addEventListener("click", function ()
            {
                const anchor  = document.createElement("a");
                anchor.href   = "https://next2d.app/en/usage/";
                anchor.target = "_blank";
                anchor.rel    = "noopener noreferrer";
                anchor.click();
            });

        document
            .getElementById("tools-arrow")
            .addEventListener("click", function ()
            {
                Util.$screen._$cursorCache = null;
                this.activeStageAreaNode();
                Util.$setCursor("auto");
            }.bind(this));

        document
            .getElementById("tools-rectangle")
            .addEventListener("click", function ()
            {
                Util.$screen._$cursorCache = null;
                this.deactiveStageAreaNode();
                Util.$setCursor("url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path d=\"M24 11h-2.051c-.469-4.725-4.224-8.48-8.949-8.95v-2.05h-2v2.05c-4.725.47-8.48 4.225-8.949 8.95h-2.051v2h2.051c.469 4.725 4.224 8.48 8.949 8.95v2.05h2v-2.05c4.725-.469 8.48-4.225 8.949-8.95h2.051v-2zm-11 8.931v-3.931h-2v3.931c-3.611-.454-6.478-3.32-6.931-6.931h3.931v-2h-3.931c.453-3.611 3.32-6.477 6.931-6.931v3.931h2v-3.931c3.611.454 6.478 3.319 6.931 6.931h-3.931v2h3.931c-.453 3.611-3.32 6.477-6.931 6.931zm1-7.931c0 1.104-.896 2-2 2s-2-.896-2-2 .896-2 2-2 2 .896 2 2z\"/></svg>'),auto");
            }.bind(this));

        document
            .getElementById("tools-circle")
            .addEventListener("click", function ()
            {
                Util.$screen._$cursorCache = null;
                this.deactiveStageAreaNode();
                Util.$setCursor("url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path d=\"M24 11h-2.051c-.469-4.725-4.224-8.48-8.949-8.95v-2.05h-2v2.05c-4.725.47-8.48 4.225-8.949 8.95h-2.051v2h2.051c.469 4.725 4.224 8.48 8.949 8.95v2.05h2v-2.05c4.725-.469 8.48-4.225 8.949-8.95h2.051v-2zm-11 8.931v-3.931h-2v3.931c-3.611-.454-6.478-3.32-6.931-6.931h3.931v-2h-3.931c.453-3.611 3.32-6.477 6.931-6.931v3.931h2v-3.931c3.611.454 6.478 3.319 6.931 6.931h-3.931v2h3.931c-.453 3.611-3.32 6.477-6.931 6.931zm1-7.931c0 1.104-.896 2-2 2s-2-.896-2-2 .896-2 2-2 2 .896 2 2z\"/></svg>'),auto");
            }.bind(this));

        document
            .getElementById("tools-round-rect")
            .addEventListener("click", function ()
            {
                Util.$screen._$cursorCache = null;
                this.deactiveStageAreaNode();
                Util.$setCursor("url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\"><path d=\"M24 11h-2.051c-.469-4.725-4.224-8.48-8.949-8.95v-2.05h-2v2.05c-4.725.47-8.48 4.225-8.949 8.95h-2.051v2h2.051c.469 4.725 4.224 8.48 8.949 8.95v2.05h2v-2.05c4.725-.469 8.48-4.225 8.949-8.95h2.051v-2zm-11 8.931v-3.931h-2v3.931c-3.611-.454-6.478-3.32-6.931-6.931h3.931v-2h-3.931c.453-3.611 3.32-6.477 6.931-6.931v3.931h2v-3.931c3.611.454 6.478 3.319 6.931 6.931h-3.931v2h3.931c-.453 3.611-3.32 6.477-6.931 6.931zm1-7.931c0 1.104-.896 2-2 2s-2-.896-2-2 .896-2 2-2 2 .896 2 2z\"/></svg>'),auto");
            }.bind(this));

        document
            .getElementById("tools-text")
            .addEventListener("click", function ()
            {
                Util.$screen._$cursorCache = null;
                this.deactiveStageAreaNode();
                Util.$setCursor("text");
            }.bind(this));

        document
            .getElementById("tools-transform")
            .addEventListener("click", function ()
            {
                Util.$screen._$cursorCache = null;
                this.activeStageAreaNode();
                Util.$setCursor("url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 48 48\"><path fill=\"white\" d=\"M27.8,39.7c-0.1,0-0.2,0-0.4-0.1c-0.2-0.1-0.4-0.3-0.6-0.5l-3.7-8.6l-4.5,4.2C18.5,34.9,18.3,35,18,35c-0.1,0-0.3,0-0.4-0.1C17.3,34.8,17,34.4,17,34l0-22c0-0.4,0.2-0.8,0.6-0.9C17.7,11,17.9,11,18,11c0.2,0,0.5,0.1,0.7,0.3l16,15c0.3,0.3,0.4,0.7,0.3,1.1c-0.1,0.4-0.5,0.6-0.9,0.7l-6.3,0.6l3.9,8.5c0.1,0.2,0.1,0.5,0,0.8c-0.1,0.2-0.3,0.5-0.5,0.6l-2.9,1.3C28.1,39.7,27.9,39.7,27.8,39.7z\"/><path fill=\"black\" d=\"M18,12l16,15l-7.7,0.7l4.5,9.8l-2.9,1.3l-4.3-9.9L18,34L18,12 M18,10c-0.3,0-0.5,0.1-0.8,0.2c-0.7,0.3-1.2,1-1.2,1.8l0,22c0,0.8,0.5,1.5,1.2,1.8C17.5,36,17.8,36,18,36c0.5,0,1-0.2,1.4-0.5l3.4-3.2l3.1,7.3c0.2,0.5,0.6,0.9,1.1,1.1c0.2,0.1,0.5,0.1,0.7,0.1c0.3,0,0.5-0.1,0.8-0.2l2.9-1.3c0.5-0.2,0.9-0.6,1.1-1.1c0.2-0.5,0.2-1.1,0-1.5l-3.3-7.2l4.9-0.4c0.8-0.1,1.5-0.6,1.7-1.3c0.3-0.7,0.1-1.6-0.5-2.1l-16-15C19,10.2,18.5,10,18,10L18,10z\"/></svg>'),auto");
            }.bind(this));

        document
            .getElementById("tools-pen")
            .addEventListener("click", function ()
            {
                Util.$screen._$cursorCache = null;
                this.activeStageAreaNode();
                this.setPenColor();
            }.bind(this));

        document
            .getElementById("tools-bucket")
            .addEventListener("click", function ()
            {
                Util.$screen._$cursorCache = null;
                this.activeStageAreaNode();
                this.setBucketColor();
            }.bind(this));

        document
            .getElementById("tools-setting")
            .addEventListener("click", function (event)
            {
                const element = document.getElementById("user-setting");

                element.style.display = "";
                element.style.left = `${event.pageX + 30}px`;
                element.style.top  = `${event.pageY - element.clientHeight}px`;

                element.setAttribute("class", "fadeIn");

                Util.$endMenu("user-setting");
            });

    }

    /**
     * @return {object}
     * @public
     */
    getUserPublishSetting ()
    {
        const object = localStorage
            .getItem(`${Util.PREFIX}@user-publish-setting`);

        if (object) {
            return JSON.parse(object);
        }

        return {
            "layer": false,
            "type": "zlib"
        };
    }

    /**
     * @return {void}
     * @public
     */
    initializeUserSetting ()
    {

        const object = this.getUserPublishSetting();

        const layerElement = document.getElementById("publish-layer-setting");
        layerElement.children[object.layer ? 1 : 0].selected = true;

        layerElement.addEventListener("change", function (event)
        {
            const object = this.getUserPublishSetting();
            object.layer = event.target.value === "1";

            localStorage
                .setItem(
                    `${Util.PREFIX}@user-publish-setting`,
                    JSON.stringify(object)
                );

        }.bind(this));

        const typeElement = document.getElementById("publish-type-setting");
        for (let idx = 0; idx < typeElement.children.length; ++idx) {

            const node = typeElement.children[idx];
            if (object.type !== node.value) {
                continue;
            }

            node.selected = true;
            break;
        }

        typeElement.addEventListener("change", function (event)
        {
            const object = this.getUserPublishSetting();
            object.type = event.target.value;

            localStorage
                .setItem(
                    `${Util.PREFIX}@user-publish-setting`,
                    JSON.stringify(object)
                );

        }.bind(this));

        const modalElement = document.getElementById("modal-setting");
        if ("modal" in object) {
            modalElement.children[object.modal ? 0 : 1].selected = true;
        }

        modalElement.addEventListener("change", function (event)
        {
            const object = this.getUserPublishSetting();
            object.modal = event.target.value === "1";

            localStorage
                .setItem(
                    `${Util.PREFIX}@user-publish-setting`,
                    JSON.stringify(object)
                );

        }.bind(this));
    }

    /**
     * @return {void}
     * @public
     */
    deactiveStageAreaNode ()
    {
        Util.$screen._$shapeMovePointer = false;
        Util.$screen._$shapeMoveTarget  = null;
        Util.$hitColor = null;

        const children = document
            .getElementById("stage-area")
            .children;

        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];
            if (node.dataset.shapePointer) {
                node.remove();
                --idx;
                continue;
            }

            if (!node.dataset.child) {
                continue;
            }

            node.style.pointerEvents = "none";

        }
    }

    /**
     * @return {void}
     * @public
     */
    setPenColor ()
    {
        const color = Util.$intToRGB(
            `0x${document.getElementById("stroke-color").value.substr(1)}` | 0
        );
        const size = document.getElementById("stroke-size").value | 0;
        Util.$setCursor(`url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24"><circle fill="rgb(${color.R},${color.G},${color.B})" cx="12" cy="12" r="12"/></svg>'),auto`);
    }

    /**
     * @return {void}
     * @public
     */
    setBucketColor ()
    {
        const color = Util.$intToRGB(
            `0x${document.getElementById("fill-color").value.substr(1)}` | 0
        );
        Util.$setCursor(`url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="rgb(${color.R},${color.G},${color.B})" d="M24 19.007c0-3.167-1.409-6.771-2.835-9.301l-.006-.01-.014-.026c-.732-1.392-1.914-3.052-3.619-4.757-2.976-2.976-5.476-3.912-6.785-3.913-.413 0-.708.094-.859.245l-.654.654c-1.898-.236-3.42.105-4.294.982-.876.875-1.164 2.159-.792 3.524.242.893.807 1.891 1.752 2.836.867.867 2.062 1.684 3.615 2.327.488-.839 1.654-1.019 2.359-.315.586.586.584 1.533-.002 2.119s-1.533.589-2.121 0c-.229-.229-.366-.515-.416-.812-1.646-.657-3.066-1.534-4.144-2.612-.728-.728-1.289-1.528-1.664-2.349l-2.835 2.832c-.445.447-.685 1.064-.686 1.82.001 1.635 1.122 3.915 3.714 6.506 2.764 2.764 5.58 4.243 7.431 4.243.649 0 1.181-.195 1.548-.562l8.086-8.079c.911.875-.777 3.541-.777 4.65 0 1.104.896 1.999 2 1.998 1.104 0 1.998-.895 1.998-2zm-18.912-12.974c-.236-.978-.05-1.845.554-2.444.526-.53 1.471-.791 2.656-.761l-3.21 3.205zm9.138 2.341l-.03-.029c-1.29-1.291-3.802-4.354-3.095-5.062.715-.715 3.488 1.521 5.062 3.095.862.863 2.088 2.248 2.938 3.459-1.718-1.073-3.493-1.469-4.875-1.463zm-3.875 12.348c-.547-.082-1.5-.547-1.9-.928l7.086-7.086c.351.37 1.264.931 1.753 1.075l-6.939 6.939z"/></svg>'),auto`);
    }

    /**
     * @return {void}
     * @public
     */
    activeStageAreaNode ()
    {
        Util.$screen._$shapeMovePointer = false;
        Util.$screen._$shapeMoveTarget  = null;
        Util.$hitColor = null;

        const children = document
            .getElementById("stage-area")
            .children;

        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];
            if (node.dataset.shapePointer) {
                node.remove();
                --idx;
                continue;
            }

            if (!node.dataset.child) {
                continue;
            }

            node.style.pointerEvents = "auto";

        }
    }

    /**
     * @return {void}
     * @public
     */
    initializeData ()
    {
        // ファイル読み込み
        const loadElement = document
            .getElementById("tools-load");

        loadElement.addEventListener("click", function (event)
        {
            const input = document.getElementById("tools-load-file-input");
            input.click();

            event.preventDefault();
        });

        const fileInput = document
            .getElementById("tools-load-file-input");

        fileInput.addEventListener("change", function (event)
        {
            const files = event.target.files;
            for (let idx = 0; idx < files.length; ++idx) {
                this.loadSaveFile(files[idx]);
            }

            // reset
            event.target.value = "";

        }.bind(this));

        const saveElement = document
            .getElementById("tools-save");

        saveElement.addEventListener("click", function ()
        {
            const postData = {
                "object": Util.$currentWorkSpace().toJSON(),
                "type": "n2d"
            };

            if (Util.$zlibWorkerActive) {

                Util.$zlibQueues.push(postData);

            } else {

                Util.$zlibWorkerActive = true;
                Util.$zlibWorker.postMessage(postData);

            }

        });

        const exportElement = document
            .getElementById("tools-export");

        exportElement.addEventListener("click", function ()
        {
            // ダウンロードリンクを生成
            const anchor = document.getElementById("save-anchor");

            if (anchor.href) {
                URL.revokeObjectURL(anchor.href);
            }

            const type = document
                .getElementById("publish-type-setting")
                .value;

            switch (type) {

                case "json":
                    anchor.download = `${Util.$currentWorkSpace().name}.json`;
                    anchor.href     = URL.createObjectURL(new Blob(
                        [Publish.toJSON()],
                        { "type" : "application/json" }
                    ));
                    anchor.click();
                    break;

                case "zlib":
                    Publish.toZlib();
                    break;

                case "webm":
                    Publish.toWebM();
                    break;

                case "gif-loop":
                    Publish.toGIF();
                    break;

                case "gif":
                    Publish.toGIF(-1);
                    break;

                case "png":
                    Publish.toPng();
                    break;

                case "apng-loop":
                    Publish.toApng(true);
                    break;

                case "apng":
                    Publish.toApng(false);
                    break;

                case "custom":
                    if ("CustomPublish" in window) {
                        window
                            .CustomPublish
                            .execute(Publish.toObject());
                    }
                    break;

            }

        });

        const languageElement = document
            .getElementById("language-setting");

        const language = localStorage
            .getItem(`${Util.PREFIX}@language-setting`);

        if (language) {
            const children = languageElement.children;
            for (let idx = 0; idx < children.length; ++idx) {
                const node = children[idx];
                if (node.value === language) {
                    node.selected = true;
                    break;
                }
            }
        }

        languageElement
            .addEventListener("change", function (event)
            {
                const language = event.target.value;

                const LanguageClass = Util.$languages.get(language);
                Util.$currentLanguage = new LanguageClass();

                localStorage
                    .setItem(`${Util.PREFIX}@language-setting`, language);

                Util.$addModalEvent(document);
            });

    }

    /**
     * @param  {File} file
     * @return {void}
     * @public
     */
    loadSaveFile (file)
    {
        file
            .arrayBuffer()
            .then(function (buffer)
            {
                const uint8Array = new Uint8Array(buffer);
                Util.$unZlibWorker.postMessage({
                    "buffer": uint8Array,
                    "type": "n2d"
                }, [uint8Array.buffer]);
            });
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    reset ()
    {
        this.activeStageAreaNode();

        Util.$setCursor("auto");

        if (this._$activeTool) {
            this._$activeTool
                .classList
                .remove("active");
        }

        // change active
        const element = document.getElementById("tools-arrow").firstChild;

        element
            .classList
            .add("active");

        this._$activeTool          = element;
        Util.$screen._$penMode     = false;
        Util.$screen._$cursorCache = null;
    }
}

Util.$tools = new Tools();

/**
 * @class
 */
class Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object)
    {
        this._$id         = object.id;
        this._$name       = object.name;
        this._$type       = object.type;
        this._$symbol     = object.symbol;
        this._$folderId   = object.folderId | 0;
        this._$startFrame = 1;
        this._$endFrame   = 0;
    }

    /**
     * @abstract
     */
    initialize () {}

    /**
     * @abstract
     */
    toObject () {}

    /**
     * @param  {number} width
     * @param  {number} height
     * @param  {object} place
     * @param  {boolean} [preview=false]
     * @return {HTMLImageElement}
     * @public
     */
    toImage (width, height, place, preview = false)
    {
        // empty image
        if (!width || !height) {
            return Util.$emptyImage;
        }

        const { Sprite, BitmapData } = window.next2d.display;
        const { Matrix, ColorTransform, Rectangle } = window.next2d.geom;

        const instance  = this.createInstance(place, preview);
        const rectangle = instance.getBounds();

        const ratio = window.devicePixelRatio * Util.$zoomScale;
        const multiMatrix = Util.$multiplicationMatrix(
            Util.$multiplicationMatrix(
                [ratio, 0, 0, ratio, 0, 0],
                [
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    0, 0
                ]
            ),
            [
                1, 0, 0, 1,
                -(instance.width / 2) - rectangle.x,
                -(instance.height / 2) - rectangle.y
            ]
        );

        const matrix = new Matrix(ratio, 0, 0, ratio);
        matrix.translate(
            multiMatrix[4] + width  * ratio / 2,
            multiMatrix[5] + height * ratio / 2
        );

        let xScale = Math.sqrt(
            place.matrix[0] * place.matrix[0]
            + place.matrix[1] * place.matrix[1]
        );

        let yScale = Math.sqrt(
            place.matrix[2] * place.matrix[2]
            + place.matrix[3] * place.matrix[3]
        );

        let offsetX = 0;
        let offsetY = 0;

        let rect = new Rectangle(0, 0, width, height);
        if (place.filter.length) {

            const filters = [];
            for (let idx = 0; idx < place.filter.length; ++idx) {

                const filter = place.filter[idx];
                if (!filter.state) {
                    continue;
                }

                const instance = filter.createInstance();

                rect = instance._$generateFilterRect(rect, xScale, yScale);

                filters.push(instance);

            }
            instance.filters = filters;

            width  = Math.ceil(rect.width);
            height = Math.ceil(rect.height);

            offsetX = rect.x;
            offsetY = rect.y;
        }

        const container = new Sprite();
        const sprite = container.addChild(new Sprite());
        sprite.addChild(instance);

        instance.transform.matrix = new Matrix(
            place.matrix[0], place.matrix[1],
            place.matrix[2], place.matrix[3],
            0, 0
        );
        instance.transform.colorTransform = new ColorTransform(
            place.colorTransform[0], place.colorTransform[1],
            place.colorTransform[2], place.colorTransform[3],
            place.colorTransform[4], place.colorTransform[5],
            place.colorTransform[6], place.colorTransform[7]
        );

        if (0 > offsetX) {
            matrix.translate(-offsetX * ratio, 0);
        }

        if (0 > offsetY) {
            matrix.translate(0, -offsetY * ratio);
        }

        const bitmapData = new BitmapData(
            Math.ceil(width  * ratio),
            Math.ceil(height * ratio),
            true, 0
        );
        bitmapData.draw(container, matrix);

        const image     = bitmapData.toImage();
        image.width     = width;
        image.height    = height;
        image.draggable = false;

        const bounds = Util.$boundsMatrix(
            this.getBounds(place, preview),
            place.matrix
        );

        image._$tx = bounds.xMin;
        image._$ty = bounds.yMin;

        image.style.position = "relative";
        image._$offsetX = 0 > offsetX ? offsetX : 0;
        image._$offsetY = 0 > offsetY ? offsetY : 0;

        return image;
    }

    /**
     * @abstract
     */
    toPublish () {}

    /**
     * @abstract
     */
    get defaultSymbol () {}

    /**
     * @abstract
     */
    createInstance () {}

    /**
     * @interface
     */
    getBounds () {}

    /**
     * @return {HTMLImageElement}
     */
    get preview ()
    {
        const bounds = this.getBounds(null, true);

        // size
        let width  = Math.abs(bounds.xMax - bounds.xMin);
        let height = Math.abs(bounds.yMax - bounds.yMin);
        if (!width || !height) {
            return Util.$emptyImage;
        }

        let scaleX   = 1;
        const scaleY = 150 / height;

        width  = width  * scaleY | 0;
        height = height * scaleY | 0;

        const controllerWidth = (document
            .documentElement
            .style
            .getPropertyValue("--controller-width")
            .split("px")[0] | 0) - 10;

        if (width > controllerWidth) {
            scaleX = controllerWidth / width;
            width  = width  * scaleX | 0;
            height = height * scaleX | 0;
        }

        const image = this.toImage(width, height, {
            "matrix": [scaleY * scaleX, 0, 0, scaleY * scaleX, 0, 0],
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": []
        }, true);

        if (image.height !== height) {
            const height = Math.min(150, image.height);
            image.width  *= height / image.height;
            image.height  = height;
        }

        return image;
    }

    /**
     * @return {number}
     * @public
     */
    get id ()
    {
        return this._$id;
    }

    /**
     * @param  {number} id
     * @return {void}
     * @public
     */
    set id (id)
    {
        this._$id = id | 0;
    }

    /**
     * @return {number}
     * @public
     */
    get folderId ()
    {
        return this._$folderId;
    }

    /**
     * @param  {number} id
     * @return {void}
     * @public
     */
    set folderId (id)
    {
        this._$folderId = id | 0;
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @param  {string} name
     * @return {void}
     * @public
     */
    set name (name)
    {
        this._$name = `${name}`;

        if (this.id) {
            const libraryElement = document
                .getElementById(`library-name-${this.id}`);
            libraryElement.textContent = this._$name;
        }

        if (Util.$currentWorkSpace().scene.id === this.id) {
            document
                .getElementById("object-name")
                .value = this._$name;

            document
                .getElementById("scene-name")
                .textContent = this._$name;

        }

    }

    /**
     * @return {string}
     * @public
     */
    get type ()
    {
        return this._$type;
    }

    /**
     * @param  {string} type
     * @return {void}
     * @public
     */
    set type (type)
    {
        this._$type = `${type}`;
    }

    /**
     * @return {string}
     * @public
     */
    get symbol ()
    {
        return this._$symbol;
    }

    /**
     * @param  {string} symbol
     * @return {void}
     * @public
     */
    set symbol (symbol)
    {
        this._$symbol = `${symbol}`;

        if (this.id) {
            const libraryElement = document
                .getElementById(`library-symbol-name-${this.id}`);
            libraryElement.textContent = this._$symbol;
        }

        if (Util.$currentWorkSpace().scene.id === this.id) {
            document.getElementById("object-symbol").value = this._$symbol;
        }
    }
}

/**
 * @class
 */
class Bitmap extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor(object)
    {
        super(object);

        this.imageType = object.imageType;
        this.width     = object.width;
        this.height    = object.height;

        this._$buffer = null;
        if (object.buffer) {
            this.buffer = object.buffer;
        }
        this._$command = null;
        this._$binary  = "";
    }

    /**
     * @return {void}
     * @public
     */
    initialize () {}

    /**
     * @return {object}
     * @public
     */
    getBounds ()
    {
        return {
            "xMin": 0,
            "xMax": this.width,
            "yMin": 0,
            "yMax": this.height
        };
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.display.Shape.namespace;
    }

    /**
     * @return {string}
     * @public
     */
    get buffer ()
    {
        if (!this._$binary) {

            const length = this._$buffer.length;

            for (let idx = 0; idx < length; ++idx) {
                this._$binary += String.fromCharCode(this._$buffer[idx]);
            }

        }

        return this._$binary;
    }

    /**
     * @param  {string|Uint8Array} binary
     * @return {void}
     * @public
     */
    set buffer (binary)
    {

        switch (typeof binary) {

            case "object":
                if (binary.constructor === Uint8Array) {
                    this._$buffer = binary;
                }
                break;

            case "string":
                if (!this._$binary) {
                    let length = binary.length;

                    this._$buffer = new Uint8Array(length);
                    for (let idx = 0; idx < length; ++idx) {
                        this._$buffer[idx] = binary.charCodeAt(idx) & 0xff;
                    }

                    this._$binary = binary;
                }
                break;

            default:
                break;

        }
    }

    /**
     * @return {string}
     * @public
     */
    get imageType ()
    {
        return this._$imageType;
    }

    /**
     * @param  {string} image_type
     * @return {void}
     * @public
     */
    set imageType (image_type)
    {
        this._$imageType = image_type;
    }

    /**
     * @return {uint}
     * @public
     */
    get width ()
    {
        return this._$width;
    }

    /**
     * @param  {uint} width
     * @return {void}
     * @public
     */
    set width (width)
    {
        this._$width = width;
    }

    /**
     * @return {uint}
     * @public
     */
    get height ()
    {
        return this._$height;
    }

    /**
     * @param  {uint} height
     * @return {void}
     * @public
     */
    set height (height)
    {
        this._$height = height;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":        this.id,
            "name":      this.name,
            "type":      this.type,
            "symbol":    this.symbol,
            "folderId":  this.folderId,
            "width":     this.width,
            "height":    this.height,
            "imageType": this.imageType,
            "buffer":    this.buffer
        };
    }

    /**
     * @return {object}
     * @public
     */
    toPublish ()
    {
        return {
            "symbol":  this.symbol,
            "extends": this.defaultSymbol,
            "buffer":  Array.from(this._$buffer),
            "bounds":  this.getBounds()
        };
    }

    /**
     * @return {next2d.display.Shape}
     * @public
     */
    createInstance ()
    {
        const { Shape, BitmapData } = window.next2d.display;
        const { width, height } = this;

        const shape = new Shape();

        const bitmapData = new BitmapData(width, height, true, 0);
        bitmapData._$buffer = this._$buffer;

        shape
            .graphics
            .beginBitmapFill(bitmapData, null, false)
            .drawRect(0, 0, width, height)
            .endFill();

        // setup
        shape.graphics._$maxAlpha = 1;
        shape.graphics._$canDraw  = true;
        shape.graphics._$xMin     = 0;
        shape.graphics._$xMax     = this.width;
        shape.graphics._$yMin     = 0;
        shape.graphics._$yMax     = this.height;
        shape.graphics._$command  = this._$command;

        return shape;
    }
}

/**
 * @class
 */
class Character
{
    /**
     * @param {object} object
     *
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        this._$libraryId    = -1;
        this._$places       = new Map();
        this._$image        = null;
        this._$currentFrame = 0;
        this._$currentPlace = null;
        this._$screenX      = 0;
        this._$screenY      = 0;
        this._$offsetX      = 0;
        this._$offsetY      = 0;
        this._$name         = "";
        this._$tween        = new Map();

        if (object) {
            this._$id         = object.id;
            this._$libraryId  = object.libraryId;
            this.places       = object.places;
            this._$name       = object.name || "";
            this._$startFrame = object.startFrame;
            this._$endFrame   = object.endFrame;
            this.tween        = object.tween;
        } else {
            this._$id         = Util.$currentWorkSpace()._$characterId++;
            this._$startFrame = 1;
            this._$endFrame   = 0;
        }
    }

    /**
     * @return {Character}
     * @public
     */
    clone ()
    {
        const character = new Character(this.toObject());
        character._$id  = Util.$currentWorkSpace()._$characterId++;
        return character;
    }

    /**
     * @param  {number} frame
     * @return {Character}
     * @public
     */
    copy (frame)
    {
        // clone
        const character      = this.clone();
        character.startFrame = frame;

        // clone place data
        character.setPlace(frame, this.clonePlace(this.startFrame, frame));

        return character;
    }

    /**
     * @param  {number} from_frame
     * @param  {number} to_frame
     * @return {object}
     * @public
     */
    clonePlace (from_frame, to_frame)
    {
        const place = this.getPlace(from_frame);

        const filters = [];
        const length = place.filter.length;
        for (let idx = 0; idx < length; ++idx) {
            filters.push(place.filter[idx].clone());
        }

        const clone = {
            "frame": to_frame,
            "matrix": place.matrix.slice(0),
            "colorTransform": place.colorTransform.slice(0),
            "blendMode": place.blendMode,
            "filter": filters,
            "depth": place.depth
        };

        if (place.loop) {
            // init
            clone.loop = {};

            // clone
            const keys = Object.keys(place.loop);
            for (let idx = 0; idx < keys.length; ++idx) {
                const name = keys[idx];
                clone.loop[name] = place.loop[name];
            }
        }

        return clone;
    }

    /**
     * @return {number}
     * @public
     */
    getTweenFrame ()
    {
        const layerElement = Util.$timeline._$targetLayer;
        if (!layerElement) {
            return 0;
        }

        const layerId = layerElement.dataset.layerId | 0;

        let frame = document
            .getElementById("current-frame")
            .textContent | 0;

        while (frame > 1) {

            const element = document
                .getElementById(`${layerId}-${frame}`);

            if (element.classList.contains("key-frame")) {
                break;
            }

            --frame;
        }

        return frame;
    }

    /**
     * @return {object}
     * @public
     */
    getTween ()
    {
        return this.hasTween()
            ? this._$tween.get(this.getTweenFrame())
            : null;
    }

    /**
     * @param  {object} object
     * @return {void}
     * @public
     */
    setTween (object)
    {
        this._$tween.set(this.getTweenFrame(), object);
    }

    /**
     * @return {boolean}
     * @public
     */
    hasTween ()
    {
        return this._$tween.has(this.getTweenFrame());
    }

    /**
     * @param  {boolean} [preview=false]
     * @return {object}
     * @public
     */
    getBounds (preview = false)
    {
        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace.getLibrary(this.libraryId);

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        return instance.getBounds(this.getPlace(frame), preview);
    }

    /**
     * @return {number}
     * @public
     */
    get rotation ()
    {
        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const matrix = this.getPlace(frame).matrix;
        return Math.atan2(matrix[1], matrix[0]) * Util.$Rad2Deg;
    }

    /**
     * @param  {number} rotate
     * @return {void}
     * @public
     */
    set rotation (rotate)
    {
        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const matrix = this.getPlace(frame).matrix;
        let radianX  = Math.atan2(matrix[1], matrix[0]);
        let radianY  = Math.atan2(-matrix[2], matrix[3]);

        const xScale = Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale = Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        const radian = rotate * Util.$Deg2Rad;
        radianY      = radianY + radian - radianX;
        radianX      = radian;

        matrix[0] = xScale  * Math.cos(radianX);
        matrix[1] = xScale  * Math.sin(radianX);
        matrix[2] = -yScale * Math.sin(radianY);
        matrix[3] = yScale  * Math.cos(radianY);
    }

    /**
     * @return {number}
     * @public
     */
    get width ()
    {
        let frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const bounds = Util.$boundsMatrix(
            this.getBounds(),
            this.getPlace(frame).matrix
        );

        const width = +Math.abs(bounds.xMax - bounds.xMin);
        return width !== Infinity ? width : 0;
    }

    /**
     * @param  {number} width
     * @return {void}
     * @public
     */
    set width (width)
    {
        const bounds  = this.getBounds();
        const exWidth = Math.abs(bounds.xMax - bounds.xMin);
        this.scaleX   = width / exWidth;
    }

    /**
     * @return {number}
     * @public
     */
    get scaleX ()
    {
        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const matrix = this.getPlace(frame).matrix;
        return Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
    }

    /**
     * @param  {number} scale_x
     * @return {void}
     * @public
     */
    set scaleX (scale_x)
    {
        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const matrix = this.getPlace(frame).matrix;
        if (matrix[1]) {

            const radianX = Math.atan2(matrix[1], matrix[0]);

            matrix[1] = scale_x * Math.sin(radianX);
            if (matrix[1] === 1 || matrix[1] === -1) {
                matrix[0] = 0;
            } else {
                matrix[0] = scale_x * Math.cos(radianX);
            }

        } else {

            matrix[0] = scale_x;

        }

    }

    /**
     * @return {number}
     * @public
     */
    get height ()
    {
        const frame  = document
            .getElementById("current-frame")
            .textContent | 0;

        const bounds = Util.$boundsMatrix(
            this.getBounds(),
            this.getPlace(frame).matrix
        );

        const height = +Math.abs(bounds.yMax - bounds.yMin);
        return height !== Infinity ? height : 0;
    }

    /**
     * @param  {number} height
     * @return {void}
     * @public
     */
    set height (height)
    {
        const bounds   = this.getBounds();
        const exHeight = Math.abs(bounds.yMax - bounds.yMin);
        this.scaleY    = height / exHeight;
    }

    /**
     * @return {number}
     * @public
     */
    get scaleY ()
    {
        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const matrix = this.getPlace(frame).matrix;
        return Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);
    }

    /**
     * @param  {number} scale_y
     * @return {void}
     * @public
     */
    set scaleY (scale_y)
    {
        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        const matrix = this.getPlace(frame).matrix;
        if (matrix[2]) {

            const radianY = Math.atan2(-matrix[2], matrix[3]);
            matrix[2] = -scale_y * Math.sin(radianY);
            if (matrix[2] === 1 || matrix[2] === -1) {
                matrix[3] = 0;
            } else {
                matrix[3] = scale_y * Math.cos(radianY);
            }

        } else {

            matrix[3] = scale_y;

        }
    }

    /**
     * @return {number}
     * @public
     */
    get x ()
    {
        const frame = document.getElementById("current-frame").textContent | 0;
        const place = this.getPlace(frame);
        return place.matrix[4];
    }

    /**
     * @param  {number} x
     * @return {void}
     * @public
     */
    set x (x)
    {
        const frame = document.getElementById("current-frame").textContent | 0;
        const place = this.getPlace(frame);
        place.matrix[4] = x;
    }

    /**
     * @return {number}
     * @public
     */
    get y ()
    {
        const frame = document.getElementById("current-frame").textContent | 0;
        const place = this.getPlace(frame);
        return place.matrix[5];
    }

    /**
     * @param  {number} y
     * @return {void}
     * @public
     */
    set y (y)
    {
        const frame = document.getElementById("current-frame").textContent | 0;
        const place = this.getPlace(frame);
        place.matrix[5] = y;
    }

    /**
     * @return {HTMLImageElement}
     * @public
     */
    get image ()
    {
        if (!this._$image) {

            const workSpace = Util.$currentWorkSpace();
            const instance  = workSpace.getLibrary(this.libraryId);

            const frame = document
                .getElementById("current-frame")
                .textContent | 0;

            const place = this.getPlace(frame);

            let keys = Object.keys(place);
            const placeObject = {};
            for (let idx = 0; idx < keys.length; ++idx) {
                const name = keys[idx];
                placeObject[name] = place[name];
            }

            // reset
            let loopConfig = place.loop;
            if (loopConfig) {

                if (loopConfig.referenceFrame) {
                    const referencePlace = this.getPlace(loopConfig.referenceFrame);
                    loopConfig = referencePlace.loop;
                }

                placeObject.loop = {};

                // clone
                keys = Object.keys(loopConfig);
                for (let idx = 0; idx < keys.length; ++idx) {
                    const name = keys[idx];
                    placeObject.loop[name] = loopConfig[name];
                }
            }

            switch (placeObject.blendMode) {

                case "alpha":
                case "erase":
                    return Util.$emptyImage;

                case "invert":
                    this._$image = instance.toImage(
                        Math.ceil(this.width),
                        Math.ceil(this.height),
                        {
                            "matrix": placeObject.matrix,
                            "colorTransform": [
                                0, 0, 0, placeObject.colorTransform[3],
                                0, 0, 0, placeObject.colorTransform[7]
                            ],
                            "blendMode": placeObject.blendMode,
                            "filter": placeObject.filter,
                            "loop": placeObject.loop
                        }
                    );
                    break;

                default:
                    this._$image = instance.toImage(
                        Math.ceil(this.width),
                        Math.ceil(this.height),
                        placeObject
                    );
                    break;

            }

            // set blend mode
            switch (placeObject.blendMode) {

                case "add":
                    this._$image.style.mixBlendMode = "color-dodge";
                    break;

                case "subtract":
                    this._$image.style.filter = "invert(100%)";
                    this._$image.style.mixBlendMode = "multiply";
                    break;

                case "invert":
                    this._$image.style.filter = "invert(100%)";
                    this._$image.style.mixBlendMode = "difference";
                    break;

                case "hardlight":
                    this._$image.style.mixBlendMode = "hard-light";
                    break;

                case "alpha":
                case "erase":
                case "layer":
                    break;

                default:
                    this._$image.style.mixBlendMode = placeObject.blendMode;
                    break;

            }

            this._$screenX = this._$image._$tx;
            this._$screenY = this._$image._$ty;
            this._$offsetX = this._$image._$offsetX;
            this._$offsetY = this._$image._$offsetY;

        }

        return this._$image;
    }

    /**
     * @return {number}
     * @public
     */
    get offsetX ()
    {
        return this._$offsetX;
    }

    /**
     * @return {number}
     * @public
     */
    get offsetY ()
    {
        return this._$offsetY;
    }

    /**
     * @return {number}
     * @public
     */
    get screenX ()
    {
        return this._$screenX;
    }

    /**
     * @param  {number} screen_x
     * @return {void}
     * @public
     */
    set screenX (screen_x)
    {
        this._$screenX = screen_x;
    }

    /**
     * @return {number}
     * @readonly
     * @public
     */
    get screenY ()
    {
        return this._$screenY;
    }

    /**
     * @param  {number} screen_y
     * @return {void}
     * @public
     */
    set screenY (screen_y)
    {
        this._$screenY = screen_y;
    }

    /**
     * @return {number}
     * @readonly
     * @public
     */
    get id ()
    {
        return this._$id;
    }

    /**
     * @return {number}
     * @public
     */
    get libraryId ()
    {
        return this._$libraryId;
    }

    /**
     * @param  {number} library_id
     * @return {void}
     * @public
     */
    set libraryId (library_id)
    {
        this._$libraryId = library_id | 0;
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @param  {string} name
     * @return {void}
     * @public
     */
    set name (name)
    {
        name += "";
        name.replace(" ", "");
        this._$name = name.trim();
    }

    /**
     * @return {array}
     * @public
     */
    get tween ()
    {
        const values = [];
        for (let [frame, value] of this._$tween) {

            values.push({
                "frame": frame,
                "value": value
            });
        }
        return values;
    }

    /**
     * @param  {array} values
     * @return {void}
     * @public
     */
    set tween (values)
    {
        for (let idx = 0; idx < values.length; ++idx) {
            const object = values[idx];
            if (!object.value.custom) {
                object.value.custom = Util.$controller.createEasingObject();
            }
            this._$tween.set(object.frame | 0, object.value);
        }
    }

    /**
     * @return {array}
     * @public
     */
    get places ()
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(this.libraryId);

        const places = [];
        for (let [frame, place] of this._$places) {

            place.frame = frame;

            const filters = [];
            for (let idx = 0; idx < place.filter.length; ++idx) {
                filters.push(place.filter[idx].toObject());
            }

            const object = {
                "frame": frame,
                "fixed": !!place.fixed,
                "depth": place.depth,
                "blendMode": place.blendMode,
                "filter": filters,
                "matrix": place.matrix.slice(0),
                "colorTransform": place.colorTransform.slice(0)
            };

            if (instance.type === "container") {

                object.loop = {
                    "type": 0,
                    "start": 1,
                    "end": 0
                };

                if (object.loop) {
                    object.loop = {
                        "type": place.loop.type,
                        "start": place.loop.start,
                        "end": place.loop.end
                    };

                    if (place.loop.referenceFrame) {
                        object.loop.referenceFrame = place.loop.referenceFrame;
                    }

                    if (place.loop.tweenFrame) {
                        object.loop.tweenFrame = place.loop.tweenFrame;
                    }
                }
            }

            places.push(object);
        }
        return places;
    }

    /**
     * @param  {array} places
     * @return {void}
     * @public
     */
    set places (places)
    {
        for (let idx = 0; idx < places.length; ++idx) {

            const place = places[idx];

            const filters = [];
            for (let idx = 0; place.filter.length > idx; ++idx) {
                const object = place.filter[idx];
                filters.push(new Util.$filterClasses[object.name](object));
            }

            place.filter = null;
            place.filter = filters;

            if (!place.loop) {
                place.loop = {
                    "type": 0,
                    "start": 1,
                    "end": 0
                };
            }

            this._$places.set(place.frame | 0, place);
        }
    }

    /**
     * @param  {number} frame
     * @return {object}
     * @public
     */
    getPlace (frame)
    {
        if (this.hasPlace(frame)) {
            return this._$places.get(frame | 0);
        }

        const places = Array.from(this._$places);
        places.sort(function (a, b)
        {
            switch (true) {

                case a[0] > b[0]:
                    return 1;

                case a[0] < b[0]:
                    return -1;

                default:
                    return 0;

            }
        });

        while (places.length) {

            const placeFrame = places.pop()[0] | 0;

            if (frame > placeFrame) {
                return this._$places.get(placeFrame);
            }

        }
    }

    /**
     * @param  {number} frame
     * @param  {object} place
     * @return {void}
     * @public
     */
    setPlace (frame, place)
    {
        place.frame = frame | 0;
        this._$places.set(frame | 0, place);
    }

    /**
     * @param  {number} frame
     * @return {boolean}
     * @public
     */
    hasPlace (frame)
    {
        return this._$places.has(frame | 0);
    }

    /**
     * @param  {number} frame
     * @return {void}
     * @public
     */
    deletePlace (frame)
    {
        this._$places.delete(frame | 0);
    }

    /**
     * @return {number}
     * @public
     */
    get startFrame ()
    {
        return this._$startFrame;
    }

    /**
     * @param  {number} start_frame
     * @return {void}
     * @public
     */
    set startFrame (start_frame)
    {
        this._$startFrame = start_frame | 0;
    }

    /**
     * @return {number}
     * @public
     */
    get endFrame ()
    {
        return this._$endFrame;
    }

    /**
     * @param  {number} end_frame
     * @return {void}
     * @public
     */
    set endFrame (end_frame)
    {
        this._$endFrame = end_frame | 0;
    }

    /**
     * @param  {number} start_frame
     * @param  {number} end_frame
     * @return {Character}
     * @public
     */
    split (start_frame, end_frame)
    {
        const character = new Character();
        character._$id  = Util.$currentWorkSpace()._$characterId++;

        // params
        character._$libraryId  = this._$libraryId;
        character._$places     = new Map(Array.from(this._$places));
        character._$startFrame = start_frame;
        character._$endFrame   = end_frame;

        for (let [frame, place] of this._$places) {

            if (start_frame > frame) {
                continue;
            }

            if (frame > end_frame) {
                continue;
            }

            character._$places.set(frame, place);
        }

        return character;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":         this.id,
            "name":       this.name,
            "libraryId":  this.libraryId,
            "places":     this.places,
            "startFrame": this.startFrame,
            "endFrame":   this.endFrame,
            "tween":      this.tween
        };
    }
}

/**
 * @class
 */
class Folder extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object)
    {
        super(object);

        this._$mode = "clone";
        if (object.mode) {
            this._$mode = object.mode;
        }
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":       this.id,
            "name":     this.name,
            "type":     this.type,
            "symbol":   this.symbol,
            "folderId": this.folderId,
            "mode":     this.mode
        };
    }

    /**
     * @return {string}
     * @public
     */
    get mode ()
    {
        return this._$mode;
    }

    /**
     * @param  {string} mode
     * @return {void}
     * @public
     *
     */
    set mode (mode)
    {
        this._$mode = mode;
    }
}

/**
 * @class
 */
class Frame
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor(object = null)
    {
        this._$layerId = 0;
        this._$classes = new Map();

        if (object) {
            this.classes = object.classes;
        }
    }

    /**
     * @return {void}
     * @public
     */
    initialize ()
    {
        for (let [frame, css] of this._$classes) {

            const element = document
                .getElementById(`${this._$layerId}-${frame}`);

            Util.$timeline.removeFrameClass(element);

            const classList = element.classList;
            for (let idx = 0; idx < css.length; ++idx) {
                classList.add(css[idx]);
            }

            element.dataset.frameState = css[0];
        }
    }

    /**
     * @return {array}
     * @public
     */
    get classes ()
    {
        const classes = [];
        for (let [frame, css] of this._$classes) {
            classes.push({
                "frame": frame,
                "classes": css
            });
        }
        return classes;
    }

    /**
     * @param  {array} classes
     * @return {void}
     * @public
     */
    set classes (classes)
    {
        for (let idx = 0; idx < classes.length; ++idx) {
            const object = classes[idx];
            this._$classes.set(object.frame | 0, object.classes);
        }
    }

    /**
     * @param  {number} frame
     * @return {boolean}
     * @public
     */
    hasClasses (frame)
    {
        return this._$classes.has(frame | 0);
    }

    /**
     * @param  {number} frame
     * @return {array}
     * @public
     */
    getClasses (frame)
    {
        return this._$classes.get(frame | 0);
    }

    /**
     * @param  {number} frame
     * @param  {array}  css
     * @return {void}
     * @public
     */
    setClasses (frame, css)
    {
        this._$classes.set(frame | 0, css);
    }

    /**
     * @param  {number} frame
     * @return {void}
     * @public
     */
    deleteClasses (frame)
    {
        this._$classes.delete(frame | 0);
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return { "classes": this.classes };
    }
}
/**
 * @class
 */
class Layer
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        this._$id         = 0;
        this._$characters = [];
        this._$instances  = new Map();

        this._$maskId     = null;
        this._$name       = null;
        this._$light      = false;
        this._$disable    = false;
        this._$lock       = false;
        this._$mode       = Util.LAYER_MODE_NORMAL;
        this._$frame      = new Frame();

        if (object) {
            this._$name      = object.name;
            this._$light     = object.light;
            this._$disable   = object.disable;
            this._$lock      = object.lock;
            this._$mode      = object.mode;
            this._$maskId    = object.maskId;
            this.frame       = new Frame(object.frames);
            this.characters  = object.characters;
        }
    }

    /**
     * @return {void}
     * @public
     */
    initialize ()
    {
        Util.$timeline.createChild();

        const element = document
            .getElementById("timeline-content")
            .lastElementChild;

        // set id
        this.id = element.dataset.layerId | 0;
        this._$frame._$layerId = this.id;

        const name = document.getElementById(`layer-name-${this.id}`);
        if (this.name) {
            name.textContent = this.name;
            document
                .getElementById(`layer-name-input-${this.id}`)
                .value = this.name;
        } else {
            this.name = name.textContent;
        }

        if (this.light) {

            const lightIcon = document
                .getElementById(`layer-light-icon-${this.id}`);

            lightIcon
                .classList
                .remove("icon-disable");

            lightIcon
                .classList
                .add("icon-active");

            element.classList.add("light-active");
        }

        if (this.disable) {

            const disableIcon = document
                .getElementById(`layer-disable-icon-${this.id}`);

            disableIcon
                .classList
                .remove("icon-disable");

            disableIcon
                .classList
                .add("icon-active");
        }

        if (this.lock) {

            const lockIcon = document
                .getElementById(`layer-lock-icon-${this.id}`);

            lockIcon
                .classList
                .remove("icon-disable");

            lockIcon
                .classList
                .add("icon-active");
        }

        // view
        this.showIcon();

        this._$frame.initialize();
    }

    /**
     * @param  {number} [frame=1]
     * @return {void}
     * @public
     */
    appendCharacter (frame = 1)
    {
        if (this.disable) {
            return ;
        }

        const element = document.getElementById("timeline-onion-skin");
        if (element.classList.contains("onion-skin-active")
            && Util.$timeline._$stopFlag
        ) {

            const classes = this._$frame._$classes;

            let mainFrame = frame;
            if (classes.has(frame)) {
                while (mainFrame > 1) {

                    if (classes.get(mainFrame).indexOf("key-frame") > -1 ||
                        classes.get(mainFrame).indexOf("empty-key-frame") > -1 ||
                        classes.get(mainFrame).indexOf("tween-frame") > -1
                    ) {
                        break;
                    }

                    --mainFrame;
                }
            }

            const cacheFrame = document
                .getElementById("current-frame")
                .textContent | 0;

            const size = classes.size + 1;
            for (let currentFrame = 1; currentFrame < size; ++currentFrame) {

                if (mainFrame === currentFrame) {
                    continue;
                }

                if (!classes.has(currentFrame)) {
                    continue;
                }

                if (classes.get(currentFrame).indexOf("key-frame") === -1
                    && classes.get(currentFrame).indexOf("tween-frame") === -1
                ) {
                    continue;
                }

                document
                    .getElementById("current-frame")
                    .textContent = `${currentFrame}`;

                const characters = this.getActiveCharacter(currentFrame);
                if (!characters.length) {
                    continue;
                }

                this.sort(characters, currentFrame);

                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];
                    character._$image = null;

                    Util.$screen.appendOnionCharacter(character, this.id);
                }
            }

            document
                .getElementById("current-frame")
                .textContent = `${cacheFrame}`;

            const characters = this.getActiveCharacter(cacheFrame);
            if (characters.length) {

                this.sort(characters, cacheFrame);

                const event = this.lock ? "none" : "auto";
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];
                    character._$image = null;

                    Util.$screen.appendCharacter(
                        character, cacheFrame, this.id, event
                    );
                }

            }

        } else {

            const characters = this.getActiveCharacter(frame);
            if (characters.length) {

                this.sort(characters, frame);

                const event = this.lock ? "none" : "auto";
                for (let idx = 0; idx < characters.length; ++idx) {
                    Util.$screen.appendCharacter(
                        characters[idx], frame, this.id, event
                    );
                }

            }
        }
    }

    /**
     * @param {array}  characters
     * @param {number} frame
     * @public
     */
    sort (characters, frame)
    {
        characters.sort((a, b) =>
        {
            const depthA = a.getPlace(frame).depth;
            const depthB = b.getPlace(frame).depth;
            switch (true) {

                case depthA > depthB:
                    return 1;

                case depthA < depthB:
                    return -1;

                default:
                    return 0;

            }
        });
    }

    /**
     * @param  {number} [frame=1]
     * @return {array}
     * @public
     */
    getActiveCharacter (frame = 1)
    {
        const characters = [];
        for (let idx = 0; idx < this._$characters.length; ++idx) {

            const character = this._$characters[idx];

            if (character.startFrame > frame) {
                continue;
            }

            if (frame >= character.endFrame) {
                continue;
            }

            characters.push(character);
        }
        return characters;
    }

    /**
     * @return {void}
     * @public
     */
    clearActiveCharacter ()
    {
        for (let idx = 0; idx < this._$characters.length; ++idx) {

            const character = this._$characters[idx];

            const element = document
                .getElementById(`character-${character.id}`);

            if (element) {
                element.style.border = "";
            }
        }
    }

    /**
     * @return {void}
     * @public
     */
    showIcon ()
    {

        // default
        const layerNameElement = document
            .getElementById(`layer-name-${this.id}`);

        layerNameElement
            .classList
            .remove("mask-in-view-text");

        layerNameElement
            .classList
            .add("view-text");

        const inputElement = document
            .getElementById(`layer-name-input-${this.id}`);

        inputElement
            .classList
            .remove("view-text-input-mask-in");

        switch (this._$mode) {

            case Util.LAYER_MODE_NORMAL:

                document
                    .getElementById(`layer-icon-${this.id}`)
                    .style.display = "";
                document
                    .getElementById(`layer-mask-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`layer-mask-in-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`layer-sound-icon-${this.id}`)
                    .style.display = "none";

                break;

            case Util.LAYER_MODE_MASK:

                document
                    .getElementById(`layer-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`layer-mask-icon-${this.id}`)
                    .style.display = "";
                document
                    .getElementById(`layer-mask-in-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`layer-sound-icon-${this.id}`)
                    .style.display = "none";

                break;

            case Util.LAYER_MODE_MASK_IN:
                {
                    document
                        .getElementById(`layer-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-in-icon-${this.id}`)
                        .style.display = "";
                    document
                        .getElementById(`layer-sound-icon-${this.id}`)
                        .style.display = "none";

                    const layerNameElement = document
                        .getElementById(`layer-name-${this.id}`);

                    layerNameElement
                        .classList
                        .remove("view-text");

                    layerNameElement
                        .classList
                        .add("mask-in-view-text");

                    const inputElement = document
                        .getElementById(`layer-name-input-${this.id}`);

                    inputElement
                        .classList
                        .add("view-text-input-mask-in");

                }
                break;

        }
    }

    /**
     * @return {number}
     * @public
     */
    get id ()
    {
        return this._$id;
    }

    /**
     * @param  {number} id
     * @return {void}
     * @public
     */
    set id (id)
    {
        this._$id = id | 0;
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @param  {string} name
     * @return {void}
     * @public
     */
    set name (name)
    {
        this._$name = name;
    }

    /**
     * @return {boolean}
     * @public
     */
    get light ()
    {
        return this._$light;
    }

    /**
     * @param  {boolean} light
     * @return {void}
     * @public
     */
    set light (light)
    {
        this._$light = light;
    }

    /**
     * @return {boolean}
     * @public
     */
    get disable ()
    {
        return this._$disable;
    }

    /**
     * @param  {boolean} disable
     * @return {void}
     * @public
     */
    set disable (disable)
    {
        this._$disable = disable;
    }

    /**
     * @return {boolean}
     * @public
     */
    get lock ()
    {
        return this._$lock;
    }

    /**
     * @param  {boolean} lock
     * @return {void}
     * @public
     */
    set lock (lock)
    {
        this._$lock = lock;
    }

    /**
     * @return {object}
     * @public
     */
    get frame ()
    {
        return this._$frame.toObject();
    }

    /**
     * @param  {Frame} frame
     * @return {void}
     * @public
     */
    set frame (frame)
    {
        this._$frame = frame;
    }

    /**
     * @return {array}
     * @public
     */
    get characters ()
    {
        const characters = [];
        for (let idx = 0; idx < this._$characters.length; ++idx) {
            characters.push(this._$characters[idx].toObject());
        }
        return characters;
    }

    /**
     * @param  {array} characters
     * @return {void}
     * @public
     */
    set characters (characters)
    {
        for (let idx = 0; idx < characters.length; ++idx) {

            const character = new Character(characters[idx]);

            this._$instances.set(character.id, character);
            this._$characters.push(character);
        }
    }

    /**
     * @param  {number} character_id
     * @return {Character}
     * @public
     */
    getCharacter (character_id)
    {
        return this._$instances.get(character_id | 0);
    }

    /**
     * @param  {Character} character
     * @return {void}
     * @public
     */
    addCharacter (character)
    {
        this._$characters.push(character);
        this._$instances.set(character.id, character);
    }

    /**
     * @param  {number} character_id
     * @return {void}
     * @public
     */
    deleteCharacter (character_id)
    {
        if (this._$instances.has(character_id | 0)) {

            const character = this._$instances.get(character_id | 0);

            this._$characters.splice(this._$characters.indexOf(character), 1);

            this._$instances.delete(character_id | 0);
        }
    }

    /**
     * @param  {number} frame
     * @return {number}
     */
    getEndFrame (frame)
    {
        while (this._$frame.hasClasses(frame)) {

            const classes = this._$frame.getClasses(frame);

            switch (true) {

                case classes.indexOf("key-frame") > -1:
                case classes.indexOf("empty-key-frame") > -1:
                    return frame;

                case classes.indexOf("key-space-frame-end") > -1:
                case classes.indexOf("empty-space-frame-end") > -1:
                    return frame + 1;

                default:
                    break;

            }

            frame++;
        }

        return frame;
    }

    /**
     * @return {number}
     * @public
     */
    get mode ()
    {
        return this._$mode;
    }

    /**
     * @param  {number} mode
     * @return {void}
     * @public
     */
    set mode (mode)
    {
        this._$mode = mode;
    }

    /**
     * @return {number|null}
     * @public
     */
    get maskId ()
    {
        return this._$maskId;
    }

    /**
     * @param  {number|null} mask_id
     * @return {void}
     * @public
     */
    set maskId (mask_id)
    {
        this._$maskId = mask_id === null
            ? null
            : mask_id | 0;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "name":       this.name,
            "light":      this.light,
            "disable":    this.disable,
            "lock":       this.lock,
            "mode":       this.mode,
            "maskId":     this.maskId,
            "frames":     this.frame,
            "characters": this.characters
        };
    }
}

/**
 * @class
 */
class MovieClip extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object)
    {
        super(object);

        // default
        this._$currentFrame = 0;
        this._$layerId      = 0;
        this._$parent       = null;
        this._$labels       = new Map();
        this._$layers       = new Map();
        this._$placeMap     = new Map();
        this._$actions      = new Map();
        this._$sounds       = new Map();

        if (object.layers) {
            this.layers = object.layers;
        }

        if (object.labels) {
            this.labels = object.labels;
        }

        if (object.placeMap) {
            this.placeMap = object.placeMap;
        }

        if (object.sounds) {
            this.sounds = object.sounds;
        }

        if (object.actions) {
            this.actions = object.actions;
        }
    }

    /**
     * @return {void}
     * @public
     */
    initialize ()
    {
        // screen clear
        this.clearStageArea();
        Util.$screen.clearTweenMarker();
        Util.$screen.hideTransformTarget();
        Util.$screen.hideGridTarget();

        // object setting
        document
            .getElementById("scene-name")
            .textContent = this.name;

        document
            .getElementById("object-name")
            .value = this.name;

        document
            .getElementById("object-symbol")
            .value = this.symbol;

        // シーンの初期化
        if (this.id === 0) {
            const scenes = document
                .getElementById("scene-name-menu-list");

            while (scenes.children.length) {
                scenes.children[0].remove();
            }
        }

        // create timeline marker
        Util.$timeline.initializeParams();
        Util.$timeline.buildTimeline();

        // init label
        for (const frame of this._$labels.keys()) {

            const element = document
                .getElementById(`frame-label-marker-${frame}`);

            element.setAttribute("class", "frame-border-box-marker");

        }

        // init action
        for (const frame of this._$actions.keys()) {

            const element = document
                .getElementById(`frame-label-action-${frame}`);

            element.setAttribute("class", "frame-border-box-action");

        }

        // init sound
        for (const frame of this._$sounds.keys()) {

            const element = document
                .getElementById(`frame-label-sound-${frame}`);

            element.setAttribute("class", "frame-border-box-sound");

        }

        // frame1 label
        const labelElement = document.getElementById("label-name");
        labelElement.value = "";
        if (this._$labels.has(1)) {
            labelElement.value = this._$labels.get(1);
        }

        // reset layer
        const element = document
            .getElementById("timeline-content");

        const children = element.children;
        while (children.length) {
            children[0].remove();
        }

        // insert layer
        this._$layerId = 0;
        for (const layer of this._$layers.values()) {
            layer.initialize();
        }

        if (!this._$layers.size) {
            this.addLayer();
        }

        if (this.id) {

            const libraryElement = document
                .getElementById(`library-child-id-${this.id}`);

            libraryElement.draggable = false;

            document
                .getElementById("stage-setting")
                .style
                .display = "none";

            document
                .getElementById("object-area")
                .style
                .display = "none";

        } else {

            document
                .getElementById("stage-setting")
                .style
                .display = "";

            document
                .getElementById("object-area")
                .style
                .display = "none";

        }

        Util.$controller.createSoundListArea();
        this.changeFrame(
            document.getElementById("current-frame").textContent | 0
        );

    }

    /**
     * @return {number}
     * @readonly
     * @public
     */
    get currentFrame ()
    {
        return this._$currentFrame;
    }

    /**
     * @return {number}
     * @readonly
     * @public
     */
    get totalFrame ()
    {
        let frame = 1;
        for (const layer of this._$layers.values()) {
            for (const layerFrame of layer._$frame._$classes.keys()) {
                frame = Math.max(frame, layerFrame | 0);
            }
        }
        return frame;
    }

    /**
     * @return {void}
     * @public
     */
    clearStageArea ()
    {
        const stageArea = document.getElementById("stage-area");

        let idx = 0;
        while (stageArea.children.length > idx) {

            const node = stageArea.children[idx];
            if (!node.dataset.child || node.dataset.child === "tween") {
                idx++;
                continue;
            }

            node.remove();
        }
    }

    /**
     * @param  {number} [frame=1]
     * @return {void}
     * @public
     */
    changeFrame (frame = 1)
    {
        // clear
        this.clearStageArea();

        const element = document.getElementById("stage-area");

        const pointers = [];
        const children = element.children;
        for (let idx = 0; children.length > idx; ++idx) {

            const node = children[idx];
            if (!node.dataset.shapePointer) {
                continue;
            }

            node.remove();
            pointers.push(node);
            --idx;
        }

        const layers = Array.from(this._$layers);
        while (layers.length) {
            const layer = layers.pop()[1];
            if (layer.mode === Util.LAYER_MODE_MASK && layer.lock) {
                continue;
            }
            layer.appendCharacter(frame);
        }

        this._$currentFrame = frame;

        Util.$screen.placeTransformTarget();
        Util.$screen.placeGridTarget();

        for (let idx = 0; pointers.length > idx; ++idx) {
            element.appendChild(pointers[idx]);
        }
    }

    /**
     * @return {void}
     * @public
     */
    clearActiveCharacter ()
    {
        for (const layer of this._$layers.values()) {
            layer.clearActiveCharacter();
        }
    }

    /**
     * @return {void}
     * @public
     */
    addSceneName ()
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(this.id | 0);

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        // add menu
        const htmlTag = `
<div id="scene-instance-id-${instance.id}" data-library-id="${instance.id}" data-frame="${frame}">${instance.name}</div>
        `;

        document
            .getElementById("scene-name-menu-list")
            .insertAdjacentHTML("beforeend", htmlTag);

        const element = document
            .getElementById(`scene-instance-id-${instance.id}`);

        element.addEventListener("click", function (event)
        {
            const element = event.currentTarget;

            const frame = element.dataset.frame | 0;
            document
                .getElementById("current-frame")
                .textContent = `${frame}`;

            const workSpace = Util.$currentWorkSpace();
            workSpace.scene = workSpace.getLibrary(
                element.dataset.libraryId | 0
            );

            const moveX = (frame - 1) * 13;
            document
                .getElementById("timeline-marker")
                .style
                .left = `${moveX}px`;

            const base = document
                .getElementById("timeline-controller-base");

            const x = moveX > base.offsetWidth / 2
                ? moveX - base.offsetWidth / 2
                : 0;
            Util.$timeline.moveTimeLine(x);

            element.remove();
        });

    }

    /**
     * @return {void}
     * @public
     */
    stop ()
    {
        const layers = [];
        for (const layer of this._$layers.values()) {
            layers.push(layer);

            const characters =  layer._$characters;
            for (let idx = 0; idx < characters.length; ++idx) {
                characters[idx]._$image = null;
            }

        }

        this._$layers.clear();
        for (let idx = 0; idx < layers.length; ++idx) {
            this._$layers.set(idx, layers[idx]);
        }

        if (this.id) {

            const element = document
                .getElementById(`library-child-id-${this.id}`);

            element.draggable = true;

        }
    }

    /**
     * @return {array}
     * @public
     */
    get labels ()
    {
        const labels = [];
        for (let [frame, value] of this._$labels) {
            labels.push({
                "frame": frame,
                "name": value
            });
        }
        return labels;
    }

    /**
     * @param  {array} labels
     * @return {void}
     * @public
     */
    set labels (labels)
    {
        for (let idx = 0; idx < labels.length; ++idx) {

            const object = labels[idx];

            this._$labels.set(
                object.frame | 0,
                object.name
            );

        }
    }

    /**
     * @param  {number} frame
     * @param  {string} value
     * @return {void}
     * @public
     */
    setLabel (frame, value)
    {
        this._$labels.set(frame | 0, value);
    }

    /**
     * @param  {number} frame
     * @return {object}
     * @public
     */
    gerLabel (frame)
    {
        return this._$labels.has(frame)
            ? this._$labels.get(frame | 0)
            : null;
    }

    /**
     * @param  {number} frame
     * @return {void}
     * @public
     */
    deleteLabel (frame)
    {
        this._$labels.delete(frame | 0);
    }

    /**
     * @return {object}
     * @public
     */
    get parent ()
    {
        return this._$parent;
    }

    /**
     * @return {array}
     * @public
     */
    get layers ()
    {
        const layers = [];
        for (const value of this._$layers.values()) {
            layers.push(value.toObject());
        }
        return layers;
    }

    /**
     * @param  {array} layers
     * @return {void}
     * @public
     */
    set layers (layers)
    {
        for (let idx = 0; idx < layers.length; ++idx) {
            this._$layers.set(idx, new Layer(layers[idx]));
        }
    }

    /**
     * @param  {Layer} [layer=null]
     * @return {void}
     * @public
     */
    addLayer (layer = null)
    {
        if (!layer) {
            layer = new Layer();
        }
        this._$layers.set(this._$layerId, layer);
        layer.initialize();
    }

    /**
     * @param  {number} layer_id
     * @return {Layer}
     * @public
     */
    getLayer (layer_id)
    {
        return this._$layers.get(layer_id | 0);
    }

    /**
     * @param  {number} layer_id
     * @param  {Layer}  layer
     * @return {void}
     * @public
     */
    setLayer (layer_id, layer)
    {
        this._$layers.set(layer_id | 0, layer);
    }

    /**
     * @param  {number} layer_id
     * @return {void}
     * @public
     */
    deleteLayer (layer_id)
    {
        this._$layers.delete(layer_id | 0);
    }

    /**
     * @return {void}
     * @public
     */
    clearLayer ()
    {
        this._$layers.clear();
    }

    /**
     * @return {object[]}
     * @public
     */
    get placeMap ()
    {
        const placeMap = [];
        for (let [frame, values] of this._$placeMap) {
            placeMap.push({
                "frame": frame,
                "values": values
            });
        }
        return placeMap;
    }

    /**
     * @param {array} values
     * @public
     */
    set placeMap (values)
    {
        for (let idx = 0; idx < values.length; ++idx) {
            const object = values[idx];
            this._$placeMap.set(object.frame | 0, object.values);
        }
    }

    /**
     * @return {array}
     * @public
     */
    get sounds ()
    {
        const sounds = [];
        for (let [frame, sound] of this._$sounds) {
            sounds.push({
                "frame": frame,
                "sound": sound
            });
        }
        return sounds;
    }

    /**
     * @param  {array} sounds
     * @return {void}
     * @public
     */
    set sounds (sounds)
    {
        for (let idx = 0; idx < sounds.length; ++idx) {
            const object = sounds[idx];
            this._$sounds.set(object.frame | 0, object.sound);
        }
    }

    /**
     * @return {array}
     * @public
     */
    get actions ()
    {
        const actions = [];
        for (let [frame, action] of this._$actions) {
            actions.push({
                "frame": frame,
                "action": action
            });
        }
        return actions;
    }

    /**
     * @param  {array} actions
     * @return {void}
     * @public
     */
    set actions (actions)
    {
        for (let idx = 0; idx < actions.length; ++idx) {
            const object = actions[idx];
            this._$actions.set(object.frame | 0, object.action);
        }
    }

    /**
     * @param  {number} frame
     * @return {string}
     * @public
     */
    getAction (frame)
    {
        return this._$actions.get(frame);
    }

    /**
     * @param  {number} frame
     * @param  {string} script
     * @return {void}
     * @public
     */
    setAction (frame, script)
    {
        this._$actions.set(frame, script);

        Util
            .$currentWorkSpace()
            .initializeInternalScript();
    }

    /**
     * @param  {number} frame
     * @return {boolean}
     * @public
     */
    hasAction (frame)
    {
        return this._$actions.has(frame);
    }

    /**
     * @param  {number} frame
     * @return {void}
     * @public
     */
    deleteAction (frame)
    {
        this._$actions.delete(frame);

        Util
            .$currentWorkSpace()
            .initializeInternalScript();
    }

    /**
     * @param  {number} frame
     * @return {array}
     * @public
     */
    getPlaceMap (frame)
    {
        return this._$placeMap.get(frame);
    }

    /**
     * @param  {number} frame
     * @return {boolean}
     */
    hasPlaceMap (frame)
    {
        return this._$placeMap.has(frame);
    }

    /**
     * @param  {object} place
     * @param  {boolean} [preview=false]
     * @return {object}
     * @public
     */
    getBounds (place, preview = false)
    {
        if (!this._$layers.size) {
            return {
                "xMin": 0,
                "xMax": 0,
                "yMin": 0,
                "yMax": 0
            };
        }

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        const object  = this.toPublish();
        const frame   = preview ? 1 : this.getFrame(place, object.totalFrame);
        const element = document.getElementById("current-frame");

        // cache
        const currentFrame  = element.textContent | 0;

        const workSpace = Util.$currentWorkSpace();

        // over write
        element.textContent = `${frame}`;
        for (const layer of this._$layers.values()) {

            if (layer.disable) {
                continue;
            }

            const characters = layer.getActiveCharacter(frame);

            const length = characters.length;
            for (let idx = 0; idx < length; ++idx) {

                const character = characters[idx];
                const place     = character.getPlace(frame);
                const matrix    = place.matrix;

                let bounds = null;
                if (!character.width || !character.height) {
                    bounds = {
                        "xMin": matrix[4],
                        "xMax": matrix[4],
                        "yMin": matrix[5],
                        "yMax": matrix[5]
                    };
                } else {
                    const instance = workSpace.getLibrary(character.libraryId | 0);
                    bounds = Util.$boundsMatrix(instance.getBounds(place), matrix);
                }

                xMin = Math.min(bounds.xMin, xMin);
                xMax = Math.max(bounds.xMax, xMax);
                yMin = Math.min(bounds.yMin, yMin);
                yMax = Math.max(bounds.yMax, yMax);

            }
        }

        element.textContent = `${currentFrame}`;

        return {
            "xMin": xMin,
            "xMax": xMax,
            "yMin": yMin,
            "yMax": yMax
        };
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":       this.id,
            "name":     this.name,
            "type":     this.type,
            "symbol":   this.symbol,
            "folderId": this.folderId,
            "parent":   this.parent,
            "layers":   this.layers,
            "labels":   this.labels,
            "placeMap": this.placeMap,
            "sounds":   this.sounds,
            "actions":  this.actions
        };
    }

    /**
     * @return {object}
     * @public
     */
    toPublish ()
    {
        const dictionary   = [];
        const controller   = [];
        const placeMap     = [];
        const placeObjects = [];

        const workSpace  = Util.$currentWorkSpace();
        const libraryMap = new Map();

        let index = 0;
        for (const id of workSpace._$libraries.keys()) {
            libraryMap.set(id, index++);
        }

        // setup
        let currentPlaceId = 0;
        let clipStart      = false;
        let clipIndex      = 0;
        const setting      = Util.$tools.getUserPublishSetting();

        const layers = Array.from(this._$layers);

        const clipLayers = [];
        let clipCount    = 0;
        let depth        = 0;
        for (let idx = layers.length - 1; idx > -1; --idx) {

            if (clipIndex && !clipLayers.length) {
                clipIndex = 0;
                clipCount = 0;
                continue;
            }

            const layer = !clipStart && clipLayers.length
                ? clipLayers.shift()
                : layers[idx][1];

            // 非表示レイヤー処理
            if (!setting.layer && layer.disable) {
                continue;
            }

            if (layer.mode === Util.LAYER_MODE_MASK_IN
                && !clipStart && !clipIndex
            ) {
                clipStart = true;
                clipIndex = idx;
            }

            if (clipStart && layer.mode === Util.LAYER_MODE_MASK_IN) {
                clipCount += layer._$characters.length;
                clipLayers.push(layer);
                continue;
            }

            const characters = layer._$characters;

            const length = layer.mode === Util.LAYER_MODE_MASK
                ? Math.min(1, characters.length)
                : characters.length;

            let index = layer.mode === Util.LAYER_MODE_MASK
                ? length - 1
                : 0;

            for (;;) {

                const id = dictionary.length;

                const character = characters[index];
                if (!character) {
                    break;
                }

                const startFrame = character.startFrame;
                const endFrame   = character.endFrame;

                const instance = workSpace._$libraries.get(character.libraryId);
                if (!Util.$useIds.has(instance.id)) {
                    Util.$useIds.set(instance.id, true);
                }

                dictionary.push({
                    "name": character.name,
                    "characterId": instance.id,
                    "endFrame": endFrame,
                    "startFrame": startFrame,
                    "clipDepth": layer.mode === Util.LAYER_MODE_MASK
                        ? index + clipCount + currentPlaceId
                        : 0
                });

                let placeIndex = 0;
                for (let frame = startFrame; frame < endFrame; ++frame) {

                    if (!(frame in controller)) {
                        controller[frame] = [];
                    }

                    if (!(frame in placeMap)) {
                        placeMap[frame] = [];
                    }

                    const place = character.getPlace(frame);
                    if (character.hasPlace(frame)) {

                        placeIndex = placeObjects.length;

                        const filters = [];
                        for (let idx = 0; idx < place.filter.length; ++idx) {
                            const filter = place.filter[idx];
                            if (!filter.state) {
                                continue;
                            }

                            filters.push({
                                "class": filter.name,
                                "params": filter.toParamArray()
                            });
                        }

                        const placeObject = {
                            "matrix": place.matrix,
                            "colorTransform": place.colorTransform,
                            "blendMode": place.blendMode,
                            "surfaceFilterList": filters
                        };

                        if (instance.type === "container") {

                            if (place.loop.referenceFrame) {

                                const referencePlace = character.getPlace(
                                    place.loop.referenceFrame
                                );

                                placeObject.loop = {
                                    "type": referencePlace.loop.type,
                                    "frame": referencePlace.frame,
                                    "start": referencePlace.loop.start,
                                    "end": referencePlace.loop.end
                                };

                            } else {

                                placeObject.loop = {
                                    "type": place.loop.type,
                                    "frame": place.frame,
                                    "start": place.loop.start,
                                    "end": place.loop.end
                                };
                            }

                            if (place.loop.tweenFrame) {
                                placeObject.loop.tweenFrame = place.loop.tweenFrame;
                            }
                        }

                        placeObjects.push(placeObject);
                    }

                    controller[frame][depth + place.depth] = id;
                    placeMap[frame][depth   + place.depth] = placeIndex;
                }

                if (layer.mode === Util.LAYER_MODE_MASK) {
                    --index;
                    if (-1 === index) {
                        break;
                    }
                } else {
                    ++index;
                    if (index === length) {
                        break;
                    }
                }
            }

            currentPlaceId += length;
            depth += length;

            if (clipStart && clipLayers.length) {
                idx = clipIndex + 1;
                clipStart = false;
            }
        }

        // empty keyを詰める
        for (let frame = 1; controller.length > frame; ++frame) {

            if (!(frame in controller)) {
                continue;
            }

            const characters = controller[frame];
            const placeMaps  = placeMap[frame];

            controller[frame] = characters.filter((value) => { return typeof value === "number" });
            placeMap[frame]   = placeMaps.filter((value)  => { return typeof value === "number" });
        }

        const sounds = [];
        for (let [frame, values] of this._$sounds) {

            const object = {
                "frame": frame,
                "sound": []
            };

            for (let idx = 0; idx < values.length; ++idx) {

                const sound = values[idx];

                const characterId = sound.characterId | 0;
                object.sound.push({
                    "characterId": characterId,
                    "volume":      sound.volume / 100,
                    "autoPlay":    sound.autoPlay,
                    "loop":        sound.loop
                });

                if (!Util.$useIds.has(characterId)) {
                    Util.$useIds.set(characterId, true);
                }
            }

            sounds.push(object);
        }

        const actions = [];
        for (let [frame, action] of this._$actions) {

            const scriptList = action
                .replace(/("[^"]*\/\/.*?")|\/\/(?:.|\r?\n)*?(?:\r?\n|.*)?/g, "$1")
                .replace(/(["'][^"']*\/\*.*?\*\/[^"']*["'])|\/\*(?:.|\r?\n)*?\*\//g, "$1")
                .replace(/^\s+|\s+$/g, "")
                .replace(/ +/g, " ")
                .split(/\r?\n/);

            let list = [];
            for (let idx = 0; idx < scriptList.length; ++idx) {
                const value = scriptList[idx].trim();
                if (!value.length) {
                    continue;
                }

                list.push(value);
            }

            actions.push({
                "frame": frame,
                "action": list.join("\n")

            });
        }

        return {
            "actions": actions,
            "symbol":  this.symbol,
            "extends": this.defaultSymbol,
            "totalFrame": this.totalFrame,
            "controller": controller,
            "dictionary": dictionary,
            "labels": this.labels,
            "placeMap": placeMap,
            "placeObjects": placeObjects,
            "sounds": sounds
        };
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.display.MovieClip.namespace;
    }

    /**
     * @param  {object} place
     * @param  {number} total_frame
     * @return {number}
     */
    getFrame (place, total_frame)
    {
        const currentFrame = document
            .getElementById("current-frame")
            .textContent | 0;

        const length = currentFrame
            - (place.loop.referenceFrame || place.frame);

        let frame = 1;
        switch (place.loop.type) {

            case 0:
                {
                    const totalFrame = place.loop.end
                        ? place.loop.end
                        : total_frame;

                    frame = place.loop.start;

                    for (let idx = 0; idx < length; ++idx) {

                        ++frame;

                        if (frame > totalFrame) {
                            frame = place.loop.start;
                        }

                    }
                }
                break;

            case 1:
                {
                    const totalFrame = place.loop.end
                        ? place.loop.end
                        : total_frame;

                    frame = Math.min(totalFrame, place.loop.start + length);
                }
                break;

            case 2:
                frame = place.loop.start;
                break;

            case 3:
                frame = place.loop.end
                    ? place.loop.end
                    : total_frame;

                frame = Math.max(place.loop.start, frame - length);
                break;

            case 4:
                {
                    const totalFrame = place.loop.end
                        ? place.loop.end
                        : total_frame;

                    frame = totalFrame;
                    for (let idx = 0; idx < length; ++idx) {

                        --frame;

                        if (place.loop.start > frame) {
                            frame = totalFrame;
                        }

                    }
                }
                break;

        }

        return frame;
    }

    /**
     * @param  {object}  place
     * @param  {boolean} [preview=false]
     * @return {next2d.display.Sprite}
     * @public
     */
    createInstance (place, preview = false)
    {
        const { MovieClip } = window.next2d.display;
        const { Matrix, ColorTransform } = window.next2d.geom;

        const workSpace = Util.$currentWorkSpace();
        const movieClip = new MovieClip();

        const object = this.toPublish();
        const frame  = preview ? 1 : this.getFrame(place, this.totalFrame);

        const controller = object.controller[frame];
        const placeMap   = object.placeMap[frame];
        for (let idx = 0; controller.length > idx; ++idx) {

            const tag      = object.dictionary[controller[idx]];
            const instance = workSpace.getLibrary(tag.characterId);
            const place    = object.placeObjects[placeMap[idx]];

            let displayObject = null;
            switch (instance.type) {

                case "container":
                    displayObject = instance._$layers.size
                        ? instance.createInstance(place, preview)
                        : new MovieClip();
                    break;

                case "shape":
                    displayObject = instance.createInstance();
                    displayObject._$bitmapId = instance._$bitmapId;
                    break;

                default:
                    displayObject = instance.createInstance();
                    break;

            }

            displayObject.transform.matrix = new Matrix(
                place.matrix[0], place.matrix[1], place.matrix[2],
                place.matrix[3], place.matrix[4], place.matrix[5]
            );

            displayObject.transform.colorTransform = new ColorTransform(
                place.colorTransform[0], place.colorTransform[1],
                place.colorTransform[2], place.colorTransform[3],
                place.colorTransform[4], place.colorTransform[5],
                place.colorTransform[6], place.colorTransform[7]
            );

            displayObject.blendMode = place.blendMode;

            const filters = [];
            for (let idx = 0; idx < place.surfaceFilterList.length; ++idx) {

                const filterTag = place.surfaceFilterList[idx];
                const filterClass = window.next2d.filters[filterTag.class];

                filters.push(
                    new (filterClass.bind.apply(filterClass, filterTag.params))()
                );
            }
            displayObject.filters = filters;

            // tag data
            displayObject._$placeId     = idx;
            displayObject._$characterId = tag.characterId;
            displayObject._$clipDepth   = tag.clipDepth;

            // added
            movieClip.addChild(displayObject);
        }

        return movieClip;
    }
}

/**
 * @class
 */
class Shape extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object = null)
    {
        super(object);

        this._$bitmapId = 0;
        this._$bounds   = null;
        this._$grid     = null;
        this._$recodes  = [];

        if (object.recodes) {
            this.recodes = object.recodes;
        }

        if (object.bounds) {
            this.bounds = object.bounds;
        }

        if (object.bitmapId) {
            this.bitmapId = object.bitmapId;
        }

        if (object.grid) {
            this.grid = object.grid;
        }
    }

    /**
     * @return {object}
     * @public
     */
    getBounds ()
    {
        return this._$bounds;
    }

    /**
     * @return {number}
     * @public
     */
    get width ()
    {
        return Math.abs(this._$bounds.xMax - this._$bounds.xMin);
    }

    /**
     * @return {number}
     * @public
     */
    get height ()
    {
        return Math.abs(this._$bounds.yMax - this._$bounds.yMin);
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.display.Shape.namespace;
    }

    /**
     * @return {array}
     * @public
     */
    get recodes ()
    {
        return this._$recodes;
    }

    /**
     * @param {array} recodes
     * @public
     */
    set recodes (recodes)
    {
        this._$recodes = recodes;
    }

    /**
     * @return {object|null}
     * @public
     */
    get bounds ()
    {
        return this._$bounds;
    }

    /**
     * @param {object} [bounds=null]
     * @public
     */
    set bounds (bounds)
    {
        this._$bounds = bounds;
    }

    /**
     * @return {object}
     * @public
     */
    get offset ()
    {
        return this._$offset;
    }

    /**
     * @param  {object} offset
     * @return {void}
     * @public
     */
    set offset (offset)
    {
        this._$offset = offset;
    }

    /**
     * @return {number}
     * @public
     */
    get bitmapId ()
    {
        return this._$bitmapId;
    }

    /**
     * @param  {number} bitmap_id
     * @return {void}
     * @public
     */
    set bitmapId (bitmap_id)
    {
        this._$bitmapId = bitmap_id | 0;
    }

    /**
     * @return {object|null}
     * @public
     */
    get grid ()
    {
        return this._$grid;
    }

    /**
     * @param {object} [grid=null]
     * @public
     */
    set grid (grid)
    {
        this._$grid = grid;
    }

    /**
     * @param  {array}  matrix
     * @param  {number} layer_id
     * @param  {number} character_id
     * @return {void}
     * @public
     */
    createPointer (matrix, layer_id, character_id)
    {
        Util.$clearShapePointer();

        const element = document.getElementById("stage-area");

        let syncId = 2;
        const { Graphics } = window.next2d.display;
        for (let idx = 0; idx < this._$recodes.length; ) {

            switch (this._$recodes[idx++]) {

                case Graphics.MOVE_TO:
                    syncId = idx;
                    idx += 2;
                    break;

                case Graphics.LINE_TO:

                    this.addPointer(
                        layer_id,
                        character_id,
                        idx,
                        this._$recodes[idx++],
                        this._$recodes[idx++],
                        matrix,
                        Graphics.LINE_TO
                    );

                    this.adjustmentPointer(idx, matrix, layer_id, character_id, syncId);

                    break;

                case Graphics.CUBIC:

                    for (let jdx = 0; 2 > jdx; ++jdx) {
                        this.addPointer(
                            layer_id,
                            character_id,
                            idx,
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            matrix,
                            Graphics.CUBIC,
                            true
                        );
                    }

                    this.addPointer(
                        layer_id,
                        character_id,
                        idx,
                        this._$recodes[idx++],
                        this._$recodes[idx++],
                        matrix,
                        Graphics.CUBIC,
                        false
                    );

                    this.adjustmentPointer(idx, matrix, layer_id, character_id, syncId);

                    break;

                case Graphics.CURVE_TO:

                    this.addPointer(
                        layer_id,
                        character_id,
                        idx,
                        this._$recodes[idx++],
                        this._$recodes[idx++],
                        matrix,
                        Graphics.CURVE_TO,
                        true
                    );

                    this.addPointer(
                        layer_id,
                        character_id,
                        idx,
                        this._$recodes[idx++],
                        this._$recodes[idx++],
                        matrix,
                        Graphics.CURVE_TO
                    );

                    this.adjustmentPointer(idx, matrix, layer_id, character_id, syncId);

                    break;

                case Graphics.FILL_STYLE:
                    idx += 4;
                    break;

                case Graphics.STROKE_STYLE:
                    idx += 8;
                    break;

                case Graphics.GRADIENT_FILL:
                    idx += 6;
                    break;

                case Graphics.GRADIENT_STROKE:
                    idx += 10;
                    break;

                case Graphics.BEGIN_PATH:
                case Graphics.END_FILL:
                case Graphics.END_STROKE:
                    break;

                default:
                    break;

            }

        }

        Util.$addModalEvent(element);
    }

    /**
     * @param  {number} index
     * @param  {array}  matrix
     * @param  {number} layer_id
     * @param  {number} character_id
     * @param  {number} sync_id
     * @return {void}
     * @public
     */
    adjustmentPointer (index, matrix, layer_id, character_id, sync_id)
    {
        const { Graphics } = window.next2d.display;
        switch (this._$recodes[index]) {

            case Graphics.MOVE_TO:
            case Graphics.FILL_STYLE:
            case Graphics.GRADIENT_FILL:
                {
                    const children = document
                        .getElementById("stage-area")
                        .children;

                    const node = children[children.length - 1];
                    node.dataset.syncId = `${sync_id}`;
                }
                break;

            case Graphics.STROKE_STYLE:
            case Graphics.GRADIENT_STROKE:
                this.addPointer(
                    layer_id,
                    character_id,
                    5,
                    this._$recodes[5],
                    this._$recodes[6],
                    matrix,
                    Graphics.MOVE_TO
                );
                break;

            default:
                break;

        }
    }

    /**
     * @param  {number}  layer_id
     * @param  {number}  character_id
     * @param  {number}  index
     * @param  {number}  x
     * @param  {number}  y
     * @param  {array}   matrix
     * @param  {number}  type
     * @param  {boolean} [curve=false]
     * @return {void}
     * @public
     */
    addPointer (
        layer_id, character_id, index, x, y, matrix, type, curve = false
    ) {

        const stageArea = document
            .getElementById("stage-area");

        const div = document.createElement("div");

        div.classList.add("transform");

        // dataset
        div.dataset.shapePointer = "true";
        div.dataset.layerId      = `${layer_id}`;
        div.dataset.characterId  = `${character_id}`;
        div.dataset.index        = `${index}`;
        div.dataset.libraryId    = `${this.id}`;
        div.dataset.curve        = `${curve}`;
        div.dataset.type         = `${type}`;
        div.dataset.position     = `${stageArea.children.length}`;

        // css
        const tx = x * matrix[0] + y * matrix[2] + matrix[4];
        const ty = x * matrix[1] + y * matrix[3] + matrix[5];

        div.style.left = `${tx + Util.$offsetLeft - 3}px`;
        div.style.top  = `${ty + Util.$offsetTop  - 3}px`;

        if (curve) {
            div.style.borderRadius = "5px";
        } else {
            div.dataset.detail = "{{ダブルクリックでカーブポイントが追加されます}}";
        }

        div.addEventListener("mousedown", (event) =>
        {
            const { Graphics } = window.next2d.display;

            const stageArea = document
                .getElementById("stage-area");

            const target = Util.$screen._$shapeMoveTarget;
            if (target) {

                Util.$screen._$objectClicked = true;
                target.style.backgroundColor = "";

                const position = target.dataset.position | 0;
                const type     = target.dataset.type | 0;
                const curve    = target.dataset.curve === "true";
                switch (type) {

                    case Graphics.CURVE_TO:
                        if (curve) {
                            stageArea.children[position + 1].style.backgroundColor = "";
                        } else {
                            stageArea.children[position - 1].style.backgroundColor = "";
                        }
                        break;

                    case Graphics.CUBIC:
                        if (curve) {
                            for (let idx = 1; idx < 3; ++idx) {
                                const element = stageArea.children[position + idx];
                                element.style.backgroundColor = "";
                                if (element.dataset.curve !== "true") {
                                    if (idx === 1) {
                                        stageArea.children[position - 1].style.backgroundColor = "";
                                    }
                                    break;
                                }
                            }
                        } else {
                            stageArea.children[position - 1].style.backgroundColor = "";
                            stageArea.children[position - 2].style.backgroundColor = "";
                        }
                        break;

                }
            }

            const element = event.target;
            element.style.backgroundColor = Util.$shapePointerColor;

            const position = element.dataset.position | 0;
            const type     = element.dataset.type | 0;
            const curve    = element.dataset.curve === "true";

            switch (type) {

                case Graphics.CURVE_TO:
                    if (curve) {
                        stageArea
                            .children[position + 1]
                            .style
                            .backgroundColor = Util.$shapeLinkedPointerColor;
                    } else {
                        stageArea
                            .children[position - 1]
                            .style
                            .backgroundColor = Util.$shapeLinkedPointerColor;
                    }
                    break;

                case Graphics.CUBIC:
                    if (curve) {
                        for (let idx = 1; idx < 3; ++idx) {
                            const element = stageArea.children[position + idx];
                            element
                                .style
                                .backgroundColor = Util.$shapeLinkedPointerColor;
                            if (element.dataset.curve !== "true") {
                                if (idx === 1) {
                                    stageArea
                                        .children[position - 1]
                                        .style
                                        .backgroundColor = Util.$shapeLinkedPointerColor;
                                }
                                break;
                            }
                        }
                    } else {
                        stageArea
                            .children[position - 1]
                            .style
                            .backgroundColor = Util.$shapeLinkedPointerColor;

                        stageArea
                            .children[position - 2]
                            .style
                            .backgroundColor = Util.$shapeLinkedPointerColor;
                    }
                    break;

            }

            Util.$screen._$shapeMovePointer = true;
            Util.$screen._$shapeMoveTarget  = element;

            Util.$screen._$rectPosition = {
                "x": event.pageX - element.offsetLeft,
                "y": event.pageY - element.offsetTop
            };

            Util
                .$currentWorkSpace()
                .temporarilySaved();

            Util.$screen._$shapeAddPointer = false;
        });

        div.addEventListener("dblclick", (event) =>
        {
            const { Graphics } = window.next2d.display;

            const workSpace = Util.$currentWorkSpace();

            const target = Util.$screen._$shapeMoveTarget;
            if (target) {

                Util.$screen._$objectClicked = true;
                target.style.backgroundColor = "";

                const position = target.dataset.position | 0;
                const type     = target.dataset.type | 0;
                const curve    = target.dataset.curve === "true";
                switch (type) {

                    case Graphics.CURVE_TO:
                        if (curve) {
                            stageArea.children[position + 1].style.backgroundColor = "";
                        } else {
                            stageArea.children[position - 1].style.backgroundColor = "";
                        }
                        break;

                    case Graphics.CUBIC:
                        if (curve) {
                            for (let idx = 1; idx < 3; ++idx) {
                                const element = stageArea.children[position + idx];
                                element.style.backgroundColor = "";
                                if (element.dataset.curve !== "true") {
                                    if (idx === 1) {
                                        stageArea.children[position - 1].style.backgroundColor = "";
                                    }
                                    break;
                                }
                            }
                        } else {
                            stageArea.children[position - 1].style.backgroundColor = "";
                            stageArea.children[position - 2].style.backgroundColor = "";
                        }
                        break;

                }
            }

            const element = event.target;
            const curve   = element.dataset.curve === "true";
            if (!curve) {

                const type  = element.dataset.type | 0;
                const index = element.dataset.index | 0;

                const instance = workSpace.getLibrary(
                    element.dataset.libraryId | 0
                );

                switch (type) {

                    case Graphics.LINE_TO:
                        {
                            workSpace
                                .temporarilySaved();

                            instance._$recodes[index - 1] = Graphics.CURVE_TO;

                            const tx = instance._$recodes[index    ];
                            const ty = instance._$recodes[index + 1];
                            instance._$recodes.splice(index + 2, 0, tx, ty);

                            instance._$recodes[index    ] += 20;
                            instance._$recodes[index + 1] += 20;

                            instance.cacheClear();

                            const frame = document
                                .getElementById("current-frame")
                                .textContent | 0;

                            Util
                                .$currentWorkSpace()
                                .scene
                                .changeFrame(frame);

                            instance.createPointer(matrix, layer_id, character_id);
                        }
                        break;

                    case Graphics.CURVE_TO:
                        {
                            workSpace
                                .temporarilySaved();

                            instance._$recodes[index - 3] = Graphics.CUBIC;

                            const tx = instance._$recodes[index    ];
                            const ty = instance._$recodes[index + 1];
                            instance._$recodes.splice(index + 2, 0, tx, ty);

                            instance._$recodes[index    ] += 20;
                            instance._$recodes[index + 1] += 20;

                            instance.cacheClear();

                            const frame = document
                                .getElementById("current-frame")
                                .textContent | 0;
                            Util.$currentWorkSpace().scene.changeFrame(frame);

                            instance.createPointer(matrix, layer_id, character_id);
                        }
                        break;

                }
            }

            // lock
            Util.$screen._$shapeAddPointer = true;
        });

        stageArea.appendChild(div);
    }

    /**
     * @return {object}
     * @public
     */
    reloadBounds (stroke = 0)
    {
        const { Graphics, Shape } = window.next2d.display;
        const shape = new Shape();

        if (stroke) {
            shape
                .graphics
                .lineStyle(stroke);
        } else {
            shape
                .graphics
                .beginFill();
        }

        for (let idx = 0; idx < this._$recodes.length; ) {

            switch (this._$recodes[idx++]) {

                case Graphics.MOVE_TO:
                    shape
                        .graphics
                        .moveTo(
                            this._$recodes[idx++],
                            this._$recodes[idx++]
                        );
                    break;

                case Graphics.LINE_TO:
                    shape
                        .graphics
                        .lineTo(
                            this._$recodes[idx++],
                            this._$recodes[idx++]
                        );
                    break;

                case Graphics.CUBIC:
                    shape
                        .graphics
                        .cubicCurveTo(
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++]
                        );
                    break;

                case Graphics.CURVE_TO:
                    shape
                        .graphics
                        .curveTo(
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++]
                        );
                    break;

                case Graphics.FILL_STYLE:
                    idx += 4;
                    break;

                case Graphics.STROKE_STYLE:
                    idx += 8;
                    break;

                case Graphics.GRADIENT_FILL:
                    {
                        const { Matrix } = window.next2d.geom;
                        const matrix = new Matrix();
                        const xScale = this.width  / 2 / 819.2;
                        const yScale = this.height / 2 / 819.2;
                        matrix.scale(xScale, yScale);
                        matrix.translate(
                            this.width  / 2 + shape.graphics._$xMin,
                            this.height / 2 + shape.graphics._$yMin
                        );

                        this._$recodes[idx + 2] = Array.from(matrix._$matrix);
                        idx += 6;
                    }
                    break;

                case Graphics.GRADIENT_STROKE:
                    {
                        const { Matrix } = window.next2d.geom;
                        const matrix = new Matrix();
                        const xScale = this.width  / 2 / 819.2;
                        const yScale = this.height / 2 / 819.2;
                        matrix.scale(xScale, yScale);
                        matrix.translate(
                            this.width  / 2 + shape.graphics._$xMin,
                            this.height / 2 + shape.graphics._$yMin
                        );

                        this._$recodes[idx + 6] = Array.from(matrix._$matrix);
                        idx += 10;
                    }
                    break;

                case Graphics.BEGIN_PATH:
                case Graphics.END_FILL:
                case Graphics.END_STROKE:
                    break;

                default:
                    break;

            }

        }

        return {
            "xMin": shape.graphics._$xMin,
            "xMax": shape.graphics._$xMax,
            "yMin": shape.graphics._$yMin,
            "yMax": shape.graphics._$yMax
        };
    }

    /**
     * @return {Shape}
     * @public
     */
    copyFrom (shape)
    {
        shape._$recodes  = this._$recodes.slice();
        shape._$bounds   = {
            "xMin": this._$bounds.xMin,
            "xMax": this._$bounds.xMax,
            "yMin": this._$bounds.yMin,
            "yMax": this._$bounds.yMax
        };
        shape._$bitmapId = this._$bitmapId;

        return shape;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":       this.id,
            "name":     this.name,
            "type":     this.type,
            "symbol":   this.symbol,
            "folderId": this.folderId,
            "bitmapId": this.bitmapId,
            "grid":     this.grid,
            "recodes":  this.recodes,
            "bounds":   this.bounds
        };
    }

    /**
     * @return {object}
     * @public
     */
    toPublish ()
    {
        if (this._$bitmapId) {
            Util.$useIds.set(this._$bitmapId, true);
        }

        return {
            "symbol":   this.symbol,
            "extends":  this.defaultSymbol,
            "bitmapId": this.bitmapId,
            "grid":     this.grid,
            "recodes":  this.recodes,
            "bounds": {
                "xMin": this._$bounds.xMin,
                "xMax": this._$bounds.xMax,
                "yMin": this._$bounds.yMin,
                "yMax": this._$bounds.yMax
            }
        };
    }

    /**
     * @param {string} style
     * @return {void}
     * @public
     */
    changeStyle (style)
    {
        const { Graphics, GradientType } = window.next2d.display;

        const index = Util.$hitColor.index;
        const currentStyle = Util.$hitColor.style;
        switch (currentStyle) {

            case Graphics.BITMAP_FILL:
            case Graphics.FILL_STYLE:
                {
                    const element = document
                        .getElementById("fill-color-type-select");

                    switch (element.value) {

                        case GradientType.LINEAR:
                        case GradientType.RADIAL:
                            {
                                const colorValue = document
                                    .getElementById("fill-color-value")
                                    .value;

                                const color = Util.$intToRGB(
                                    `0x${colorValue.substr(1)}` | 0
                                );

                                const alpha = (document
                                    .getElementById("fill-alpha-value")
                                    .value | 0) / 100 * 255;

                                this.changeGradient(
                                    index, style, Graphics.GRADIENT_FILL,
                                    6, color, alpha
                                );
                            }
                            break;

                        default:
                            break;

                    }
                }
                break;

            case Graphics.GRADIENT_FILL:
                {
                    const element = document
                        .getElementById("fill-color-type-select");

                    const stops = this._$recodes[index + 1];
                    const color = stops.pop();
                    switch (element.value) {

                        case "bitmap":
                        case "rgba":
                            this._$recodes.splice(index - 1, 12,
                                Graphics.FILL_STYLE,
                                color.R, color.G,
                                color.B, color.A,
                                Graphics.END_FILL
                            );

                            Util.$hitColor = {
                                "index": index,
                                "style": Graphics.FILL_STYLE,
                                "shape": this
                            };
                            break;

                        default:
                            this.changeGradient(
                                index, style, Graphics.GRADIENT_FILL,
                                12, color, color.A
                            );
                            break;

                    }
                }
                break;

            case Graphics.STROKE_STYLE:
                {
                    const element = document
                        .getElementById("fill-color-type-select");

                    switch (element.value) {

                        case GradientType.LINEAR:
                        case GradientType.RADIAL:
                            {
                                const colorValue = document
                                    .getElementById("fill-color-value")
                                    .value;

                                const color = Util.$intToRGB(
                                    `0x${colorValue.substr(1)}` | 0
                                );

                                const alpha = (document
                                    .getElementById("fill-alpha-value")
                                    .value | 0) / 100 * 255;

                                this.changeGradient(
                                    index, style, Graphics.GRADIENT_STROKE,
                                    5, color, alpha
                                );
                            }
                            break;

                        default:
                            break;

                    }
                }
                break;

            case Graphics.GRADIENT_STROKE:
                {
                    const element = document
                        .getElementById("fill-color-type-select");

                    const stops      = this._$recodes[index + 5];
                    const color      = stops.pop();
                    const width      = this._$recodes[index];
                    const caps       = this._$recodes[index + 1];
                    const joints     = this._$recodes[index + 2];
                    const miterLimit = this._$recodes[index + 3];
                    switch (element.value) {

                        case "bitmap":
                        case "rgba":
                            this._$recodes.splice(index - 1, 11,
                                Graphics.STROKE_STYLE,
                                width, caps,
                                joints, miterLimit,
                                color.R, color.G,
                                color.B, color.A,
                                Graphics.END_STROKE
                            );

                            Util.$hitColor = {
                                "index": index,
                                "width": width,
                                "style": Graphics.STROKE_STYLE,
                                "shape": this
                            };
                            break;

                        default:
                            this.changeGradient(
                                index, style, Graphics.GRADIENT_STROKE,
                                6, color, color.A
                            );
                            break;

                    }
                }
                break;

        }

        this.cacheClear();

        const frame = document
            .getElementById("current-frame")
            .textContent | 0;

        Util.$currentWorkSpace().scene.changeFrame(frame);
    }

    /**
     * @param  {number} index
     * @param  {string} style
     * @param  {number} graphics_type
     * @param  {number} delete_number
     * @param  {object} color
     * @param  {number} alpha
     * @return {void}
     * @public
     */
    changeGradient (index, style, graphics_type, delete_number, color, alpha)
    {
        const { Graphics, SpreadMethod, InterpolationMethod } = window.next2d.display;
        const { Matrix } = window.next2d.geom;

        const matrix = new Matrix();
        const xScale = this.width  / 2 / 819.2;
        const yScale = this.height / 2 / 819.2;
        matrix.scale(xScale, yScale);
        matrix.translate(
            this.width  / 2 + this._$bounds.xMin,
            this.height / 2 + this._$bounds.yMin
        );

        const ratios = [{
            "ratio": 0,
            "R": 255,
            "G": 255,
            "B": 255,
            "A": 255
        }, {
            "ratio": 1,
            "R": color.R,
            "G": color.G,
            "B": color.B,
            "A": alpha
        }];

        Util.$hitColor = {
            "index"  : index,
            "style"  : graphics_type,
            "type"   : style,
            "ratios" : ratios,
            "shape"  : this
        };

        if (Graphics.GRADIENT_STROKE === graphics_type) {

            this._$recodes[index - 1] = Graphics.GRADIENT_STROKE;

            this._$recodes.splice(index + 4, delete_number,
                style, ratios,
                Array.from(matrix._$matrix),
                SpreadMethod.PAD,
                InterpolationMethod.RGB,
                0
            );

            Util.$hitColor.width = this._$recodes[index];

        } else {

            this._$recodes.splice(index - 1, delete_number,
                graphics_type, style, ratios,
                Array.from(matrix._$matrix),
                SpreadMethod.PAD,
                InterpolationMethod.RGB,
                0
            );

        }

        Util.$controller.initializeGradient();
    }

    /**
     * @return {void}
     * @public
     */
    changeColor ()
    {
        const { Graphics } = window.next2d.display;

        const index = Util.$hitColor.index;
        switch (Util.$hitColor.style) {

            case Graphics.BITMAP_FILL:
                break;

            case Graphics.BITMAP_STROKE:
                {
                    const width = Util.$clamp(document
                        .getElementById("fill-stroke-width-value")
                        .value | 0, 1, 255);

                    if (this._$recodes[index] !== width) {

                        Util.$hitColor.width  = width;
                        this._$recodes[index] = width;

                        const bounds = this.reloadBounds(width);
                        this._$bounds.xMin = bounds.xMin;
                        this._$bounds.xMax = bounds.xMax;
                        this._$bounds.yMin = bounds.yMin;
                        this._$bounds.yMax = bounds.yMax;

                        this.cacheClear();
                    }
                }
                break;

            case Graphics.FILL_STYLE:
                {
                    const colorValue = document
                        .getElementById("fill-color-value")
                        .value;

                    const color = Util.$intToRGB(
                        `0x${colorValue.substr(1)}` | 0
                    );

                    this._$recodes[index    ] = color.R;
                    this._$recodes[index + 1] = color.G;
                    this._$recodes[index + 2] = color.B;
                    this._$recodes[index + 3] = Util.$clamp((document
                        .getElementById("fill-alpha-value")
                        .value | 0) / 100 * 255, 0, 255);
                }
                break;

            case Graphics.GRADIENT_FILL:
                {
                    const colors  = this._$recodes[index + 1];
                    const element = Util.$controller._$gradientTarget;

                    const colorIndex = element
                        ? element.dataset.index
                        : colors.length - 1;

                    const object = colors[colorIndex];

                    const colorValue = document
                        .getElementById("fill-color-value")
                        .value;

                    const color = Util.$intToRGB(
                        `0x${colorValue.substr(1)}` | 0
                    );

                    object.R = color.R;
                    object.G = color.G;
                    object.B = color.B;
                    object.A = Util.$clamp((document
                        .getElementById("fill-alpha-value")
                        .value | 0) / 100 * 255, 0, 255);
                }

                break;

            case Graphics.STROKE_STYLE:
                {
                    const colorValue = document
                        .getElementById("fill-color-value")
                        .value;

                    const color = Util.$intToRGB(
                        `0x${colorValue.substr(1)}` | 0
                    );

                    this._$recodes[index + 4] = color.R;
                    this._$recodes[index + 5] = color.G;
                    this._$recodes[index + 6] = color.B;
                    this._$recodes[index + 7] = Util.$clamp((document
                        .getElementById("fill-alpha-value")
                        .value | 0) / 100 * 255, 0, 255);

                    const width = Util.$clamp(document
                        .getElementById("fill-stroke-width-value")
                        .value | 0, 1, 255);

                    if (this._$recodes[index] !== width) {

                        Util.$hitColor.width  = width;
                        this._$recodes[index] = width;

                        const bounds = this.reloadBounds(width);
                        this._$bounds.xMin = bounds.xMin;
                        this._$bounds.xMax = bounds.xMax;
                        this._$bounds.yMin = bounds.yMin;
                        this._$bounds.yMax = bounds.yMax;

                        this.cacheClear();
                    }

                }
                break;

            case Graphics.GRADIENT_STROKE:
                {
                    const colors  = this._$recodes[index + 5];
                    const element = Util.$controller._$gradientTarget;

                    const colorIndex = element
                        ? element.dataset.index
                        : colors.length - 1;

                    const object = colors[colorIndex];

                    const colorValue = document
                        .getElementById("fill-color-value")
                        .value;

                    const color = Util.$intToRGB(
                        `0x${colorValue.substr(1)}` | 0
                    );

                    object.R = color.R;
                    object.G = color.G;
                    object.B = color.B;
                    object.A = Util.$clamp((document
                        .getElementById("fill-alpha-value")
                        .value | 0) / 100 * 255, 0, 255);

                    const width = Util.$clamp(document
                        .getElementById("fill-stroke-width-value")
                        .value | 0, 1, 255);

                    if (this._$recodes[index] !== width) {

                        Util.$hitColor.width  = width;
                        this._$recodes[index] = width;

                        const bounds = this.reloadBounds(width);
                        this._$bounds.xMin = bounds.xMin;
                        this._$bounds.xMax = bounds.xMax;
                        this._$bounds.yMin = bounds.yMin;
                        this._$bounds.yMax = bounds.yMax;

                        this.cacheClear();
                    }
                }
                break;

        }

        this.cacheClear();
    }

    /**
     * @return {void}
     * @public
     */
    cacheClear ()
    {
        const scene =  Util.$currentWorkSpace().scene;
        const values = scene._$layers.values();
        for (const layer of values) {

            const length = layer._$characters.length;
            for (let idx = 0; idx < length; ++idx) {

                const character = layer._$characters[idx];

                if (character.libraryId !== this.id) {
                    continue;
                }

                character._$image = null;
            }
        }
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @param  {array} place_matrix
     * @return {void}
     * @public
     */
    setHitColor (x, y, place_matrix)
    {
        const { Graphics, GradientType } = window.next2d.display;
        const { Point, Matrix } = window.next2d.geom;

        const matrix = new Matrix();

        const xScale = Math.sqrt(
            place_matrix[0] * place_matrix[0]
            + place_matrix[1] * place_matrix[1]
        );

        const yScale = Math.sqrt(
            place_matrix[2] * place_matrix[2]
            + place_matrix[3] * place_matrix[3]
        );
        matrix.scale(xScale, yScale);

        const radian = Math.atan2(place_matrix[1], place_matrix[0]);
        if (radian) {
            matrix.translate(-this.width / 2, -this.height / 2);
            matrix.rotate(radian);
            matrix.translate(this.width / 2, this.height / 2);
        }

        const topLeft     = matrix.transformPoint(new Point(0, 0));
        const topRight    = matrix.transformPoint(new Point(this.width, 0));
        const bottomLeft  = matrix.transformPoint(new Point(0, this.height));
        const bottomRight = matrix.transformPoint(new Point(this.width, this.height));

        const left = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
        const top  = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
        matrix.translate(-left, -top);

        // reset
        Util.$hitColor = null;

        Util.$hitContext.lineWidth = 0;
        Util.$hitContext.beginPath();
        Util.$hitContext.setTransform(
            matrix._$matrix[0], matrix._$matrix[1],
            matrix._$matrix[2], matrix._$matrix[3],
            -this._$bounds.xMin * xScale + matrix._$matrix[4],
            -this._$bounds.yMin * yScale + matrix._$matrix[5]
        );

        const recode = this._$recodes;
        const length  = recode.length;
        for (let idx = 0; idx < length; ) {
            switch (recode[idx++]) {

                case Graphics.BEGIN_PATH:
                    Util.$hitContext.beginPath();
                    break;

                case Graphics.MOVE_TO:
                    Util.$hitContext.moveTo(recode[idx++], recode[idx++]);
                    break;

                case Graphics.LINE_TO:
                    Util.$hitContext.lineTo(recode[idx++], recode[idx++]);
                    break;

                case Graphics.CURVE_TO:
                    Util.$hitContext.quadraticCurveTo(
                        recode[idx++], recode[idx++],
                        recode[idx++], recode[idx++]
                    );
                    break;

                case Graphics.CUBIC:
                    Util.$hitContext.bezierCurveTo(
                        recode[idx++], recode[idx++],
                        recode[idx++], recode[idx++],
                        recode[idx++], recode[idx++]
                    );
                    break;

                case Graphics.FILL_STYLE:
                    if (Util.$hitContext.isPointInPath(x, y)) {
                        if (this._$bitmapId) {

                            Util.$hitColor = {
                                "index": idx,
                                "style": Graphics.BITMAP_FILL,
                                "shape": this
                            };

                            document
                                .getElementById("fill-color-type-select")[1]
                                .selected = true;

                        } else {

                            Util.$hitColor = {
                                "index": idx,
                                "style": Graphics.FILL_STYLE,
                                "shape": this
                            };

                            const R = recode[idx    ].toString(16).padStart(2, "0");
                            const G = recode[idx + 1].toString(16).padStart(2, "0");
                            const B = recode[idx + 2].toString(16).padStart(2, "0");

                            document
                                .getElementById("fill-color-type-select")[0]
                                .selected = true;

                            document
                                .getElementById("fill-color-value")
                                .value = `#${R}${G}${B}`;

                            document
                                .getElementById("fill-alpha-value")
                                .value = `${recode[idx + 3] / 255 * 100}`;

                        }

                        Util.$controller.changeShapeColor();

                    }
                    idx += 4;
                    break;

                case Graphics.GRADIENT_FILL:
                    if (Util.$hitContext.isPointInPath(x, y)) {

                        document
                            .getElementById("fill-color-type-select")[
                                recode[idx] === GradientType.LINEAR ? 2 : 3
                            ]
                            .selected = true;

                        Util.$hitColor = {
                            "index"  : idx,
                            "style"  : Graphics.GRADIENT_FILL,
                            "type"   : recode[idx],
                            "ratios" : recode[idx + 1],
                            "shape"  : this
                        };

                        Util.$controller.changeShapeColor();
                    }
                    idx += 6;
                    break;

                case Graphics.STROKE_STYLE:
                    Util.$hitContext.lineWidth = recode[idx] | 0;
                    if (Util.$hitContext.isPointInStroke(x, y)) {

                        if (this._$bitmapId) {

                            Util.$hitColor = {
                                "index": idx,
                                "width": Util.$hitContext.lineWidth,
                                "style": Graphics.BITMAP_STROKE,
                                "shape": this
                            };

                            document
                                .getElementById("fill-color-type-select")[1]
                                .selected = true;

                        } else {

                            Util.$hitColor = {
                                "index": idx,
                                "width": Util.$hitContext.lineWidth,
                                "style": Graphics.STROKE_STYLE,
                                "shape": this
                            };

                            const R = recode[idx + 4].toString(16).padStart(2, "0");
                            const G = recode[idx + 5].toString(16).padStart(2, "0");
                            const B = recode[idx + 6].toString(16).padStart(2, "0");

                            document
                                .getElementById("fill-color-type-select")[0]
                                .selected = true;

                            document
                                .getElementById("fill-color-value")
                                .value = `#${R}${G}${B}`;

                            document
                                .getElementById("fill-alpha-value")
                                .value = `${recode[idx + 7] / 255 * 100}`;
                        }

                        document
                            .getElementById("fill-stroke-width-value")
                            .value = `${Util.$hitContext.lineWidth}`;

                        Util.$controller.changeShapeColor();
                    }
                    idx += 8;
                    break;

                case Graphics.GRADIENT_STROKE:
                    Util.$hitContext.lineWidth = recode[idx];
                    if (Util.$hitContext.isPointInStroke(x, y)) {

                        document
                            .getElementById("fill-color-type-select")[
                                recode[idx + 4] === GradientType.LINEAR ? 2 : 3
                            ]
                            .selected = true;

                        Util.$hitColor = {
                            "index"  : idx,
                            "width"  : recode[idx],
                            "style"  : Graphics.GRADIENT_STROKE,
                            "type"   : recode[idx + 4],
                            "ratios" : recode[idx + 5],
                            "shape"  : this
                        };

                        Util.$controller.changeShapeColor();

                    }
                    idx += 10;
                    break;

                case Graphics.CLOSE_PATH:
                case Graphics.END_STROKE:
                case Graphics.END_FILL:
                    break;

                default:
                    break;

            }
        }
    }

    /**
     * @return {next2d.display.Shape}
     * @public
     */
    createInstance ()
    {
        const { Shape, Graphics } = window.next2d.display;

        const shape = new Shape();

        if (this._$grid) {
            const { Rectangle } = window.next2d.geom;
            shape.scale9Grid = new Rectangle(
                this._$grid.x, this._$grid.y,
                this._$grid.w, this._$grid.h
            );
        }

        const graphics = shape.graphics;

        graphics._$maxAlpha = 1;
        graphics._$canDraw  = true;
        graphics._$xMin     = this._$bounds.xMin;
        graphics._$xMax     = this._$bounds.xMax;
        graphics._$yMin     = this._$bounds.yMin;
        graphics._$yMax     = this._$bounds.yMax;

        if (this._$bitmapId) {

            const { BitmapData } = window.next2d.display;

            const instance = Util
                .$currentWorkSpace()
                .getLibrary(this._$bitmapId);

            if (instance) {

                shape._$bitmapId = this._$bitmapId;

                // setup
                graphics._$recode = [];

                const bitmapData = new BitmapData(
                    instance.width, instance.height, true, 0
                );
                bitmapData._$buffer = instance._$buffer;

                // clone
                const recodes = this._$recodes;
                if (recodes[recodes.length - 1] === Graphics.END_FILL) {

                    const length  = recodes.length - 6;
                    for (let idx = 0; idx < length; ++idx) {
                        graphics._$recode.push(recodes[idx]);
                    }

                    // add Bitmap Fill
                    graphics._$recode.push(
                        Graphics.BITMAP_FILL,
                        bitmapData,
                        null,
                        "repeat",
                        false
                    );

                } else {

                    const width      = this._$recodes[recodes.length - 9];
                    const caps       = this._$recodes[recodes.length - 8];
                    const joints     = this._$recodes[recodes.length - 7];
                    const miterLimit = this._$recodes[recodes.length - 6];

                    const length  = recodes.length - 10;
                    for (let idx = 0; idx < length; ++idx) {
                        graphics._$recode.push(recodes[idx]);
                    }

                    graphics._$recode.push(
                        Graphics.BITMAP_STROKE,
                        width,
                        caps,
                        joints,
                        miterLimit,
                        bitmapData,
                        [1, 0, 0, 1, graphics._$xMin, graphics._$yMin],
                        "repeat",
                        false
                    );

                }

            } else {

                graphics._$recode = this._$recodes.slice(0);

            }

        } else {

            graphics._$recode = this._$recodes.slice(0);

        }

        return shape;
    }
}


/**
 * @class
 */
class Sound extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor(object)
    {
        super(object);
        this.buffer = object.buffer;

        this._$binary   = "";
        this._$volume   = 100;
        this._$loop     = false;

        if ("volume" in object) {
            this.volume = object.volume;
        }

        if ("loop" in object) {
            this.loop = object.loop;
        }

        this._$audio = document.createElement("audio");

        this._$audio.preload  = "auto";
        this._$audio.autoplay = false;
        this._$audio.loop     = false;
        this._$audio.controls = true;

        this._$audio.src = URL.createObjectURL(new Blob(
            [new Uint8Array(this._$buffer)],
            { "type": "audio/mp3" }
        ));
        this._$audio.load();
    }

    /**
     * @return {void}
     * @public
     */
    initialize () {}

    /**
     * @return {HTMLVideoElement}
     */
    get preview ()
    {
        const bounds = this.getBounds();

        // size
        let width  = Math.abs(bounds.xMax - bounds.xMin);
        let height = Math.abs(bounds.yMax - bounds.yMin);

        let scaleX   = 1;
        const scaleY = 150 / height;

        width  = width  * scaleY | 0;
        height = height * scaleY | 0;

        const controllerWidth = (document
            .documentElement
            .style
            .getPropertyValue("--controller-width")
            .split("px")[0] | 0) - 10;

        if (width > controllerWidth) {
            scaleX = controllerWidth / width;
            width  = width  * scaleX | 0;
            height = height * scaleX | 0;
        }

        this._$audio.style.width  = `${width}px`;
        this._$audio.style.height = `${height}px`;

        this._$audio.controls = true;
        return this._$audio;
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.media.Sound.namespace;
    }

    /**
     * @return {string}
     * @public
     */
    get buffer ()
    {
        if (!this._$binary) {

            const length = this._$buffer.length;

            for (let idx = 0; idx < length; ++idx) {
                this._$binary += String.fromCharCode(this._$buffer[idx]);
            }

        }

        return this._$binary;
    }

    /**
     * @param  {string|Uint8Array} binary
     * @return {void}
     * @public
     */
    set buffer (binary)
    {

        switch (typeof binary) {

            case "object":
                if (binary.constructor === Uint8Array) {
                    this._$buffer = binary;
                }
                break;

            case "string":
                if (!this._$binary) {
                    let length = binary.length;

                    this._$buffer = new Uint8Array(length);
                    for (let idx = 0; idx < length; ++idx) {
                        this._$buffer[idx] = binary.charCodeAt(idx) & 0xff;
                    }

                    this._$binary = binary;
                }
                break;

            default:
                break;

        }
    }

    /**
     * @return {number}
     * @public
     */
    get volume ()
    {
        return this._$volume;
    }

    /**
     * @param  {number} volume
     * @return {void}
     * @public
     */
    set volume (volume)
    {
        this._$volume = volume;
    }

    /**
     * @return {boolean}
     * @public
     */
    get loop ()
    {
        return this._$loop;
    }

    /**
     * @param  {boolean} loop
     * @return {void}
     * @public
     */
    set loop (loop)
    {
        this._$loop = loop;
    }

    /**
     * @return {object}
     * @public
     */
    getBounds ()
    {
        return {
            "xMin": 0,
            "xMax": Util.CONTROLLER_DEFAULT_SIZE,
            "yMin": 0,
            "yMax": 150
        };
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":       this.id,
            "name":     this.name,
            "type":     this.type,
            "symbol":   this.symbol,
            "folderId": this.folderId,
            "buffer":   this.buffer,
            "volume":   this.volume,
            "loop":     this.loop
        };
    }

    /**
     * @return {object}
     * @public
     */
    toPublish ()
    {
        return {
            "buffer": Array.from(this._$buffer),
            "audioBuffer": null,
            "init": false
        };
    }
}

/**
 * @class
 */
class TextField extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object = null)
    {
        super(object);

        this._$text           = "";
        this._$font           = "sans-serif";
        this._$size           = 12;
        this._$align          = "left";
        this._$color          = 0;
        this._$fontType       = 0;
        this._$inputType      = "static";
        this._$leading        = 0;
        this._$letterSpacing  = 0;
        this._$leftMargin     = 0;
        this._$rightMargin    = 0;
        this._$autoSize       = 0;
        this._$multiline      = true;
        this._$wordWrap       = true;
        this._$border         = false;
        this._$scroll         = true;
        this._$cache          = null;
        this._$htmlText       = null;
        this._$thickness      = 0;
        this._$thicknessColor = 0;

        this._$bounds = {
            "xMin": 0,
            "xMax": Util.FONT_DEFAULT_SIZE,
            "yMin": 0,
            "yMax": Util.FONT_DEFAULT_SIZE
        };

        this._$originBounds = {
            "xMin": 0,
            "xMax": Util.FONT_DEFAULT_SIZE,
            "yMin": 0,
            "yMax": Util.FONT_DEFAULT_SIZE
        };

        if (object.text) {
            this.text = object.text;
        }

        if (object.font) {
            this.font = object.font;
        }

        if (object.fontType) {
            this.fontType = object.fontType;
        }

        if (object.inputType) {
            this.inputType = object.inputType;
        }

        if (object.size) {
            this.size = object.size;
        }

        if (object.align) {
            this.align = object.align;
        }

        if (object.color) {
            this.color = object.color;
        }

        if (object.leading) {
            this.leading = object.leading;
        }

        if (object.letterSpacing) {
            this.letterSpacing = object.letterSpacing;
        }

        if (object.leftMargin) {
            this.leftMargin = object.leftMargin;
        }

        if (object.rightMargin) {
            this.rightMargin = object.rightMargin;
        }

        if ("multiline" in object) {
            this.multiline = object.multiline;
        }

        if ("wordWrap" in object) {
            this.wordWrap = object.wordWrap;
        }

        if (object.autoFontSize) {
            this.autoFontSize = object.autoFontSize;
        }

        if ("scroll" in object) {
            this.scroll = object.scroll;
        }

        if (object.border) {
            this.border = object.border;
        }

        if (object.bounds) {
            this.bounds = object.bounds;
        }

        if (object.originBounds) {
            this.originBounds = object.originBounds;
        }

        if (object.autoSize) {
            this.autoSize = object.autoSize;
        }

        if (object.thickness) {
            this.thickness = object.thickness;
        }

        if (object.thicknessColor) {
            this.thicknessColor = object.thicknessColor;
        }
    }

    /**
     * @return {void}
     * @public
     */
    initialize () {}

    /**
     * @return {object}
     * @public
     */
    getBounds ()
    {
        return {
            "xMin": -this._$thickness,
            "xMax": this._$bounds.xMax + this._$thickness,
            "yMin": -this._$thickness,
            "yMax": this._$bounds.yMax + 4 + this._$thickness
        };
    }

    /**
     * @return {string}
     * @public
     */
    get text ()
    {
        return this._$text;
    }

    /**
     * @param {string} text
     * @public
     */
    set text (text)
    {
        this._$text = text;
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get size ()
    {
        return this._$size;
    }

    /**
     * @param {number} size
     * @public
     */
    set size (size)
    {
        this._$size = size | 0;
        this.resize();
    }

    /**
     * @return {string}
     * @public
     */
    get font ()
    {
        return this._$font;
    }

    /**
     * @param {string} font
     * @public
     */
    set font (font)
    {
        this._$font = font;
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get fontType ()
    {
        return this._$fontType;
    }

    /**
     * @param {number} font_type
     * @public
     */
    set fontType (font_type)
    {
        this._$fontType = font_type | 0;
        this.resize();
    }

    /**
     * @return {string}
     * @public
     */
    get inputType ()
    {
        return this._$inputType;
    }

    /**
     * @param {string} input_type
     * @public
     */
    set inputType (input_type)
    {
        this._$inputType = input_type;
    }

    /**
     * @return {string}
     * @public
     */
    get align ()
    {
        return this._$align;
    }

    /**
     * @param {string} align
     * @public
     */
    set align (align)
    {
        this._$align = align;
    }

    /**
     * @return {number}
     * @public
     */
    get color ()
    {
        return this._$color;
    }

    /**
     * @param {number} color
     * @public
     */
    set color (color)
    {
        this._$color = color | 0;
    }

    /**
     * @return {number}
     * @public
     */
    get leading ()
    {
        return this._$leading;
    }

    /**
     * @param {number} leading
     * @public
     */
    set leading (leading)
    {
        this._$leading = leading | 0;
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get letterSpacing ()
    {
        return this._$letterSpacing;
    }

    /**
     * @param {number} letter_spacing
     * @public
     */
    set letterSpacing (letter_spacing)
    {
        this._$letterSpacing = letter_spacing | 0;
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get leftMargin ()
    {
        return this._$leftMargin;
    }

    /**
     * @param {number} left_margin
     * @public
     */
    set leftMargin (left_margin)
    {
        this._$leftMargin = left_margin | 0;
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get rightMargin ()
    {
        return this._$rightMargin;
    }

    /**
     * @param {number} right_margin
     * @public
     */
    set rightMargin (right_margin)
    {
        this._$rightMargin = right_margin | 0;
        this.resize();
    }

    /**
     * @return {boolean}
     * @public
     */
    get multiline ()
    {
        return this._$multiline;
    }

    /**
     * @param {boolean} multiline
     * @public
     */
    set multiline (multiline)
    {
        this._$multiline = !!multiline;
        this.resize();
    }

    /**
     * @return {boolean}
     * @public
     */
    get border ()
    {
        return this._$border;
    }

    /**
     * @param {boolean} border
     * @public
     */
    set border (border)
    {
        this._$border = !!border;
    }

    /**
     * @return {boolean}
     * @public
     */
    get scroll ()
    {
        return this._$scroll;
    }

    /**
     * @param {boolean} scroll
     * @public
     */
    set scroll (scroll)
    {
        this._$scroll = !!scroll;
    }

    /**
     * @return {boolean}
     * @public
     */
    get wordWrap ()
    {
        return this._$wordWrap;
    }

    /**
     * @param {boolean} word_wrap
     * @public
     */
    set wordWrap (word_wrap)
    {
        this._$wordWrap = !!word_wrap;
        this.resize();
    }

    /**
     * @return {object}
     * @public
     */
    get bounds ()
    {
        return this._$bounds;
    }

    /**
     * @param {object} [bounds=null]
     * @public
     */
    set bounds (bounds)
    {
        this._$bounds = bounds;
    }

    /**
     * @return {object}
     * @public
     */
    get originBounds ()
    {
        return this._$originBounds;
    }

    /**
     * @param {object} origin_bounds
     * @public
     */
    set originBounds (origin_bounds)
    {
        this._$originBounds = origin_bounds;
    }

    /**
     * @return {number}
     * @public
     */
    get autoSize ()
    {
        return this._$autoSize;
    }

    /**
     * @param {number} auto_size
     * @public
     */
    set autoSize (auto_size)
    {
        this._$autoSize = auto_size | 0;
        if (this._$autoSize !== 1) {
            this._$bounds.xMax = this._$originBounds.xMax;
            this._$bounds.yMax = this._$originBounds.yMax;
        }
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get thickness ()
    {
        return this._$thickness;
    }

    /**
     * @param {number} thickness
     * @public
     */
    set thickness (thickness)
    {
        this._$thickness = thickness | 0;
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get thicknessColor ()
    {
        return this._$thicknessColor;
    }

    /**
     * @param {number} thickness_color
     * @public
     */
    set thicknessColor (thickness_color)
    {
        this._$thicknessColor = thickness_color | 0;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":             this.id,
            "name":           this.name,
            "type":           this.type,
            "symbol":         this.symbol,
            "folderId":       this.folderId,
            "text":           this.text,
            "font":           this.font,
            "fontType":       this.fontType,
            "inputType":      this.inputType,
            "size":           this.size,
            "align":          this.align,
            "color":          this.color,
            "leading":        this.leading,
            "letterSpacing":  this.letterSpacing,
            "leftMargin":     this.leftMargin,
            "rightMargin":    this.rightMargin,
            "multiline":      this.multiline,
            "wordWrap":       this.wordWrap,
            "border":         this.border,
            "autoSize":       this.autoSize,
            "scroll":         this.scroll,
            "originBounds":   this.originBounds,
            "bounds":         this.bounds,
            "thickness":      this.thickness,
            "thicknessColor": this.thicknessColor
        };
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.text.TextField.namespace;
    }

    /**
     * @return {object}
     * @public
     */
    toPublish ()
    {
        return {
            "symbol":         this.symbol,
            "extends":        this.defaultSymbol,
            "text":           this.text,
            "font":           this.font,
            "fontType":       this.fontType,
            "inputType":      this.inputType,
            "size":           this.size,
            "align":          this.align,
            "color":          this.color,
            "leading":        this.leading,
            "letterSpacing":  this.letterSpacing,
            "leftMargin":     this.leftMargin,
            "rightMargin":    this.rightMargin,
            "multiline":      this.multiline,
            "wordWrap":       this.wordWrap,
            "border":         this.border,
            "autoSize":       this.autoSize,
            "scroll":         this.scroll,
            "originBounds":   this.originBounds,
            "bounds":         this.bounds,
            "thickness":      this.thickness,
            "thicknessColor": this.thicknessColor
        };
    }

    /**
     * @return {void}
     * @public
     */
    resize ()
    {
        const textField = this.createInstance();
        this._$bounds = {
            "xMin": textField._$bounds.xMin,
            "xMax": textField._$bounds.xMax,
            "yMin": textField._$bounds.yMin,
            "yMax": textField._$bounds.yMax
        };
    }

    /**
     * @return {next2d.text.TextField}
     * @public
     */
    createInstance ()
    {
        const { TextField } = window.next2d.text;
        const textField = new TextField();

        textField._$bounds = {
            "xMin": this._$originBounds.xMin,
            "xMax": this._$originBounds.xMax,
            "yMin": this._$originBounds.yMin,
            "yMax": this._$originBounds.yMax
        };
        textField._$originBounds = {
            "xMin": this._$originBounds.xMin,
            "xMax": this._$originBounds.xMax,
            "yMin": this._$originBounds.yMin,
            "yMax": this._$originBounds.yMax
        };

        const textFormat         = textField.defaultTextFormat;
        textFormat.font          = this._$font;
        textFormat.size          = this._$size;
        textFormat.align         = this._$align;
        textFormat.color         = this._$color;
        textFormat.leading       = this._$leading;
        textFormat.letterSpacing = this._$letterSpacing;
        textFormat.leftMargin    = this._$leftMargin;
        textFormat.rightMargin   = this._$rightMargin;

        switch (this._$fontType) {

            case 1:
                textFormat.bold = true;
                break;

            case 2:
                textFormat.italic = true;
                break;

            case 3:
                textFormat.bold   = true;
                textFormat.italic = true;
                break;

        }

        switch (this._$autoSize) {

            case 1:
                textField.autoSize = this._$align;
                break;

            case 2:
                textField.autoFontSize = true;
                break;

        }

        textField.multiline      = this._$multiline;
        textField.wordWrap       = this._$wordWrap;
        textField.border         = this._$border;
        textField.scroll         = this._$scroll;
        textField.thickness      = this._$thickness;
        textField.thicknessColor = this._$thicknessColor;
        textField.text           = this._$text;

        return textField;
    }

    /**
     * @param  {number} width
     * @param  {number} height
     * @param  {object} place
     * @return {HTMLTextAreaElement}
     * @public
     */
    toImage (width, height, place)
    {
        const image = super.toImage(width, height, place);

        image._$tx -= this._$thickness;
        image._$ty -= this._$thickness;

        let resizeX = 0;
        switch (this._$autoSize) {

            case 0:
                if (this._$align === "right") {
                    resizeX = -4;
                }
                break;

            case 1:
                switch (this._$align) {

                    case "center":
                        resizeX = (this._$bounds.xMax - this._$originBounds.xMax) / 2;
                        if (resizeX) {
                            resizeX -= 2;
                        }
                        break;

                    case "right":
                        resizeX = this._$originBounds.xMax - this._$bounds.xMax;
                        if (resizeX) {
                            resizeX += 2;
                            resizeX *= -1;
                        }
                        break;

                }
                break;

        }

        if (this._$autoSize === 1) {
            image._$tx -= resizeX;
        }

        return image;
    }
}

/**
 * @class
 */
class Video extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object)
    {
        super(object);

        this._$volume   = 100;
        this._$loop     = false;
        this._$autoPlay = true;
        this._$binary   = "";
        this._$queue    = [];
        this._$loaded   = false;

        this.buffer   = object.buffer;
        this.width    = object.width;
        this.height   = object.height;

        if ("volume" in object) {
            this.volume = object.volume;
        }

        if ("loop" in object) {
            this.loop = object.loop;
        }

        if ("autoPlay" in object) {
            this.autoPlay = object.autoPlay;
        }

        this._$video = document.createElement("video");
        this._$video.crossOrigin = "anonymous";
        this._$video.type        = "video/mp4";
        this._$video.muted       = true;
        this._$video.autoplay    = false;

        const start = (event) =>
        {
            event.target.removeEventListener("canplaythrough", start);

            event.target.play();
            event.target.currentTime = 1;
            event.target.pause();

            this._$loaded = true;
            setTimeout(() => { this.delayImage() }, 150);

        };
        this._$video.addEventListener("canplaythrough", start);

        this._$video.src = URL.createObjectURL(new Blob(
            [new Uint8Array(this._$buffer)],
            { "type": "video/mp4" }
        ));
        this._$video.load();
    }

    /**
     * @return {void}
     * @public
     */
    initialize () {}

    /**
     * @return {HTMLVideoElement}
     */
    get preview ()
    {
        const bounds = this.getBounds();

        // size
        let width  = Math.abs(bounds.xMax - bounds.xMin);
        let height = Math.abs(bounds.yMax - bounds.yMin);

        let scaleX   = 1;
        const scaleY = 150 / height;

        width  = width  * scaleY | 0;
        height = height * scaleY | 0;

        const controllerWidth = (document
            .documentElement
            .style
            .getPropertyValue("--controller-width")
            .split("px")[0] | 0) - 10;

        if (width > controllerWidth) {
            scaleX = controllerWidth / width;
            width  = width  * scaleX | 0;
            height = height * scaleX | 0;
        }

        this._$video.style.width  = `${width}px`;
        this._$video.style.height = `${height}px`;

        this._$video.controls = true;
        return this._$video;
    }

    /**
     * @return {object}
     * @public
     */
    getBounds ()
    {
        return {
            "xMin": 0,
            "xMax": this.width,
            "yMin": 0,
            "yMax": this.height
        };
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.media.Video.namespace;
    }

    /**
     * @return {string}
     * @public
     */
    get buffer ()
    {
        if (!this._$binary) {

            const length = this._$buffer.length;

            for (let idx = 0; idx < length; ++idx) {
                this._$binary += String.fromCharCode(this._$buffer[idx]);
            }

        }

        return this._$binary;
    }

    /**
     * @param  {string|Uint8Array} binary
     * @return {void}
     * @public
     */
    set buffer (binary)
    {

        switch (typeof binary) {

            case "object":
                if (binary.constructor === Uint8Array) {
                    this._$buffer = binary;
                }
                break;

            case "string":
                if (!this._$binary) {
                    let length = binary.length;

                    this._$buffer = new Uint8Array(length);
                    for (let idx = 0; idx < length; ++idx) {
                        this._$buffer[idx] = binary.charCodeAt(idx) & 0xff;
                    }

                    this._$binary = binary;
                }
                break;

            default:
                break;

        }
    }

    /**
     * @return {number}
     * @public
     */
    get volume ()
    {
        return this._$volume;
    }

    /**
     * @param  {number} volume
     * @return {void}
     * @public
     */
    set volume (volume)
    {
        this._$volume = volume;
    }

    /**
     * @return {boolean}
     * @public
     */
    get loop ()
    {
        return this._$loop;
    }

    /**
     * @param  {boolean} loop
     * @return {void}
     * @public
     */
    set loop (loop)
    {
        this._$loop = loop;
    }

    /**
     * @return {boolean}
     * @public
     */
    get autoPlay ()
    {
        return this._$autoPlay;
    }

    /**
     * @param  {boolean} auto_play
     * @return {void}
     * @public
     */
    set autoPlay (auto_play)
    {
        this._$autoPlay = auto_play;
    }

    /**
     * @return {uint}
     * @public
     */
    get width ()
    {
        return this._$width;
    }

    /**
     * @param  {uint} width
     * @return {void}
     * @public
     */
    set width (width)
    {
        this._$width = width;
    }

    /**
     * @return {uint}
     * @public
     */
    get height ()
    {
        return this._$height;
    }

    /**
     * @param  {uint} height
     * @return {void}
     * @public
     */
    set height (height)
    {
        this._$height = height;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":        this.id,
            "name":      this.name,
            "type":      this.type,
            "symbol":    this.symbol,
            "folderId":  this.folderId,
            "width":     this.width,
            "height":    this.height,
            "buffer":    this.buffer,
            "volume":    this.volume,
            "loop":      this.loop,
            "autoPlay":  this.autoPlay
        };
    }

    /**
     * @return {object}
     * @public
     */
    toPublish ()
    {
        return {
            "symbol":   this.symbol,
            "extends":  this.defaultSymbol,
            "buffer":   Array.from(this._$buffer),
            "bounds":   this.getBounds(),
            "volume":   this.volume / 100,
            "loop":     this.loop,
            "autoPlay": this.autoPlay
        };
    }

    /**
     * @param  {object}  place
     * @param  {boolean} [preview=false]
     * @return {next2d.display.Shape}
     * @public
     */
    createInstance (place, preview = false)
    {
        const { Video } = window.next2d.media;

        const video = this._$loaded
            ? new Video(this._$video.videoWidth, this._$video.videoHeight)
            : new Video(this.width, this.height);

        video._$characterId = this.id;
        video._$video       = this._$video;

        if (this._$loaded) {
            const context = Util.$root.stage._$player._$context;

            if (!preview) {

                const currentFrame = document
                    .getElementById("current-frame")
                    .textContent | 0;

                video._$video.currentTime = currentFrame / 60;

            } else {

                video._$video.currentTime = 1;

            }

            video._$texture = context
                .frameBuffer
                .createTextureFromVideo(video._$video, video._$smoothing);
        }

        return video;
    }

    /**
     * @return {void}
     * @public
     */
    delayImage ()
    {
        for (let idx = 0; idx < this._$queue.length; ++idx) {
            const object = this._$queue[idx];
            object.image.src = this.toImage(
                object.width, object.height, object.place, object.preview
            ).src;
        }
        this._$queue.length = 0;
    }

    /**
     * @param  {number}  width
     * @param  {number}  height
     * @param  {object}  place
     * @param  {boolean} [preview=false]
     * @return {HTMLImageElement}
     * @public
     */
    toImage (width, height, place, preview = false)
    {
        const image = super.toImage(width, height, place, preview);
        if (this._$loaded) {
            return image;
        }

        this._$queue.push({
            "image": image,
            "width": width,
            "height": height,
            "preview": preview,
            "place": place
        });

        return image;
    }
}

/**
 * @class
 */
class Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor(object = null)
    {
        this._$blurX   = 4;
        this._$blurY   = 4;
        this._$quality = 1;
        this._$state   = true;
        this._$name    = "";

        if (object) {
            this.blurX   = object.blurX;
            this.blurY   = object.blurY;
            this.quality = object.quality | 0;
            this.state   = object.state;
        }
    }

    /**
     * @return {Filter}
     * @public
     */
    clone ()
    {
        return new this.constructor(this.toObject());
    }

    /**
     * @param  {Filter} filter
     * @return {boolean}
     * @public
     */
    isSame (filter)
    {
        if (this._$quality !== filter._$quality) {
            return false;
        }

        if (this._$blurX !== filter._$blurX) {
            return false;
        }

        if (this._$blurY !== filter._$blurY) {
            return false;
        }

        return true;
    }

    /**
     * @return {number}
     * @public
     */
    get blurX ()
    {
        return this._$blurX;
    }

    /**
     * @param  {number} blur_x
     * @return {void}
     * @public
     */
    set blurX (blur_x)
    {
        this._$blurX = Util.$clamp(+blur_x, Util.MIN_BLUR, Util.MAX_BLUR);
    }

    /**
     * @return {number}
     * @public
     */
    get blurY ()
    {
        return this._$blurY;
    }

    /**
     * @param  {number} blur_y
     * @return {void}
     * @public
     */
    set blurY (blur_y)
    {
        this._$blurY = Util.$clamp(+blur_y, Util.MIN_BLUR, Util.MAX_BLUR);
    }

    /**
     * @return {number}
     * @public
     */
    get quality ()
    {
        return this._$quality;
    }

    /**
     * @param  {number} quality
     * @return {void}
     * @public
     */
    set quality (quality)
    {
        this._$quality = Util.$clamp(quality | 0, 1, 3);
    }

    /**
     * @return {boolean}
     * @public
     */
    get state ()
    {
        return this._$state;
    }

    /**
     * @param  {boolean} state
     * @return {void}
     * @public
     */
    set state (state)
    {
        this._$state = state;
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @param  {string} name
     * @return {void}
     * @public
     */
    set name (name)
    {
        this._$name = name;
    }
}
/**
 * @class
 */
class BevelFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        super(object);
        this.name = "BevelFilter";

        this._$distance       = 4;
        this._$angle          = 45;
        this._$highlightColor = 0xffffff;
        this._$highlightAlpha = 100;
        this._$shadowColor    = 0;
        this._$shadowAlpha    = 100;
        this._$strength       = 1;
        this._$type           = "inner";
        this._$knockout       = false;

        if (object) {
            this.distance       = object.distance;
            this.angle          = object.angle;
            this.highlightColor = object.highlightColor | 0;
            this.highlightAlpha = object.highlightAlpha * 100;
            this.shadowColor    = object.shadowColor | 0;
            this.shadowAlpha    = object.shadowAlpha * 100;
            this.strength       = object.strength;
            this.type           = object.type;
            this.knockout       = object.knockout;
        }
    }

    /**
     * @return {number}
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }

    /**
     * @param  {number} distance
     * @return {void}
     * @public
     */
    set distance (distance)
    {
        this._$distance = Util.$clamp(+distance, Util.MIN_DISTANCE, Util.MAX_DISTANCE);
    }

    /**
     * @return {number}
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }

    /**
     * @param  {number} angle
     * @return {void}
     * @public
     */
    set angle (angle)
    {
        this._$angle = +angle % 360;
    }

    /**
     * @return {number}
     * @public
     */
    get highlightColor ()
    {
        return this._$highlightColor;
    }

    /**
     * @param  {number} highlight_color
     * @return {void}
     * @public
     */
    set highlightColor (highlight_color)
    {
        this._$highlightColor = Util.$clamp(highlight_color | 0, 0, 0xffffff);
    }

    /**
     * @return {number}
     * @public
     */
    get highlightAlpha ()
    {
        return this._$highlightAlpha;
    }

    /**
     * @param  {number} highlight_alpha
     * @return {void}
     * @public
     */
    set highlightAlpha (highlight_alpha)
    {
        this._$highlightAlpha = Util.$clamp(+highlight_alpha, 0, 100);
    }

    /**
     * @return {number}
     * @public
     */
    get shadowColor ()
    {
        return this._$shadowColor;
    }

    /**
     * @param  {number} shadow_color
     * @return {void}
     * @public
     */
    set shadowColor (shadow_color)
    {
        this._$shadowColor = Util.$clamp(shadow_color | 0, 0, 0xffffff);
    }

    /**
     * @return {number}
     * @public
     */
    get shadowAlpha ()
    {
        return this._$shadowAlpha;
    }

    /**
     * @param  {number} shadow_alpha
     * @return {void}
     * @public
     */
    set shadowAlpha (shadow_alpha)
    {
        this._$shadowAlpha = Util.$clamp(+shadow_alpha, 0, 100);
    }

    /**
     * @return {number}
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }

    /**
     * @param  {number} strength
     * @return {void}
     * @public
     */
    set strength (strength)
    {
        this._$strength = Util.$clamp(+strength, Util.MIN_STRENGTH, Util.MAX_STRENGTH);
    }

    /**
     * @return {string}
     * @public
     */
    get type ()
    {
        return this._$type;
    }

    /**
     * @param  {string} type
     * @return {void}
     * @public
     */
    set type (type)
    {
        this._$type = type;
    }

    /**
     * @return {boolean}
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }

    /**
     * @param  {boolean} knockout
     * @return {void}
     * @public
     */
    set knockout (knockout)
    {
        this._$knockout = knockout;
    }

    /**
     * @param  {BevelFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        if (this._$highlightColor !== filter._$highlightColor) {
            return false;
        }

        if (this._$highlightAlpha !== filter._$highlightAlpha) {
            return false;
        }

        if (this._$shadowColor !== filter._$shadowColor) {
            return false;
        }

        if (this._$shadowAlpha !== filter._$shadowAlpha) {
            return false;
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$type !== filter._$type) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @return {window.next2d.filters.BevelFilter}
     * @public
     */
    createInstance ()
    {
        return new window.next2d.filters.BevelFilter(
            this.distance, this.angle, this.highlightColor, this.highlightAlpha / 100,
            this.shadowColor, this.shadowAlpha / 100, this.blurX, this.blurY,
            this.strength, this.quality, this.type, this.knockout
        );
    }

    /**
     * @return {array}
     */
    toParamArray ()
    {
        return [null,
            this.distance, this.angle, this.highlightColor, this.highlightAlpha / 100,
            this.shadowColor, this.shadowAlpha / 100, this.blurX, this.blurY,
            this.strength, this.quality, this.type, this.knockout
        ];
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "distance": this.distance,
            "angle": this.angle,
            "highlightColor": this.highlightColor,
            "highlightAlpha": this.highlightAlpha / 100,
            "shadowColor": this.shadowColor,
            "shadowAlpha": this.shadowAlpha / 100,
            "strength": this.strength,
            "type": this.type,
            "knockout": this.knockout
        };
    }
}
/**
 * @class
 */
class BlurFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        super(object);
        this.name = "BlurFilter";
    }

    /**
     * @return {window.next2d.filters.BlurFilter}
     * @public
     */
    createInstance ()
    {
        return new window.next2d.filters.BlurFilter(
            this.blurX, this.blurY, this.quality
        );
    }

    /**
     * @return {array}
     */
    toParamArray ()
    {
        return [null, this.blurX, this.blurY, this.quality];
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state
        };
    }
}
/**
 * @class
 */
class DropShadowFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        super(object);
        this.name = "DropShadowFilter";

        this._$distance   = 4;
        this._$angle      = 45;
        this._$color      = 0;
        this._$alpha      = 100;
        this._$strength   = 1;
        this._$inner      = false;
        this._$knockout   = false;
        this._$hideObject = false;

        if (object) {
            this.distance   = object.distance;
            this.angle      = object.angle;
            this.color      = object.color;
            this.alpha      = object.alpha * 100;
            this.strength   = object.strength;
            this.inner      = object.inner;
            this.knockout   = object.knockout;
            this.hideObject = object.hideObject;
        }
    }

    /**
     * @return {number}
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }

    /**
     * @param  {number} distance
     * @return {void}
     * @public
     */
    set distance (distance)
    {
        this._$distance = Util.$clamp(+distance, Util.MIN_DISTANCE, Util.MAX_DISTANCE);
    }

    /**
     * @return {number}
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }

    /**
     * @param  {number} angle
     * @return {void}
     * @public
     */
    set angle (angle)
    {
        this._$angle = +angle % 360;
    }

    /**
     * @return {number}
     * @public
     */
    get color ()
    {
        return this._$color;
    }

    /**
     * @param  {number} color
     * @return {void}
     * @public
     */
    set color (color)
    {
        this._$color = Util.$clamp(color | 0, 0, 0xffffff);
    }

    /**
     * @return {number}
     * @public
     */
    get alpha ()
    {
        return this._$alpha;
    }

    /**
     * @param  {number} alpha
     * @return {void}
     * @public
     */
    set alpha (alpha)
    {
        this._$alpha = Util.$clamp(+alpha, 0, 100);
    }

    /**
     * @return {number}
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }

    /**
     * @param  {number} strength
     * @return {void}
     * @public
     */
    set strength (strength)
    {
        this._$strength = Util.$clamp(+strength, Util.MIN_STRENGTH, Util.MAX_STRENGTH);
    }

    /**
     * @return {boolean}
     * @public
     */
    get inner ()
    {
        return this._$inner;
    }

    /**
     * @param  {boolean} inner
     * @return {void}
     * @public
     */
    set inner (inner)
    {
        this._$inner = inner;
    }

    /**
     * @return {boolean}
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }

    /**
     * @param  {boolean} knockout
     * @return {void}
     * @public
     */
    set knockout (knockout)
    {
        this._$knockout = knockout;
    }

    /**
     * @return {boolean}
     * @public
     */
    get hideObject ()
    {
        return this._$hideObject;
    }

    /**
     * @param  {boolean} hideObject
     * @return {void}
     * @public
     */
    set hideObject (hideObject)
    {
        this._$hideObject = hideObject;
    }

    /**
     * @param  {DropShadowFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        if (this._$color !== filter._$color) {
            return false;
        }

        if (this._$alpha !== filter._$alpha) {
            return false;
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$inner !== filter._$inner) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        if (this._$hideObject !== filter._$hideObject) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @return {window.next2d.filters.DropShadowFilter}
     * @public
     */
    createInstance ()
    {
        return new window.next2d.filters.DropShadowFilter(
            this.distance, this.angle, this.color, this.alpha / 100,
            this.blurX, this.blurY, this.strength, this.quality,
            this.inner, this.knockout, this.hideObject
        );
    }

    /**
     * @return {array}
     */
    toParamArray ()
    {
        return [null,
            this.distance, this.angle, this.color, this.alpha / 100,
            this.blurX, this.blurY, this.strength, this.quality,
            this.inner, this.knockout, this.hideObject
        ];
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "distance": this.distance,
            "angle": this.angle,
            "color": this.color,
            "alpha": this.alpha / 100,
            "strength": this.strength,
            "inner": this.inner,
            "knockout": this.knockout,
            "hideObject": this.hideObject
        };
    }
}
/**
 * @class
 */
class GlowFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        super(object);
        this.name = "GlowFilter";

        this._$color      = 0;
        this._$alpha      = 100;
        this._$strength   = 1;
        this._$inner      = false;
        this._$knockout   = false;

        if (object) {
            this.color      = object.color;
            this.alpha      = object.alpha * 100;
            this.strength   = object.strength;
            this.inner      = object.inner;
            this.knockout   = object.knockout;
        }
    }

    /**
     * @return {number}
     * @public
     */
    get color ()
    {
        return this._$color;
    }

    /**
     * @param  {number} color
     * @return {void}
     * @public
     */
    set color (color)
    {
        this._$color = +color;
    }

    /**
     * @return {number}
     * @public
     */
    get alpha ()
    {
        return this._$alpha;
    }

    /**
     * @param  {number} alpha
     * @return {void}
     * @public
     */
    set alpha (alpha)
    {
        this._$alpha = Util.$clamp(+alpha, 0, 100);
    }

    /**
     * @return {number}
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }

    /**
     * @param  {number} strength
     * @return {void}
     * @public
     */
    set strength (strength)
    {
        this._$strength = Util.$clamp(+strength, Util.MIN_STRENGTH, Util.MAX_STRENGTH);
    }

    /**
     * @return {boolean}
     * @public
     */
    get inner ()
    {
        return this._$inner;
    }

    /**
     * @param  {boolean} inner
     * @return {void}
     * @public
     */
    set inner (inner)
    {
        this._$inner = inner;
    }

    /**
     * @return {boolean}
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }

    /**
     * @param  {boolean} knockout
     * @return {void}
     * @public
     */
    set knockout (knockout)
    {
        this._$knockout = knockout;
    }

    /**
     * @param  {GlowFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$color !== filter._$color) {
            return false;
        }

        if (this._$alpha !== filter._$alpha) {
            return false;
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$inner !== filter._$inner) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @return {window.next2d.filters.GlowFilter}
     * @public
     */
    createInstance ()
    {
        return new window.next2d.filters.GlowFilter(
            this.color, this.alpha / 100, this.blurX, this.blurY,
            this.strength, this.quality, this.inner, this.knockout
        );
    }

    /**
     * @return {array}
     */
    toParamArray ()
    {
        return [null,
            this.color, this.alpha / 100, this.blurX, this.blurY,
            this.strength, this.quality, this.inner, this.knockout
        ];
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "color": this.color,
            "alpha": this.alpha / 100,
            "strength": this.strength,
            "inner": this.inner,
            "knockout": this.knockout
        };
    }
}
/**
 * @class
 */
class GradientBevelFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        super(object);
        this.name = "GradientBevelFilter";

        this._$distance = 4;
        this._$angle    = 45;
        this._$colors   = [0xffffff, 0xff0000, 0];
        this._$alphas   = [100, 0, 100];
        this._$ratios   = [0, 128, 255];
        this._$strength = 1;
        this._$type     = "inner";
        this._$knockout = false;

        if (object) {
            this.distance = +object.distance;
            this.angle    = +object.angle;
            this.colors   = object.colors;
            this.alphas   = object.alphas;
            this.ratios   = object.ratios;
            this.strength = +object.strength;
            this.type     = object.type;
            this.knockout = object.knockout;
        }
    }

    /**
     * @return {number}
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }

    /**
     * @param  {number} distance
     * @return {void}
     * @public
     */
    set distance (distance)
    {
        this._$distance = Util.$clamp(+distance, Util.MIN_DISTANCE, Util.MAX_DISTANCE);
    }

    /**
     * @return {number}
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }

    /**
     * @param  {number} angle
     * @return {void}
     * @public
     */
    set angle (angle)
    {
        this._$angle = +angle % 360;
    }

    /**
     * @return {array}
     * @public
     */
    get colors ()
    {
        return this._$colors;
    }

    /**
     * @param  {array} colors
     * @return {void}
     * @public
     */
    set colors (colors)
    {
        this._$colors.length = 0;
        this._$colors = colors;
    }

    /**
     * @return {array}
     * @public
     */
    get alphas ()
    {
        return this._$alphas;
    }

    /**
     * @param  {array} alphas
     * @return {void}
     * @public
     */
    set alphas (alphas)
    {
        this._$alphas.length = 0;
        for (let idx = 0; idx < alphas.length; ++idx) {
            this._$alphas.push(alphas[idx] * 100);
        }
    }

    /**
     * @return {array}
     * @public
     */
    get ratios ()
    {
        return this._$ratios;
    }

    /**
     * @param  {array} ratios
     * @return {void}
     * @public
     */
    set ratios (ratios)
    {
        this._$ratios.length = 0;
        for (let idx = 0; idx < ratios.length; ++idx) {
            this._$ratios.push(ratios[idx] * 255);
        }
    }

    /**
     * @return {number}
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }

    /**
     * @param  {number} strength
     * @return {void}
     * @public
     */
    set strength (strength)
    {
        this._$strength = Util.$clamp(+strength, Util.MIN_STRENGTH, Util.MAX_STRENGTH);
    }

    /**
     * @return {string}
     * @public
     */
    get type ()
    {
        return this._$type;
    }

    /**
     * @param  {string} type
     * @return {void}
     * @public
     */
    set type (type)
    {
        this._$type = type;
    }

    /**
     * @return {boolean}
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }

    /**
     * @param  {boolean} knockout
     * @return {void}
     * @public
     */
    set knockout (knockout)
    {
        this._$knockout = knockout;
    }

    /**
     * @return {object}
     * @public
     */
    adjustment ()
    {
        const ratios = [];
        const colors = [];
        const alphas = [];

        const ratioMap = new Map();
        for (let idx = 0; idx < this._$ratios.length; ++idx) {

            const ratio = this._$ratios[idx] / 255;

            ratios.push(ratio);
            ratioMap.set(ratio, idx);
        }

        ratios.sort(function (a, b)
        {
            switch (true) {

                case a > b:
                    return 1;

                case a < b:
                    return -1;

                default:
                    return 0;

            }
        });

        for (let idx = 0; idx < ratios.length; ++idx) {

            const index = ratioMap.get(ratios[idx]);

            colors.push(this._$colors[index]);
            alphas.push(this._$alphas[index] / 100);
        }

        return {
            "ratios": ratios,
            "colors": colors,
            "alphas": alphas
        };
    }

    /**
     * @param  {GradientBevelFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        for (let idx = 0; idx < this._$colors.length; ++idx) {
            if (this._$colors[idx] !== filter._$colors[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$alphas.length; ++idx) {
            if (this._$alphas[idx] !== filter._$alphas[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$ratios.length; ++idx) {
            if (this._$ratios[idx] !== filter._$ratios[idx]) {
                return false;
            }
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$type !== filter._$type) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @return {window.next2d.filters.GradientBevelFilter}
     * @public
     */
    createInstance ()
    {
        const object = this.adjustment();
        return new window.next2d.filters.GradientBevelFilter(
            this.distance, this.angle, object.colors, object.alphas,
            object.ratios, this.blurX, this.blurY, this.strength,
            this.quality, this.type, this.knockout
        );
    }

    /**
     * @return {array}
     */
    toParamArray ()
    {
        const object = this.adjustment();
        return [null,
            this.distance, this.angle, object.colors, object.alphas,
            object.ratios, this.blurX, this.blurY, this.strength,
            this.quality, this.type, this.knockout
        ];
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        const object = this.adjustment();
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "distance": this.distance,
            "angle": this.angle,
            "colors": object.colors,
            "alphas": object.alphas,
            "ratios": object.ratios,
            "strength": this.strength,
            "type": this.type,
            "knockout": this.knockout
        };
    }
}
/**
 * @class
 */
class GradientGlowFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        super(object);
        this.name = "GradientGlowFilter";

        this._$distance = 4;
        this._$angle    = 45;
        this._$colors   = [0xffffff, 0];
        this._$alphas   = [0, 100];
        this._$ratios   = [0, 255];
        this._$strength = 1;
        this._$type     = "outer";
        this._$knockout = false;

        if (object) {
            this.distance = +object.distance;
            this.angle    = +object.angle;
            this.colors   = object.colors;
            this.alphas   = object.alphas;
            this.ratios   = object.ratios;
            this.strength = +object.strength;
            this.type     = object.type;
            this.knockout = object.knockout;
        }
    }

    /**
     * @return {number}
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }

    /**
     * @param  {number} distance
     * @return {void}
     * @public
     */
    set distance (distance)
    {
        this._$distance = Util.$clamp(+distance, Util.MIN_DISTANCE, Util.MAX_DISTANCE);
    }

    /**
     * @return {number}
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }

    /**
     * @param  {number} angle
     * @return {void}
     * @public
     */
    set angle (angle)
    {
        this._$angle = +angle % 360;
    }

    /**
     * @return {array}
     * @public
     */
    get colors ()
    {
        return this._$colors;
    }

    /**
     * @param  {array} colors
     * @return {void}
     * @public
     */
    set colors (colors)
    {
        this._$colors.length = 0;
        this._$colors = colors;
    }

    /**
     * @return {array}
     * @public
     */
    get alphas ()
    {
        return this._$alphas;
    }

    /**
     * @param  {array} alphas
     * @return {void}
     * @public
     */
    set alphas (alphas)
    {
        this._$alphas.length = 0;
        for (let idx = 0; idx < alphas.length; ++idx) {
            this._$alphas.push(alphas[idx] * 100);
        }
    }

    /**
     * @return {array}
     * @public
     */
    get ratios ()
    {
        return this._$ratios;
    }

    /**
     * @param  {array} ratios
     * @return {void}
     * @public
     */
    set ratios (ratios)
    {
        this._$ratios.length = 0;
        for (let idx = 0; idx < ratios.length; ++idx) {
            this._$ratios.push(ratios[idx] * 255);
        }
    }

    /**
     * @return {number}
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }

    /**
     * @param  {number} strength
     * @return {void}
     * @public
     */
    set strength (strength)
    {
        this._$strength = Util.$clamp(+strength, Util.MIN_STRENGTH, Util.MAX_STRENGTH);
    }

    /**
     * @return {string}
     * @public
     */
    get type ()
    {
        return this._$type;
    }

    /**
     * @param  {string} type
     * @return {void}
     * @public
     */
    set type (type)
    {
        this._$type = type;
    }

    /**
     * @return {boolean}
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }

    /**
     * @param  {boolean} knockout
     * @return {void}
     * @public
     */
    set knockout (knockout)
    {
        this._$knockout = knockout;
    }

    /**
     * @return {object}
     * @public
     */
    adjustment ()
    {
        const ratios = [];
        const colors = [];
        const alphas = [];

        const ratioMap = new Map();
        for (let idx = 0; idx < this._$ratios.length; ++idx) {

            const ratio = this._$ratios[idx] / 255;

            ratios.push(ratio);
            ratioMap.set(ratio, idx);
        }

        ratios.sort(function (a, b)
        {
            switch (true) {

                case a > b:
                    return 1;

                case a < b:
                    return -1;

                default:
                    return 0;

            }
        });

        for (let idx = 0; idx < ratios.length; ++idx) {

            const index = ratioMap.get(ratios[idx]);

            colors.push(this._$colors[index]);
            alphas.push(this._$alphas[index] / 100);
        }

        return {
            "ratios": ratios,
            "colors": colors,
            "alphas": alphas
        };
    }

    /**
     * @param  {GradientGlowFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        for (let idx = 0; idx < this._$colors.length; ++idx) {
            if (this._$colors[idx] !== filter._$colors[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$alphas.length; ++idx) {
            if (this._$alphas[idx] !== filter._$alphas[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$ratios.length; ++idx) {
            if (this._$ratios[idx] !== filter._$ratios[idx]) {
                return false;
            }
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$type !== filter._$type) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @return {window.next2d.filters.GradientGlowFilter}
     * @public
     */
    createInstance ()
    {
        const object = this.adjustment();
        return new window.next2d.filters.GradientGlowFilter(
            this.distance, this.angle, object.colors, object.alphas,
            object.ratios, this.blurX, this.blurY, this.strength,
            this.quality, this.type, this.knockout
        );
    }

    /**
     * @return {array}
     */
    toParamArray ()
    {
        const object = this.adjustment();
        return [null,
            this.distance, this.angle, object.colors, object.alphas,
            object.ratios, this.blurX, this.blurY, this.strength,
            this.quality, this.type, this.knockout
        ];
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        const object = this.adjustment();
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "distance": this.distance,
            "angle": this.angle,
            "colors": object.colors,
            "alphas": object.alphas,
            "ratios": object.ratios,
            "strength": this.strength,
            "type": this.type,
            "knockout": this.knockout
        };
    }
}
/**
 * @class
 */
class ByteStream
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        this._$buffer     = null;
        this._$bitOffset  = 0;
        this._$byteOffset = 0;
    }

    /**
     * @param   {Uint8Array} data
     * @returns {void}
     */
    setData (data)
    {
        this._$buffer = data;
    }

    /**
     * @param   {number} length
     * @returns {Uint8Array}
     */
    getData (length)
    {
        this.byteAlign();

        const offset = this._$byteOffset + length;
        const array  = this._$buffer.slice(this._$byteOffset, offset);

        this._$byteOffset = offset;

        return array;
    }

    /**
     * @returns {string}
     */
    getHeaderSignature ()
    {
        let signature = "";

        let count = 3;
        while (count) {

            const code = this.getUI8();
            switch (code) {

                // trim
                case 32:
                case 96:
                case 127:
                    continue;

                default:
                    break;

            }

            signature += String.fromCharCode(code);

            --count;

        }

        return signature;
    }

    /**
     * @returns {number}
     */
    getVersion ()
    {
        return this.getUI8();
    }

    /**
     * @returns void
     */
    byteAlign ()
    {
        if (!this._$bitOffset) {
            return;
        }

        this._$byteOffset = this._$byteOffset + (this._$bitOffset + 7) / 8 | 0;
        this._$bitOffset  = 0;
    }

    /**
     * @returns void
     */
    byteCarry ()
    {
        if (this._$bitOffset > 7) {
            this._$byteOffset  = this._$byteOffset + (0 | (this._$bitOffset + 7) / 8);
            this._$bitOffset  &= 0x07;
        } else {
            while (this._$bitOffset < 0) {
                --this._$byteOffset;
                this._$bitOffset += 8;
            }
        }
    }

    /**
     * @param   {number} number
     * @returns {number}
     */
    getUIBits (number)
    {
        let value = 0;
        while (number) {

            value <<= 1;
            value |= this.getUIBit();

            --number;
        }
        return value;
    }

    /**
     * @returns {number}
     */
    getUIBit ()
    {
        this.byteCarry();
        return this._$buffer[this._$byteOffset] >> 7 - this._$bitOffset++ & 0x1;
    }

    /**
     * @param   {number} number
     * @returns {number}
     */
    getSIBits (number)
    {
        const value = this.getUIBits(number);
        const msb   = value & 0x1 << number - 1;
        if (msb) {
            return -(value ^ 2 * msb - 1) - 1;
        }
        return value;
    }

    /**
     * @returns {number}
     */
    getUI8 ()
    {
        this.byteAlign();
        return this._$buffer[this._$byteOffset++];
    }

    /**
     * @returns {number}
     */
    getUI16 ()
    {
        this.byteAlign();
        return this.getUI8() | this.getUI8() << 8;
    }

    /**
     * @returns {number}
     */
    getUI32 ()
    {
        this.byteAlign();
        return this.getUI8() | (this.getUI8()
            | (this.getUI8() | this.getUI8() << 8) << 8) << 8;
    }
}
/**
 * @class
 */
class ReComposition
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        this._$byteStream = new ByteStream();

        // reset
        this._$callback   = null;
        this._$bounds     = { "xMin": 0, "xMax": 0, "yMin": 0, "yMax": 0 };
        this._$swfVersion = 0;
        this._$info       = null;
        this._$buildData  = null;
        this._$fileSize   = 0;
        this._$mode       = "swf";
        this._$offset     = 0;
    }

    /**
     * @param  {Uint8Array} buffer
     * @return {ReComposition}
     * @public
     */
    setData (buffer)
    {
        this._$byteStream.setData(buffer);
        return this;
    }

    /**
     * @param  {function} callback
     * @return {void}
     * @public
     */
    run (callback = null)
    {
        // set
        this._$callback = callback;

        // signature
        const signature = this._$byteStream.getHeaderSignature();

        // version
        const version = this._$byteStream.getVersion();

        // file size
        this._$fileSize = this._$byteStream.getUI32();
        this._$mode     = "swf";
        switch (signature) {

            // No ZIP
            case "FWS":
                return this.parseAndBuild();

            // ZLIB
            case "CWS":
                {
                    if (Util.$unzipWorkerActive) {
                        Util.$unzipQueues.push(this);
                        return ;
                    }

                    // start worker
                    Util.$unzipWorkerActive = true;

                    if (!Util.$unzipWorker) {
                        Util.$unzipWorker = new Worker(Util.$unzipURL);
                    }

                    const worker = Util.$unzipWorker;

                    // set message event
                    worker.onmessage = Util.$unzipHandler.bind(this);

                    const data = this._$byteStream._$buffer;
                    worker.postMessage({
                        "fileSize": this._$fileSize,
                        "mode":     this._$mode,
                        "buffer":   data
                    }, [data.buffer]);
                }

                break;

            // LZMA
            case "ZWS":
                {
                    if (Util.$unlzmaWorkerActive) {
                        Util.$unlzmaQueues.push(this);
                        return ;
                    }

                    // start worker
                    Util.$unlzmaWorkerActive = true;

                    const worker = new Worker(Util.$unlzmaWorkerURL);

                    // set message event
                    worker.onmessage = Util.$unlzmaHandler.bind(this);

                    const data = this._$byteStream._$buffer;
                    worker.postMessage({
                        "fileSize": this._$fileSize,
                        "mode":     this._$mode,
                        "buffer":   data
                    }, [data.buffer]);
                }

                break;

            // error
            default:
                throw new Error("this data is not swf.");

        }

    }

    /**
     * @returns void
     * @public
     */
    parseAndBuild ()
    {
        // set stage bounds
        this._$byteStream.byteAlign();

        const nBits = this._$byteStream.getUIBits(5);
        this._$bounds.xMin = this._$byteStream.getSIBits(nBits);
        this._$bounds.xMax = this._$byteStream.getSIBits(nBits);
        this._$bounds.yMin = this._$byteStream.getSIBits(nBits);
        this._$bounds.yMax = this._$byteStream.getSIBits(nBits);

        this._$byteStream.getUI16(); // frameRate
        this._$byteStream.getUI16(); // frameCount

        // current offset
        this._$offset = this._$byteStream._$byteOffset;

        if (Util.$parserWorkerWait) {
            Util.$parserQueues.push(this);
            return ;
        }

        Util.$parserWorkerWait = true;

        if (!Util.$parserWorker) {
            Util.$parserWorker = new Worker(Util.$parserURL);
        }

        Util.$parserWorker.onmessage = Util.$parserHandler.bind(this);

        const buffer = this._$byteStream._$buffer;
        Util.$parserWorker.postMessage({
            "version": this._$swfVersion,
            "offset":  this._$offset,
            "buffer":  buffer
        }, [buffer.buffer]);

    }

    /**
     * @return {MovieClip|DisplayObject}
     * @public
     */
    build ()
    {

        // setup
        const info   = this.buildData.info;
        const object = this.buildData.parent;

        this.loaderInfo._$bytes._$byteArray   = this.buildData.buffer;
        this.loaderInfo._$actionScriptVersion = info._$asv;

        // symbol copy and build
        let isMain = false;
        let length = this.loaderInfo._$symbols.length;
        if (length) {

            const applicationDomain = this.loaderInfo._$applicationDomain;
            const symbols   = Util.$getArray();
            for (let idx = 0; idx < length; ++idx) {

                const symbol = this.loaderInfo._$symbols[idx];

                const id = symbol.tagId;
                if (id === 0) {
                    isMain = true;
                }

                switch (true) {

                    case id in this.loaderInfo._$characters:
                    case this.loaderInfo._$fonts.has(id):
                        {

                            const instance = Util.$getPackage(applicationDomain, symbol.path);
                            if (instance._$loaderInfoId === this.loaderInfo._$id
                                || !("__$$characterId" in instance.prototype)
                            ) {

                                instance.prototype.__$$characterId  = id;
                                instance.prototype.__$$loaderInfoId = this.loaderInfo._$id;

                                const slots = instance.__$$slots;

                                const names  = Util.$Object.keys(slots);
                                const length = names.length;
                                for (let idx = 0; idx < length; ++idx) {

                                    const slot = slots[names[idx]];

                                    if (!slot.__$$classInit) {
                                        continue;
                                    }

                                    slot.__$$classInit();
                                }

                                Util.$poolArray(names);

                            }

                        }
                        break;

                    default:
                        break;

                }

                symbols[id] = symbol.path;
            }

            // set new symbol
            this.loaderInfo._$symbols = symbols;

        }

        // create main
        if (isMain) {

            const main = Util.$buildAVM2(
                this.loaderInfo._$applicationDomain,
                this.loaderInfo._$symbols[0]
            );
            main._$root = main;
            main._$symbolBuild(0, this.loaderInfo._$id, object);

            // init set
            this.loaderInfo._$content = main;

        } else {

            MovieClip._$targetBuild(this.loaderInfo._$content, object);
            this.loaderInfo._$content._$characterBuild();

        }

        // init scenes
        length = info._$sceneInfo.length;
        if (length) {

            const scenes = Util.$getArray();
            for (let idx = 0; idx < length; ++idx) {

                const sceneInfo = info._$sceneInfo[idx];

                // create Scene
                const scene    = new Scene(sceneInfo.name, Util.$getArray(), 1);
                scene._$offset = sceneInfo.offset;

                // set numFrames
                const next = idx + 1 | 0;

                let offset = this.loaderInfo._$content._$totalFrames;
                if (next in info._$sceneInfo) {
                    offset = info._$sceneInfo[next].offset | 0;
                }
                scene._$numFrames = offset - scene._$offset | 0;

                // set labels
                const labels = this.loaderInfo._$content.currentLabels;
                if (labels) {
                    const total  = labels.length;
                    const sceneLabels = Util.$getArray();
                    for (let idx = 0; idx < total; ++idx) {

                        const label = labels[idx];

                        if (label.frame > sceneInfo.offset && label.frame <= offset) {
                            sceneLabels[sceneLabels.length] = label;
                        }

                    }
                    scene._$labels = sceneLabels;
                }

                // set array
                scenes[scenes.length] = scene;

            }

            this.loaderInfo._$content._$scenes = scenes;
        }

        this._$callback(this.loaderInfo._$content);
    }
}
/**
 * @class
 */
class SVGToShape
{
    /**
     * @param  {string} value
     * @param  {MovieClip} movie_clip
     * @return {void}
     * @method
     * @static
     */
    static parse (value, movie_clip)
    {
        const defs  = /<defs>(.*)<\/defs>/sgi.exec(value)[1];
        const paths = SVGToShape.parseXML(
            `${value.replace(/<defs>(.*)<\/defs>/sgi, "")}`
        );

        if (paths) {

            SVGToShape.parsePath(paths, defs, movie_clip);

            const layers = [];
            for (const layer of movie_clip._$layers.values()) {
                layers.unshift(layer);
            }

            movie_clip.clearLayer();
            for (let idx = 0; idx < layers.length; ++idx) {
                movie_clip.setLayer(idx, layers[idx]);
            }
        }
    }

    /**
     * @param  {string} xml
     * @return {array}
     * @method
     * @static
     */
    static parseXML (xml)
    {
        const pathReg = /<((path|rect|circle|polygon).+?)\/>/gi;

        const paths = [];
        for (let reg = "1"; reg;) {
            reg = pathReg.exec(xml);
            reg && paths.push(reg[1]);
        }

        return paths;
    }

    /**
     * @param  {array}     paths
     * @param  {string}    defs
     * @param  {MovieClip} movie_clip
     * @method
     * @static
     */
    static parsePath (paths, defs, movie_clip)
    {
        const { Shape, Graphics } = window.next2d.display;
        const workSpace = Util.$currentWorkSpace();

        for (let idx = 0; idx < paths.length; ++idx) {

            const graphics = new Shape().graphics;

            const value = paths[idx];

            // STROKE
            let strokeWidth = /stroke-width=\"(.+?)\"/gi.exec(value);
            if (!strokeWidth) {
                strokeWidth = /stroke-width:(.+?)["|;]/gi.exec(value);
            }

            if (strokeWidth) {
                strokeWidth = +strokeWidth[1];
                if (strokeWidth) {
                    let color = /stroke=\"(.+?)\"/gi.exec(value);
                    if (!color) {
                        color = /stroke:(.+?)["|;]/gi.exec(value);
                    }

                    graphics.lineStyle(strokeWidth, color ? color[1] : 0);
                }
            }

            // FILL
            let color = /fill=\"(.+?)\"/gi.exec(value);
            if (!color) {
                color = /fill:(.+?)["|;]/gi.exec(value);
            }

            let alpha = 1;
            let style = /style=\"(.+?)\"/gi.exec(value);
            if (style && style[1].indexOf("opacity") > -1) {
                alpha = style[1].split(":")[1];
            }

            if (color) {
                graphics.beginFill(color[1], +alpha);
            } else {
                if (!strokeWidth) {
                    graphics.beginFill(0, +alpha);
                }
            }

            const id = workSpace.nextLibraryId;

            const shape = workSpace.addLibrary(
                Util.$controller.createContainer("shape", `Shape_${id}`, id)
            );

            const layer = new Layer();
            layer.name  = `Layer_${movie_clip._$layers.size}`;
            layer
                ._$frame
                .setClasses(1, [
                    "key-frame"
                ]);

            movie_clip.setLayer(movie_clip._$layers.size, layer);

            const character = new Character();
            character.libraryId  = shape.id;
            character.startFrame = 1;
            character.endFrame   = layer.getEndFrame(2);
            character.setPlace(1, {
                "frame": 1,
                "matrix": [1, 0, 0, 1, 0, 0],
                "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                "blendMode": "normal",
                "filter": [],
                "depth": layer._$characters.length
            });
            layer.addCharacter(character);

            // draw rect
            if (value.indexOf("rect") > -1) {

                const param  = value.replace("rect", "");
                const x      = +/x=\"(.+?)\"/gi.exec(param)[1];
                const y      = +/y=\"(.+?)\"/gi.exec(param)[1];
                const width  = +/width=\"(.+?)\"/gi.exec(param)[1];
                const height = +/height=\"(.+?)\"/gi.exec(param)[1];
                const rx     = +/rx=\"(.+?)\"/gi.exec(param)[1];

                graphics
                    .drawRoundRect(x, y, width, height, rx * 2)
                    .endFill();

                shape._$recodes = graphics._$recode.slice();
                shape._$bounds = {
                    "xMin": graphics._$xMin,
                    "xMax": graphics._$xMax,
                    "yMin": graphics._$yMin,
                    "yMax": graphics._$yMax
                };

                continue;
            }

            if (value.indexOf("circle") > -1) {

                const param = value.replace("rect", "");
                const x     = +/cx=\"(.+?)\"/gi.exec(param)[1];
                const y     = +/cy=\"(.+?)\"/gi.exec(param)[1];
                const r     = +/r=\"(.+?)\"/gi.exec(param)[1];

                graphics
                    .drawCircle(x, y, r)
                    .endFill();

                shape._$recodes = graphics._$recode.slice();
                shape._$bounds = {
                    "xMin": graphics._$xMin,
                    "xMax": graphics._$xMax,
                    "yMin": graphics._$yMin,
                    "yMax": graphics._$yMax
                };

                continue;
            }

            if (value.indexOf("polygon") > -1) {

                const path = value.replace("polygon", "");

                let points = /points=\"(.+?)\"/gi.exec(path)[1];

                points = points.replace(/,/g, " ");
                points = points.replace(/-/g, " -");
                points = points.trim().split(" ");
                points = SVGToShape._$adjParam(points);

                graphics.moveTo(+points[0], +points[1]);
                for (let idx = 2; idx < points.length; idx += 2) {
                    graphics.lineTo(
                        +points[idx    ],
                        +points[idx + 1]
                    );
                }
                graphics.endFill();

                shape._$recodes = graphics._$recode.slice();
                shape._$bounds = {
                    "xMin": graphics._$xMin,
                    "xMax": graphics._$xMax,
                    "yMin": graphics._$yMin,
                    "yMax": graphics._$yMax
                };

                continue;
            }

            let start   = false;
            let startX  = 0;
            let startY  = 0;

            const currentPoint = [0, 0];
            const lastControl  = [0, 0];
            const actionReg = /([a-z])([^a-z]*)/gi;

            const d = /d=\"(.+?)\"/gi.exec(value)[1];
            for (let reg = "1"; reg;) {

                // TODO transform
                // let tx = 0;
                // let ty = 0;
                // if (value.indexOf("translate") > -1) {
                //
                //     let translate = /translate\((.+?)\)/gi.exec(value)[1];
                //     translate = translate.replace(/,/g, " ");
                //     translate = translate.replace(/-/g, " -");
                //     translate = translate.trim().split(" ");
                //     translate = SVGToShape._$adjParam(translate);
                //
                //     const param = [];
                //     for (let idx = 0; idx < translate.length; ++idx) {
                //
                //         const value = translate[idx];
                //         if (value === "") {
                //             continue;
                //         }
                //
                //         param.push(+value);
                //     }
                //
                //     tx = param[0];
                //     ty = param[1];
                // }

                reg = actionReg.exec(d);
                if (reg) {

                    const type = `${reg[1]}`;

                    let param = reg[2];
                    switch (type) {

                        case "m":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            currentPoint[0] += +param[0];
                            currentPoint[1] += +param[1];

                            if (!start) {
                                start = true;
                                startX = currentPoint[0];
                                startY = currentPoint[1];
                            }

                            graphics.moveTo(
                                currentPoint[0],
                                currentPoint[1]
                            );

                            for (let idx = 2; idx < param.length; idx += 2) {
                                currentPoint[0] += +param[idx    ];
                                currentPoint[1] += +param[idx + 1];
                                lastControl[0]   = currentPoint[0];
                                lastControl[1]   = currentPoint[1];
                                graphics.lineTo(
                                    currentPoint[0],
                                    currentPoint[1]
                                );
                            }
                            break;

                        case "M":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            currentPoint[0] = +param[0];
                            currentPoint[1] = +param[1];

                            if (!start) {
                                start = true;
                                startX = currentPoint[0];
                                startY = currentPoint[1];
                            }

                            graphics.moveTo(
                                currentPoint[0],
                                currentPoint[1]
                            );

                            for (let idx = 2; idx < param.length; idx += 2) {
                                currentPoint[0] = +param[idx    ];
                                currentPoint[1] = +param[idx + 1];
                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                                graphics.lineTo(
                                    currentPoint[0],
                                    currentPoint[1]
                                );
                            }
                            break;

                        case "l":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 2) {
                                currentPoint[0] += +param[idx    ];
                                currentPoint[1] += +param[idx + 1];
                                lastControl[0]   = currentPoint[0];
                                lastControl[1]   = currentPoint[1];
                                graphics.lineTo(
                                    currentPoint[0],
                                    currentPoint[1]
                                );
                            }
                            break;

                        case "L":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 2) {
                                currentPoint[0] = +param[idx    ];
                                currentPoint[1] = +param[idx + 1];
                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                                graphics.lineTo(
                                    currentPoint[0],
                                    currentPoint[1]
                                );
                            }
                            break;

                        case "h":
                            currentPoint[0] += +param;
                            lastControl[0]   = currentPoint[0];
                            graphics.lineTo(
                                currentPoint[0],
                                currentPoint[1]
                            );
                            break;

                        case "H":
                            currentPoint[0] = +param;
                            lastControl[0]  = currentPoint[0];
                            graphics.lineTo(
                                currentPoint[0],
                                currentPoint[1]
                            );
                            break;

                        case "v":
                            currentPoint[1] += +param;
                            lastControl[1]   = currentPoint[1];
                            graphics.lineTo(
                                currentPoint[0],
                                currentPoint[1]
                            );
                            break;

                        case "V":
                            currentPoint[1] = +param;
                            lastControl[1]  = currentPoint[1];
                            graphics.lineTo(currentPoint[0], currentPoint[1]);
                            break;

                        case "q":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 4) {

                                param[idx    ] = +param[idx    ] + currentPoint[0];
                                param[idx + 1] = +param[idx + 1] + currentPoint[1];
                                param[idx + 2] = +param[idx + 2] + currentPoint[0];
                                param[idx + 3] = +param[idx + 3] + currentPoint[1];

                                graphics.curveTo(
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2], param[idx + 3]
                                );

                                currentPoint[0] = param[idx + 2];
                                currentPoint[1] = param[idx + 3];

                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                            }
                            break;

                        case "Q":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 4) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];

                                graphics.curveTo(
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2], param[idx + 3]
                                );

                                currentPoint[0] = param[idx + 2];
                                currentPoint[1] = param[idx + 3];

                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                            }
                            break;

                        case "c":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 6) {

                                param[idx    ] = +param[idx    ] + currentPoint[0];
                                param[idx + 1] = +param[idx + 1] + currentPoint[1];
                                param[idx + 2] = +param[idx + 2] + currentPoint[0];
                                param[idx + 3] = +param[idx + 3] + currentPoint[1];
                                param[idx + 4] = +param[idx + 4] + currentPoint[0];
                                param[idx + 5] = +param[idx + 5] + currentPoint[1];

                                graphics.cubicCurveTo(
                                    param[idx    ], param[idx + 1], param[idx + 2],
                                    param[idx + 3], param[idx + 4], param[idx + 5]
                                );

                                currentPoint[0] = param[idx + 4];
                                currentPoint[1] = param[idx + 5];

                                lastControl[0] = 2 * param[idx + 4] - param[idx + 2];
                                lastControl[1] = 2 * param[idx + 5] - param[idx + 3];
                            }

                            break;

                        case "C":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 6) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];
                                param[idx + 4] = +param[idx + 4];
                                param[idx + 5] = +param[idx + 5];

                                graphics.cubicCurveTo(
                                    param[idx    ], param[idx + 1], param[idx + 2],
                                    param[idx + 3], param[idx + 4], param[idx + 5]
                                );

                                currentPoint[0] = param[idx + 4];
                                currentPoint[1] = param[idx + 5];

                                lastControl[0] = 2 * param[idx + 4] - param[idx + 2];
                                lastControl[1] = 2 * param[idx + 5] - param[idx + 3];

                            }
                            break;

                        case "s":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 4) {

                                param[idx    ] = +param[idx    ] + currentPoint[0];
                                param[idx + 1] = +param[idx + 1] + currentPoint[1];
                                param[idx + 2] = +param[idx + 2] + currentPoint[0];
                                param[idx + 3] = +param[idx + 3] + currentPoint[1];

                                graphics.cubicCurveTo(
                                    lastControl[0], lastControl[1],
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2], param[idx + 3]
                                );

                                currentPoint[0] = param[idx + 2];
                                currentPoint[1] = param[idx + 3];

                                lastControl[0] = 2 * param[idx + 2] - param[idx    ];
                                lastControl[1] = 2 * param[idx + 3] - param[idx + 1];
                            }

                            break;

                        case "S":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 4) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];

                                graphics.cubicCurveTo(
                                    lastControl[0], lastControl[1],
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2], param[idx + 3]
                                );

                                currentPoint[0] = param[idx + 2];
                                currentPoint[1] = param[idx + 3];

                                lastControl[0] = 2 * param[idx + 2] - param[idx    ];
                                lastControl[1] = 2 * param[idx + 3] - param[idx + 1];
                            }
                            break;

                        case "a":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 7) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];
                                param[idx + 4] = +param[idx + 4];
                                param[idx + 5] = +param[idx + 5] + currentPoint[0];
                                param[idx + 6] = +param[idx + 6] + currentPoint[1];

                                const curves = SVGToShape._$arcToCurve(
                                    currentPoint[0], currentPoint[1],
                                    param[idx + 5], param[idx + 6],
                                    param[idx + 3], param[idx + 4],
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2]
                                );

                                for (let idx = 0; idx < curves.length; ++idx) {
                                    const curve = curves[idx];
                                    graphics.cubicCurveTo(
                                        curve[0], curve[1],
                                        curve[2], curve[3],
                                        curve[4], curve[5]
                                    );
                                }

                                currentPoint[0] = param[idx + 5];
                                currentPoint[1] = param[idx + 6];

                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                            }

                            break;

                        case "A":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 7) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];
                                param[idx + 4] = +param[idx + 4];
                                param[idx + 5] = +param[idx + 5];
                                param[idx + 6] = +param[idx + 6];

                                const curves = SVGToShape._$arcToCurve(
                                    currentPoint[0], currentPoint[1],
                                    param[idx + 5], param[idx + 6],
                                    param[idx + 3], param[idx + 4],
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2]
                                );

                                for (let idx = 0; idx < curves.length; ++idx) {
                                    const curve = curves[idx];
                                    graphics.cubicCurveTo(
                                        curve[0], curve[1],
                                        curve[2], curve[3],
                                        curve[4], curve[5]
                                    );
                                }

                                currentPoint[0] = param[idx + 5];
                                currentPoint[1] = param[idx + 6];

                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                            }
                            break;

                        case "z":
                        case "Z":
                            if (graphics._$fills) {
                                graphics._$fills.push(Graphics.CLOSE_PATH);
                            }
                            if (graphics._$lines) {
                                graphics._$lines.push(Graphics.CLOSE_PATH);
                            }

                            currentPoint[0] = startX;
                            currentPoint[1] = startY;
                            lastControl[0]  = currentPoint[0];
                            lastControl[1]  = currentPoint[1];
                            start = false;
                            break;

                        default:
                            console.log("TODO: ", type, param);
                            break;

                    }
                }
            }
            graphics.endLine();
            graphics.endFill();

            if (graphics._$recode) {
                shape._$recodes = graphics._$recode.slice();
            }

            shape._$bounds = {
                "xMin": graphics._$xMin,
                "xMax": graphics._$xMax,
                "yMin": graphics._$yMin,
                "yMax": graphics._$yMax
            };
        }
    }

    /**
     * @param  {array} param
     * @return {array}
     * @private
     */
    static _$adjParam (param)
    {
        for (;;) {
            let count = 0;
            for (let idx = 0; idx < param.length; ++idx) {

                const value = param[idx];
                if (!isNaN(value)) {
                    count++;
                    continue;
                }

                const values = value.split(".");
                param.splice(idx + 1, 0, `0.${values.pop()}`);
                param[idx] = values.join(".");
            }

            if (param.length === count) {
                break;
            }
        }
        return param;
    }

    /**
     * @param {next2d.display.Graphics} graphics
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {number} start_ang
     * @param {number} end_ang
     * @private
     * @static
     */
    static _$arc (graphics, x, y, radius, start_ang, end_ang)
    {
        let num = Math.min(Math.ceil(radius * 2 + 1), 1024);
        if (num < 1) {
            return;
        }

        start_ang = start_ang === undefined
            ? 0
            : start_ang;

        end_ang = end_ang === undefined
            ? Math.PI * 2
            : end_ang;

        const delta = (end_ang - start_ang) / num;
        for (let idx = 0; idx <= num; idx++) {
            const f = start_ang + idx * delta;
            graphics.lineTo(x + Math.cos(f) * radius, y + Math.sin(f) * radius);
        }
    }

    /**
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} fa
     * @param {number} fs
     * @param {number} rx
     * @param {number} ry
     * @param {number} phi
     * @private
     * @static
     */
    static _$arcToCurve (x1, y1, x2, y2, fa, fs, rx, ry, phi)
    {
        const TAU = Math.PI * 2;
        const sin_phi = Math.sin(phi * TAU / 360);
        const cos_phi = Math.cos(phi * TAU / 360);

        const x1p = cos_phi  * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
        const y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;

        if (x1p === 0 && y1p === 0 || rx === 0 || ry === 0) {
            return [];
        }

        rx = Math.abs(rx);
        ry = Math.abs(ry);

        const lambda = x1p * x1p / (rx * rx) + y1p * y1p / (ry * ry);
        if (lambda > 1) {
            rx *= Math.sqrt(lambda);
            ry *= Math.sqrt(lambda);
        }

        const cc = SVGToShape._$getArcCenter(
            x1, y1, x2, y2, fa, fs,
            rx, ry, sin_phi, cos_phi
        );

        const result = [];
        let theta1 = cc[2];
        let delta_theta = cc[3];

        const segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);
        delta_theta /= segments;

        for (let idx = 0; idx < segments; idx++) {
            result.push(SVGToShape._$approximateUnitArc(theta1, delta_theta));
            theta1 += delta_theta;
        }

        return result.map((curve) =>
        {
            for (let idx = 0; idx < curve.length; idx += 2) {

                let x = curve[idx    ];
                let y = curve[idx + 1];

                // scale
                x *= rx;
                y *= ry;

                // rotate
                const xp = cos_phi * x - sin_phi * y;
                const yp = sin_phi * x + cos_phi * y;

                // translate
                curve[idx    ] = xp + cc[0];
                curve[idx + 1] = yp + cc[1];
            }

            curve.shift();
            curve.shift();

            return curve;
        });
    }

    /**
     * @param {number} theta1
     * @param {number} delta_theta
     * @return {array}
     * @private
     * @static
     */
    static _$approximateUnitArc (theta1, delta_theta)
    {
        const alpha = 4 / 3 * Math.tan(delta_theta / 4);

        const x1 = Math.cos(theta1);
        const y1 = Math.sin(theta1);
        const x2 = Math.cos(theta1 + delta_theta);
        const y2 = Math.sin(theta1 + delta_theta);

        return [
            x1, y1,
            x1 - y1 * alpha,
            y1 + x1 * alpha,
            x2 + y2 * alpha,
            y2 - x2 * alpha,
            x2, y2
        ];
    }

    /**
     *
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} fa
     * @param {number} fs
     * @param {number} rx
     * @param {number} ry
     * @param {number} sin_phi
     * @param {number} cos_phi
     * @return {array}
     * @private
     * @static
     */
    static _$getArcCenter (x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi)
    {
        const TAU = Math.PI * 2;

        const x1p = cos_phi  * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
        const y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;

        const rx_sq  = rx * rx;
        const ry_sq  = ry * ry;
        const x1p_sq = x1p * x1p;
        const y1p_sq = y1p * y1p;

        let radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;

        if (radicant < 0) {
            radicant = 0;
        }

        radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;
        radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);

        const cxp = radicant *  rx / ry * y1p;
        const cyp = radicant * -ry / rx * x1p;

        const cx = cos_phi * cxp - sin_phi * cyp + (x1 + x2) / 2;
        const cy = sin_phi * cxp + cos_phi * cyp + (y1 + y2) / 2;

        const v1x = (x1p - cxp)  / rx;
        const v1y = (y1p - cyp)  / ry;
        const v2x = (-x1p - cxp) / rx;
        const v2y = (-y1p - cyp) / ry;

        const theta1 = SVGToShape._$unitVectorAngle(1, 0, v1x, v1y);
        let delta_theta = SVGToShape._$unitVectorAngle(v1x, v1y, v2x, v2y);

        if (fs === 0 && delta_theta > 0) {
            delta_theta -= TAU;
        }
        if (fs === 1 && delta_theta < 0) {
            delta_theta += TAU;
        }

        return [cx, cy, theta1, delta_theta];
    }

    /**
     * @param  {number} ux
     * @param  {number} uy
     * @param  {number} vx
     * @param  {number} vy
     * @return {number}
     * @static
     * @private
     */
    static _$unitVectorAngle (ux, uy, vx, vy)
    {
        const sign = ux * vy - uy * vx < 0 ? -1 : 1;
        let dot = ux * vx + uy * vy;

        if (dot > 1.0) {
            dot = 1.0;
        }

        if (dot < -1.0) {
            dot = -1.0;
        }

        return sign * Math.acos(dot);
    }
}

/**
 * @class
 */
class VectorToCanvas
{
    /**
     * @param   {object} src
     * @returns {object}
     * @public
     */
    clone (src)
    {
        const execute = function (src, obj)
        {
            const keys   = Object.keys(src);
            const length = keys.length | 0;
            for (let idx = 0; idx < length; ++idx) {

                const prop  = keys[idx];
                const value = src[prop];

                switch (true) {

                    case Util.$isArray(value):
                        obj[prop] = [];
                        execute(value, obj[prop]);
                        break;

                    case typeof value === "object":
                        obj[prop] = {};
                        execute(value, obj[prop]);
                        break;

                    default:
                        obj[prop] = value;
                        break;

                }
            }
        };

        const obj = {};
        execute(src, obj);

        return obj;
    }

    /**
     * @param   {object}  shapes
     * @param   {boolean} [is_morph=false]
     * @returns {array}
     * @public
     */
    convert (shapes, is_morph = false)
    {
        let lineStyles = shapes.lineStyles;
        let fillStyles = shapes.fillStyles;
        let idx        = 0;
        let obj        = {};
        let cache      = [];
        let AnchorX    = 0;
        let AnchorY    = 0;
        let MoveX      = 0;
        let MoveY      = 0;
        let LineX      = 0;
        let LineY      = 0;
        let FillStyle0 = 0;
        let FillStyle1 = 0;
        let LineStyle  = 0;
        let fills0     = [];
        let fills1     = [];
        let lines      = [];
        let stack      = [];
        let depth      = 0;

        // setup
        const shapeData = shapes.ShapeData;
        const records   = shapeData.records;
        const newStyles = shapeData.styles;

        let i = 0;
        let s = 0;
        for (;;) {

            const state = records[i++];

            // end
            if (state === -1) {
                stack = this.setStack(stack, this.fillMerge(fills0, fills1, is_morph));
                stack = this.setStack(stack, lines);
                break;
            }

            // data change
            if (state) {

                ++depth;

                // StateNewStyles
                if (records[i++]) {

                    //  build data
                    stack   = this.setStack(stack, this.fillMerge(fills0, fills1, is_morph));
                    stack   = this.setStack(stack, lines);

                    // reset
                    AnchorX = 0;
                    AnchorY = 0;
                    fills0  = [];
                    fills1  = [];
                    lines   = [];

                    const styles = newStyles[s++];
                    if (records[i++]) {
                        fillStyles = styles.FillStyles;
                    }

                    if (records[i++]) {
                        lineStyles = styles.LineStyles;
                    }

                }

                // default
                MoveX = AnchorX;
                MoveY = AnchorY;

                // override
                if (records[i++]) {
                    MoveX = AnchorX = records[i++] / 20;
                    MoveY = AnchorX = records[i++] / 20;
                }

                LineX = MoveX;
                LineY = MoveY;

                // StateFillStyle0
                if (records[i++]) {
                    FillStyle0 = records[i++];
                }

                // StateFillStyle1
                if (records[i++]) {
                    FillStyle1 = records[i++];
                }

                // StateLineStyle
                if (records[i++]) {
                    LineStyle = records[i++];
                }

                continue;
            }

            const isCurved = records[i++];
            const ControlX = isCurved ? records[i++] / 20 : 0;
            const ControlY = isCurved ? records[i++] / 20 : 0;
            AnchorX        = records[i++] / 20;
            AnchorY        = records[i++] / 20;

            const record = {
                "isCurved": isCurved,
                "ControlX": ControlX,
                "ControlY": ControlY,
                "AnchorX":  AnchorX,
                "AnchorY":  AnchorY
            };

            // fill0
            if (FillStyle0) {

                idx = FillStyle0 - 1 | 0;
                if (!(idx in fills0)) {
                    fills0[idx] = [];
                }

                if (!(depth in fills0[idx])) {
                    fills0[idx][depth] = {
                        "obj":    fillStyles ? fillStyles[idx] : null,
                        "startX": MoveX,
                        "startY": MoveY,
                        "endX":   0,
                        "endY":   0,
                        "cache":  []
                    };
                }

                obj   = fills0[idx][depth];
                cache = obj.cache;
                cache[cache.length] = this.clone(record);

                obj.endX = AnchorX;
                obj.endY = AnchorY;
            }

            // fill1
            if (FillStyle1) {

                idx = FillStyle1 - 1 | 0;
                if (!(idx in fills1)) {
                    fills1[idx] = [];
                }

                if (!(depth in fills1[idx])) {
                    fills1[idx][depth] = {
                        "obj":    fillStyles ? fillStyles[idx] : null,
                        "startX": MoveX,
                        "startY": MoveY,
                        "endX":   0,
                        "endY":   0,
                        "cache":  []
                    };
                }

                obj   = fills1[idx][depth];
                cache = obj.cache;
                cache[cache.length] = this.clone(record);

                obj.endX = AnchorX;
                obj.endY = AnchorY;
            }

            // lines
            if (LineStyle) {

                idx = LineStyle - 1 | 0;
                if (!(idx in lines)) {
                    lines[idx] = {
                        "obj":   lineStyles ? lineStyles[idx] : null,
                        "cache": []
                    };
                }

                obj   = lines[idx];
                cache = obj.cache;
                cache[cache.length] = [0, LineX, LineY];

                let code = [2, AnchorX, AnchorY];
                if (isCurved) {
                    code = [1, ControlX, ControlY, AnchorX, AnchorY];
                }

                cache[cache.length] = code;
            }

            LineX = AnchorX;
            LineY = AnchorY;
        }

        return this.toGraphicPath(stack);
    }

    /**
     * @param  {array} stack
     * @return {array}
     * @public
     */
    toGraphicPath (stack)
    {
        const {
            Graphics,
            GradientType,
            InterpolationMethod,
            SpreadMethod,
            CapsStyle,
            JointStyle
        } = window.next2d.display;

        const recodes = [];
        for (let idx = 0; idx < stack.length; ++idx) {

            const data = stack[idx];

            recodes.push(Graphics.BEGIN_PATH);

            for (let idx = 0; idx < data.recode.length; ++idx) {
                recodes.push.apply(recodes, data.recode[idx]);
            }

            const isStroke = "Width" in data.object;
            let lineWidth  = 0;
            let capsStyle  = CapsStyle.NONE;
            let miterLimit = 0;
            let jointStyle = JointStyle.ROUND;
            if (isStroke) {

                lineWidth = data.object.Width;

                switch (data.object.StartCapStyle) {

                    case 0:
                        capsStyle = CapsStyle.ROUND;
                        break;

                    case 1:
                        capsStyle = CapsStyle.NONE;
                        break;

                    case 2:
                        capsStyle = CapsStyle.SQUARE;
                        break;

                }

                switch (data.object.JoinStyle) {

                    case 0:
                        jointStyle = JointStyle.ROUND;
                        break;

                    case 1:
                        jointStyle = JointStyle.BEVEL;
                        break;

                    case 2:
                        jointStyle = JointStyle.MITER;
                        miterLimit = data.object.MiterLimitFactor;
                        break;

                }
            }

            const styleObject = data.object.HasFillFlag
                ? data.object.FillType
                : data.object;

            switch (styleObject.fillStyleType) {

                case 0x00: // solid fill

                    if (isStroke) {

                        recodes.push(
                            Graphics.STROKE_STYLE,
                            lineWidth,
                            capsStyle,
                            jointStyle,
                            miterLimit,
                            styleObject.Color.R,
                            styleObject.Color.G,
                            styleObject.Color.B,
                            styleObject.Color.A * 255,
                            Graphics.END_STROKE
                        );

                    } else {

                        recodes.push(
                            Graphics.FILL_STYLE,
                            styleObject.Color.R,
                            styleObject.Color.G,
                            styleObject.Color.B,
                            styleObject.Color.A * 255,
                            Graphics.END_FILL
                        );

                    }

                    break;

                case 0x10: // linear gradient fill
                case 0x12: // radial gradient fill
                case 0x13: // radial gradient fill
                    {
                        const gradient = styleObject.gradient;

                        const colorStops = [];
                        const gradientRecords = gradient.GradientRecords;
                        for (let idx = 0; idx < gradientRecords.length; ++idx) {
                            const recode = gradientRecords[idx];
                            colorStops.push({
                                "ratio": recode.Ratio,
                                "R": recode.Color.R,
                                "G": recode.Color.G,
                                "B": recode.Color.B,
                                "A": recode.Color.A * 255
                            });
                        }

                        const interpolationMode = gradient.InterpolationMode === 0
                            ? InterpolationMethod.RGB
                            : InterpolationMethod.LINEAR_RGB;

                        let spreadMode = SpreadMethod.PAD;
                        switch (gradient.SpreadMode) {

                            case 0:
                                spreadMode = SpreadMethod.PAD;
                                break;

                            case 1:
                                spreadMode = SpreadMethod.REFLECT;
                                break;

                            case 2:
                                spreadMode = SpreadMethod.REPEAT;
                                break;

                        }

                        if (isStroke) {

                            recodes.push(
                                Graphics.GRADIENT_STROKE,
                                lineWidth,
                                capsStyle,
                                jointStyle,
                                miterLimit,
                                styleObject.fillStyleType === 0x10
                                    ? GradientType.LINEAR
                                    : GradientType.RADIAL,
                                colorStops,
                                styleObject.gradientMatrix,
                                spreadMode,
                                interpolationMode,
                                gradient.FocalPoint
                            );

                        } else {

                            recodes.push(
                                Graphics.GRADIENT_FILL,
                                styleObject.fillStyleType === 0x10
                                    ? GradientType.LINEAR
                                    : GradientType.RADIAL,
                                colorStops,
                                styleObject.gradientMatrix,
                                spreadMode,
                                interpolationMode,
                                gradient.FocalPoint
                            );

                        }
                    }
                    break;

                case 0x40: // repeating bitmap fill
                case 0x41: // clipped bitmap fill
                case 0x42: // non-smoothed repeating bitmap fill
                case 0x43: // non-smoothed clipped bitmap fill
                    {
                        const bitmap = Util
                            .$currentWorkSpace()
                            .getLibrary(
                                Util.$characters.get(styleObject.bitmapId)
                            );

                        // eslint-disable-next-line no-loop-func
                        const wait = function (recodes, style_object)
                        {
                            if (!this._$buffer) {
                                return requestAnimationFrame(wait);
                            }

                            const smooth =
                                style_object.fillStyleType === 0x40
                                || style_object.fillStyleType === 0x41;

                            const repeat =
                                style_object.fillStyleType === 0x40
                                || style_object.fillStyleType === 0x42;

                            const matrix = Util.$multiplicationMatrix(
                                style_object.bitmapMatrix,
                                [0.05, 0, 0, 0.05, 0, 0]
                            );

                            const { BitmapData } = window.next2d.display;
                            const bitmapData = new BitmapData(
                                this.width, this.height, true, 0
                            );
                            bitmapData._$buffer = this._$buffer;

                            recodes.push(
                                Graphics.BITMAP_FILL,
                                bitmapData,
                                matrix,
                                repeat ? "repeat" : "no-repeat",
                                smooth
                            );

                        }.bind(bitmap, recodes, styleObject);
                        wait();
                    }
                    break;

                default:
                    break;

            }
        }

        return recodes;
    }

    /**
     * @param   {array}   fills0
     * @param   {array}   fills1
     * @param   {boolean} is_morph
     * @returns {array}
     * @public
     */
    fillMerge (fills0, fills1, is_morph)
    {
        fills0 = this.fillReverse(fills0);

        if (fills0.length) {

            const keys   = Object.keys(fills0);
            const length = keys.length | 0;
            for (let key = 0; key < length; ++key) {

                const idx   = keys[key];
                const fills = fills0[idx];

                if (idx in fills1) {

                    const fill1 = fills1[idx];
                    const fKeys = Object.keys(fills);
                    const kLen  = fKeys.length | 0;
                    for (let kIdx = 0; kIdx < kLen; ++kIdx) {
                        fill1[fill1.length] = fills[fKeys[kIdx]];
                    }

                } else {

                    fills1[idx] = fills;

                }
            }
        }

        return this.coordinateAdjustment(fills1, is_morph);
    }

    /**
     * @param   {array} fills0
     * @returns {array}
     * @public
     */
    fillReverse (fills0)
    {
        if (!fills0.length) {
            return fills0;
        }

        const f0Keys = Object.keys(fills0);
        const f0Len  = f0Keys.length | 0;
        for (let f0Idx = 0; f0Idx < f0Len; ++f0Idx) {

            const i     = f0Keys[f0Idx];
            const fills = fills0[i];
            const fKeys = Object.keys(fills);
            const fLen  = fKeys.length | 0;
            for (let fIdx = 0; fIdx < fLen; ++fIdx) {

                const depth   = fKeys[fIdx];

                let AnchorX = 0;
                let AnchorY = 0;
                const obj   = fills[depth];
                let cacheX  = obj.startX;
                let cacheY  = obj.startY;
                const cache = obj.cache;
                let length  = cache.length | 0;
                if (length) {

                    const cKeys = Object.keys(cache);
                    const cLen  = cKeys.length | 0;
                    for (let cIdx = 0; cIdx < cLen; ++cIdx) {
                        const idx      = cKeys[cIdx];
                        const recode   = cache[idx];
                        AnchorX        = recode.AnchorX;
                        AnchorY        = recode.AnchorY;
                        recode.AnchorX = cacheX;
                        recode.AnchorY = cacheY;
                        cacheX         = AnchorX;
                        cacheY         = AnchorY;
                    }

                    const array = [];
                    if (length > 0) {

                        while (length) {

                            --length;

                            array[array.length] = cache[length];

                        }

                    }

                    obj.cache = array;

                }

                // set
                cacheX     = obj.startX;
                cacheY     = obj.startY;
                obj.startX = obj.endX;
                obj.startY = obj.endY;
                obj.endX   = cacheX;
                obj.endY   = cacheY;
            }
        }

        return fills0;
    }

    /**
     * @param   {array}   fills1
     * @param   {boolean} is_morph
     * @returns {array}
     * @public
     */
    coordinateAdjustment (fills1, is_morph)
    {
        const f1Keys = Object.keys(fills1);
        const f1Len  = f1Keys.length | 0;
        for (let f1Idx = 0; f1Idx < f1Len; ++f1Idx) {

            // setup
            const i     = f1Keys[f1Idx];
            const array = [];
            const fills = fills1[i];

            const fKeys = Object.keys(fills);
            const fLen  = fKeys.length | 0;
            for (let fIdx = 0; fIdx < fLen; ++fIdx) {
                array[array.length] = fills[fKeys[fIdx]];
            }

            let adjustment = [];
            switch (true) {

                case array.length > 1 && !is_morph:

                    for (;;) {

                        if (!array.length) {
                            break;
                        }

                        const fill = array.shift();
                        if (fill.startX === fill.endX && fill.startY === fill.endY) {
                            adjustment[adjustment.length] = fill;
                            continue;
                        }

                        let isMatch = 0;
                        let length  = array.length | 0;
                        while (length) {

                            --length;

                            const comparison = array[length];
                            if (comparison.startX === fill.endX && comparison.startY === fill.endY) {

                                fill.endX  = comparison.endX;
                                fill.endY  = comparison.endY;

                                const cache0 = fill.cache;
                                const cache1 = comparison.cache;
                                const cLen   = cache1.length | 0;
                                for (let cIdx = 0; cIdx < cLen; ++cIdx) {
                                    cache0[cache0.length] = cache1[cIdx];
                                }

                                array.splice(length, 1);
                                array.unshift(fill);
                                isMatch = 1;

                                break;
                            }
                        }

                        if (!isMatch) {
                            array.unshift(fill);
                        }

                    }

                    break;

                default:
                    adjustment = array;
                    break;

            }

            const aLen  = adjustment.length | 0;
            const cache = [];

            let obj = {};
            for (let idx = 0; idx < aLen; ++idx) {

                const data = adjustment[idx];
                obj        = data.obj;

                const caches = data.cache;
                const cacheLength = caches.length | 0;
                cache[cache.length] = [0, data.startX, data.startY];

                for (let compIdx = 0; compIdx < cacheLength; ++compIdx) {
                    const r = caches[compIdx];
                    cache[cache.length] = r.isCurved
                        ? [1, r.ControlX, r.ControlY, r.AnchorX, r.AnchorY]
                        : [2, r.AnchorX, r.AnchorY];
                }
            }

            fills1[i] = {
                "cache": cache,
                "obj":   obj
            };

        }

        return fills1;
    }

    /**
     * @param   {array} stack
     * @param   {array} array
     * @returns {array}
     * @public
     */
    setStack (stack, array)
    {
        if (array.length) {
            const keys   = Object.keys(array);
            const length = keys.length | 0;
            for (let idx = 0; idx < length; ++idx) {

                const data = array[keys[idx]];

                stack.push({
                    "object": data.obj,
                    "recode": data.cache
                });
            }
        }

        return stack;
    }
}
Util.$vtc = new VectorToCanvas();
/**
 * @class
 */
class Setting
{
    /**
     * @constructor
     */
    constructor()
    {
        this._$undoLimit = 100;
        this._$language  = "Japanese";
    }
}
/**
 * @class
 */
class WorkSpace
{
    /**
     * @param {string} json
     * @constructor
     */
    constructor(json = "")
    {
        this._$name        = "";
        this._$stage       = null;
        this._$libraries   = new Map();
        this._$position    = 0;
        this._$characterId = 0;
        this._$revision    = [];
        this._$currentData = null;

        if (json) {
            this.load(json);
        }

        if (!this._$libraries.has(0)) {

            const root = new MovieClip({
                "id": 0,
                "type": "container",
                "name": "main",
                "symbol": ""
            });

            this._$libraries.set(0, root);
        }

        if (!this._$stage) {
            this._$stage = new Stage();
        }

    }

    /**
     * @return {void}
     * @public
     */
    run ()
    {
        // ステージをセット
        this.stage.initialize();

        // 初期化
        this.initialize(this.root);
    }

    /**
     * @param  {MovieClip} scene
     * @return {void}
     * @public
     */
    initialize (scene)
    {
        // シーンをセット
        this.scene = scene;

        // ライブラリを初期化
        this.initializeLibrary();

        // 内部スクリプトを初期化
        this.initializeInternalScript();
    }

    /**
     * @return {void}
     * @public
     */
    initializeLibrary ()
    {
        const library = document.getElementById("library-list-box");

        while (library.children.length) {
            library.children[0].remove();
        }

        const select = document
            .getElementById("sound-select");

        while (select.children.length) {
            select.children[0].remove();
        }

        const folderMap   = new Map();
        const childrenMap = new Map();

        // ライブラリにセット
        for (const value of this._$libraries.values()) {

            if (!value.id) {
                continue;
            }

            Util.$controller.createContainer(
                value.type, value.name, value.id, value.symbol
            );

            // fixed logic
            if (value.type === "folder" && value.mode === Util.FOLDER_OPEN) {
                const element = document
                    .getElementById(`folder-${value.id}`);

                element.classList.remove("library-type-folder-close");
                element.classList.add("library-type-folder-open");
            }

            if (value.folderId) {

                const element = document
                    .getElementById(`library-child-id-${value.id}`);

                element.remove();

                if (!childrenMap.has(value.folderId)) {
                    childrenMap.set(value.folderId, []);
                }

                childrenMap.get(value.folderId).unshift(element);
            }

            if (value.type === "folder") {
                folderMap.set(value.id, value);
            }
        }

        if (folderMap.size) {

            for (const [folderId, folder] of folderMap) {

                if (!childrenMap.has(folderId)) {
                    continue;
                }

                const element = document
                    .getElementById(`library-child-id-${folder.id}`);

                const children = childrenMap.get(folderId);
                for (let idx = 0; idx < children.length; ++idx) {

                    const child = children[idx];

                    element.parentNode.insertBefore(
                        child, element.nextElementSibling
                    );

                }

            }

            for (const folder of folderMap.values()) {

                if (folder.folderId) {
                    continue;
                }

                Util.$controller.updateFolderStyle(folder, folder.mode);
            }

            folderMap.clear();
            childrenMap.clear();
        }
    }

    /**
     * @return {void}
     * @public
     */
    initializeInternalScript ()
    {
        const element = document
            .getElementById("javascript-internal-list-box");

        const children = element.children;
        while (children.length) {
            children[0].remove();
        }

        for (const instance of this._$libraries.values()) {

            if (instance._$type !== "container") {
                continue;
            }

            if (!instance._$actions.size) {
                continue;
            }

            const id = instance.id;
            const parentTag = `<div id="script-${id}" data-library-id="${id}" class="internal-parent"><i></i>${instance._$name}</div>`;

            element.insertAdjacentHTML("beforeend", parentTag);

            const parentElement = document
                .getElementById(`script-${id}`);

            parentElement.addEventListener("dblclick", Util.$changeScene);

            for (const frame of instance._$actions.keys()) {

                const childTag = `<div id="script-${id}-${frame}" data-library-id="${id}" data-frame="${frame}" class="internal-child"><i></i>frame ${frame}</div>`;

                element.insertAdjacentHTML("beforeend", childTag);

                const childElement = document
                    .getElementById(`script-${id}-${frame}`);

                childElement.addEventListener("mousedown", function (event)
                {
                    const target = event.currentTarget;

                    Util.$keyLock      = true;
                    Util.$activeScript = true;

                    const frame = target.dataset.frame | 0;
                    Util.$timeline._$actionFrame = frame;

                    const scene = Util
                        .$currentWorkSpace()
                        .getLibrary(target.dataset.libraryId | 0);

                    Util.$timeline._$actionScene = scene;
                    const editor = Util.$timeline._$editor;
                    editor.setValue(scene.getAction(frame), -1);

                    document
                        .getElementById("editor-title")
                        .textContent = `${scene.name} / frame[${frame}]`;

                    editor.focus();

                    const element = document.getElementById("editor-modal");
                    element.style.display = "";
                    if (isNaN(parseFloat(element.style.left))) {
                        element.style.left = "200px";
                        element.style.top  = `${300 - element.clientHeight / 2}px`;
                    }

                    element.setAttribute("class", "fadeIn");
                    Util.$endMenu("editor-modal");
                });
            }

        }
    }

    /**
     * @return {void}
     * @public
     */
    stop ()
    {
        if (this._$scene) {
            this._$scene.stop();
            this._$scene = null;
        }
    }

    /**
     * @return {MovieClip}
     * @public
     */
    get scene ()
    {
        return this._$scene;
    }

    /**
     * @param  {MovieClip} scene
     * @return {void}
     * @public
     */
    set scene (scene)
    {
        if (this._$scene) {
            this._$scene.stop();
        }

        this._$scene = scene;
        scene.initialize();
    }

    /**
     * @param  {string} json
     * @return {void}
     * @public
     */
    load (json)
    {
        const object = JSON.parse(json);

        // copy
        this._$characterId = object.characterId|0;
        this._$name        = object.name;
        this._$stage       = new Stage(object.stage);

        if (this._$libraries.size) {
            this._$libraries.clear();
        }

        const libraries = object.libraries;
        for (let idx = 0; idx < libraries.length; ++idx) {
            this.addLibrary(libraries[idx]);
        }
    }

    /**
     * @return {string}
     * @public
     */
    toJSON ()
    {
        // ライブラリデータ
        const libraries = [];
        for (const value of this._$libraries.values()) {
            libraries.push(value.toObject());
        }

        return JSON.stringify({
            "version": Util.VERSION,
            "name": this.name,
            "characterId": this._$characterId,
            "stage": this.stage.toObject(),
            "libraries": libraries
        });
    }

    /**
     * @return {void}
     * @public
     */
    async temporarilySaved ()
    {
        Util.$updated = true;
        if (this._$currentData) {
            this._$currentData = null;
        }

        if (this._$position !== this._$revision.length) {
            this._$revision.length = this._$position;
        }

        this._$revision.push(this.toJSON());
        this._$position++;

        // remove old data
        if (this._$revision.length > Util.REVISION_LIMIT) {

            this._$revision.shift();

            this._$position = this._$revision.length;
        }
    }

    /**
     * @return {void}
     * @public
     */
    async undo ()
    {
        if (!this._$position) {
            return ;
        }

        if (!this._$currentData) {
            this._$currentData = this.toJSON();
        }

        const currentSceneId = this._$scene.id;
        this._$scene.stop();
        this._$scene = null;

        this.load(this._$revision[--this._$position]);

        // loadしたデータで初期化
        this.initialize(this.getLibrary(currentSceneId));

        // 再描画
        this.scene.changeFrame(
            document.getElementById("current-frame").textContent|0
        );
    }

    /**
     * @return {void}
     * @public
     */
    async redo ()
    {
        if (!this._$revision.length
            || this._$position === this._$revision.length
        ) {
            return ;
        }

        let data = null;
        if ((this._$position + 1) === this._$revision.length) {

            if (!this._$currentData) {
                return ;
            }

            data = this._$currentData;

            this._$position++;
            this._$currentData = null;

        } else {

            data = this._$revision[++this._$position];

        }

        if (!data) {
            return ;
        }

        const currentSceneId = this._$scene.id;
        this._$scene.stop();
        this._$scene = null;

        this.load(data);

        // loadしたデータで初期化
        this.initialize(this.getLibrary(currentSceneId));

        // 再描画
        this.scene.changeFrame(
            document.getElementById("current-frame").textContent|0
        );
    }

    /**
     * @return {MovieClip}
     * @readonly
     * @public
     */
    get root ()
    {
        return this._$libraries.get(0);
    }

    /**
     * @return {Stage}
     * @readonly
     * @public
     */
    get stage ()
    {
        return this._$stage;
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @param  {string} name
     * @return {void}
     * @public
     */
    set name (name)
    {
        this._$name = `${name}`;
    }

    /**
     * @param  {object} library
     * @return {object}
     * @public
     */
    addLibrary (library)
    {
        let instance;
        switch (library.type) {

            case "container":
                instance = new MovieClip(library);
                break;

            case "button":
                instance = new Button(library);
                break;

            case "bitmap":
                instance = new Bitmap(library);
                break;

            case "text":
                instance = new TextField(library);
                break;

            case "sound":
                instance = new Sound(library);
                break;

            case "video":
                instance = new Video(library);
                break;

            case "shape":
                instance = new Shape(library);
                break;

            case "folder":
                instance = new Folder(library);
                break;

        }

        this._$libraries.set(instance.id, instance);

        return instance;
    }

    /**
     * @param  {uint} id
     * @return {object}
     * @public
     */
    getLibrary (id)
    {
        // idが文字列の場合があるので、uintに変換
        return this._$libraries.get(id|0);
    }

    /**
     * @param  {uint} id
     * @return {void}
     * @public
     */
    removeLibrary (id)
    {
        this._$libraries.delete(id|0);

        for (let instance of this._$libraries.values()) {

            if (instance.type !== "container") {
                continue;
            }

            for (let layer of instance._$layers.values()) {

                const characters = layer._$characters.slice(0);
                const length = characters.length;
                for (let idx = 0; idx < length; ++idx) {

                    const character = characters[idx];
                    if (character.libraryId !== id) {
                        continue;
                    }

                    layer.deleteCharacter(character.id);

                    for (let frame = character.startFrame;
                         character.endFrame > frame;
                         ++frame
                    ) {

                        if (layer.getActiveCharacter(frame).length) {
                            continue;
                        }

                        Util.$screen.clearFrames(layer, frame, frame + 1);
                    }
                }
            }
        }

        document
            .getElementById("object-area")
            .style
            .display = "none";

        Util.$controller.deleteInstanceSelectOption(id|0);
        this.initializeInternalScript();
    }

    /**
     * @return {number}
     * @readonly
     * @public
     */
    get nextLibraryId ()
    {
        const keys = Array.from(this._$libraries.keys());
        keys.sort(function (a, b)
        {
            if (a > b) {
                return 1;
            }

            if (a < b) {
                return -1;
            }

            return 0;
        });
        return (this._$libraries.get((keys.pop()|0)).id|0) + 1;
    }
}


        global["next2d-tools"] = Util;
    })(this);
}