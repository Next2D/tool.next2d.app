/*!
 * licenses: MIT Licenses.
 * version: 0.70.9
 * author: Toshiyuki Ienaga <ienaga@tvon.jp>
 * copyright: (c) 2021-2022 Toshiyuki Ienaga.
 */

if (!("nt" in window)) {
    (function (global)
    {
        "use strict";

/**
 * @class
 */
class Language
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        this.mapping = this.createMapping();
        requestAnimationFrame(this.initialize.bind(this));
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        const elements = document.getElementsByClassName("language");
        for (let idx = 0; idx < elements.length; ++idx) {

            const element = elements[idx];

            const text = element.dataset.text;
            if (!this.mapping.has(text)) {
                continue;
            }

            let value = this.mapping.get(text);

            let shortcutKey = element.dataset.shortcutKey;
            if (shortcutKey) {
                const mapping = Util.$shortcutSetting.viewMapping.get(
                    element.dataset.area
                );

                const shortcutText = mapping.has(shortcutKey)
                    ? mapping.get(shortcutKey).text
                    : element.dataset.shortcutText;

                value += ` (${shortcutText})`;
            }

            element.innerText = value;
        }
    }

    /**
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    replace (value)
    {
        return this.mapping.has(value)
            ? this.mapping.get(value)
            : value;
    }
}

/**
 * @class
 * @extends Language
 */
class Chinese extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{追加ファイル}}", "附加文件"],
            ["{{既存のコンテンツ}}", "现有的内容"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "你可以选择覆盖、重命名和添加文件或跳过"],
            ["{{全て上書き}}", "覆盖所有"],
            ["{{全てスキップ}}", "跳过所有"],
            ["{{追加・上書き}}", "添加和覆盖"],
            ["{{スキップ}}", "跳过"],
            ["{{表示確認したいフレームを指定}}", "指定你要检查显示的框架"],
            ["{{ファイル名を指定}}", "指定文件名"],
            ["{{ファイル名}}", "文件名"],
            ["{{終了フレームを指定}}", "指定终端框架"],
            ["{{開始フレームを指定}}", "指定起始框架"],
            ["{{フレーム設定}}", "框架设置"],
            ["{{書き出し設定}}", "出口设置"],
            ["{{ファイル形式の選択}}", "选择文件格式"],
            ["{{ファイル形式}}", "文件格式"],
            ["{{サイズ設定}}", "尺寸"],
            ["{{左上}}", "左上"],
            ["{{中央上}}", "中-上"],
            ["{{右上}}", "右上"],
            ["{{中央左}}", "中间偏左"],
            ["{{中央}}", "中央"],
            ["{{中央右}}", "中右翼"],
            ["{{左下}}", "左下角"],
            ["{{中央下}}", "中下级"],
            ["{{右下}}", "右下"],
            ["{{中心点のX座標}}", "中心点的X坐标"],
            ["{{中心点のY座標}}", "中心点的Y坐标"],
            ["{{MovieClipに変換}}", "转换为MovieClip"],
            ["{{変換}}", "蜕变"],
            ["{{ループ回数}}", "循环次数"],
            ["{{カーブポインターの削除}}", "删除曲线指针"],
            ["{{ステージ基準}}", "阶段性标准"],
            ["{{閉じる}}", "贴近"],
            ["{{保存}}", "储存"],
            ["{{リセット}}", "重置"],
            ["{{スクリーン}}", "筛选"],
            ["{{ショートカット設定}}", "捷径设置"],
            ["{{レイヤーカラー}}", "分层色"],
            ["{{Next2Dを支援する}}", "支持Next2D"],
            ["{{サポート}}", "支持"],
            ["{{未使用のアイテムを削除}}", "删除未使用的项目"],
            ["{{レイヤーをペースト}}", "粘贴层"],
            ["{{レイヤーをコピー}}", "复制层"],
            ["{{フレームをペースト}}", "粘贴框架"],
            ["{{フレームをコピー}}", "复制框架"],
            ["{{キーフレームを削除}}", "删除关键帧"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "不能向关键帧添加空关键帧"],
            ["{{ズームツール}}", "缩放工具"],
            ["{{タイムライン幅の拡大・縮小}}", "时间线宽度 扩大/缩小"],
            ["{{ガイドレイヤー}}", "指导层"],
            ["{{音量設定}}", "音量设置"],
            ["{{サウンドを削除}}", "移除声音"],
            ["{{カスタムループ}}", "定制的循环"],
            ["{{読込のみ}}", "只读"],
            ["{{書込を許可}}", "职位许可"],
            ["{{単一行}}", "单线"],
            ["{{複数行}}", "多线"],
            ["{{自動で折り返し}}", "自动绕行"],
            ["{{左寄せ}}", "左对齐"],
            ["{{中央揃え}}", "定心"],
            ["{{右寄せ}}", "右对齐"],
            ["{{放射状グラデーション}}", "径向梯度"],
            ["{{線形グラデーション}}", "线性梯度"],
            ["{{画像}}", "图片"],
            ["{{画像選択}}", "图像选择"],
            ["{{種別}}", "分类"],
            ["{{Shapeの色設定}}", "形状颜色设置"],
            ["{{変形}}", "变形"],
            ["{{カラー効果}}", "颜色转换"],
            ["{{フィルター}}", "滤镜"],
            ["{{Shapeを複製}}", "复制的形状"],
            ["{{読み込み}}", "读在"],
            ["{{新規フォルダー}}", "新文件夹"],
            ["{{新規MovieClip}}", "新的电影剪辑"],
            ["{{枠に合わせてテキストをリサイズ}}", "调整文字大小以适应框架"],
            ["{{テキストに合わせて枠をリサイズ}}", "调整框架的大小以适应文本"],
            ["{{リサイズしない}}", "不调整大小"],
            ["{{フォント}}", "字体"],
            ["{{テキスト}}", "文本"],
            ["{{ループ}}", "循环"],
            ["{{音量}}", "音量"],
            ["{{ビデオ}}", "视频"],
            ["{{イージング}}", "缓和"],
            ["{{サウンド}}", "声音"],
            ["{{シンボル}}", "符号"],
            ["{{名前}}", "命名"],
            ["{{オブジェクト}}", "对象"],
            ["{{ステージ設定}}", "舞台设置"],
            ["{{プレビュー}}", "预览"],
            ["{{削除}}", "删除"],
            ["{{ペースト}}", "粘贴"],
            ["{{コピー}}", "拷贝"],
            ["{{プラグインメニュー}}", "插件菜单"],
            ["{{トゥイーン}}", "嫩枝"],
            ["{{カーブポインターの追加}}", "额外的曲线指示器"],
            ["{{パスの結合}}", "路径合并"],
            ["{{シェイプ}}", "形状"],
            ["{{キーフレームに配分}}", "分配给关键帧"],
            ["{{レイヤーに配分}}", "分配到各层"],
            ["{{タイムライン}}", "时间线"],
            ["{{整列}}", "对齐"],
            ["{{最背面}}", "最 后"],
            ["{{ひとつ背面へ}}", "一个背影"],
            ["{{ひとつ前面へ}}", "一个正面"],
            ["{{最前面}}", "最前线"],
            ["{{重ね順}}", "继承顺序"],
            ["{{プラグイン}}", "插件"],
            ["{{ライブラリ}}", "图书馆"],
            ["{{プロパティ}}", "财产"],
            ["{{マスクレイヤー}}", "掩膜层"],
            ["{{通常レイヤー}}", "普通层"],
            ["{{モーショントゥイーンの削除}}", "删去了运动推理的内容"],
            ["{{モーショントゥイーンの追加}}", "额外的议案推理"],
            ["{{モーダル表示}}", "模态指示"],
            ["{{言語}}", "语言"],
            ["{{フォーマット}}", "格式"],
            ["{{含める}}", "包括"],
            ["{{含めない}}", "不包括"],
            ["{{使い方、リファレンス}}", "用法，参考"],
            ["{{非表示レイヤー}}", "隐藏层"],
            ["{{設定}}", "设置"],
            ["{{デフォルトのループを利用する}}", "使用默认的循环"],
            ["{{フレームピッカー}}", "选框机"],
            ["{{ステージ左揃え}}", "舞台左侧对齐"],
            ["{{ステージ中央揃え(水平方向)}}", "对准舞台中心（水平）"],
            ["{{ステージ右揃え}}", "舞台右侧的对齐"],
            ["{{ステージ上揃え}}", "对齐舞台"],
            ["{{ステージ中央揃え(垂直方向)}}", "对准舞台中心（垂直）"],
            ["{{ステージ下揃え}}", "对准舞台底部"],
            ["{{左揃え}}", "左对齐"],
            ["{{中央揃え(水平方向)}}", "居中（水平方向）"],
            ["{{右揃え}}", "右对齐"],
            ["{{上揃え}}", "上对齐"],
            ["{{中央揃え(垂直方向)}}", "居中（垂直方向）"],
            ["{{下揃え}}", "下对齐"],
            ["{{開始フレーム}}", "起始框架"],
            ["{{終了フレーム}}", "终端框架"],
            ["{{ループで再生}}", "循环播放"],
            ["{{1回再生}}", "1次播放"],
            ["{{指定したフレームで固定}}", "固定在指定的框架内"],
            ["{{1回逆再生}}", "1 反向播放"],
            ["{{逆ループで再生}}", "反向循环播放"],
            ["{{画面の拡大・縮小}}", "画面的放大和缩小"],
            ["{{カスタムイージングデータを保存}}", "保存自定义缓和数据"],
            ["{{カスタムイージングデータの読込}}", "读取自定义宽松数据"],
            ["{{プレビューのON/OFF}}", "预览开/关"],
            ["{{フォント枠サイズ}}", "字体帧大小"],
            ["{{フォント枠カラー}}", "字体帧颜色"],
            ["{{オニオンスキン}}", "洋葱皮"],
            ["{{バケツツール}}", "整体填充工具"],
            ["{{ペンツール}}", "钢笔工具"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "双击来添加一个曲线点"],
            ["{{選択ツール}}", "选择工具"],
            ["{{Shape変形ツール}}", "形状变换工具"],
            ["{{テキストツール}}", "文本工具"],
            ["{{矩形ツール}}", "矩形工具"],
            ["{{楕円ツール}}", "椭圆工具"],
            ["{{角丸矩形ツール}}", "圆角矩形工具"],
            ["{{塗りのカラー}}", "填充颜色"],
            ["{{線のカラー}}", "画笔颜色"],
            ["{{線の太さ}}", "画笔宽度"],
            ["{{プロジェクトデータの読込}}", "载入工程文件"],
            ["{{プロジェクトデータを保存}}", "保存工程文件"],
            ["{{書き出し}}", "导出"],
            ["{{Discordへ移動}}", "前往discord"],
            ["{{バグ報告}}", "错误报告"],
            ["{{設定}}", "设置"],
            ["{{タブを追加}}", "添加标签页"],
            ["{{タブの一覧を表示・移動}}", "标签页列表"],
            ["{{スクリプトを追加}}", "添加一个脚本"],
            ["{{キーフレームを追加}}", "添加一个关键帧"],
            ["{{空のキーフレームを追加}}", "添加一个空的关键帧"],
            ["{{フレームを追加}}", "添加帧"],
            ["{{フレームを削除}}", "删除帧"],
            ["{{再生}}", "播放"],
            ["{{停止}}", "停止"],
            ["{{ループ設定}}", "循环设置"],
            ["{{レイヤーを追加}}", "添加图层"],
            ["{{レイヤーを削除}}", "删除图层"],
            ["{{全てのレイヤーをハイライト}}", "高亮所有图层"],
            ["{{全てのレイヤーを非表示}}", "隐藏所有图层"],
            ["{{全てのレイヤーをロック}}", "锁定所有图层"],
            ["{{比率を固定}}", "锁定比例"],
            ["{{ステージの幅}}", "画面宽度"],
            ["{{背景色}}", "背景颜色"],
            ["{{ステージの高さ}}", "画面高度"],
            ["{{フレームレート}}", "帧速率"],
            ["{{シンボル名}}", "符号名称"],
            ["{{イージング設定}}", "过渡设置"],
            ["{{ビデオの音量設定}}", "视频音量设置"],
            ["{{自動再生}}", "自动播放"],
            ["{{テキストエリアのボーダー設定}}", "文本框边框设置"],
            ["{{テキスト入力設定}}", "文本输入设置"],
            ["{{フォント選択}}", "字体选择"],
            ["{{自動サイズ調整}}", "自动调整尺寸"],
            ["{{フォントスタイルタイプ}}", "字体风格类型"],
            ["{{行揃え}}", "对齐"],
            ["{{改行設定}}", "换行设置"],
            ["{{スクロール設定}}", "滚动设置"],
            ["{{フォントサイズ}}", "字体大小"],
            ["{{フォントカラー}}", "字体颜色"],
            ["{{行間}}", "行间距"],
            ["{{文字幅}}", "字符宽度"],
            ["{{左マージン}}", "左边距"],
            ["{{右マージン}}", "右边距"],
            ["{{カラー種別の選択}}", "选择颜色类型"],
            ["{{背景画像の選択}}", "选择背景图片"],
            ["{{カラーポインターを追加}}", "添加颜色指针"],
            ["{{カラー値}}", "颜色"],
            ["{{アルファ(0%-100%)}}", "透明度（0%-100%）"],
            ["{{アルファ値}}", "透明度"],
            ["{{選択対象の幅}}", "选择对象的宽度"],
            ["{{選択対象のX座標}}", "选择对象的X轴坐标"],
            ["{{選択対象の高さ}}", "选择对象的高度"],
            ["{{選択対象のY座標}}", "选择对象的Y轴坐标"],
            ["{{選択対象の幅の伸縮}}", "选定对象的X轴缩放"],
            ["{{選択対象を回転}}", "旋转物体"],
            ["{{選択対象の高さの伸縮}}", "所选对象的比例Y"],
            ["{{アルファオフセット(-255〜255)}}", "透明度偏移（-255~255）"],
            ["{{赤(0%-100%)}}", "红色（0%-100%）"],
            ["{{赤オフセット(-255〜255)}}", "红色偏移（-255~255）"],
            ["{{緑(0%-100%)}}", "绿色（0%-100%）"],
            ["{{緑オフセット(-255〜255)}}", "绿色偏移（-255~255）"],
            ["{{青(0%-100%)}}", "蓝色（0%-100%）"],
            ["{{青オフセット(-255〜255)}}", "蓝色偏移（-255~255）"],
            ["{{ブレンドモード}}", "混合模式"],
            ["{{フィルターを選択}}", "选择滤镜"],
            ["{{フィルターを追加}}", "添加滤镜"],
            ["{{サウンドを追加}}", "添加声音"],
            ["{{フィルターを表示・非表示する}}", "显示和隐藏滤镜"],
            ["{{フィルターを削除}}", "删除滤镜"],
            ["{{水平方向にぼかす}}", "横向模糊"],
            ["{{垂直方向にぼかす}}", "纵向模糊"],
            ["{{フィルター強度}}", "滤镜强度"],
            ["{{フィルター角度}}", "滤镜角度"],
            ["{{シャドウのアルファ}}", "阴影透明度"],
            ["{{シャドウのカラー}}", "阴影颜色"],
            ["{{フィルター距離}}", "滤镜距离"],
            ["{{ハイライトのカラー}}", "高光色"],
            ["{{ハイライトのアルファ}}", "高光透明度"],
            ["{{グラデーションカラー}}", "渐变色"],
            ["{{グラデーションのアルファ}}", "渐变透明度"],
            ["{{タブの移動・名前を変更}}", "移动/重命名标签"],
            ["{{プロジェクトを閉じる}}", "关闭工程"],
            ["{{上下に移動}}", "上下移动"],
            ["{{レイヤー変更(ダブルクリック)}}", "改变图层（双击）"],
            ["{{レイヤーをハイライト}}", "高亮图层"],
            ["{{レイヤーを非表示}}", "隐藏图层"],
            ["{{レイヤーをロック}}", "锁定图层"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "曲线指针（双击打开/关闭）"],
            ["{{インスタンス名}}", "实例名称"],
            ["{{ライブラリ内の検索}}", "在库中搜索"],
            ["{{フレームラベル}}", "帧标签"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "如果工程没有保存，将无法恢复此标签页数据。 你想删除这个标签页吗？"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class English extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{追加ファイル}}", "Additional File"],
            ["{{既存のコンテンツ}}", "Existing Content"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "You can choose to overwrite, rename and add files, or skip"],
            ["{{全て上書き}}", "Overwrite All"],
            ["{{全てスキップ}}", "Skip All"],
            ["{{追加・上書き}}", "Add or Overwrite"],
            ["{{スキップ}}", "Skip"],
            ["{{表示確認したいフレームを指定}}", "Specify the frame you want to check the display"],
            ["{{ファイル名を指定}}", "Specify File Name"],
            ["{{ファイル名}}", "File Name"],
            ["{{終了フレームを指定}}", "Specify End Frame"],
            ["{{開始フレームを指定}}", "Specify Start Frame"],
            ["{{フレーム設定}}", "Frame Setting"],
            ["{{書き出し設定}}", "Export Settings"],
            ["{{ファイル形式の選択}}", "Select File Format"],
            ["{{ファイル形式}}", "File Formats"],
            ["{{サイズ設定}}", "Size Setting"],
            ["{{左上}}", "Top Left"],
            ["{{中央上}}", "Top Center"],
            ["{{右上}}", "Top Right"],
            ["{{中央左}}", "Center Left"],
            ["{{中央}}", "Center"],
            ["{{中央右}}", "Center Right"],
            ["{{左下}}", "Bottom Left"],
            ["{{中央下}}", "Bottom Center"],
            ["{{右下}}", "Bottom Right"],
            ["{{中心点のX座標}}", "X coordinate of the center point"],
            ["{{中心点のY座標}}", "Y coordinate of the center point"],
            ["{{MovieClipに変換}}", "Convert to MovieClip"],
            ["{{変換}}", "Conversion"],
            ["{{ループ回数}}", "Loop Count"],
            ["{{カーブポインターの削除}}", "Delete curve pointer"],
            ["{{ステージ基準}}", "Stage Criteria"],
            ["{{閉じる}}", "Close"],
            ["{{保存}}", "Save"],
            ["{{リセット}}", "Reset"],
            ["{{スクリーン}}", "Screen"],
            ["{{ショートカット設定}}", "Shortcut Settings"],
            ["{{レイヤーカラー}}", "Layer Color"],
            ["{{Next2Dを支援する}}", "Support Next2D"],
            ["{{サポート}}", "Support"],
            ["{{未使用のアイテムを削除}}", "Delete unused items"],
            ["{{レイヤーをペースト}}", "Paste Layer"],
            ["{{レイヤーをコピー}}", "Copy Layer"],
            ["{{フレームをペースト}}", "Paste Frame"],
            ["{{フレームをコピー}}", "Copy Frame"],
            ["{{キーフレームを削除}}", "Delete keyframe"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "Cannot add an empty keyframe to a keyframe"],
            ["{{ズームツール}}", "Zoom Tool"],
            ["{{タイムライン幅の拡大・縮小}}", "Timeline Width Expand/Reduce"],
            ["{{ガイドレイヤー}}", "Guide Layer"],
            ["{{音量設定}}", "Volume Setting"],
            ["{{サウンドを削除}}", "Remove Sound"],
            ["{{カスタムループ}}", "Custom Loop"],
            ["{{読込のみ}}", "ReadOnly"],
            ["{{書込を許可}}", "Writeable"],
            ["{{単一行}}", "Single line"],
            ["{{複数行}}", "Multiline"],
            ["{{自動で折り返し}}", "Auto Wrap"],
            ["{{左寄せ}}", "Left"],
            ["{{中央揃え}}", "Center"],
            ["{{右寄せ}}", "Right"],
            ["{{放射状グラデーション}}", "Radial Gradient"],
            ["{{線形グラデーション}}", "Linear Gradient"],
            ["{{画像}}", "Image"],
            ["{{画像選択}}", "Image Selection"],
            ["{{種別}}", "Type"],
            ["{{Shapeの色設定}}", "Shape color settings"],
            ["{{変形}}", "Transform"],
            ["{{カラー効果}}", "Color Transform"],
            ["{{フィルター}}", "Filter"],
            ["{{Shapeを複製}}", "Duplicate Shape"],
            ["{{読み込み}}", "Read in"],
            ["{{新規フォルダー}}", "Added Folder"],
            ["{{新規MovieClip}}", "Added MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "Resize text to fit the frame"],
            ["{{テキストに合わせて枠をリサイズ}}", "Resize the frame to fit the text"],
            ["{{リサイズしない}}", "No Resize"],
            ["{{フォント}}", "Font"],
            ["{{テキスト}}", "Text"],
            ["{{ループ}}", "Loop"],
            ["{{音量}}", "Volume"],
            ["{{ビデオ}}", "Video"],
            ["{{イージング}}", "Easing"],
            ["{{サウンド}}", "Sound"],
            ["{{シンボル}}", "Symbol"],
            ["{{名前}}", "Name"],
            ["{{オブジェクト}}", "Object"],
            ["{{ステージ設定}}", "Stage Setting"],
            ["{{プレビュー}}", "Preview"],
            ["{{削除}}", "Delete"],
            ["{{ペースト}}", "Paste"],
            ["{{コピー}}", "Copy"],
            ["{{プラグインメニュー}}", "Plugin Menu"],
            ["{{トゥイーン}}", "Tween"],
            ["{{カーブポインターの追加}}", "Added Curve Pointer"],
            ["{{パスの結合}}", "Integrating paths"],
            ["{{シェイプ}}", "Shape"],
            ["{{キーフレームに配分}}", "Distribute to Keyframes"],
            ["{{レイヤーに配分}}", "Distribute to Layers"],
            ["{{タイムライン}}", "Timeline"],
            ["{{整列}}", "Align"],
            ["{{最背面}}", "Send to Back"],
            ["{{ひとつ背面へ}}", "Send to Backward"],
            ["{{ひとつ前面へ}}", "Bring to Forward"],
            ["{{最前面}}", "Bring to Front"],
            ["{{重ね順}}", "Arrange"],
            ["{{プラグイン}}", "Plugin"],
            ["{{ライブラリ}}", "Library"],
            ["{{プロパティ}}", "Property"],
            ["{{マスクレイヤー}}", "Mask Layer"],
            ["{{通常レイヤー}}", "Normal Layer"],
            ["{{モーショントゥイーンの削除}}", "Deleted Motion Tweening"],
            ["{{モーショントゥイーンの追加}}", "Added Motion Tweening"],
            ["{{モーダル表示}}", "Modal Indication"],
            ["{{言語}}", "Language"],
            ["{{フォーマット}}", "Format"],
            ["{{含める}}", "Include"],
            ["{{含めない}}", "Not Including"],
            ["{{使い方、リファレンス}}", "Usage, Reference"],
            ["{{非表示レイヤー}}", "Hidden Layers"],
            ["{{設定}}", "Setting"],
            ["{{デフォルトのループを利用する}}", "Use the default loop"],
            ["{{フレームピッカー}}", "Frame Picker"],
            ["{{ステージ左揃え}}", "Align Stage Left"],
            ["{{ステージ中央揃え(水平方向)}}", "Align Stage Center (Horizontal)"],
            ["{{ステージ右揃え}}", "Align Stage Right"],
            ["{{ステージ上揃え}}", "Align Stage Top"],
            ["{{ステージ中央揃え(垂直方向)}}", "Center Stage (Vertical)"],
            ["{{ステージ下揃え}}", "Align Bottom of Stage"],
            ["{{左揃え}}", "Left"],
            ["{{中央揃え(水平方向)}}", "Center (Horizontal)"],
            ["{{右揃え}}", "Right"],
            ["{{上揃え}}", "Top"],
            ["{{中央揃え(垂直方向)}}", "Center (Vertical)"],
            ["{{下揃え}}", "Bottom"],
            ["{{開始フレーム}}", "Start Frame"],
            ["{{終了フレーム}}", "End Frame"],
            ["{{ループで再生}}", "Play in loop"],
            ["{{1回再生}}", "1 playback"],
            ["{{指定したフレームで固定}}", "Fixed at the specified frame"],
            ["{{1回逆再生}}", "1 reverse playback"],
            ["{{逆ループで再生}}", "Playback in reverse loop"],
            ["{{画面の拡大・縮小}}", "Zoom in/out of screen"],
            ["{{カスタムイージングデータを保存}}", "Save custom easing data"],
            ["{{カスタムイージングデータの読込}}", "Reading custom easing data"],
            ["{{プレビューのON/OFF}}", "Preview on/off"],
            ["{{フォント枠サイズ}}", "Font Frame Size"],
            ["{{フォント枠カラー}}", "Font Frame Color"],
            ["{{オニオンスキン}}", "Onion Skin"],
            ["{{バケツツール}}", "Bucket Tools"],
            ["{{ペンツール}}", "Pen Tool"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Double-click to add a curve point"],
            ["{{選択ツール}}", "Selection Tool"],
            ["{{Shape変形ツール}}", "Shape Transform Tool"],
            ["{{テキストツール}}", "Text Tool"],
            ["{{矩形ツール}}", "Rectangle Tool"],
            ["{{楕円ツール}}", "Ellipse Tool"],
            ["{{角丸矩形ツール}}", "Rounded Rectangle Tool"],
            ["{{塗りのカラー}}", "Fill Color"],
            ["{{線のカラー}}", "Stroke Color"],
            ["{{線の太さ}}", "Stroke Width"],
            ["{{プロジェクトデータの読込}}", "Loading project data"],
            ["{{プロジェクトデータを保存}}", "Save project data"],
            ["{{書き出し}}", "Export"],
            ["{{Discordへ移動}}", "Go to discord"],
            ["{{バグ報告}}", "Bug reports"],
            ["{{設定}}", "Setting"],
            ["{{タブを追加}}", "Add a tab"],
            ["{{タブの一覧を表示・移動}}", "View and move through the list of tabs"],
            ["{{スクリプトを追加}}", "Add a script"],
            ["{{キーフレームを追加}}", "Add a keyframe"],
            ["{{空のキーフレームを追加}}", "Add an empty keyframe"],
            ["{{フレームを追加}}", "Add a frame"],
            ["{{フレームを削除}}", "Delete frame"],
            ["{{再生}}", "Play"],
            ["{{停止}}", "Stop"],
            ["{{ループ設定}}", "Loop Setting"],
            ["{{レイヤーを追加}}", "Add a layer"],
            ["{{レイヤーを削除}}", "Delete layer"],
            ["{{全てのレイヤーをハイライト}}", "Highlight all layers"],
            ["{{全てのレイヤーを非表示}}", "Hide all layers"],
            ["{{全てのレイヤーをロック}}", "Lock all layers"],
            ["{{比率を固定}}", "Fixed ratio"],
            ["{{ステージの幅}}", "Stage Width"],
            ["{{背景色}}", "Background Color"],
            ["{{ステージの高さ}}", "Stage Height"],
            ["{{フレームレート}}", "Frame Rate"],
            ["{{シンボル名}}", "Symbol Name"],
            ["{{イージング設定}}", "Easing Setting"],
            ["{{ビデオの音量設定}}", "Video Volume Setting"],
            ["{{自動再生}}", "Auto Play"],
            ["{{テキストエリアのボーダー設定}}", "Text Area Border Setting"],
            ["{{テキスト入力設定}}", "Text Input Setting"],
            ["{{フォント選択}}", "Font Select"],
            ["{{自動サイズ調整}}", "Automatic size adjustment"],
            ["{{フォントスタイルタイプ}}", "Font Style Type"],
            ["{{行揃え}}", "Align"],
            ["{{改行設定}}", "Newline Setting"],
            ["{{スクロール設定}}", "Scroll Setting"],
            ["{{フォントサイズ}}", "Font Size"],
            ["{{フォントカラー}}", "Font Color"],
            ["{{行間}}", "Line Space"],
            ["{{文字幅}}", "Character Width"],
            ["{{左マージン}}", "Left Margin"],
            ["{{右マージン}}", "Right Margin"],
            ["{{カラー種別の選択}}", "Select a color type"],
            ["{{背景画像の選択}}", "Selecting a background image"],
            ["{{カラーポインターを追加}}", "Add color pointers"],
            ["{{カラー値}}", "Color"],
            ["{{アルファ(0%-100%)}}", "Alpha(0%-100%)"],
            ["{{アルファ値}}", "Alpha"],
            ["{{選択対象の幅}}", "Width of the selection object"],
            ["{{選択対象のX座標}}", "X coordinate of the selection object"],
            ["{{選択対象の高さ}}", "Height  of the selection object"],
            ["{{選択対象のY座標}}", "Y coordinate of the selection object"],
            ["{{選択対象の幅の伸縮}}", "scaleX of the selected object"],
            ["{{選択対象を回転}}", "Rotate the object"],
            ["{{選択対象の高さの伸縮}}", "scaleY of the selected object"],
            ["{{アルファオフセット(-255〜255)}}", "Alpha Offset(-255〜255)"],
            ["{{赤(0%-100%)}}", "Red(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Red Offset(-255〜255)"],
            ["{{緑(0%-100%)}}", "Green(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Green Offset(-255〜255)"],
            ["{{青(0%-100%)}}", "Blue(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Blue Offset(-255〜255)"],
            ["{{ブレンドモード}}", "Blend Mode"],
            ["{{フィルターを選択}}", "Select a filter"],
            ["{{フィルターを追加}}", "Add a filter"],
            ["{{サウンドを追加}}", "Add a sound"],
            ["{{フィルターを表示・非表示する}}", "Show and Hide filters"],
            ["{{フィルターを削除}}", "Delete Filter"],
            ["{{水平方向にぼかす}}", "Blur Horizontally"],
            ["{{垂直方向にぼかす}}", "Blur Vertically"],
            ["{{フィルター強度}}", "Filter Strength"],
            ["{{フィルター角度}}", "Filter Angle"],
            ["{{シャドウのアルファ}}", "Shadow Alpha"],
            ["{{シャドウのカラー}}", "Shadow Color"],
            ["{{フィルター距離}}", "Filter Distance"],
            ["{{ハイライトのカラー}}", "Highlight Color"],
            ["{{ハイライトのアルファ}}", "Highlight Alpha"],
            ["{{グラデーションカラー}}", "Gradient Color"],
            ["{{グラデーションのアルファ}}", "Gradient Alpha"],
            ["{{タブの移動・名前を変更}}", "Move/Rename tabs"],
            ["{{プロジェクトを閉じる}}", "Close the project"],
            ["{{上下に移動}}", "Move up and down"],
            ["{{レイヤー変更(ダブルクリック)}}", "Layer Change(double-click)"],
            ["{{レイヤーをハイライト}}", "Highlight Layer"],
            ["{{レイヤーを非表示}}", "Hide Layer"],
            ["{{レイヤーをロック}}", "Lock the Layer"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Curve Pointer (double click to turn on/off)"],
            ["{{インスタンス名}}", "Instance Name"],
            ["{{ライブラリ内の検索}}", "Search in the library"],
            ["{{フレームラベル}}", "Frame Label"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "If the project is not saved, the project data in this tab cannot be recovered. Do you want to delete the tab?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class French extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{追加ファイル}}", "Fichier supplémentaire"],
            ["{{既存のコンテンツ}}", "Contenu existant"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "Vous pouvez choisir d'écraser, de renommer et d'ajouter des fichiers, ou de ne pas le faire"],
            ["{{全て上書き}}", "Ecraser tout"],
            ["{{全てスキップ}}", "Ignorer tout"],
            ["{{追加・上書き}}", "Ajouter ou Écraser"],
            ["{{スキップ}}", "Ignorer"],
            ["{{表示確認したいフレームを指定}}", "Specify the frame you want to check the display"],
            ["{{ファイル名を指定}}", "Spécifier le nom du fichier"],
            ["{{ファイル名}}", "nom du fichier"],
            ["{{終了フレームを指定}}", "Spécifier le cadre de fin"],
            ["{{開始フレームを指定}}", "Spécifier le cadre de départ"],
            ["{{フレーム設定}}", "Réglage du cadre"],
            ["{{書き出し設定}}", "Paramètres d'exportation"],
            ["{{ファイル形式の選択}}", "Sélectionner le format du fichier"],
            ["{{ファイル形式}}", "Formats de fichiers"],
            ["{{サイズ設定}}", "Réglage de la taille"],
            ["{{左上}}", "En haut à gauche"],
            ["{{中央上}}", "Centre supérieur"],
            ["{{右上}}", "Haut Droite"],
            ["{{中央左}}", "Centre gauche"],
            ["{{中央}}", "Centre"],
            ["{{中央右}}", "Centre droit"],
            ["{{左下}}", "Bas gauche"],
            ["{{中央下}}", "Bas Centre"],
            ["{{右下}}", "Bas droit"],
            ["{{中心点のX座標}}", "Coordonnée X du point central"],
            ["{{中心点のY座標}}", "Coordonnée Y du point central"],
            ["{{MovieClipに変換}}", "Convertir en MovieClip"],
            ["{{変換}}", "transformation"],
            ["{{ループ回数}}", "Nombre de boucles"],
            ["{{カーブポインターの削除}}", "Supprimer le pointeur de courbe"],
            ["{{ステージ基準}}", "Critères d'étape"],
            ["{{閉じる}}", "Fermer"],
            ["{{保存}}", "Sauvez"],
            ["{{リセット}}", "réinitialiser"],
            ["{{スクリーン}}", "Écran"],
            ["{{ショートカット設定}}", "Paramètres des raccourcis"],
            ["{{レイヤーカラー}}", "couleur superposée"],
            ["{{Next2Dを支援する}}", "Soutenez Next2D"],
            ["{{サポート}}", "soutien"],
            ["{{未使用のアイテムを削除}}", "Retirer les articles non utilisés"],
            ["{{レイヤーをペースト}}", "Couche de pâte"],
            ["{{レイヤーをコピー}}", "Copie de la couche"],
            ["{{フレームをペースト}}", "Coller le cadre"],
            ["{{フレームをコピー}}", "Cadre de copie"],
            ["{{キーフレームを削除}}", "Supprimez les images clés"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "Impossible d'ajouter des images clés vides à des images clés"],
            ["{{ズームツール}}", "Outil de zoom"],
            ["{{タイムライン幅の拡大・縮小}}", "Largeur de la ligne de temps Développer/réduire"],
            ["{{ガイドレイヤー}}", "couche de guidage"],
            ["{{音量設定}}", "Réglage du volume"],
            ["{{サウンドを削除}}", "Supprimer le son"],
            ["{{カスタムループ}}", "boucle personnalisée"],
            ["{{読込のみ}}", "Lecture seulement"],
            ["{{書込を許可}}", "autorisation de poste"],
            ["{{単一行}}", "Ligne unique"],
            ["{{複数行}}", "Multiline"],
            ["{{自動で折り返し}}", "Enveloppe automatique"],
            ["{{左寄せ}}", "Gauche"],
            ["{{中央揃え}}", "Centre"],
            ["{{右寄せ}}", "Droite"],
            ["{{放射状グラデーション}}", "gradation radiale"],
            ["{{線形グラデーション}}", "gradient linéaire"],
            ["{{画像}}", "Image"],
            ["{{画像選択}}", "Sélection d'images"],
            ["{{種別}}", "Type"],
            ["{{Shapeの色設定}}", "Paramètres de couleur de la forme"],
            ["{{変形}}", "déformation"],
            ["{{カラー効果}}", "Transformation des couleurs"],
            ["{{フィルター}}", "filtre"],
            ["{{Shapeを複製}}", "Dupliquer la forme"],
            ["{{読み込み}}", "lire dans"],
            ["{{新規フォルダー}}", "Nouveau dossier"],
            ["{{新規MovieClip}}", "Nouveau MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "Redimensionnez le texte pour l'adapter au cadre"],
            ["{{テキストに合わせて枠をリサイズ}}", "Redimensionnez le cadre pour l'adapter au texte"],
            ["{{リサイズしない}}", "Pas de redimensionnement"],
            ["{{フォント}}", "police"],
            ["{{テキスト}}", "Texte"],
            ["{{ループ}}", "boucle"],
            ["{{音量}}", "volume"],
            ["{{ビデオ}}", "Vidéo"],
            ["{{イージング}}", "facilitant"],
            ["{{サウンド}}", "son"],
            ["{{シンボル}}", "Symbole"],
            ["{{名前}}", "Nom"],
            ["{{オブジェクト}}", "objet"],
            ["{{ステージ設定}}", "Mise en scène"],
            ["{{プレビュー}}", "Prévisualisation"],
            ["{{削除}}", "Supprimer"],
            ["{{ペースト}}", "Pâte"],
            ["{{コピー}}", "Copie"],
            ["{{プラグインメニュー}}", "Menu plug-in"],
            ["{{トゥイーン}}", "entre"],
            ["{{カーブポインターの追加}}", "Pointeur de courbe supplémentaire"],
            ["{{パスの結合}}", "Fusion de chemins"],
            ["{{シェイプ}}", "forme"],
            ["{{キーフレームに配分}}", "Attribution aux images clés"],
            ["{{レイヤーに配分}}", "Affectation aux couches"],
            ["{{タイムライン}}", "chronologie"],
            ["{{整列}}", "Aligner"],
            ["{{最背面}}", "La plupart des dos"],
            ["{{ひとつ背面へ}}", "Un à l'arrière"],
            ["{{ひとつ前面へ}}", "Un front"],
            ["{{最前面}}", "Frontmost"],
            ["{{重ね順}}", "Organiser"],
            ["{{プラグイン}}", "plug-in"],
            ["{{ライブラリ}}", "bibliothèque"],
            ["{{プロパティ}}", "propriété"],
            ["{{マスクレイヤー}}", "couche de masque"],
            ["{{通常レイヤー}}", "Couche normale"],
            ["{{モーショントゥイーンの削除}}", "Suppression des tweens de mouvement"],
            ["{{モーショントゥイーンの追加}}", "Des tweens de mouvement supplémentaires"],
            ["{{モーダル表示}}", "indication modale"],
            ["{{言語}}", "Langue"],
            ["{{フォーマット}}", "format"],
            ["{{含める}}", "inclure"],
            ["{{含めない}}", "à ne pas inclure"],
            ["{{使い方、リファレンス}}", "Utilisation, référence"],
            ["{{非表示レイヤー}}", "couche cachée"],
            ["{{設定}}", "configuration"],
            ["{{デフォルトのループを利用する}}", "Utilisez la boucle par défaut"],
            ["{{フレームピッカー}}", "ramasseur de cadres"],
            ["{{ステージ左揃え}}", "Aligner la scène à gauche"],
            ["{{ステージ中央揃え(水平方向)}}", "Aligner le centre de la scène (horizontal)"],
            ["{{ステージ右揃え}}", "Aligner la scène à droite"],
            ["{{ステージ上揃え}}", "Aligner la scène vers le haut"],
            ["{{ステージ中央揃え(垂直方向)}}", "Aligner le centre de la scène (vertical)"],
            ["{{ステージ下揃え}}", "Aligner le fond de la scène"],
            ["{{左揃え}}", "Gauche"],
            ["{{中央揃え(水平方向)}}", "Centre(sens horizontal)"],
            ["{{右揃え}}", "Droit"],
            ["{{上揃え}}", "Top"],
            ["{{中央揃え(垂直方向)}}", "Centre(Vertical)"],
            ["{{下揃え}}", "Fond"],
            ["{{開始フレーム}}", "cadre de départ"],
            ["{{終了フレーム}}", "cadre terminal"],
            ["{{ループで再生}}", "Lecture en boucle"],
            ["{{1回再生}}", "1 lecture"],
            ["{{指定したフレームで固定}}", "Fixé dans le cadre spécifié"],
            ["{{1回逆再生}}", "1 lecture en sens inverse"],
            ["{{逆ループで再生}}", "Lecture en boucle inversée"],
            ["{{画面の拡大・縮小}}", "Zoom avant et arrière sur l'écran"],
            ["{{カスタムイージングデータを保存}}", "Enregistrez les données d'assouplissement personnalisées"],
            ["{{カスタムイージングデータの読込}}", "Lecture des données de l'assouplissement personnalisé"],
            ["{{プレビューのON/OFF}}", "Activation/désactivation de la prévisualisation"],
            ["{{フォント枠サイズ}}", "Taille du cadre de la police"],
            ["{{フォント枠カラー}}", "Couleur du cadre de la police"],
            ["{{オニオンスキン}}", "Peau d'oignon"],
            ["{{バケツツール}}", "Outils à godets"],
            ["{{ペンツール}}", "Outil stylo"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Double-cliquez pour ajouter un point de courbe"],
            ["{{選択ツール}}", "Outils de sélection"],
            ["{{Shape変形ツール}}", "Outil de transformation des formes"],
            ["{{テキストツール}}", "Outil texte"],
            ["{{矩形ツール}}", "Outil Rectangle"],
            ["{{楕円ツール}}", "Outil Ellipse"],
            ["{{角丸矩形ツール}}", "Outil Rectangle arrondi"],
            ["{{塗りのカラー}}", "Couleur de remplissage"],
            ["{{線のカラー}}", "Couleur du trait"],
            ["{{線の太さ}}", "Largeur de course"],
            ["{{プロジェクトデータの読込}}", "Chargement des données du projet"],
            ["{{プロジェクトデータを保存}}", "Sauvegarder les données du projet"],
            ["{{書き出し}}", "Exportation"],
            ["{{Discordへ移動}}", "Aller sur le discord"],
            ["{{バグ報告}}", "Rapports de bogue"],
            ["{{設定}}", "Réglage de"],
            ["{{タブを追加}}", "Ajouter un onglet"],
            ["{{タブの一覧を表示・移動}}", "Visualiser et se déplacer dans la liste des onglets"],
            ["{{スクリプトを追加}}", "Ajouter un script"],
            ["{{キーフレームを追加}}", "Ajouter une image clé"],
            ["{{空のキーフレームを追加}}", "Ajouter une image clé vide"],
            ["{{フレームを追加}}", "Ajouter un cadre"],
            ["{{フレームを削除}}", "Supprimer le cadre"],
            ["{{再生}}", "Jouer"],
            ["{{停止}}", "Stop"],
            ["{{ループ設定}}", "Réglage de la boucle"],
            ["{{レイヤーを追加}}", "Ajouter une couche"],
            ["{{レイヤーを削除}}", "Supprimer la couche"],
            ["{{全てのレイヤーをハイライト}}", "Mettez en évidence toutes les couches"],
            ["{{全てのレイヤーを非表示}}", "Cacher toutes les couches"],
            ["{{全てのレイヤーをロック}}", "Verrouiller toutes les couches"],
            ["{{比率を固定}}", "Ratio fixe"],
            ["{{ステージの幅}}", "Largeur de la scène"],
            ["{{背景色}}", "Couleur de fond"],
            ["{{ステージの高さ}}", "Hauteur de la scène"],
            ["{{フレームレート}}", "Fréquence d'images"],
            ["{{シンボル名}}", "Nom du symbole"],
            ["{{イージング設定}}", "Réglage de l'assouplissement"],
            ["{{ビデオの音量設定}}", "Réglage du volume vidéo"],
            ["{{自動再生}}", "Lecture automatique"],
            ["{{テキストエリアのボーダー設定}}", "Réglage de la bordure de la zone de texte"],
            ["{{テキスト入力設定}}", "Réglage de la saisie du texte"],
            ["{{フォント選択}}", "Sélection de la police"],
            ["{{自動サイズ調整}}", "Ajustement automatique de la taille"],
            ["{{フォントスタイルタイプ}}", "Type de police"],
            ["{{行揃え}}", "Aligner"],
            ["{{改行設定}}", "Réglage des nouvelles lignes"],
            ["{{スクロール設定}}", "Réglage du défilement"],
            ["{{フォントサイズ}}", "Taille de la police"],
            ["{{フォントカラー}}", "Couleur de la police"],
            ["{{行間}}", "Espace linéaire"],
            ["{{文字幅}}", "Largeur des caractères"],
            ["{{左マージン}}", "Marge gauche"],
            ["{{右マージン}}", "Marge droite"],
            ["{{カラー種別の選択}}", "Sélectionnez un type de couleur"],
            ["{{背景画像の選択}}", "Sélection d'une image de fond"],
            ["{{カラーポインターを追加}}", "Ajouter des pointeurs de couleur"],
            ["{{カラー値}}", "Couleur"],
            ["{{アルファ(0%-100%)}}", "Alpha(0%-100%)"],
            ["{{アルファ値}}", "Alpha"],
            ["{{選択対象の幅}}", "Largeur de l'objet de sélection"],
            ["{{選択対象のX座標}}", "Coordonnée X de l'objet de sélection"],
            ["{{選択対象の高さ}}", "Hauteur de l'objet de sélection"],
            ["{{選択対象のY座標}}", "Coordonnée Y de l'objet de sélection"],
            ["{{選択対象の幅の伸縮}}", "scaleX de l'objet sélectionné"],
            ["{{選択対象を回転}}", "Faire pivoter l'objet"],
            ["{{選択対象の高さの伸縮}}", "scaleY de l'objet sélectionné"],
            ["{{アルファオフセット(-255〜255)}}", "Décalage alpha(-255〜255)"],
            ["{{赤(0%-100%)}}", "Rouge(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Décalage rouge(-255〜255)"],
            ["{{緑(0%-100%)}}", "Vert(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Compensation verte(-255〜255)"],
            ["{{青(0%-100%)}}", "Bleu(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Décalage bleu(-255〜255)"],
            ["{{ブレンドモード}}", "Mode de mélange"],
            ["{{フィルターを選択}}", "Sélectionnez un filtre"],
            ["{{フィルターを追加}}", "Ajouter un filtre"],
            ["{{サウンドを追加}}", "Ajouter un son"],
            ["{{フィルターを表示・非表示する}}", "Afficher et masquer les filtres"],
            ["{{フィルターを削除}}", "Supprimer le filtre"],
            ["{{水平方向にぼかす}}", "Flou horizontal"],
            ["{{垂直方向にぼかす}}", "Flou vertical"],
            ["{{フィルター強度}}", "Résistance du filtre"],
            ["{{フィルター角度}}", "Angle du filtre"],
            ["{{シャドウのアルファ}}", "Shadow Alpha"],
            ["{{シャドウのカラー}}", "Couleur de l'ombre"],
            ["{{フィルター距離}}", "Distance du filtre"],
            ["{{ハイライトのカラー}}", "Couleur de mise en évidence"],
            ["{{ハイライトのアルファ}}", "Highlight Alpha"],
            ["{{グラデーションカラー}}", "Couleur dégradée"],
            ["{{グラデーションのアルファ}}", "Gradient Alpha"],
            ["{{タブの移動・名前を変更}}", "Déplacer/Renommer les onglets"],
            ["{{プロジェクトを閉じる}}", "Fermer le projet"],
            ["{{上下に移動}}", "Déplacement vers le haut et le bas"],
            ["{{レイヤー変更(ダブルクリック)}}", "Changement de couche (double-clic)"],
            ["{{レイヤーをハイライト}}", "Couche de mise en évidence"],
            ["{{レイヤーを非表示}}", "Masquer la couche"],
            ["{{レイヤーをロック}}", "Verrouiller le calque"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Pointeur de courbe (double-cliquez pour l'activer ou le désactiver)"],
            ["{{インスタンス名}}", "Nom de l'instance"],
            ["{{ライブラリ内の検索}}", "Recherche dans la bibliothèque"],
            ["{{フレームラベル}}", "Étiquette du cadre"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "Si le projet n'est pas sauvegardé, les données du projet dans cet onglet ne peuvent pas être récupérées. Voulez-vous supprimer l'onglet ?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Italiano extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{追加ファイル}}", "File aggiuntivo"],
            ["{{既存のコンテンツ}}", "Contenuto esistente"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "È possibile scegliere di sovrascrivere, rinominare e aggiungere i file, o di saltare"],
            ["{{全て上書き}}", "Sovrascrivi tutto"],
            ["{{全てスキップ}}", "Salta tutto"],
            ["{{追加・上書き}}", "Aggiungi o sovrascrivi"],
            ["{{スキップ}}", "Salta"],
            ["{{表示確認したいフレームを指定}}", "Specificare la cornice di cui si desidera controllare la visualizzazione"],
            ["{{ファイル名を指定}}", "Specificare il nome del file"],
            ["{{ファイル名}}", "nome del file"],
            ["{{終了フレームを指定}}", "Specificare la cornice finale"],
            ["{{開始フレームを指定}}", "Specificare il fotogramma iniziale"],
            ["{{フレーム設定}}", "Impostazione del telaio"],
            ["{{書き出し設定}}", "Impostazioni di esportazione"],
            ["{{ファイル形式の選択}}", "Selezionare il formato del file"],
            ["{{ファイル形式}}", "Formati dei file"],
            ["{{サイズ設定}}", "Impostazione delle dimensioni"],
            ["{{左上}}", "In alto a sinistra"],
            ["{{中央上}}", "In alto al centro"],
            ["{{右上}}", "In alto a destra"],
            ["{{中央左}}", "Centro Sinistra"],
            ["{{中央}}", "Centro"],
            ["{{中央右}}", "Centro Destra"],
            ["{{左下}}", "In basso a sinistra"],
            ["{{中央下}}", "In basso al centro"],
            ["{{右下}}", "In basso a destra"],
            ["{{中心点のX座標}}", "Coordinata X del punto centrale"],
            ["{{中心点のY座標}}", "Coordinata Y del punto centrale"],
            ["{{MovieClipに変換}}", "Convertire in MovieClip"],
            ["{{変換}}", "trasformazione"],
            ["{{ループ回数}}", "Conteggio dei cicli"],
            ["{{カーブポインターの削除}}", "Elimina il puntatore di curva"],
            ["{{ステージ基準}}", "Criteri di fase"],
            ["{{閉じる}}", "Chiudere"],
            ["{{保存}}", "Risparmiare"],
            ["{{リセット}}", "azzeramento"],
            ["{{スクリーン}}", "Schermo"],
            ["{{ショートカット設定}}", "Impostazioni delle scorciatoie"],
            ["{{レイヤーカラー}}", "colore stratificato"],
            ["{{Next2Dを支援する}}", "Supporto Next2D"],
            ["{{サポート}}", "supporto"],
            ["{{未使用のアイテムを削除}}", "Rimuovere gli articoli inutilizzati"],
            ["{{レイヤーをペースト}}", "Strato di pasta"],
            ["{{レイヤーをコピー}}", "Copiare il livello"],
            ["{{フレームをペースト}}", "Incolla la cornice"],
            ["{{フレームをコピー}}", "Cornice di copia"],
            ["{{キーフレームを削除}}", "Elimina i fotogrammi chiave"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "Impossibile aggiungere keyframes vuoti ai keyframes"],
            ["{{ズームツール}}", "Strumento zoom"],
            ["{{タイムライン幅の拡大・縮小}}", "Larghezza della timeline Espandere/ridurre"],
            ["{{ガイドレイヤー}}", "strato guida"],
            ["{{音量設定}}", "Regolazione del volume"],
            ["{{サウンドを削除}}", "Rimuovere il suono"],
            ["{{カスタムループ}}", "anello personalizzato"],
            ["{{読込のみ}}", "Leggere solo"],
            ["{{書込を許可}}", "autorizzazione del post"],
            ["{{単一行}}", "Linea singola"],
            ["{{複数行}}", "Multiline"],
            ["{{自動で折り返し}}", "Avvolgimento automatico"],
            ["{{左寄せ}}", "Sinistra"],
            ["{{中央揃え}}", "Centro"],
            ["{{右寄せ}}", "Destra"],
            ["{{放射状グラデーション}}", "gradazione radiale"],
            ["{{線形グラデーション}}", "gradiente lineare"],
            ["{{画像}}", "Immagine"],
            ["{{画像選択}}", "Selezione dell'immagine"],
            ["{{種別}}", "Tipo"],
            ["{{Shapeの色設定}}", "Impostazioni del colore della forma"],
            ["{{変形}}", "deformazione"],
            ["{{カラー効果}}", "Trasformazione del colore"],
            ["{{フィルター}}", "filtro"],
            ["{{Shapeを複製}}", "Forma duplicata"],
            ["{{読み込み}}", "leggere in"],
            ["{{新規フォルダー}}", "Nuova cartella"],
            ["{{新規MovieClip}}", "Nuovo MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "Ridimensiona il testo per adattarlo alla cornice"],
            ["{{テキストに合わせて枠をリサイズ}}", "Ridimensiona la cornice per adattarla al testo"],
            ["{{リサイズしない}}", "Nessun ridimensionamento"],
            ["{{フォント}}", "font"],
            ["{{テキスト}}", "Testo"],
            ["{{ループ}}", "loop"],
            ["{{音量}}", "volume"],
            ["{{ビデオ}}", "Video"],
            ["{{イージング}}", "facilitando"],
            ["{{サウンド}}", "suono"],
            ["{{シンボル}}", "Simbolo"],
            ["{{名前}}", "Nome"],
            ["{{オブジェクト}}", "oggetto"],
            ["{{ステージ設定}}", "Scenario"],
            ["{{プレビュー}}", "Anteprima"],
            ["{{削除}}", "Cancellare"],
            ["{{ペースト}}", "Incolla"],
            ["{{コピー}}", "Copia"],
            ["{{プラグインメニュー}}", "Menu del plug-in"],
            ["{{トゥイーン}}", "tween"],
            ["{{カーブポインターの追加}}", "Puntatore di curva supplementare"],
            ["{{パスの結合}}", "Fusione di percorsi"],
            ["{{シェイプ}}", "forma"],
            ["{{キーフレームに配分}}", "Assegnazione ai fotogrammi chiave"],
            ["{{レイヤーに配分}}", "Assegnazione ai livelli"],
            ["{{タイムライン}}", "Timeline"],
            ["{{整列}}", "Allineare"],
            ["{{最背面}}", "La maggior parte della schiena"],
            ["{{ひとつ背面へ}}", "Uno sul retro"],
            ["{{ひとつ前面へ}}", "Una parte anteriore"],
            ["{{最前面}}", "In prima linea"],
            ["{{重ね順}}", "Organizzare"],
            ["{{プラグイン}}", "plug-in"],
            ["{{ライブラリ}}", "biblioteca"],
            ["{{プロパティ}}", "proprietà"],
            ["{{マスクレイヤー}}", "strato di maschera"],
            ["{{通常レイヤー}}", "Strato normale"],
            ["{{モーショントゥイーンの削除}}", "Soppressione dei tweens di movimento"],
            ["{{モーショントゥイーンの追加}}", "Ulteriori tween di movimento"],
            ["{{モーダル表示}}", "indicazione modale"],
            ["{{言語}}", "Lingua"],
            ["{{フォーマット}}", "formato"],
            ["{{含める}}", "includere"],
            ["{{含めない}}", "non includere"],
            ["{{使い方、リファレンス}}", "Uso, riferimento"],
            ["{{非表示レイヤー}}", "strato nascosto"],
            ["{{設定}}", "setup"],
            ["{{デフォルトのループを利用する}}", "Utilizzare il ciclo predefinito"],
            ["{{フレームピッカー}}", "raccoglitore di cornici"],
            ["{{ステージ左揃え}}", "Allineare il palco a sinistra"],
            ["{{ステージ中央揃え(水平方向)}}", "Allineare il centro del palco (orizzontale)"],
            ["{{ステージ右揃え}}", "Allineare il palco a destra"],
            ["{{ステージ上揃え}}", "Allineare il palco in alto"],
            ["{{ステージ中央揃え(垂直方向)}}", "Allineare il centro del palco (verticale)"],
            ["{{ステージ下揃え}}", "Allineare il fondo del palco"],
            ["{{左揃え}}", "Sinistra"],
            ["{{中央揃え(水平方向)}}", "Centro (Orizzontalità)"],
            ["{{右揃え}}", "Destra"],
            ["{{上揃え}}", "Top"],
            ["{{中央揃え(垂直方向)}}", "Centro (Verticale)"],
            ["{{下揃え}}", "Fondo"],
            ["{{開始フレーム}}", "telaio di partenza"],
            ["{{終了フレーム}}", "telaio finale"],
            ["{{ループで再生}}", "Gioca in loop"],
            ["{{1回再生}}", "1 riproduzione"],
            ["{{指定したフレームで固定}}", "Fissato nella cornice specificata"],
            ["{{1回逆再生}}", "1 riproduzione inversa"],
            ["{{逆ループで再生}}", "Riproduzione in loop inverso"],
            ["{{画面の拡大・縮小}}", "Ingrandire e rimpicciolire lo schermo"],
            ["{{カスタムイージングデータを保存}}", "Salva i dati di easing personalizzati"],
            ["{{カスタムイージングデータの読込}}", "Lettura dei dati di easing personalizzati"],
            ["{{プレビューのON/OFF}}", "Anteprima on/off"],
            ["{{フォント枠サイズ}}", "Dimensione della cornice del carattere"],
            ["{{フォント枠カラー}}", "Colore della cornice del carattere"],
            ["{{オニオンスキン}}", "Pelle di cipolla"],
            ["{{バケツツール}}", "Strumenti a secchiello"],
            ["{{ペンツール}}", "Strumento penna"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Doppio clic per aggiungere un punto di curva"],
            ["{{選択ツール}}", "Strumenti di selezione"],
            ["{{Shape変形ツール}}", "Strumento di trasformazione della forma"],
            ["{{テキストツール}}", "Text Tool"],
            ["{{矩形ツール}}", "Strumento di testo"],
            ["{{楕円ツール}}", "Strumento Ellisse"],
            ["{{角丸矩形ツール}}", "Strumento Rettangolo arrotondato"],
            ["{{塗りのカラー}}", "Colore di riempimento"],
            ["{{線のカラー}}", "Colore del tratto"],
            ["{{線の太さ}}", "Larghezza della corsa"],
            ["{{プロジェクトデータの読込}}", "Caricamento dei dati del progetto"],
            ["{{プロジェクトデータを保存}}", "Salvare i dati del progetto"],
            ["{{書き出し}}", "Esportazione"],
            ["{{Discordへ移動}}", "Vai su discordia"],
            ["{{バグ報告}}", "Segnalazioni di bug"],
            ["{{設定}}", "Impostazione"],
            ["{{タブを追加}}", "Aggiungere una scheda"],
            ["{{タブの一覧を表示・移動}}", "Visualizzare e spostarsi attraverso l'elenco delle schede"],
            ["{{スクリプトを追加}}", "Aggiungere uno script"],
            ["{{キーフレームを追加}}", "Aggiungere un keyframe"],
            ["{{空のキーフレームを追加}}", "Aggiungere un keyframe vuoto"],
            ["{{フレームを追加}}", "Aggiungere una cornice"],
            ["{{フレームを削除}}", "Cancellare la cornice"],
            ["{{再生}}", "Gioca"],
            ["{{停止}}", "Fermare"],
            ["{{ループ設定}}", "Impostazione del loop"],
            ["{{レイヤーを追加}}", "Aggiungere uno strato"],
            ["{{レイヤーを削除}}", "Cancellare il livello"],
            ["{{全てのレイヤーをハイライト}}", "Evidenzia tutti i livelli"],
            ["{{全てのレイヤーを非表示}}", "Nascondi tutti i livelli"],
            ["{{全てのレイヤーをロック}}", "Blocca tutti i livelli"],
            ["{{比率を固定}}", "Rapporto fisso"],
            ["{{ステージの幅}}", "Larghezza del palco"],
            ["{{背景色}}", "Colore di sfondo"],
            ["{{ステージの高さ}}", "Altezza del palco"],
            ["{{フレームレート}}", "Frame Rate"],
            ["{{シンボル名}}", "Nome del simbolo"],
            ["{{イージング設定}}", "Impostazione di rilassamento"],
            ["{{ビデオの音量設定}}", "Impostazione del volume video"],
            ["{{自動再生}}", "Riproduzione automatica"],
            ["{{テキストエリアのボーダー設定}}", "Impostazione del bordo dell'area di testo"],
            ["{{テキスト入力設定}}", "Impostazione dell'inserimento del testo"],
            ["{{フォント選択}}", "Seleziona il carattere"],
            ["{{自動サイズ調整}}", "Regolazione automatica delle dimensioni"],
            ["{{フォントスタイルタイプ}}", "Tipo di stile di carattere"],
            ["{{行揃え}}", "Allineare"],
            ["{{改行設定}}", "Impostazione Newline"],
            ["{{スクロール設定}}", "Impostazione dello scorrimento"],
            ["{{フォントサイズ}}", "Dimensione del carattere"],
            ["{{フォントカラー}}", "Colore del carattere"],
            ["{{行間}}", "Spazio di linea"],
            ["{{文字幅}}", "Larghezza del carattere"],
            ["{{左マージン}}", "Margine sinistro"],
            ["{{右マージン}}", "Margine destro"],
            ["{{カラー種別の選択}}", "Seleziona un tipo di colore"],
            ["{{背景画像の選択}}", "Selezionare un'immagine di sfondo"],
            ["{{カラーポインターを追加}}", "Aggiungere i puntatori di colore"],
            ["{{カラー値}}", "Colore"],
            ["{{アルファ(0%-100%)}}", "Alpha(0%-100%)"],
            ["{{アルファ値}}", "Alpha"],
            ["{{選択対象の幅}}", "Larghezza dell'oggetto di selezione"],
            ["{{選択対象のX座標}}", "Coordinata X dell'oggetto di selezione"],
            ["{{選択対象の高さ}}", "Altezza dell'oggetto di selezione"],
            ["{{選択対象のY座標}}", "Coordinata Y dell'oggetto di selezione"],
            ["{{選択対象の幅の伸縮}}", "scaleX dell'oggetto selezionato"],
            ["{{選択対象を回転}}", "Ruotare l'oggetto"],
            ["{{選択対象の高さの伸縮}}", "scalaY dell'oggetto selezionato"],
            ["{{アルファオフセット(-255〜255)}}", "Offset alfa(-255〜255)"],
            ["{{赤(0%-100%)}}", "Rosso(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Offset rosso(-255〜255)"],
            ["{{緑(0%-100%)}}", "Verde(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Offset Verde(-255〜255)"],
            ["{{青(0%-100%)}}", "Blu(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Offset Blu(-255〜255)"],
            ["{{ブレンドモード}}", "Modalità di fusione"],
            ["{{フィルターを選択}}", "Seleziona un filtro"],
            ["{{フィルターを追加}}", "Aggiungere un filtro"],
            ["{{サウンドを追加}}", "Aggiungere un suono"],
            ["{{フィルターを表示・非表示する}}", "Mostrare e nascondere i filtri"],
            ["{{フィルターを削除}}", "Cancellare il filtro"],
            ["{{水平方向にぼかす}}", "Sfocatura orizzontale"],
            ["{{垂直方向にぼかす}}", "Sfocatura verticale"],
            ["{{フィルター強度}}", "Forza del filtro"],
            ["{{フィルター角度}}", "Angolo del filtro"],
            ["{{シャドウのアルファ}}", "Ombra alfa"],
            ["{{シャドウのカラー}}", "Colore dell'ombra"],
            ["{{フィルター距離}}", "Distanza del filtro"],
            ["{{ハイライトのカラー}}", "Colore in evidenza"],
            ["{{ハイライトのアルファ}}", "Evidenziare l'alfa"],
            ["{{グラデーションカラー}}", "Colore sfumato"],
            ["{{グラデーションのアルファ}}", "Gradiente alfa"],
            ["{{タブの移動・名前を変更}}", "Spostare/rinominare le schede"],
            ["{{プロジェクトを閉じる}}", "Chiudere il progetto"],
            ["{{上下に移動}}", "Sposta su e giù"],
            ["{{レイヤー変更(ダブルクリック)}}", "Cambio di livello (doppio clic)"],
            ["{{レイヤーをハイライト}}", "Strato di evidenziazione"],
            ["{{レイヤーを非表示}}", "Nascondere lo strato"],
            ["{{レイヤーをロック}}", "Bloccare il livello"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Curve Pointer (doppio clic per attivare/disattivare)"],
            ["{{インスタンス名}}", "Nome dell'istanza"],
            ["{{ライブラリ内の検索}}", "Cerca nella biblioteca"],
            ["{{フレームラベル}}", "Etichetta del telaio"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "Se il progetto non viene salvato, i dati del progetto in questa scheda non possono essere recuperati. Vuoi cancellare la scheda?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Japanese extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{追加ファイル}}", "追加ファイル"],
            ["{{既存のコンテンツ}}", "既存のコンテンツ"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます"],
            ["{{全て上書き}}", "全て上書き"],
            ["{{全てスキップ}}", "全てスキップ"],
            ["{{追加・上書き}}", "追加・上書き"],
            ["{{スキップ}}", "スキップ"],
            ["{{表示確認したいフレームを指定}}", "表示確認したいフレームを指定"],
            ["{{ファイル名を指定}}", "ファイル名を指定"],
            ["{{ファイル名}}", "ファイル名"],
            ["{{終了フレームを指定}}", "終了フレームを指定"],
            ["{{開始フレームを指定}}", "開始フレームを指定"],
            ["{{フレーム設定}}", "フレーム設定"],
            ["{{書き出し設定}}", "書き出し設定"],
            ["{{ファイル形式の選択}}", "ファイル形式の選択"],
            ["{{ファイル形式}}", "ファイル形式"],
            ["{{サイズ設定}}", "サイズ設定"],
            ["{{左上}}", "左上"],
            ["{{中央上}}", "中央上"],
            ["{{右上}}", "右上"],
            ["{{中央左}}", "中央左"],
            ["{{中央}}", "中央"],
            ["{{中央右}}", "中央右"],
            ["{{左下}}", "左下"],
            ["{{中央下}}", "中央下"],
            ["{{右下}}", "右下"],
            ["{{中心点のX座標}}", "中心点のX座標"],
            ["{{中心点のY座標}}", "中心点のY座標"],
            ["{{MovieClipに変換}}", "MovieClipに変換"],
            ["{{変換}}", "変換"],
            ["{{ループ回数}}", "ループ回数"],
            ["{{カーブポインターの削除}}", "カーブポインターの削除"],
            ["{{ステージ基準}}", "ステージ基準"],
            ["{{閉じる}}", "閉じる"],
            ["{{保存}}", "保存"],
            ["{{リセット}}", "リセット"],
            ["{{スクリーン}}", "スクリーン"],
            ["{{ショートカット設定}}", "ショートカット設定"],
            ["{{レイヤーカラー}}", "レイヤーカラー"],
            ["{{Next2Dを支援する}}", "Next2Dを支援する"],
            ["{{サポート}}", "サポート"],
            ["{{未使用のアイテムを削除}}", "未使用のアイテムを削除"],
            ["{{レイヤーをペースト}}", "レイヤーをペースト"],
            ["{{レイヤーをコピー}}", "レイヤーをコピー"],
            ["{{フレームをペースト}}", "フレームをペースト"],
            ["{{フレームをコピー}}", "フレームをコピー"],
            ["{{キーフレームを削除}}", "キーフレームを削除"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "キーフレームに空のキーフレームを追加できません"],
            ["{{ズームツール}}", "ズームツール"],
            ["{{タイムライン幅の拡大・縮小}}", "タイムライン幅の拡大・縮小"],
            ["{{ガイドレイヤー}}", "ガイドレイヤー"],
            ["{{音量設定}}", "音量設定"],
            ["{{サウンドを削除}}", "サウンドを削除"],
            ["{{カスタムループ}}", "カスタムループ"],
            ["{{読込のみ}}", "読込のみ"],
            ["{{書込を許可}}", "書込を許可"],
            ["{{単一行}}", "単一行"],
            ["{{複数行}}", "複数行"],
            ["{{自動で折り返し}}", "自動で折り返し"],
            ["{{左寄せ}}", "左寄せ"],
            ["{{中央揃え}}", "中央揃え"],
            ["{{右寄せ}}", "右寄せ"],
            ["{{放射状グラデーション}}", "放射状グラデーション"],
            ["{{線形グラデーション}}", "線形グラデーション"],
            ["{{画像}}", "画像"],
            ["{{画像選択}}", "画像選択"],
            ["{{種別}}", "種別"],
            ["{{Shapeの色設定}}", "Shapeの色設定"],
            ["{{変形}}", "変形"],
            ["{{カラー効果}}", "カラー効果"],
            ["{{フィルター}}", "フィルター"],
            ["{{Shapeを複製}}", "Shapeを複製"],
            ["{{読み込み}}", "読み込み"],
            ["{{新規フォルダー}}", "新規フォルダー"],
            ["{{新規MovieClip}}", "新規MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "枠に合わせてテキストをリサイズ"],
            ["{{テキストに合わせて枠をリサイズ}}", "テキストに合わせて枠をリサイズ"],
            ["{{リサイズしない}}", "リサイズしない"],
            ["{{フォント}}", "フォント"],
            ["{{テキスト}}", "テキスト"],
            ["{{ループ}}", "ループ"],
            ["{{音量}}", "音量"],
            ["{{ビデオ}}", "ビデオ"],
            ["{{イージング}}", "イージング"],
            ["{{サウンド}}", "サウンド"],
            ["{{シンボル}}", "シンボル"],
            ["{{名前}}", "名前"],
            ["{{オブジェクト}}", "オブジェクト"],
            ["{{ステージ設定}}", "ステージ設定"],
            ["{{プレビュー}}", "プレビュー"],
            ["{{削除}}", "削除"],
            ["{{ペースト}}", "ペースト"],
            ["{{コピー}}", "コピー"],
            ["{{プラグインメニュー}}", "プラグインメニュー"],
            ["{{トゥイーン}}", "トゥイーン"],
            ["{{カーブポインターの追加}}", "カーブポインターの追加"],
            ["{{パスの結合}}", "パスの結合"],
            ["{{シェイプ}}", "シェイプ"],
            ["{{キーフレームに配分}}", "キーフレームに配分"],
            ["{{レイヤーに配分}}", "レイヤーに配分"],
            ["{{タイムライン}}", "タイムライン"],
            ["{{整列}}", "整列"],
            ["{{最背面}}", "最背面"],
            ["{{ひとつ背面へ}}", "ひとつ背面へ"],
            ["{{ひとつ前面へ}}", "ひとつ前面へ"],
            ["{{最前面}}", "最前面"],
            ["{{重ね順}}", "重ね順"],
            ["{{プラグイン}}", "プラグイン"],
            ["{{ライブラリ}}", "ライブラリ"],
            ["{{プロパティ}}", "プロパティ"],
            ["{{マスクレイヤー}}", "マスクレイヤー"],
            ["{{通常レイヤー}}", "通常レイヤー"],
            ["{{モーショントゥイーンの削除}}", "モーショントゥイーンの削除"],
            ["{{モーショントゥイーンの追加}}", "モーショントゥイーンの追加"],
            ["{{モーダル表示}}", "モーダル表示"],
            ["{{言語}}", "言語"],
            ["{{フォーマット}}", "フォーマット"],
            ["{{含める}}", "含める"],
            ["{{含めない}}", "含めない"],
            ["{{使い方、リファレンス}}", "使い方、リファレンス"],
            ["{{非表示レイヤー}}", "非表示レイヤー"],
            ["{{設定}}", "設定"],
            ["{{デフォルトのループを利用する}}", "デフォルトのループを利用する"],
            ["{{フレームピッカー}}", "フレームピッカー"],
            ["{{ステージ左揃え}}", "ステージ左揃え"],
            ["{{ステージ中央揃え(水平方向)}}", "ステージ中央揃え(水平方向)"],
            ["{{ステージ右揃え}}", "ステージ右揃え"],
            ["{{ステージ上揃え}}", "ステージ上揃え"],
            ["{{ステージ中央揃え(垂直方向)}}", "ステージ中央揃え(垂直方向)"],
            ["{{ステージ下揃え}}", "ステージ下揃え"],
            ["{{左揃え}}", "左揃え"],
            ["{{中央揃え(水平方向)}}", "中央揃え(水平方向)"],
            ["{{右揃え}}", "右揃え"],
            ["{{上揃え}}", "上揃え"],
            ["{{中央揃え(垂直方向)}}", "中央揃え(垂直方向)"],
            ["{{下揃え}}", "下揃え"],
            ["{{開始フレーム}}", "開始フレーム"],
            ["{{終了フレーム}}", "終了フレーム"],
            ["{{ループで再生}}", "ループで再生"],
            ["{{1回再生}}", "1回再生"],
            ["{{指定したフレームで固定}}", "指定したフレームで固定"],
            ["{{1回逆再生}}", "1回逆再生"],
            ["{{逆ループで再生}}", "逆ループで再生"],
            ["{{画面の拡大・縮小}}", "画面の拡大・縮小"],
            ["{{カスタムイージングデータを保存}}", "カスタムイージングデータを保存"],
            ["{{カスタムイージングデータの読込}}", "カスタムイージングデータの読込"],
            ["{{プレビューのON/OFF}}", "プレビューのON/OFF"],
            ["{{フォント枠サイズ}}", "フォント枠サイズ"],
            ["{{フォント枠カラー}}", "フォント枠カラー"],
            ["{{オニオンスキン}}", "オニオンスキン"],
            ["{{バケツツール}}", "バケツツール"],
            ["{{ペンツール}}", "ペンツール"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "ダブルクリックでカーブポイントが追加されます"],
            ["{{選択ツール}}", "選択ツール"],
            ["{{Shape変形ツール}}", "Shape変形ツール"],
            ["{{テキストツール}}", "テキストツール"],
            ["{{矩形ツール}}", "矩形ツール"],
            ["{{楕円ツール}}", "楕円ツール"],
            ["{{角丸矩形ツール}}", "角丸矩形ツール"],
            ["{{塗りのカラー}}", "塗りのカラー"],
            ["{{線のカラー}}", "線のカラー"],
            ["{{線の太さ}}", "線の太さ"],
            ["{{プロジェクトデータの読込}}", "プロジェクトデータの読込"],
            ["{{プロジェクトデータを保存}}", "プロジェクトデータを保存"],
            ["{{書き出し}}", "書き出し"],
            ["{{Discordへ移動}}", "Discordへ移動"],
            ["{{バグ報告}}", "バグ報告"],
            ["{{設定}}", "設定"],
            ["{{タブを追加}}", "タブを追加"],
            ["{{タブの一覧を表示・移動}}", "タブの一覧を表示・移動"],
            ["{{スクリプトを追加}}", "スクリプトを追加"],
            ["{{キーフレームを追加}}", "キーフレームを追加"],
            ["{{空のキーフレームを追加}}", "空のキーフレームを追加"],
            ["{{フレームを追加}}", "フレームを追加"],
            ["{{フレームを削除}}", "フレームを削除"],
            ["{{再生}}", "再生"],
            ["{{停止}}", "停止"],
            ["{{ループ設定}}", "ループ設定"],
            ["{{レイヤーを追加}}", "レイヤーを追加"],
            ["{{レイヤーを削除}}", "レイヤーを削除"],
            ["{{全てのレイヤーをハイライト}}", "全てのレイヤーをハイライト"],
            ["{{全てのレイヤーを非表示}}", "全てのレイヤーを非表示"],
            ["{{全てのレイヤーをロック}}", "全てのレイヤーをロック"],
            ["{{比率を固定}}", "比率を固定"],
            ["{{ステージの幅}}", "ステージの幅"],
            ["{{背景色}}", "背景色"],
            ["{{ステージの高さ}}", "ステージの高さ"],
            ["{{フレームレート}}", "フレームレート"],
            ["{{シンボル名}}", "シンボル名"],
            ["{{イージング設定}}", "イージング設定"],
            ["{{ビデオの音量設定}}", "ビデオの音量設定"],
            ["{{自動再生}}", "自動再生"],
            ["{{テキストエリアのボーダー設定}}", "テキストエリアのボーダー設定"],
            ["{{テキスト入力設定}}", "テキスト入力設定"],
            ["{{フォント選択}}", "フォント選択"],
            ["{{自動サイズ調整}}", "自動サイズ調整"],
            ["{{フォントスタイルタイプ}}", "フォントスタイルタイプ"],
            ["{{行揃え}}", "行揃え"],
            ["{{改行設定}}", "改行設定"],
            ["{{スクロール設定}}", "スクロール設定"],
            ["{{フォントサイズ}}", "フォントサイズ"],
            ["{{フォントカラー}}", "フォントカラー"],
            ["{{行間}}", "行間"],
            ["{{文字幅}}", "文字幅"],
            ["{{左マージン}}", "左マージン"],
            ["{{右マージン}}", "右マージン"],
            ["{{カラー種別の選択}}", "カラー種別の選択"],
            ["{{背景画像の選択}}", "背景画像の選択"],
            ["{{カラーポインターを追加}}", "カラーポインターを追加"],
            ["{{カラー値}}", "カラー値"],
            ["{{アルファ(0%-100%)}}", "アルファ(0%-100%)"],
            ["{{アルファ値}}", "アルファ値"],
            ["{{選択対象の幅}}", "選択対象の幅"],
            ["{{選択対象のX座標}}", "選択対象のX座標"],
            ["{{選択対象の高さ}}", "選択対象の高さ"],
            ["{{選択対象のY座標}}", "選択対象のY座標"],
            ["{{選択対象の幅の伸縮}}", "選択対象の幅の伸縮"],
            ["{{選択対象を回転}}", "選択対象を回転"],
            ["{{選択対象の高さの伸縮}}", "選択対象の高さの伸縮"],
            ["{{アルファオフセット(-255〜255)}}", "アルファオフセット(-255〜255)"],
            ["{{赤(0%-100%)}}", "赤(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "赤オフセット(-255〜255)"],
            ["{{緑(0%-100%)}}", "緑(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "緑オフセット(-255〜255)"],
            ["{{青(0%-100%)}}", "青(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "青オフセット(-255〜255)"],
            ["{{ブレンドモード}}", "ブレンドモード"],
            ["{{フィルターを選択}}", "フィルターを選択"],
            ["{{フィルターを追加}}", "フィルターを追加"],
            ["{{サウンドを追加}}", "サウンドを追加"],
            ["{{フィルターを表示・非表示する}}", "フィルターを表示・非表示する"],
            ["{{フィルターを削除}}", "フィルターを削除"],
            ["{{水平方向にぼかす}}", "水平方向にぼかす"],
            ["{{垂直方向にぼかす}}", "垂直方向にぼかす"],
            ["{{フィルター強度}}", "フィルター強度"],
            ["{{フィルター角度}}", "フィルター角度"],
            ["{{シャドウのアルファ}}", "シャドウのアルファ"],
            ["{{シャドウのカラー}}", "シャドウのカラー"],
            ["{{フィルター距離}}", "フィルター距離"],
            ["{{ハイライトのカラー}}", "ハイライトのカラー"],
            ["{{ハイライトのアルファ}}", "ハイライトのアルファ"],
            ["{{グラデーションカラー}}", "グラデーションカラー"],
            ["{{グラデーションのアルファ}}", "グラデーションのアルファ"],
            ["{{タブの移動・名前を変更}}", "タブの移動・名前を変更"],
            ["{{プロジェクトを閉じる}}", "プロジェクトを閉じる"],
            ["{{上下に移動}}", "上下に移動"],
            ["{{レイヤー変更(ダブルクリック)}}", "レイヤー変更(ダブルクリック)"],
            ["{{レイヤーをハイライト}}", "レイヤーをハイライト"],
            ["{{レイヤーを非表示}}", "レイヤーを非表示"],
            ["{{レイヤーをロック}}", "レイヤーをロック"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "カーブポインター(ダブルクリックでON/OFF)"],
            ["{{インスタンス名}}", "インスタンス名"],
            ["{{ライブラリ内の検索}}", "ライブラリ内の検索"],
            ["{{フレームラベル}}", "フレームラベル"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Korean extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{追加ファイル}}", "추가 파일"],
            ["{{既存のコンテンツ}}", "기존 콘텐츠"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "파일을 덮어쓰거나 이름을 변경하고 추가하거나 건너뛰도록 선택할 수 있습니다"],
            ["{{全て上書き}}", "모두 덮어쓰기"],
            ["{{全てスキップ}}", "모두 건너뛰기"],
            ["{{追加・上書き}}", "추가 또는 덮어쓰기"],
            ["{{スキップ}}", "건너뛰다"],
            ["{{表示確認したいフレームを指定}}", "표시 확인할 프레임 지정"],
            ["{{ファイル名を指定}}", "파일 이름 지정"],
            ["{{ファイル名}}", "파일 이름"],
            ["{{終了フレームを指定}}", "끝 프레임 지정"],
            ["{{開始フレームを指定}}", "시작 프레임 지정"],
            ["{{フレーム設定}}", "프레임 설정"],
            ["{{書き出し設定}}", "내보내기 설정"],
            ["{{ファイル形式の選択}}", "파일 형식 선택"],
            ["{{ファイル形式}}", "파일 형식"],
            ["{{サイズ設定}}", "사이즈 설정"],
            ["{{左上}}", "왼쪽 상단"],
            ["{{中央上}}", "상단 중앙"],
            ["{{右上}}", "오른쪽 상단"],
            ["{{中央左}}", "중앙 왼쪽"],
            ["{{中央}}", "센터"],
            ["{{中央右}}", "중앙 오른쪽"],
            ["{{左下}}", "왼쪽 하단"],
            ["{{中央下}}", "하단 중앙"],
            ["{{右下}}", "오른쪽 하단"],
            ["{{中心点のX座標}}", "중심점의 X 좌표"],
            ["{{中心点のY座標}}", "중심점의 Y 좌표"],
            ["{{MovieClipに変換}}", "MovieClip로 변환"],
            ["{{変換}}", "변환"],
            ["{{ループ回数}}", "루프 횟수"],
            ["{{カーブポインターの削除}}", "곡선 테이블의"],
            ["{{ステージ基準}}", "스테이지 기준"],
            ["{{閉じる}}", "닫다"],
            ["{{保存}}", "저장"],
            ["{{リセット}}", "리셋"],
            ["{{スクリーン}}", "스크린"],
            ["{{ショートカット設定}}", "바로 가기 설정"],
            ["{{レイヤーカラー}}", "레이어 색상"],
            ["{{Next2Dを支援する}}", "Next2D 지원"],
            ["{{サポート}}", "지원"],
            ["{{未使用のアイテムを削除}}", "사용하지 않는 항목 삭제"],
            ["{{レイヤーをペースト}}", "레이어 붙여넣기"],
            ["{{レイヤーをコピー}}", "레이어 복사"],
            ["{{フレームをペースト}}", "프레임을 붙여넣기"],
            ["{{フレームをコピー}}", "프레임 복사"],
            ["{{キーフレームを削除}}", "키프레임 삭제"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "키프레임에 빈 키프레임을 추가할 수 없음"],
            ["{{ズームツール}}", "줌 도구"],
            ["{{タイムライン幅の拡大・縮小}}", "타임라인 폭 확대·축소"],
            ["{{ガイドレイヤー}}", "가이드레이야"],
            ["{{音量設定}}", "볼륨 설정"],
            ["{{サウンドを削除}}", "사운드 삭제"],
            ["{{カスタムループ}}", "맞춤형 루프"],
            ["{{読込のみ}}", "로드 전용"],
            ["{{書込を許可}}", "쓰기 허용"],
            ["{{単一行}}", "단일 행"],
            ["{{複数行}}", "여러 줄"],
            ["{{自動で折り返し}}", "자동으로 되감기"],
            ["{{左寄せ}}", "왼쪽"],
            ["{{中央揃え}}", "센터"],
            ["{{右寄せ}}", "권리"],
            ["{{放射状グラデーション}}", "방사형 그라데이션"],
            ["{{線形グラデーション}}", "선형 그라데이션"],
            ["{{画像}}", "이미지"],
            ["{{画像選択}}", "이미지 선택"],
            ["{{種別}}", "종별"],
            ["{{Shapeの色設定}}", "Shape 색상 설정"],
            ["{{変形}}", "변형"],
            ["{{カラー効果}}", "색상 변환"],
            ["{{フィルター}}", "필터"],
            ["{{Shapeを複製}}", "Shape 복제"],
            ["{{読み込み}}", "로딩"],
            ["{{新規フォルダー}}", "새 폴더"],
            ["{{新規MovieClip}}", "새로운 MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "프레임에 맞게 텍스트를 크기 조정"],
            ["{{テキストに合わせて枠をリサイズ}}", "텍스트에 맞게 프레임을 크기 조정"],
            ["{{リサイズしない}}", "크기 조정하지 않음"],
            ["{{フォント}}", "글꼴"],
            ["{{テキスト}}", "텍스트"],
            ["{{ループ}}", "루프"],
            ["{{音量}}", "볼륨"],
            ["{{ビデオ}}", "동영상"],
            ["{{イージング}}", "부드럽게"],
            ["{{サウンド}}", "소리"],
            ["{{シンボル}}", "상징"],
            ["{{名前}}", "이름"],
            ["{{オブジェクト}}", "개체"],
            ["{{ステージ設定}}", "스테이지 설정"],
            ["{{プレビュー}}", "미리보기"],
            ["{{削除}}", "삭제"],
            ["{{ペースト}}", "붙여넣기"],
            ["{{コピー}}", "복사"],
            ["{{プラグインメニュー}}", "플러그인 메뉴"],
            ["{{トゥイーン}}", "트윈"],
            ["{{カーブポインターの追加}}", "커브 포인터 추가"],
            ["{{パスの結合}}", "경로 결합"],
            ["{{シェイプ}}", "모양"],
            ["{{キーフレームに配分}}", "키프레임에 할당"],
            ["{{レイヤーに配分}}", "레이어에 배포"],
            ["{{タイムライン}}", "타임라인"],
            ["{{整列}}", "맞추다"],
            ["{{最背面}}", "최후면"],
            ["{{ひとつ背面へ}}", "하나의 뒷면으로"],
            ["{{ひとつ前面へ}}", "하나 앞으로"],
            ["{{最前面}}", "최전면"],
            ["{{重ね順}}", "겹침 순서"],
            ["{{プラグイン}}", "플러그인"],
            ["{{ライブラリ}}", "도서관"],
            ["{{プロパティ}}", "속성"],
            ["{{マスクレイヤー}}", "마스크 레이어"],
            ["{{通常レイヤー}}", "일반 레이어"],
            ["{{モーショントゥイーンの削除}}", "모션 트윈 삭제"],
            ["{{モーショントゥイーンの追加}}", "모션 트윈 추가"],
            ["{{モーダル表示}}", "모달 표시"],
            ["{{言語}}", "언어"],
            ["{{フォーマット}}", "형식"],
            ["{{含める}}", "포함"],
            ["{{含めない}}", "포함하지 않음"],
            ["{{使い方、リファレンス}}", "사용법, 참조"],
            ["{{非表示レイヤー}}", "숨겨진 레이어"],
            ["{{設定}}", "설정"],
            ["{{デフォルトのループを利用する}}", "기본 루프 사용"],
            ["{{フレームピッカー}}", "프레임 선택기"],
            ["{{ステージ左揃え}}", "스테이지 왼쪽 정렬"],
            ["{{ステージ中央揃え(水平方向)}}", "스테이지 중앙 정렬(수평 방향)"],
            ["{{ステージ右揃え}}", "스테이지 오른쪽 정렬"],
            ["{{ステージ上揃え}}", "무대에서 정렬"],
            ["{{ステージ中央揃え(垂直方向)}}", "스테이지 중앙 정렬(수직 방향)"],
            ["{{ステージ下揃え}}", "무대 아래 정렬"],
            ["{{左揃え}}", "왼쪽 정렬"],
            ["{{中央揃え(水平方向)}}", "중앙 정렬(수평 방향)"],
            ["{{右揃え}}", "오른쪽 정렬"],
            ["{{上揃え}}", "상단 정렬"],
            ["{{中央揃え(垂直方向)}}", "중앙 정렬(수직 방향)"],
            ["{{下揃え}}", "아래 정렬"],
            ["{{開始フレーム}}", "시작 프레임"],
            ["{{終了フレーム}}", "종료 프레임"],
            ["{{ループで再生}}", "루프로 재생"],
            ["{{1回再生}}", "한 번 재생"],
            ["{{指定したフレームで固定}}", "지정된 프레임으로 고정"],
            ["{{1回逆再生}}", "1회 역재생"],
            ["{{逆ループで再生}}", "역 루프로 재생"],
            ["{{画面の拡大・縮小}}", "화면 확대/축소"],
            ["{{カスタムイージングデータを保存}}", "맞춤형 여유 데이터 저장"],
            ["{{カスタムイージングデータの読込}}", "사용자 정의 여유 데이터 읽기"],
            ["{{プレビューのON/OFF}}", "프레뷰의 ON/OFF"],
            ["{{フォント枠サイズ}}", "글꼴 프레임 크기"],
            ["{{フォント枠カラー}}", "글꼴 프레임 색상"],
            ["{{オニオンスキン}}", "양파 껍질"],
            ["{{バケツツール}}", "버킷 도구"],
            ["{{ペンツール}}", "펜 도구"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "곡선 점을 추가하려면 두 번 클릭"],
            ["{{選択ツール}}", "선택 도구"],
            ["{{Shape変形ツール}}", "모양 변형 도구"],
            ["{{テキストツール}}", "텍스트 도구"],
            ["{{矩形ツール}}", "너무 직사각형"],
            ["{{楕円ツール}}", "타원 도구"],
            ["{{角丸矩形ツール}}", "둥근 사각형 도구"],
            ["{{塗りのカラー}}", "채우기 색상"],
            ["{{線のカラー}}", "획 색상"],
            ["{{線の太さ}}", "획 폭"],
            ["{{プロジェクトデータの読込}}", "프로젝트 데이터 로드"],
            ["{{プロジェクトデータを保存}}", "프로젝트 데이터 저장"],
            ["{{書き出し}}", "내 보내다"],
            ["{{Discordへ移動}}", "불화로 이동"],
            ["{{バグ報告}}", "버그 보고서"],
            ["{{設定}}", "환경"],
            ["{{タブを追加}}", "탭 추가"],
            ["{{タブの一覧を表示・移動}}", "탭 목록 보기 및 이동"],
            ["{{スクリプトを追加}}", "스크립트 추가"],
            ["{{キーフレームを追加}}", "키프레임 추가"],
            ["{{空のキーフレームを追加}}", "빈 키프레임 추가"],
            ["{{フレームを追加}}", "프레임 추가"],
            ["{{フレームを削除}}", "프레임 삭제"],
            ["{{再生}}", "놀다"],
            ["{{停止}}", "중지"],
            ["{{ループ設定}}", "루프 설정"],
            ["{{レイヤーを追加}}", "레이어 추가"],
            ["{{レイヤーを削除}}", "레이어 삭제"],
            ["{{全てのレイヤーをハイライト}}", "모든 레이어 강조 표시"],
            ["{{全てのレイヤーを非表示}}", "모든 레이어 숨기기"],
            ["{{全てのレイヤーをロック}}", "모든 레이어 잠금"],
            ["{{比率を固定}}", "고정 비율"],
            ["{{ステージの幅}}", "무대 폭"],
            ["{{背景色}}", "배경색"],
            ["{{ステージの高さ}}", "무대 높이"],
            ["{{フレームレート}}", "프레임 속도"],
            ["{{シンボル名}}", "기호 이름"],
            ["{{イージング設定}}", "이징 설정"],
            ["{{ビデオの音量設定}}", "비디오 볼륨 설정"],
            ["{{自動再生}}", "자동 재생"],
            ["{{テキストエリアのボーダー設定}}", "텍스트 영역 테두리 설정"],
            ["{{テキスト入力設定}}", "텍스트 입력 설정"],
            ["{{フォント選択}}", "글꼴 선택"],
            ["{{自動サイズ調整}}", "자동 크기 조정"],
            ["{{フォントスタイルタイプ}}", "글꼴 스타일 유형"],
            ["{{行揃え}}", "맞추다"],
            ["{{改行設定}}", "개행 설정"],
            ["{{スクロール設定}}", "스크롤 설정"],
            ["{{フォントサイズ}}", "글꼴 크기"],
            ["{{フォントカラー}}", "글꼴 색상"],
            ["{{行間}}", "줄 간격"],
            ["{{文字幅}}", "문자 너비"],
            ["{{左マージン}}", "왼쪽 여백"],
            ["{{右マージン}}", "오른쪽 여백"],
            ["{{カラー種別の選択}}", "색상 유형 선택"],
            ["{{背景画像の選択}}", "배경 이미지 선택"],
            ["{{カラーポインターを追加}}", "색상 포인터 추가"],
            ["{{カラー値}}", "색상"],
            ["{{アルファ(0%-100%)}}", "알파(0%-100%)"],
            ["{{アルファ値}}", "알파"],
            ["{{選択対象の幅}}", "선택 개체의 너비"],
            ["{{選択対象のX座標}}", "선택 객체의 X 좌표"],
            ["{{選択対象の高さ}}", "선택 개체의 높이"],
            ["{{選択対象のY座標}}", "선택 객체의 Y 좌표"],
            ["{{選択対象の幅の伸縮}}", "선택한 객체의 scaleX"],
            ["{{選択対象を回転}}", "개체 회전"],
            ["{{選択対象の高さの伸縮}}", "선택한 객체의 scaleY"],
            ["{{アルファオフセット(-255〜255)}}", "알파 오프셋(-255〜255)"],
            ["{{赤(0%-100%)}}", "빨간색(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "레드 오프셋(-255〜255)"],
            ["{{緑(0%-100%)}}", "녹색(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "그린 오프셋(-255〜255)"],
            ["{{青(0%-100%)}}", "파란색(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "블루 오프셋(-255〜255)"],
            ["{{ブレンドモード}}", "혼합 모드"],
            ["{{フィルターを選択}}", "필터 선택"],
            ["{{フィルターを追加}}", "필터 추가"],
            ["{{サウンドを追加}}", "소리 추가"],
            ["{{フィルターを表示・非表示する}}", "필터 표시 및 숨기기"],
            ["{{フィルターを削除}}", "필터 삭제"],
            ["{{水平方向にぼかす}}", "수평으로 흐림"],
            ["{{垂直方向にぼかす}}", "수직으로 흐림"],
            ["{{フィルター強度}}", "필터 강도"],
            ["{{フィルター角度}}", "필터 각도"],
            ["{{シャドウのアルファ}}", "섀도우 알파"],
            ["{{シャドウのカラー}}", "그림자 색상"],
            ["{{フィルター距離}}", "필터 거리"],
            ["{{ハイライトのカラー}}", "하이라이트 색상"],
            ["{{ハイライトのアルファ}}", "하이라이트 알파"],
            ["{{グラデーションカラー}}", "그라데이션 색상"],
            ["{{グラデーションのアルファ}}", "그라디언트 알파"],
            ["{{タブの移動・名前を変更}}", "탭 이동/이름 바꾸기"],
            ["{{プロジェクトを閉じる}}", "프로젝트 닫기"],
            ["{{上下に移動}}", "위아래로 이동"],
            ["{{レイヤー変更(ダブルクリック)}}", "레이어 변경(더블 클릭)"],
            ["{{レイヤーをハイライト}}", "하이라이트 레이어"],
            ["{{レイヤーを非表示}}", "레이어 숨기기"],
            ["{{レイヤーをロック}}", "레이어 잠금"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "곡선 포인터(켜기/끄려면 두 번 클릭)"],
            ["{{インスタンス名}}", "인스턴스 이름"],
            ["{{ライブラリ内の検索}}", "도서관에서 검색"],
            ["{{フレームラベル}}", "프레임 라벨"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "프로젝트를 저장하지 않으면 이 탭의 프로젝트 데이터를 복구할 수 없습니다. 탭을 삭제하시겠습니까?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Russia extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{追加ファイル}}", "Дополнительный файл"],
            ["{{既存のコンテンツ}}", "Существующее содержание"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "Вы можете выбрать перезапись, переименование и добавление файлов или пропуск"],
            ["{{全て上書き}}", "Переписать все"],
            ["{{全てスキップ}}", "Пропустить все"],
            ["{{追加・上書き}}", "Добавить или перезаписать"],
            ["{{スキップ}}", "Пропустить"],
            ["{{表示確認したいフレームを指定}}", "Укажите кадр, отображение которого вы хотите проверить"],
            ["{{ファイル名を指定}}", "Укажите имя файла"],
            ["{{ファイル名}}", "имя файла"],
            ["{{終了フレームを指定}}", "Укажите конечную рамку"],
            ["{{開始フレームを指定}}", "Укажите начальный кадр"],
            ["{{フレーム設定}}", "Установка рамы"],
            ["{{書き出し設定}}", "Настройки экспорта"],
            ["{{ファイル形式の選択}}", "Выберите формат файла"],
            ["{{ファイル形式}}", "Форматы файлов"],
            ["{{サイズ設定}}", "Установка размера"],
            ["{{左上}}", "Вверху слева"],
            ["{{中央上}}", "Вверху по центру"],
            ["{{右上}}", "Верхний правый"],
            ["{{中央左}}", "Центр Левый"],
            ["{{中央}}", "Центр"],
            ["{{中央右}}", "Центр Правый"],
            ["{{左下}}", "Низ Левый"],
            ["{{中央下}}", "Нижняя часть Центр"],
            ["{{右下}}", "Дно справа"],
            ["{{中心点のX座標}}", "X-координата центральной точки"],
            ["{{中心点のY座標}}", "Y-координата центральной точки"],
            ["{{MovieClipに変換}}", "Конвертировать в MovieClip"],
            ["{{変換}}", "трансформация"],
            ["{{ループ回数}}", "Количество циклов"],
            ["{{カーブポインターの削除}}", "Удалить указатель кривой"],
            ["{{ステージ基準}}", "Критерии этапа"],
            ["{{閉じる}}", "Закрыть"],
            ["{{保存}}", "Сохранить"],
            ["{{リセット}}", "сброс"],
            ["{{スクリーン}}", "Экран"],
            ["{{ショートカット設定}}", "Настройки ярлыков"],
            ["{{レイヤーカラー}}", "слоистый цвет"],
            ["{{Next2Dを支援する}}", "Поддержите Next2D"],
            ["{{サポート}}", "поддержка"],
            ["{{未使用のアイテムを削除}}", "Удалите неиспользуемые предметы"],
            ["{{レイヤーをペースト}}", "Слой пасты"],
            ["{{レイヤーをコピー}}", "Копирование слоя"],
            ["{{フレームをペースト}}", "Вставить рамку"],
            ["{{フレームをコピー}}", "Копировальная рама"],
            ["{{キーフレームを削除}}", "Удалить ключевые кадры"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "Невозможно добавить пустые ключевые кадры в ключевые кадры"],
            ["{{ズームツール}}", "Инструмент масштабирования"],
            ["{{タイムライン幅の拡大・縮小}}", "Ширина временной шкалы Расширение/сокращение"],
            ["{{ガイドレイヤー}}", "направляющий слой"],
            ["{{音量設定}}", "Настройка громкости"],
            ["{{サウンドを削除}}", "Удалить звук"],
            ["{{カスタムループ}}", "индивидуальная петля"],
            ["{{読込のみ}}", "Только чтение"],
            ["{{書込を許可}}", "разрешение на публикацию"],
            ["{{単一行}}", "Одиночная линия"],
            ["{{複数行}}", "Многолинейный"],
            ["{{自動で折り返し}}", "Автоматический обхват"],
            ["{{左寄せ}}", "Слева"],
            ["{{中央揃え}}", "Центр"],
            ["{{右寄せ}}", "Правый"],
            ["{{放射状グラデーション}}", "радиальная градация"],
            ["{{線形グラデーション}}", "линейный градиент"],
            ["{{画像}}", "Изображение"],
            ["{{画像選択}}", "Выбор изображения"],
            ["{{種別}}", "Тип"],
            ["{{Shapeの色設定}}", "Настройки цвета формы"],
            ["{{変形}}", "деформация"],
            ["{{カラー効果}}", "Трансформация цвета"],
            ["{{フィルター}}", "фильтр"],
            ["{{Shapeを複製}}", "Дублировать форму"],
            ["{{読み込み}}", "читать в"],
            ["{{新規フォルダー}}", "Новая папка"],
            ["{{新規MovieClip}}", "Новый MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "Измените размер текста, чтобы он поместился в рамку"],
            ["{{テキストに合わせて枠をリサイズ}}", "Измените размер рамки, чтобы вместить текст"],
            ["{{リサイズしない}}", "Отсутствие изменения размера"],
            ["{{フォント}}", "шрифт"],
            ["{{テキスト}}", "Текст"],
            ["{{ループ}}", "петля"],
            ["{{音量}}", "громкость"],
            ["{{ビデオ}}", "Видео"],
            ["{{イージング}}", "облегчение"],
            ["{{サウンド}}", "звук"],
            ["{{シンボル}}", "Символ"],
            ["{{名前}}", "Имя"],
            ["{{オブジェクト}}", "объект"],
            ["{{ステージ設定}}", "Постановка сцены"],
            ["{{プレビュー}}", "Предварительный просмотр"],
            ["{{削除}}", "Удалить"],
            ["{{ペースト}}", "Паста"],
            ["{{コピー}}", "Копировать"],
            ["{{プラグインメニュー}}", "Меню подключаемых модулей"],
            ["{{トゥイーン}}", "между"],
            ["{{カーブポインターの追加}}", "Дополнительный указатель кривой"],
            ["{{パスの結合}}", "Объединение путей"],
            ["{{シェイプ}}", "форма"],
            ["{{キーフレームに配分}}", "Распределение по ключевым кадрам"],
            ["{{レイヤーに配分}}", "Распределение по слоям"],
            ["{{タイムライン}}", "временная шкала"],
            ["{{整列}}", "Выровнять"],
            ["{{最背面}}", "Большая часть спины"],
            ["{{ひとつ背面へ}}", "Один в задней части"],
            ["{{ひとつ前面へ}}", "Один фронт"],
            ["{{最前面}}", "На переднем крае"],
            ["{{重ね順}}", "Организуйте"],
            ["{{プラグイン}}", "плагин"],
            ["{{ライブラリ}}", "библиотека"],
            ["{{プロパティ}}", "собственность"],
            ["{{マスクレイヤー}}", "слой маски"],
            ["{{通常レイヤー}}", "Нормальный слой"],
            ["{{モーショントゥイーンの削除}}", "Удаление твинов движения"],
            ["{{モーショントゥイーンの追加}}", "Дополнительные твины движения"],
            ["{{モーダル表示}}", "модальная индикация"],
            ["{{言語}}", "Язык"],
            ["{{フォーマット}}", "формат"],
            ["{{含める}}", "включать"],
            ["{{含めない}}", "не включать"],
            ["{{使い方、リファレンス}}", "Использование, ссылка"],
            ["{{非表示レイヤー}}", "скрытый слой"],
            ["{{設定}}", "настройка"],
            ["{{デフォルトのループを利用する}}", "Используйте цикл по умолчанию"],
            ["{{フレームピッカー}}", "подборщик рам"],
            ["{{ステージ左揃え}}", "Выровнять сцену слева"],
            ["{{ステージ中央揃え(水平方向)}}", "Выровняйте центр сцены (горизонтально)"],
            ["{{ステージ右揃え}}", "Выровнять сцену вправо"],
            ["{{ステージ上揃え}}", "Выровнять сцену вверх"],
            ["{{ステージ中央揃え(垂直方向)}}", "Выровняйте центр сцены (вертикально)"],
            ["{{ステージ下揃え}}", "Выровнять дно сцены"],
            ["{{左揃え}}", "Слева"],
            ["{{中央揃え(水平方向)}}", "Центр (горизонтальность)"],
            ["{{右揃え}}", "Справа"],
            ["{{上揃え}}", "Топ"],
            ["{{中央揃え(垂直方向)}}", "Центр (вертикальный)"],
            ["{{下揃え}}", "Дно"],
            ["{{開始フレーム}}", "начальная рамка"],
            ["{{終了フレーム}}", "торцевая рама"],
            ["{{ループで再生}}", "Воспроизведение по кругу"],
            ["{{1回再生}}", "1 воспроизведение"],
            ["{{指定したフレームで固定}}", "Фиксируется в указанном кадре"],
            ["{{1回逆再生}}", "1 воспроизведение в обратном направлении"],
            ["{{逆ループで再生}}", "Воспроизведение в обратном цикле"],
            ["{{画面の拡大・縮小}}", "Увеличение и уменьшение масштаба экрана"],
            ["{{カスタムイージングデータを保存}}", "Сохраните данные пользовательского смягчения"],
            ["{{カスタムイージングデータの読込}}", "Чтение пользовательских данных о смягчении"],
            ["{{プレビューのON/OFF}}", "Включение/выключение предварительного просмотра"],
            ["{{フォント枠サイズ}}", "Размер рамки шрифта"],
            ["{{フォント枠カラー}}", "Цвет шрифтовой рамки"],
            ["{{オニオンスキン}}", "Луковая шкурка"],
            ["{{バケツツール}}", "Ведерные инструменты"],
            ["{{ペンツール}}", "Инструмент \"Перо"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Дважды щелкните, чтобы добавить точку кривой"],
            ["{{選択ツール}}", "Инструменты выбора"],
            ["{{Shape変形ツール}}", "Инструмент преобразования формы"],
            ["{{テキストツール}}", "Текстовый инструмент"],
            ["{{矩形ツール}}", "Инструмент \"Прямоугольник"],
            ["{{楕円ツール}}", "Инструмент \"Эллипс"],
            ["{{角丸矩形ツール}}", "Инструмент \"Скругленный прямоугольник"],
            ["{{塗りのカラー}}", "Цвет заливки"],
            ["{{線のカラー}}", "Цвет штриха"],
            ["{{線の太さ}}", "Ширина штриха"],
            ["{{プロジェクトデータの読込}}", "Загрузка данных проекта"],
            ["{{プロジェクトデータを保存}}", "Сохранить данные проекта"],
            ["{{書き出し}}", "Экспорт"],
            ["{{Discordへ移動}}", "Зайдите в дискорд"],
            ["{{バグ報告}}", "Сообщения об ошибках"],
            ["{{設定}}", "Настройка"],
            ["{{タブを追加}}", "Добавить вкладку"],
            ["{{タブの一覧を表示・移動}}", "Просмотр и перемещение по списку вкладок"],
            ["{{スクリプトを追加}}", "Добавить сценарий"],
            ["{{キーフレームを追加}}", "Добавить ключевой кадр"],
            ["{{空のキーフレームを追加}}", "Добавьте пустой ключевой кадр"],
            ["{{フレームを追加}}", "Добавить рамку"],
            ["{{フレームを削除}}", "Удалить рамку"],
            ["{{再生}}", "Играть"],
            ["{{停止}}", "Остановить"],
            ["{{ループ設定}}", "Настройка контура"],
            ["{{レイヤーを追加}}", "Добавить слой"],
            ["{{レイヤーを削除}}", "Удалить слой"],
            ["{{全てのレイヤーをハイライト}}", "Выделите все слои"],
            ["{{全てのレイヤーを非表示}}", "Скрыть все слои"],
            ["{{全てのレイヤーをロック}}", "Заблокируйте все слои"],
            ["{{比率を固定}}", "Фиксированный коэффициент"],
            ["{{ステージの幅}}", "Ширина сцены"],
            ["{{背景色}}", "Цвет фона"],
            ["{{ステージの高さ}}", "Высота сцены"],
            ["{{フレームレート}}", "Частота кадров"],
            ["{{シンボル名}}", "Название символа"],
            ["{{イージング設定}}", "Установка облегчения"],
            ["{{ビデオの音量設定}}", "Настройка громкости видео"],
            ["{{自動再生}}", "Автоматическое воспроизведение"],
            ["{{テキストエリアのボーダー設定}}", "Настройка границ текстовой области"],
            ["{{テキスト入力設定}}", "Настройка ввода текста"],
            ["{{フォント選択}}", "Выбор шрифта"],
            ["{{自動サイズ調整}}", "Автоматическая регулировка размера"],
            ["{{フォントスタイルタイプ}}", "Тип стиля шрифта"],
            ["{{行揃え}}", "Выровнять"],
            ["{{改行設定}}", "Установка новой строки"],
            ["{{スクロール設定}}", "Настройка прокрутки"],
            ["{{フォントサイズ}}", "Размер шрифта"],
            ["{{フォントカラー}}", "Цвет шрифта"],
            ["{{行間}}", "Пространство линии"],
            ["{{文字幅}}", "Ширина символа"],
            ["{{左マージン}}", "Левое поле"],
            ["{{右マージン}}", "Правая граница"],
            ["{{カラー種別の選択}}", "Выберите тип цвета"],
            ["{{背景画像の選択}}", "Выбор фонового изображения"],
            ["{{カラーポインターを追加}}", "Добавьте указатели цвета"],
            ["{{カラー値}}", "Цвет"],
            ["{{アルファ(0%-100%)}}", "Альфа(0%-100%)"],
            ["{{アルファ値}}", "Альфа"],
            ["{{選択対象の幅}}", "Ширина объекта выделения"],
            ["{{選択対象のX座標}}", "X координата объекта выделения"],
            ["{{選択対象の高さ}}", "Высота объекта выделения"],
            ["{{選択対象のY座標}}", "Y координата объекта выделения"],
            ["{{選択対象の幅の伸縮}}", "масштабX выбранного объекта"],
            ["{{選択対象を回転}}", "Повернуть объект"],
            ["{{選択対象の高さの伸縮}}", "scaleY выбранного объекта"],
            ["{{アルファオフセット(-255〜255)}}", "Альфа-смещение(-255〜255)"],
            ["{{赤(0%-100%)}}", "Красный(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Красное смещение(-255〜255)"],
            ["{{緑(0%-100%)}}", "Зеленый(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Зеленый зачет(-255〜255)"],
            ["{{青(0%-100%)}}", "Голубой(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Синее смещение(-255〜255)"],
            ["{{ブレンドモード}}", "Режим наложения"],
            ["{{フィルターを選択}}", "Выберите фильтр"],
            ["{{フィルターを追加}}", "Добавить фильтр"],
            ["{{サウンドを追加}}", "Добавить звук"],
            ["{{フィルターを表示・非表示する}}", "Показать и скрыть фильтры"],
            ["{{フィルターを削除}}", "Удалить фильтр"],
            ["{{水平方向にぼかす}}", "Размытие по горизонтали"],
            ["{{垂直方向にぼかす}}", "Размытие по вертикали"],
            ["{{フィルター強度}}", "Прочность фильтра"],
            ["{{フィルター角度}}", "Угол фильтрации"],
            ["{{シャドウのアルファ}}", "Тень Альфа"],
            ["{{シャドウのカラー}}", "Цвет теней"],
            ["{{フィルター距離}}", "Расстояние между фильтрами"],
            ["{{ハイライトのカラー}}", "Цвет подсветки"],
            ["{{ハイライトのアルファ}}", "Выделение Альфа"],
            ["{{グラデーションカラー}}", "Цвет градиента"],
            ["{{グラデーションのアルファ}}", "Градиент Альфа"],
            ["{{タブの移動・名前を変更}}", "Переместить/именовать вкладки"],
            ["{{プロジェクトを閉じる}}", "Закрыть проект"],
            ["{{上下に移動}}", "Двигайтесь вверх и вниз"],
            ["{{レイヤー変更(ダブルクリック)}}", "Смена слоя (двойной щелчок)"],
            ["{{レイヤーをハイライト}}", "Выделительный слой"],
            ["{{レイヤーを非表示}}", "Скрыть слой"],
            ["{{レイヤーをロック}}", "Заблокировать слой"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Указатель кривой (двойной щелчок для включения/выключения)"],
            ["{{インスタンス名}}", "Имя экземпляра"],
            ["{{ライブラリ内の検索}}", "Поиск в библиотеке"],
            ["{{フレームラベル}}", "Рамочная этикетка"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "Если проект не сохранен, данные проекта на этой вкладке не могут быть восстановлены. Вы хотите удалить вкладку?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Spanish extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{追加ファイル}}", "Archivo adicional"],
            ["{{既存のコンテンツ}}", "Contenido existente"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "Puede elegir entre sobrescribir, renombrar y añadir archivos, u omitir"],
            ["{{全て上書き}}", "Sobrescribir todo"],
            ["{{全てスキップ}}", "Omitir todo"],
            ["{{追加・上書き}}", "Añadir o sobrescribir"],
            ["{{スキップ}}", "Omitir"],
            ["{{表示確認したいフレームを指定}}", "Especifique el marco del que desea comprobar la visualización"],
            ["{{ファイル名を指定}}", "Especifique el nombre del archivo"],
            ["{{ファイル名}}", "nombre del archivo"],
            ["{{終了フレームを指定}}", "Especifique el marco final"],
            ["{{開始フレームを指定}}", "Especifique el marco de inicio"],
            ["{{フレーム設定}}", "Ajuste del marco"],
            ["{{書き出し設定}}", "Configuración de la exportación"],
            ["{{ファイル形式の選択}}", "Seleccione el formato de archivo"],
            ["{{ファイル形式}}", "Formatos de archivo"],
            ["{{サイズ設定}}", "Ajuste del tamaño"],
            ["{{左上}}", "Arriba a la izquierda"],
            ["{{中央上}}", "Centro superior"],
            ["{{右上}}", "Arriba Derecha"],
            ["{{中央左}}", "Centro Izquierda"],
            ["{{中央}}", "Centro"],
            ["{{中央右}}", "Centro derecha"],
            ["{{左下}}", "Abajo a la izquierda"],
            ["{{中央下}}", "Abajo Centro"],
            ["{{右下}}", "Abajo a la derecha"],
            ["{{中心点のX座標}}", "Coordenada X del punto central"],
            ["{{中心点のY座標}}", "Coordenada Y del punto central"],
            ["{{MovieClipに変換}}", "Convertir a MovieClip"],
            ["{{変換}}", "transformación"],
            ["{{ループ回数}}", "Recuento de bucles"],
            ["{{カーブポインターの削除}}", "Borrar el puntero de la curva"],
            ["{{ステージ基準}}", "Criterios de la etapa"],
            ["{{閉じる}}", "Cerrar"],
            ["{{保存}}", "Guardar"],
            ["{{リセット}}", "restablecer"],
            ["{{スクリーン}}", "Pantalla"],
            ["{{ショートカット設定}}", "Configuración de los accesos directos"],
            ["{{レイヤーカラー}}", "color en capas"],
            ["{{Next2Dを支援する}}", "Apoya a Next2D"],
            ["{{サポート}}", "soporte"],
            ["{{未使用のアイテムを削除}}", "Eliminar los elementos no utilizados"],
            ["{{レイヤーをペースト}}", "Capa de pasta"],
            ["{{レイヤーをコピー}}", "Copiar capa"],
            ["{{フレームをペースト}}", "Pegar el marco"],
            ["{{フレームをコピー}}", "Copiar marco"],
            ["{{キーフレームを削除}}", "Eliminar fotogramas clave"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "No se pueden añadir fotogramas clave vacíos a los fotogramas clave"],
            ["{{ズームツール}}", "Herramienta de zoom"],
            ["{{タイムライン幅の拡大・縮小}}", "Anchura de la línea de tiempo Ampliar/reducir"],
            ["{{ガイドレイヤー}}", "capa de guía"],
            ["{{音量設定}}", "Ajuste del volumen"],
            ["{{サウンドを削除}}", "Eliminar el sonido"],
            ["{{カスタムループ}}", "bucle personalizado"],
            ["{{読込のみ}}", "Sólo para leer"],
            ["{{書込を許可}}", "permiso de correos"],
            ["{{単一行}}", "Línea única"],
            ["{{複数行}}", "Multilínea"],
            ["{{自動で折り返し}}", "Envoltura automática"],
            ["{{左寄せ}}", "Izquierda"],
            ["{{中央揃え}}", "Centro"],
            ["{{右寄せ}}", "Derecha"],
            ["{{放射状グラデーション}}", "gradación radial"],
            ["{{線形グラデーション}}", "gradiente lineal"],
            ["{{画像}}", "Imagen"],
            ["{{画像選択}}", "Selección de imágenes"],
            ["{{種別}}", "Tipo"],
            ["{{Shapeの色設定}}", "Configuración del color de la forma"],
            ["{{変形}}", "deformación"],
            ["{{カラー効果}}", "Transformación del color"],
            ["{{フィルター}}", "filtro"],
            ["{{Shapeを複製}}", "Duplicar la forma"],
            ["{{読み込み}}", "leer en"],
            ["{{新規フォルダー}}", "Carpeta nueva"],
            ["{{新規MovieClip}}", "Nuevo MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "Cambia el tamaño del texto para que se ajuste al marco"],
            ["{{テキストに合わせて枠をリサイズ}}", "Cambia el tamaño del marco para que se ajuste al texto"],
            ["{{リサイズしない}}", "No hay cambio de tamaño"],
            ["{{フォント}}", "fuente"],
            ["{{テキスト}}", "Texto"],
            ["{{ループ}}", "bucle"],
            ["{{音量}}", "volumen"],
            ["{{ビデオ}}", "Vídeo"],
            ["{{イージング}}", "facilitando"],
            ["{{サウンド}}", "sonido"],
            ["{{シンボル}}", "Símbolo"],
            ["{{名前}}", "Nombre"],
            ["{{オブジェクト}}", "objeto"],
            ["{{ステージ設定}}", "Puesta en escena"],
            ["{{プレビュー}}", "Previsualización"],
            ["{{削除}}", "Borrar"],
            ["{{ペースト}}", "Pegar"],
            ["{{コピー}}", "Copiar"],
            ["{{プラグインメニュー}}", "Menú de complementos"],
            ["{{トゥイーン}}", "tween"],
            ["{{カーブポインターの追加}}", "Puntero de curva adicional"],
            ["{{パスの結合}}", "Fusión de caminos"],
            ["{{シェイプ}}", "forma"],
            ["{{キーフレームに配分}}", "Asignación a los fotogramas clave"],
            ["{{レイヤーに配分}}", "Asignación a las capas"],
            ["{{タイムライン}}", "línea de tiempo"],
            ["{{整列}}", "Alinear"],
            ["{{最背面}}", "La mayor parte de la espalda"],
            ["{{ひとつ背面へ}}", "Uno en la parte trasera"],
            ["{{ひとつ前面へ}}", "Un frente"],
            ["{{最前面}}", "Frontmost"],
            ["{{重ね順}}", "Organice"],
            ["{{プラグイン}}", "plug-in"],
            ["{{ライブラリ}}", "biblioteca"],
            ["{{プロパティ}}", "propiedad"],
            ["{{マスクレイヤー}}", "capa de máscara"],
            ["{{通常レイヤー}}", "Capa normal"],
            ["{{モーショントゥイーンの削除}}", "Supresión de los tweens de movimiento"],
            ["{{モーショントゥイーンの追加}}", "Tweens de movimiento adicionales"],
            ["{{モーダル表示}}", "indicación modal"],
            ["{{言語}}", "El idioma"],
            ["{{フォーマット}}", "formato"],
            ["{{含める}}", "incluir"],
            ["{{含めない}}", "no incluir"],
            ["{{使い方、リファレンス}}", "Uso, referencia"],
            ["{{非表示レイヤー}}", "capa oculta"],
            ["{{設定}}", "configuración"],
            ["{{デフォルトのループを利用する}}", "Utiliza el bucle por defecto"],
            ["{{フレームピッカー}}", "Recogedor de marcos"],
            ["{{ステージ左揃え}}", "Alinear el escenario a la izquierda"],
            ["{{ステージ中央揃え(水平方向)}}", "Alinear el centro del escenario (horizontal)"],
            ["{{ステージ右揃え}}", "Alinear el escenario a la derecha"],
            ["{{ステージ上揃え}}", "Alinear el escenario hacia arriba"],
            ["{{ステージ中央揃え(垂直方向)}}", "Alinear el centro del escenario (vertical)"],
            ["{{ステージ下揃え}}", "Alinear el fondo del escenario"],
            ["{{左揃え}}", "Izquierda"],
            ["{{中央揃え(水平方向)}}", "Centro (Horizontal)"],
            ["{{右揃え}}", "Derecho"],
            ["{{上揃え}}", "Arriba"],
            ["{{中央揃え(垂直方向)}}", "Centro (Vertical)"],
            ["{{下揃え}}", "Fondo"],
            ["{{開始フレーム}}", "marco de inicio"],
            ["{{終了フレーム}}", "marco final"],
            ["{{ループで再生}}", "Reproducir en bucle"],
            ["{{1回再生}}", "1 reproducción"],
            ["{{指定したフレームで固定}}", "Fijado en el marco especificado"],
            ["{{1回逆再生}}", "1 reproducción inversa"],
            ["{{逆ループで再生}}", "Reproducción en bucle invertido"],
            ["{{画面の拡大・縮小}}", "Acercar y alejar la pantalla"],
            ["{{カスタムイージングデータを保存}}", "Guarda los datos de la flexión personalizada"],
            ["{{カスタムイージングデータの読込}}", "Lectura de datos de flexibilización personalizados"],
            ["{{プレビューのON/OFF}}", "Activación/desactivación de la vista previa"],
            ["{{フォント枠サイズ}}", "Tamaño del marco de la fuente"],
            ["{{フォント枠カラー}}", "Color del marco de la fuente"],
            ["{{オニオンスキン}}", "Piel de cebolla"],
            ["{{バケツツール}}", "Herramientas para cubos"],
            ["{{ペンツール}}", "Herramienta de la pluma"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Haga doble clic para añadir un punto de curva"],
            ["{{選択ツール}}", "Herramientas de selección"],
            ["{{Shape変形ツール}}", "Herramienta de transformación de formas"],
            ["{{テキストツール}}", "Herramienta de texto"],
            ["{{矩形ツール}}", "Herramienta Rectángulo"],
            ["{{楕円ツール}}", "Herramienta Elipse"],
            ["{{角丸矩形ツール}}", "Herramienta Rectángulo Redondeado"],
            ["{{塗りのカラー}}", "Color de relleno"],
            ["{{線のカラー}}", "Color del trazo"],
            ["{{線の太さ}}", "Anchura de la carrera"],
            ["{{プロジェクトデータの読込}}", "Carga de los datos del proyecto"],
            ["{{プロジェクトデータを保存}}", "Guardar los datos del proyecto"],
            ["{{書き出し}}", "Exportar"],
            ["{{Discordへ移動}}", "Ir a la discordia"],
            ["{{バグ報告}}", "Informes de errores"],
            ["{{設定}}", "Configuración"],
            ["{{タブを追加}}", "Añadir una pestaña"],
            ["{{タブの一覧を表示・移動}}", "Ver y desplazarse por la lista de pestañas"],
            ["{{スクリプトを追加}}", "Añadir una secuencia de comandos"],
            ["{{キーフレームを追加}}", "Añadir un fotograma clave"],
            ["{{空のキーフレームを追加}}", "Añadir un fotograma clave vacío"],
            ["{{フレームを追加}}", "Añadir un marco"],
            ["{{フレームを削除}}", "Borrar el marco"],
            ["{{再生}}", "Juega a"],
            ["{{停止}}", "Detener"],
            ["{{ループ設定}}", "Ajuste del bucle"],
            ["{{レイヤーを追加}}", "Añadir una capa"],
            ["{{レイヤーを削除}}", "Eliminar la capa"],
            ["{{全てのレイヤーをハイライト}}", "Resaltar todas las capas"],
            ["{{全てのレイヤーを非表示}}", "Ocultar todas las capas"],
            ["{{全てのレイヤーをロック}}", "Bloquear todas las capas"],
            ["{{比率を固定}}", "Relación fija"],
            ["{{ステージの幅}}", "Anchura del escenario"],
            ["{{背景色}}", "Color de fondo"],
            ["{{ステージの高さ}}", "Altura del escenario"],
            ["{{フレームレート}}", "Velocidad de fotogramas"],
            ["{{シンボル名}}", "Nombre del símbolo"],
            ["{{イージング設定}}", "Ajuste de la flexibilización"],
            ["{{ビデオの音量設定}}", "Ajuste del volumen de vídeo"],
            ["{{自動再生}}", "Reproducción automática"],
            ["{{テキストエリアのボーダー設定}}", "Configuración del borde del área de texto"],
            ["{{テキスト入力設定}}", "Ajuste de la entrada de texto"],
            ["{{フォント選択}}", "Selección de fuentes"],
            ["{{自動サイズ調整}}", "Ajuste automático del tamaño"],
            ["{{フォントスタイルタイプ}}", "Tipo de letra"],
            ["{{行揃え}}", "Alinear"],
            ["{{改行設定}}", "Ajuste de la nueva línea"],
            ["{{スクロール設定}}", "Ajuste de desplazamiento"],
            ["{{フォントサイズ}}", "Tamaño de la fuente"],
            ["{{フォントカラー}}", "Color de la fuente"],
            ["{{行間}}", "Espacio de la línea"],
            ["{{文字幅}}", "Anchura de los caracteres"],
            ["{{左マージン}}", "Margen izquierdo"],
            ["{{右マージン}}", "Margen derecho"],
            ["{{カラー種別の選択}}", "Seleccione un tipo de color"],
            ["{{背景画像の選択}}", "Seleccionar una imagen de fondo"],
            ["{{カラーポインターを追加}}", "Añadir punteros de color"],
            ["{{カラー値}}", "Color"],
            ["{{アルファ(0%-100%)}}", "Alpha(0%-100%)"],
            ["{{アルファ値}}", "Alpha"],
            ["{{選択対象の幅}}", "Anchura del objeto de selección"],
            ["{{選択対象のX座標}}", "Coordenada X del objeto de selección"],
            ["{{選択対象の高さ}}", "Altura del objeto de selección"],
            ["{{選択対象のY座標}}", "Coordenada Y del objeto de selección"],
            ["{{選択対象の幅の伸縮}}", "scaleX del objeto seleccionado"],
            ["{{選択対象を回転}}", "Girar el objeto"],
            ["{{選択対象の高さの伸縮}}", "escalaY del objeto seleccionado"],
            ["{{アルファオフセット(-255〜255)}}", "Desplazamiento alfa(-255〜255)"],
            ["{{赤(0%-100%)}}", "Rojo(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Compensación roja(-255〜255)"],
            ["{{緑(0%-100%)}}", "Verde(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Compensación verde(-255〜255)"],
            ["{{青(0%-100%)}}", "Azul(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Offset azul(-255〜255)"],
            ["{{ブレンドモード}}", "Modo de fusión"],
            ["{{フィルターを選択}}", "Seleccione un filtro"],
            ["{{フィルターを追加}}", "Añadir un filtro"],
            ["{{サウンドを追加}}", "Añadir un sonido"],
            ["{{フィルターを表示・非表示する}}", "Mostrar y ocultar filtros"],
            ["{{フィルターを削除}}", "Eliminar el filtro"],
            ["{{水平方向にぼかす}}", "Desenfoque horizontal"],
            ["{{垂直方向にぼかす}}", "Desenfoque vertical"],
            ["{{フィルター強度}}", "Fuerza del filtro"],
            ["{{フィルター角度}}", "Ángulo del filtro"],
            ["{{シャドウのアルファ}}", "Sombra Alfa"],
            ["{{シャドウのカラー}}", "Color de la sombra"],
            ["{{フィルター距離}}", "Distancia del filtro"],
            ["{{ハイライトのカラー}}", "Color de realce"],
            ["{{ハイライトのアルファ}}", "Resaltar Alpha"],
            ["{{グラデーションカラー}}", "Color degradado"],
            ["{{グラデーションのアルファ}}", "Gradiente Alfa"],
            ["{{タブの移動・名前を変更}}", "Mover/Renombrar pestañas"],
            ["{{プロジェクトを閉じる}}", "Cerrar el proyecto"],
            ["{{上下に移動}}", "Subir y bajar"],
            ["{{レイヤー変更(ダブルクリック)}}", "Cambio de capa (doble clic)"],
            ["{{レイヤーをハイライト}}", "Capa de resaltado"],
            ["{{レイヤーを非表示}}", "Ocultar capa"],
            ["{{レイヤーをロック}}", "Bloquear la capa"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Puntero de curva (doble clic para activar/desactivar)"],
            ["{{インスタンス名}}", "Nombre de la instancia"],
            ["{{ライブラリ内の検索}}", "Buscar en la biblioteca"],
            ["{{フレームラベル}}", "Etiqueta del marco"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "Si el proyecto no se guarda, los datos del proyecto en esta pestaña no se pueden recuperar. ¿Desea eliminar la pestaña?"]
        ]);
    }
}

let characterId = 0;

const Util = {};

Util.VERSION                  = 1;
Util.PREFIX                   = "__next2d-tools__";
Util.DATABASE_NAME            = "save-data";
Util.STORE_KEY                = "local";
Util.LAYER_MODE_NORMAL        = 0;
Util.LAYER_MODE_MASK          = 1;
Util.LAYER_MODE_MASK_IN       = 2;
Util.LAYER_MODE_GUIDE         = 3;
Util.LAYER_MODE_GUIDE_IN      = 4;
Util.REVISION_LIMIT           = 100;
Util.FOLDER_OPEN              = "open";
Util.FOLDER_CLOSE             = "close";
Util.DEFAULT_LOOP             = 5;
Util.$activeWorkSpaceId       = 0;
Util.$workSpaces              = [];
Util.$readStatus              = 0;
Util.$readEnd                 = 1;
Util.$shiftKey                = false;
Util.$ctrlKey                 = false;
Util.$altKey                  = false;
Util.$zoomScale               = 1;
Util.$currentFrame            = 1;
Util.$root                    = null;
Util.$Rad2Deg                 = 180 / Math.PI;
Util.$Deg2Rad                 = Math.PI / 180;
Util.$keyLock                 = false;
Util.$activeScript            = false;
Util.$previewMode             = false;
Util.$offsetLeft              = 0;
Util.$offsetTop               = 0;
Util.$currentCursor           = "auto";
Util.$useIds                  = new Map();
Util.$symbols                 = new Map();
Util.$copyWorkSpaceId         = -1;
Util.$copyLibrary             = null;
Util.$copyLayer               = null;
Util.$copyCharacter           = null;
Util.$canCopyLayer            = false;
Util.$canCopyCharacter        = false;
Util.$hitColor                = null;
Util.$updated                 = false;
Util.$languages               = new Map();
Util.$currentLanguage         = null;
Util.$shapePointerColor       = "#009900";
Util.$shapeLinkedPointerColor = "#ffa500";
Util.$shortcut                = new Map();
Util.$useShortcutSetting      = false;
Util.$changeLibraryId         = 0;

const userAgentData = window.navigator.userAgentData;
if (userAgentData) {
    userAgentData
        .getHighEntropyValues(["platform"])
        .then((object) =>
        {
            Util.$isMac = object.platform.indexOf("mac") > -1;
        });
} else {
    Util.$isMac = window.navigator.userAgent.indexOf("Mac") > -1;
}

const canvas     = document.createElement("canvas");
canvas.width     = 1;
canvas.height    = 1;
Util.$hitContext = canvas.getContext("2d");

Util.$transformTargets = [
    "scale-top-left",
    "scale-top-right",
    "scale-bottom-left",
    "scale-bottom-right",
    "scale-center-left",
    "scale-center-top",
    "scale-center-right",
    "scale-center-bottom",
    "target-rect",
    "target-rotation",
    "reference-point"
];

Util.$gridTargets = [
    "grid-top-left",
    "grid-top-right",
    "grid-bottom-left",
    "grid-bottom-right"
];

/**
 * @type {HTMLImageElement}
 */
Util.$emptyImage = new Image();
Util.$emptyImage.draggable = false;

/**
 * @param  {*}   value
 * @param  {int} min
 * @param  {int} max
 * @return {number}
 * @static
 */
Util.$clamp = (value, min, max) =>
{
    const number = +value;
    return Math.min(Math.max(min, isNaN(number) ? 0 : number), max);
};

/**
 * @param  {string} key
 * @param  {object} [options=null]
 * @return {string}
 * @static
 */
Util.$generateShortcutKey = (key, options = null) =>
{
    let value = key.length === 1 ? key.toLowerCase() : key;
    if (options) {
        if (options.shift) {
            value += "Shift";
        }
        if (options.alt) {
            value += "Alt";
        }
        if (options.ctrl) {
            value += "Ctrl";
        }
    }
    return value;
};

/**
 * @param  {*} source
 * @return {boolean}
 * @static
 */
Util.$isArray = (source) =>
{
    return Array.isArray(source);
};

/**
 * @param  {string} [value="auto"]
 * @return {void}
 * @static
 */
Util.$setCursor = (value = "auto") =>
{
    if (Util.$currentCursor !== value) {
        Util.$currentCursor = value;
        document
            .documentElement
            .style
            .setProperty("--tool-cursor", value);
    }
};

/**
 * @description モーダルのアニメーションイベントを登録
 *
 * @param  {HTMLElement} element
 * @return {void}
 * @method
 * @static
 */
Util.$addModalEvent = (element) =>
{
    const elements = element
        .querySelectorAll("[data-detail]");

    for (let idx = 0; idx < elements.length; ++idx) {

        const element = elements[idx];

        element.addEventListener("mouseover", Util.$fadeIn);
        element.addEventListener("mouseout",  Util.$fadeOut);
    }
};

/**
 * @description モーダルのフェードアウト関数
 *
 * @param  {MouseEvent} event
 * @method
 * @static
 */
Util.$fadeIn = (event) =>
{
    const object = Util.$userSetting.getPublishSetting();
    if ("modal" in object && !object.modal) {
        return ;
    }

    const target = event.currentTarget;

    let value = Util.$currentLanguage.replace(
        target.dataset.detail
    );

    let shortcutKey = target.dataset.shortcutKey;
    if (shortcutKey) {

        const mapping = Util.$shortcutSetting.viewMapping.get(
            target.dataset.area
        );

        const shortcutText = mapping.has(shortcutKey)
            ? mapping.get(shortcutKey).text
            : target.dataset.shortcutText;

        value += ` (${shortcutText})`;
    }

    const element = document.getElementById("detail-modal");
    if (element.textContent !== value) {
        element.textContent = value;
    }

    // 表示領域に収まるようx座標を調整
    switch (true) {

        case element.clientWidth + event.pageX - 20 > window.innerWidth:
            element.style.left = `${event.pageX - (element.clientWidth + event.pageX + 10 - window.innerWidth)}px`;
            break;

        case 0 > event.pageX - 20:
            element.style.left = "10px";
            break;

        default:
            element.style.left  = `${event.pageX - 20}px`;
            break;

    }

    // 表示領域に収まるようy座標を調整
    switch (true) {

        case element.clientHeight + event.pageY + 20 > window.innerHeight:
            element.style.top = `${event.pageY - element.clientHeight - 20}px`;
            break;

        default:
            element.style.top = `${event.pageY + 20}px`;
            break;

    }

    element.setAttribute("class", "fadeIn");

    // 1.5秒で自動的に消えるようタイマーをセット
    element.dataset.timerId = setTimeout(() =>
    {
        if (!element.classList.contains("fadeOut")) {
            element.setAttribute("class", "fadeOut");
        }
    }, 1500);
};

/**
 * @description モーダルのフェードアウト関数
 *
 * @method
 * @static
 */
Util.$fadeOut = () =>
{
    const object = Util.$userSetting.getPublishSetting();
    if ("modal" in object && !object.modal) {
        return ;
    }

    const element = document.getElementById("detail-modal");
    clearTimeout(element.dataset.timerId | 0);
    element.setAttribute("class", "fadeOut");
};

/**
 * @param  {string} ignore
 * @return {void}
 * @static
 */
Util.$endMenu = (ignore) =>
{
    const names = [
        "timeline-menu",
        "library-menu",
        "tab-name-menu",
        "timeline-layer-menu",
        "scene-name-menu",
        "user-setting",
        "screen-menu",
        "editor-modal",
        "plugin-modal",
        "shortcut-setting-menu",
        "library-export-modal"
    ];

    for (let idx = 0; idx < names.length; ++idx) {

        const name = names[idx];
        if (name === ignore) {
            continue;
        }

        if (name === "editor-modal"
            && Util.$javaScriptEditor.active
        ) {
            Util.$javaScriptEditor.hide();
        }

        const menu = document.getElementById(name);
        if (!menu.classList.contains("fadeIn")) {
            continue;
        }
        menu.setAttribute("class", "fadeOut");
    }
};

/**
 * @return {void}
 * @static
 */
Util.$loadSaveData = () =>
{
    const binary = localStorage
        .getItem(`${Util.PREFIX}@${Util.DATABASE_NAME}`);

    if (binary) {

        localStorage
            .removeItem(`${Util.PREFIX}@${Util.DATABASE_NAME}`);

        const length = binary.length;
        const buffer = new Uint8Array(length);
        for (let idx = 0; idx < length; ++idx) {
            buffer[idx] = binary.charCodeAt(idx) & 0xff;
        }

        Util.$unZlibWorker.postMessage({
            "buffer": buffer,
            "type": "local"
        }, [buffer.buffer]);

    } else {

        const request = Util.$launchDB();
        request.onsuccess = (event) =>
        {
            const db = event.target.result;
            const transaction = db.transaction(
                `${Util.DATABASE_NAME}`, "readonly"
            );

            const store = transaction
                .objectStore(`${Util.DATABASE_NAME}`);

            const request = store.get(Util.STORE_KEY);
            request.onsuccess = (event) =>
            {
                const binary = event.target.result;
                if (binary) {

                    const length = binary.length;
                    const buffer = new Uint8Array(length);
                    for (let idx = 0; idx < length; ++idx) {
                        buffer[idx] = binary.charCodeAt(idx) & 0xff;
                    }

                    Util.$unZlibWorker.postMessage({
                        "buffer": buffer,
                        "type": "local"
                    }, [buffer.buffer]);

                } else {

                    Util.$workSpaces.push(new WorkSpace());

                    Util.$screenTab.run();

                    Util.$initializeEnd();

                }

                db.close();
            };
        };
    }
};

/**
 * @param   {Float32Array} a
 * @param   {Float32Array} b
 * @returns {Float32Array}
 * @static
 */
Util.$multiplicationMatrix = (a, b) =>
{
    return new Float32Array([
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        a[0] * b[4] + a[2] * b[5] + a[4],
        a[1] * b[4] + a[3] * b[5] + a[5]
    ]);
};

/**
 * @description 画面全体のショートカットを登録
 *
 * @param  {string} code
 * @param  {function} callback
 * @return {void}
 * @method
 * @static
 */
Util.$setShortcut = (code, callback) =>
{
    Util.$shortcut.set(code, callback);
};

/**
 * @description ショートカットを削除
 *
 * @param  {string} code
 * @return {void}
 * @method
 * @static
 */
Util.$deleteShortcut = (code) =>
{
    if (!Util.$shortcut.has(code)) {
        return ;
    }
    Util.$shortcut.delete(code);
};

/**
 * @param  {KeyboardEvent} event
 * @return {void}
 * @method
 * @static
 */
Util.$executeKeyCommand = (event) =>
{
    Util.$shiftKey = event.shiftKey;
    Util.$ctrlKey  = event.ctrlKey || event.metaKey; // command
    Util.$altKey   = event.altKey;

    if (Util.$ctrlKey) {

        switch (event.key) {

            case "-":
            case "+":
            case ";":
                event.stopPropagation();
                event.preventDefault();
                break;

            default:
                break;

        }

    }

    if (Util.$keyLock) {
        return ;
    }

    if (Util.$useShortcutSetting) {
        event.stopPropagation();
        event.preventDefault();
        return ;
    }

    const code = Util.$generateShortcutKey(event.key, {
        "alt": Util.$altKey,
        "shift": Util.$shiftKey,
        "ctrl": Util.$ctrlKey
    });

    if (!Util.$shortcut.has(code)) {
        return ;
    }

    event.stopPropagation();
    event.preventDefault();
    Util.$shortcut.get(code)(event);
};

/**
 * @return {void}
 * @static
 */
Util.$initialize = () =>
{
    // end event
    window.removeEventListener("DOMContentLoaded", Util.$initialize);

    Util.$filterClasses = {
        "BevelFilter": BevelFilter,
        "BlurFilter": BlurFilter,
        "DropShadowFilter": DropShadowFilter,
        "GlowFilter": GlowFilter,
        "GradientBevelFilter": GradientBevelFilter,
        "GradientGlowFilter": GradientGlowFilter
    };

    Util.$languages.set("Japanese", Japanese);
    Util.$languages.set("English", English);
    Util.$languages.set("Chinese", Chinese);
    Util.$languages.set("Korean", Korean);
    Util.$languages.set("French", French);
    Util.$languages.set("Russia", Russia);
    Util.$languages.set("Italiano", Italiano);
    Util.$languages.set("Spanish", Spanish);

    let language = localStorage
        .getItem(`${Util.PREFIX}@language-setting`);

    if (!language) {

        switch (navigator.language) {

            case "ja":
                language = "Japanese";
                break;

            case "ko":
                language = "Korean";
                break;

            case "zh":
                language = "Chinese";
                break;

            case "fr":
                language = "French";
                break;

            case "ru":
                language = "Russia";
                break;

            case "it":
                language = "Italiano";
                break;

            case "es":
                language = "Spanish";
                break;

            default:
                language = "English";
                break;

        }

    }

    const LanguageClass = Util.$languages.get(language);
    Util.$currentLanguage = new LanguageClass();

    // load local data
    Util.$loadSaveData();

    // added event
    window.addEventListener("keydown", Util.$executeKeyCommand);

    // key reset
    window.addEventListener("keyup", () =>
    {
        Util.$shiftKey = false;
        Util.$ctrlKey  = false;
        Util.$altKey   = false;
    });

    window.addEventListener("beforeunload", (event) =>
    {
        if (Util.$updated) {

            event.preventDefault();
            event.returnValue = "データ保存中...";

            Util.$autoSave();

        }
    });

    // フレームのデフォルト幅をセット
    document
        .documentElement
        .style
        .setProperty("--timeline-frame-width", "12px");

    document
        .documentElement
        .style
        .setProperty("--screen-height", `${window.innerHeight - 50}px`);

    const width  = Stage.STAGE_DEFAULT_WIDTH;
    const height = Stage.STAGE_DEFAULT_HEIGHT;
    const fps    = Stage.STAGE_DEFAULT_FPS;

    const previewDisplay = document.getElementById("preview-display");
    if (previewDisplay) {
        previewDisplay.style.width  = `${width}px`;
        previewDisplay.style.height = `${height}px`;
    }

    if ("next2d" in window) {
        Util.$root = window
            .next2d
            .createRootMovieClip(width, height, fps, {
                "tagId": "preview-display"
            });

        Util.$root.stage._$player.stop();
    }

    const previewStop = document.getElementById("preview-stop");
    if (previewStop) {
        previewStop.addEventListener("click", Util.$hidePreview);
    }

    document
        .documentElement
        .style
        .setProperty("--ad", "260px");

    // clear
    Util.$initialize = null;
};
window.addEventListener("DOMContentLoaded", Util.$initialize);

/**
 * @return {void}
 * @static
 */
Util.$showPreview = () =>
{
    // タイムライン側を停止
    Util
        .$timelinePlayer
        .executeTimelineStop();

    Util.$javaScriptEditor.save();

    Util.$previewMode = true;
    Util.$keyLock     = true;

    const element = document.getElementById("player-preview");
    element.style.display = "";
    element.style.zIndex  = "9999";

    const workSpace = Util.$currentWorkSpace();

    const preview = document.getElementById("preview-display");
    preview.style.width  = `${workSpace.stage.width}px`;
    preview.style.height = `${workSpace.stage.height}px`;

    const stopElement = document.getElementById("preview-stop");
    stopElement.style.top  = `${preview.offsetTop - 20}px`;
    stopElement.style.left = `${preview.offsetLeft + workSpace.stage.width}px`;
    stopElement.addEventListener("click", Util.$hidePreview);

    const stage = Util.$root.stage;
    stage.frameRate = document.getElementById("stage-fps").value | 0;

    const player  = stage._$player;
    player.width  = workSpace.stage.width;
    player.height = workSpace.stage.height;

    // fixed logic
    player._$resize();
    stage.clearGlobalVariable();
    stage._$events = new Map();
    player._$broadcastEvents = new Map();

    const json = Publish.toJSON();
    Util.$useIds.clear();

    const { Loader } = window.next2d.display;
    const { URLRequest } = window.next2d.net;
    const { Event } = window.next2d.events;

    const loader = new Loader();

    loader
        .contentLoaderInfo
        .addEventListener(Event.COMPLETE, (event) =>
        {
            const loaderInfo = event.currentTarget;

            const stage  = Util.$root.stage;
            const player = stage._$player;
            const data   = loaderInfo._$data;

            player.width  = data.stage.width;
            player.height = data.stage.height;
            player.stage.frameRate = data.stage.fps;

            const color = Util.$intToRGB(
                `0x${data.stage.bgColor.slice(1)}` | 0
            );

            player._$context._$setColor(
                color.R / 255,
                color.G / 255,
                color.B / 255,
                1
            );

            player._$backgroundColor = [
                color.R / 255,
                color.G / 255,
                color.B / 255,
                1
            ];

            Util.$root = null;
            Util.$root = loaderInfo.content;
            while (stage.numChildren) {
                stage.removeChildAt(0);
            }

            stage.addChild(Util.$root);

            player._$cacheStore.reset();

            const { BlendMode } = window.next2d.display;

            const context = player._$context;
            context._$globalAlpha              = 1;
            context._$globalCompositeOperation = BlendMode.NORMAL;
            context._$imageSmoothingEnabled    = false;

            context.frameBuffer.unbind();
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.clearRect(0, 0, context.canvas.width, context.canvas.height);
            context._$bind(player._$buffer);

            player.play();
        });

    loader.load(new URLRequest(
        URL.createObjectURL(new Blob([json], { "type": "application/json" }))
    ));

    // setup clear
    player._$broadcastEvents.clear();
    window.next2d.media.SoundMixer.volume = 1;

    player._$loadStatus = 1;
    player._$updateLoadStatus();
};

/**
 * @return {void}
 * @static
 */
Util.$hidePreview = () =>
{
    const stopElement = document.getElementById("preview-stop");
    stopElement.removeEventListener("click", Util.$hidePreview);

    const element = document.getElementById("player-preview");
    element.style.display = "none";
    element.style.zIndex  = "0";

    Util.$previewMode = false;
    if (!Util.$activeScript) {
        Util.$keyLock = false;
    }

    while (Util.$root.numChildren) {
        Util.$root.removeChild(Util.$root.getChildAt(0));
    }
    Util.$root.stage._$player.stop();
};

/**
 * @return {string}
 * @static
 */
Util.$toJSON = () =>
{
    // cache WorkSpaceId
    const activeWorkSpaceId = Util.$activeWorkSpaceId;

    const children = document
        .getElementById("view-tab-area")
        .children;

    const data = [];
    for (let idx = 0; idx < children.length; ++idx) {

        const node = children[idx];

        const workSpace = Util.$workSpaces[node.dataset.tabId | 0];
        if (!workSpace) {
            continue;
        }

        Util.$activeWorkSpaceId = node.dataset.tabId | 0;

        data.push(workSpace.toJSON());

    }

    // reset
    Util.$activeWorkSpaceId = activeWorkSpaceId;

    return JSON.stringify(data);
};

/**
 * @return {void}
 * @static
 */
Util.$autoSave = () =>
{
    Util.$javaScriptEditor.save();

    const postData = {
        "object": Util.$toJSON(),
        "type": "local"
    };

    if (Util.$zlibWorkerActive) {

        Util.$zlibQueues.push(postData);

    } else {

        Util.$zlibWorkerActive = true;
        Util.$zlibWorker.postMessage(postData);

    }

};

/**
 * @return {WorkSpace}
 * @static
 */
Util.$currentWorkSpace = () =>
{
    return Util.$workSpaces[Util.$activeWorkSpaceId];
};

/**
 * @return {void}
 * @static
 */
Util.$initializeEnd = () =>
{
    Util.$readStatus++;
    if (Util.$readStatus === Util.$readEnd) {

        // HTML内に設定されたdata-detailの値を、モーダル出力するのに登録
        Util.$addModalEvent(document);

        // WorkSpaceを起動
        Util.$currentWorkSpace().run();
    }
};

/**
 * @param {number} id
 * @static
 */
Util.$changeWorkSpace = (id) =>
{
    // reset
    Util.$useIds.clear();
    Util.$symbols.clear();

    Util.$currentWorkSpace().stop();

    Util.$activeWorkSpaceId = id | 0;

    Util.$currentWorkSpace().run();
};

// ZLIB Inflate Worker
Util.$unZlibWorker = new Worker(URL.createObjectURL(
    new Blob(["/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function(){\"use strict\";let t,i=this;function r(r,e){let s=r.split(\".\"),h=i;!(s[0]in h)&&h.execScript&&h.execScript(\"var \"+s[0]);for(var n;s.length&&(n=s.shift());)s.length||e===t?h=h[n]?h[n]:h[n]={}:h[n]=e}let e=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Uint32Array&&\"undefined\"!=typeof DataView;function s(t){let i,r,s,h,n,a,f,o,l,u,c=t.length,b=0,y=Number.POSITIVE_INFINITY;for(o=0;o<c;++o)t[o]>b&&(b=t[o]),t[o]<y&&(y=t[o]);for(i=1<<b,r=new(e?Uint32Array:Array)(i),s=1,h=0,n=2;s<=b;){for(o=0;o<c;++o)if(t[o]===s){for(a=0,f=h,l=0;l<s;++l)a=a<<1|1&f,f>>=1;for(u=s<<16|o,l=a;l<i;l+=n)r[l]=u;++h}++s,h<<=1,n<<=1}return[r,b,y]}function h(t,i){switch(this.g=[],this.h=32768,this.d=this.f=this.a=this.l=0,this.input=e?new Uint8Array(t):t,this.m=!1,this.i=a,this.r=!1,!i&&(i={})||(i.index&&(this.a=i.index),i.bufferSize&&(this.h=i.bufferSize),i.bufferType&&(this.i=i.bufferType),i.resize&&(this.r=i.resize)),this.i){case n:this.b=32768,this.c=new(e?Uint8Array:Array)(32768+this.h+258);break;case a:this.b=0,this.c=new(e?Uint8Array:Array)(this.h),this.e=this.z,this.n=this.v,this.j=this.w;break;default:throw Error(\"invalid inflate mode\")}}var n=0,a=1,f={t:n,s:a};h.prototype.k=function(){for(;!this.m;){let N=T(this,3);switch(1&N&&(this.m=!0),N>>>=1,N){case 0:var i=this.input,r=this.a,h=this.c,f=this.b,o=i.length,l=t,u=h.length,b=t;if(this.d=this.f=0,r+1>=o)throw Error(\"invalid uncompressed block header: LEN\");if(l=i[r++]|i[r++]<<8,r+1>=o)throw Error(\"invalid uncompressed block header: NLEN\");if(l===~(i[r++]|i[r++]<<8))throw Error(\"invalid uncompressed block header: length verify\");if(r+l>i.length)throw Error(\"input buffer is broken\");switch(this.i){case n:for(;f+l>h.length;){if(l-=b=u-f,e)h.set(i.subarray(r,r+b),f),f+=b,r+=b;else for(;b--;)h[f++]=i[r++];this.b=f,h=this.e(),f=this.b}break;case a:for(;f+l>h.length;)h=this.e({p:2});break;default:throw Error(\"invalid inflate mode\")}if(e)h.set(i.subarray(r,r+l),f),f+=l,r+=l;else for(;l--;)h[f++]=i[r++];this.a=r,this.b=f,this.c=h;break;case 1:this.j(E,I);break;case 2:var y,p,d,g,w=T(this,5)+257,A=T(this,5)+1,v=T(this,4)+4,k=new(e?Uint8Array:Array)(c.length),U=t,m=t,z=t,j=t,x=t;for(x=0;x<v;++x)k[c[x]]=T(this,3);if(!e)for(x=v,v=k.length;x<v;++x)k[c[x]]=0;for(y=s(k),U=new(e?Uint8Array:Array)(w+A),x=0,g=w+A;x<g;)switch(m=S(this,y)){case 16:for(j=3+T(this,2);j--;)U[x++]=z;break;case 17:for(j=3+T(this,3);j--;)U[x++]=0;z=0;break;case 18:for(j=11+T(this,7);j--;)U[x++]=0;z=0;break;default:z=U[x++]=m}p=s(e?U.subarray(0,w):U.slice(0,w)),d=s(e?U.subarray(w):U.slice(w)),this.j(p,d);break;default:throw Error(\"unknown BTYPE: \"+N)}}return this.n()};var o,l,u=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],c=e?new Uint16Array(u):u,b=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],y=e?new Uint16Array(b):b,p=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],d=e?new Uint8Array(p):p,g=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],w=e?new Uint16Array(g):g,A=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],v=e?new Uint8Array(A):A,k=new(e?Uint8Array:Array)(288);for(o=0,l=k.length;o<l;++o)k[o]=143>=o?8:255>=o?9:279>=o?7:8;var U,m,E=s(k),z=new(e?Uint8Array:Array)(30);for(U=0,m=z.length;U<m;++U)z[U]=5;var I=s(z);function T(t,i){for(var r,e=t.f,s=t.d,h=t.input,n=t.a,a=h.length;s<i;){if(n>=a)throw Error(\"input buffer is broken\");e|=h[n++]<<s,s+=8}return r=e&(1<<i)-1,t.f=e>>>i,t.d=s-i,t.a=n,r}function S(t,i){for(var r,e,s=t.f,h=t.d,n=t.input,a=t.a,f=n.length,o=i[0],l=i[1];h<l&&!(a>=f);)s|=n[a++]<<h,h+=8;if((e=(r=o[s&(1<<l)-1])>>>16)>h)throw Error(\"invalid code length: \"+e);return t.f=s>>e,t.d=h-e,t.a=a,65535&r}function j(t,i){let r,e;if(this.input=t,this.a=0,!i&&(i={})||(i.index&&(this.a=i.index),i.verify&&(this.A=i.verify)),r=t[this.a++],e=t[this.a++],(15&r)!==x)throw Error(\"unsupported compression method\");if(this.method=x,0!=((r<<8)+e)%31)throw Error(\"invalid fcheck flag:\"+((r<<8)+e)%31);if(32&e)throw Error(\"fdict flag is not supported\");this.q=new h(t,{index:this.a,bufferSize:i.bufferSize,bufferType:i.bufferType,resize:i.resize})}h.prototype.j=function(t,i){let r=this.c,e=this.b;this.o=t;for(var s,h,n,a,f=r.length-258;256!==(s=S(this,t));)if(256>s)e>=f&&(this.b=e,r=this.e(),e=this.b),r[e++]=s;else for(a=y[h=s-257],0<d[h]&&(a+=T(this,d[h])),s=S(this,i),n=w[s],0<v[s]&&(n+=T(this,v[s])),e>=f&&(this.b=e,r=this.e(),e=this.b);a--;)r[e]=r[e++-n];for(;8<=this.d;)this.d-=8,this.a--;this.b=e},h.prototype.w=function(t,i){let r=this.c,e=this.b;this.o=t;for(var s,h,n,a,f=r.length;256!==(s=S(this,t));)if(256>s)e>=f&&(r=this.e(),f=r.length),r[e++]=s;else for(a=y[h=s-257],0<d[h]&&(a+=T(this,d[h])),s=S(this,i),n=w[s],0<v[s]&&(n+=T(this,v[s])),e+a>f&&(r=this.e(),f=r.length);a--;)r[e]=r[e++-n];for(;8<=this.d;)this.d-=8,this.a--;this.b=e},h.prototype.e=function(){let t,i,r=new(e?Uint8Array:Array)(this.b-32768),s=this.b-32768,h=this.c;if(e)r.set(h.subarray(32768,r.length));else for(t=0,i=r.length;t<i;++t)r[t]=h[t+32768];if(this.g.push(r),this.l+=r.length,e)h.set(h.subarray(s,s+32768));else for(t=0;32768>t;++t)h[t]=h[s+t];return this.b=32768,h},h.prototype.z=function(t){let i,r,s,h,n=this.input.length/this.a+1|0,a=this.input,f=this.c;return t&&(\"number\"==typeof t.p&&(n=t.p),\"number\"==typeof t.u&&(n+=t.u)),2>n?(r=(a.length-this.a)/this.o[2],h=r/2*258|0,s=h<f.length?f.length+h:f.length<<1):s=f.length*n,e?(i=new Uint8Array(s),i.set(f)):i=f,this.c=i},h.prototype.n=function(){let t,i,r,s,h,n=0,a=this.c,f=this.g,o=new(e?Uint8Array:Array)(this.l+(this.b-32768));if(0===f.length)return e?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);for(i=0,r=f.length;i<r;++i)for(t=f[i],s=0,h=t.length;s<h;++s)o[n++]=t[s];for(i=32768,r=this.b;i<r;++i)o[n++]=a[i];return this.g=[],this.buffer=o},h.prototype.v=function(){let t,i=this.b;return e?this.r?(t=new Uint8Array(i),t.set(this.c.subarray(0,i))):t=this.c.subarray(0,i):(this.c.length>i&&(this.c.length=i),t=this.c),this.buffer=t},j.prototype.k=function(){let t,i,r=this.input;if(t=this.q.k(),this.a=this.q.a,this.A){i=(r[this.a++]<<24|r[this.a++]<<16|r[this.a++]<<8|r[this.a++])>>>0;let f=t;if(\"string\"==typeof f){let t,i,r=f.split(\"\");for(t=0,i=r.length;t<i;t++)r[t]=(255&r[t].charCodeAt(0))>>>0;f=r}for(var e,s=1,h=0,n=f.length,a=0;0<n;){n-=e=1024<n?1024:n;do{h+=s+=f[a++]}while(--e);s%=65521,h%=65521}if(i!==(h<<16|s)>>>0)throw Error(\"invalid adler-32 checksum\")}return t};var x=8;r(\"Zlib.Inflate\",j),r(\"Zlib.Inflate.prototype.decompress\",j.prototype.k);let N,C,L,O,Z={ADAPTIVE:f.s,BLOCK:f.t};if(Object.keys)N=Object.keys(Z);else for(C in N=[],L=0,Z)N[L++]=C;for(L=0,O=N.length;L<O;++L)C=N[L],r(\"Zlib.Inflate.BufferType.\"+C,Z[C])}).call(this),this.addEventListener(\"message\",(function(t){const i=new Zlib.Inflate(t.data.buffer).decompress();let r=\"\";for(let t=0;t<i.length;t+=4096)r+=String.fromCharCode.apply(null,i.slice(t,t+4096));this.postMessage({json:r,type:t.data.type})}));"], { "type": "text/javascript" })
));

/**
 * @param {MessageEvent} event
 * @public
 */
Util.$unZlibWorker.onmessage = (event) =>
{
    if (event.data.type === "n2d") {

        const workSpaces = new WorkSpace(decodeURIComponent(event.data.json));

        Util
            .$workSpaces
            .push(workSpaces);

        Util.$screenTab.createElement(workSpaces, Util.$workSpaces.length - 1);

    } else {

        const values = JSON.parse(decodeURIComponent(event.data.json));

        for (let idx = 0; idx < values.length; ++idx) {
            Util.$workSpaces.push(new WorkSpace(values[idx]));
        }

        if (!Util.$workSpaces.length) {
            Util.$workSpaces.push(new WorkSpace());
        }

        // タブセット
        Util.$screenTab.run();

        // end
        Util.$initializeEnd();

    }
};

// ZLIB Deflate Worker
Util.$zlibWorker = new Worker(URL.createObjectURL(
    new Blob(["/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function(){\"use strict\";let e,r=!0,t=this;function n(r,n){let a=r.split(\".\"),i=t;!(a[0]in i)&&i.execScript&&i.execScript(\"var \"+a[0]);for(var s;a.length&&(s=a.shift());)a.length||n===e?i=i[s]?i[s]:i[s]={}:i[s]=n}let a=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Uint32Array&&\"undefined\"!=typeof DataView;function i(e,r){if(this.index=\"number\"==typeof r?r:0,this.e=0,this.buffer=e instanceof(a?Uint8Array:Array)?e:new(a?Uint8Array:Array)(32768),2*this.buffer.length<=this.index)throw Error(\"invalid index\");this.buffer.length<=this.index&&s(this)}function s(e){let r,t=e.buffer,n=t.length,i=new(a?Uint8Array:Array)(n<<1);if(a)i.set(t);else for(r=0;r<n;++r)i[r]=t[r];return e.buffer=i}i.prototype.b=function(e,r,t){let n,a=this.buffer,i=this.index,f=this.e,h=a[i];if(t&&1<r&&(e=8<r?(l[255&e]<<24|l[e>>>8&255]<<16|l[e>>>16&255]<<8|l[e>>>24&255])>>32-r:l[e]>>8-r),8>r+f)h=h<<r|e,f+=r;else for(n=0;n<r;++n)h=h<<1|e>>r-n-1&1,8==++f&&(f=0,a[i++]=l[h],h=0,i===a.length&&(a=s(this)));a[i]=h,this.buffer=a,this.e=f,this.index=i},i.prototype.finish=function(){let e,r=this.buffer,t=this.index;return 0<this.e&&(r[t]<<=8-this.e,r[t]=l[r[t]],t++),a?e=r.subarray(0,t):(r.length=t,e=r),e};let f,h=new(a?Uint8Array:Array)(256);for(f=0;256>f;++f){for(var o=c=f,u=7,c=c>>>1;c;c>>>=1)o<<=1,o|=1&c,--u;h[f]=(o<<u&255)>>>0}var l=h;function b(e){this.buffer=new(a?Uint16Array:Array)(2*e),this.length=0}function y(e,r){this.d=g,this.i=0,this.input=a&&e instanceof Array?new Uint8Array(e):e,this.c=0,r&&(r.lazy&&(this.i=r.lazy),\"number\"==typeof r.compressionType&&(this.d=r.compressionType),r.outputBuffer&&(this.a=a&&r.outputBuffer instanceof Array?new Uint8Array(r.outputBuffer):r.outputBuffer),\"number\"==typeof r.outputIndex&&(this.c=r.outputIndex)),this.a||(this.a=new(a?Uint8Array:Array)(32768))}b.prototype.getParent=function(e){return 2*((e-2)/4|0)},b.prototype.push=function(e,r){let t,n,a,i=this.buffer;for(t=this.length,i[this.length++]=r,i[this.length++]=e;0<t&&(n=this.getParent(t),i[t]>i[n]);)a=i[t],i[t]=i[n],i[n]=a,a=i[t+1],i[t+1]=i[n+1],i[n+1]=a,t=n;return this.length},b.prototype.pop=function(){let e,r,t,n,a,i=this.buffer;for(r=i[0],e=i[1],this.length-=2,i[0]=i[this.length],i[1]=i[this.length+1],a=0;(n=2*a+2,!(n>=this.length))&&(n+2<this.length&&i[n+2]>i[n]&&(n+=2),i[n]>i[a]);)t=i[a],i[a]=i[n],i[n]=t,t=i[a+1],i[a+1]=i[n+1],i[n+1]=t,a=n;return{index:e,value:r,length:this.length}};var p,g=2,A={NONE:0,h:1,g:g,n:3},k=[];for(p=0;288>p;p++)switch(r){case 143>=p:k.push([p+48,8]);break;case 255>=p:k.push([p-144+400,9]);break;case 279>=p:k.push([p-256+0,7]);break;case 287>=p:k.push([p-280+192,8]);break;default:throw\"invalid literal: \"+p}function w(e,r){this.length=e,this.k=r}y.prototype.f=function(){let t,n,s,f,h=this.input;switch(this.d){case 0:for(s=0,f=h.length;s<f;){n=a?h.subarray(s,s+65535):h.slice(s,s+65535),s+=n.length;let r=n,t=s===f,i=e,o=e,u=e,c=e,l=e,b=this.a,y=this.c;if(a){for(b=new Uint8Array(this.a.buffer);b.length<=y+r.length+5;)b=new Uint8Array(b.length<<1);b.set(this.a)}if(i=t?1:0,b[y++]=0|i,o=r.length,u=65536+~o&65535,b[y++]=255&o,b[y++]=o>>>8&255,b[y++]=255&u,b[y++]=u>>>8&255,a)b.set(r,y),y+=r.length,b=b.subarray(0,y);else{for(c=0,l=r.length;c<l;++c)b[y++]=r[c];b.length=y}this.c=y,this.a=b}break;case 1:var o=new i(a?new Uint8Array(this.a.buffer):this.a,this.c);o.b(1,1,r),o.b(1,2,r);var u,c,l,b=v(this,h);for(u=0,c=b.length;u<c;u++)if(l=b[u],i.prototype.b.apply(o,k[l]),256<l)o.b(b[++u],b[++u],r),o.b(b[++u],5),o.b(b[++u],b[++u],r);else if(256===l)break;this.a=o.finish(),this.c=this.a.length;break;case g:var y,p,A,w,d,U,m,D,E,j,O,Z,B,C,I,M=new i(a?new Uint8Array(this.a.buffer):this.a,this.c),T=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=Array(19);for(y=g,M.b(1,1,r),M.b(y,2,r),p=v(this,h),m=N(U=x(this.m,15)),E=N(D=x(this.l,7)),A=286;257<A&&0===U[A-1];A--);for(w=30;1<w&&0===D[w-1];w--);var S,L,P,F,G,J,R=A,V=w,X=new(a?Uint32Array:Array)(R+V),Y=new(a?Uint32Array:Array)(316),q=new(a?Uint8Array:Array)(19);for(S=L=0;S<R;S++)X[L++]=U[S];for(S=0;S<V;S++)X[L++]=D[S];if(!a)for(S=0,F=q.length;S<F;++S)q[S]=0;for(S=G=0,F=X.length;S<F;S+=L){for(L=1;S+L<F&&X[S+L]===X[S];++L);if(P=L,0===X[S])if(3>P)for(;0<P--;)Y[G++]=0,q[0]++;else for(;0<P;)(J=138>P?P:138)>P-3&&J<P&&(J=P-3),10>=J?(Y[G++]=17,Y[G++]=J-3,q[17]++):(Y[G++]=18,Y[G++]=J-11,q[18]++),P-=J;else if(Y[G++]=X[S],q[X[S]]++,3>--P)for(;0<P--;)Y[G++]=X[S],q[X[S]]++;else for(;0<P;)(J=6>P?P:6)>P-3&&J<P&&(J=P-3),Y[G++]=16,Y[G++]=J-3,q[16]++,P-=J}for(t=a?Y.subarray(0,G):Y.slice(0,G),j=x(q,7),C=0;19>C;C++)z[C]=j[T[C]];for(d=19;4<d&&0===z[d-1];d--);for(O=N(j),M.b(A-257,5,r),M.b(w-1,5,r),M.b(d-4,4,r),C=0;C<d;C++)M.b(z[C],3,r);for(C=0,I=t.length;C<I;C++)if(Z=t[C],M.b(O[Z],j[Z],r),16<=Z){switch(C++,Z){case 16:B=2;break;case 17:B=3;break;case 18:B=7;break;default:throw\"invalid code: \"+Z}M.b(t[C],B,r)}var H,K,Q,W,$,_,ee,re,te=[m,U],ne=[E,D];for($=te[0],_=te[1],ee=ne[0],re=ne[1],H=0,K=p.length;H<K;++H)if(Q=p[H],M.b($[Q],_[Q],r),256<Q)M.b(p[++H],p[++H],r),W=p[++H],M.b(ee[W],re[W],r),M.b(p[++H],p[++H],r);else if(256===Q)break;this.a=M.finish(),this.c=this.a.length;break;default:throw\"invalid compression type\"}return this.a};let d=function(){function e(e){switch(r){case 3===e:return[257,e-3,0];case 4===e:return[258,e-4,0];case 5===e:return[259,e-5,0];case 6===e:return[260,e-6,0];case 7===e:return[261,e-7,0];case 8===e:return[262,e-8,0];case 9===e:return[263,e-9,0];case 10===e:return[264,e-10,0];case 12>=e:return[265,e-11,1];case 14>=e:return[266,e-13,1];case 16>=e:return[267,e-15,1];case 18>=e:return[268,e-17,1];case 22>=e:return[269,e-19,2];case 26>=e:return[270,e-23,2];case 30>=e:return[271,e-27,2];case 34>=e:return[272,e-31,2];case 42>=e:return[273,e-35,3];case 50>=e:return[274,e-43,3];case 58>=e:return[275,e-51,3];case 66>=e:return[276,e-59,3];case 82>=e:return[277,e-67,4];case 98>=e:return[278,e-83,4];case 114>=e:return[279,e-99,4];case 130>=e:return[280,e-115,4];case 162>=e:return[281,e-131,5];case 194>=e:return[282,e-163,5];case 226>=e:return[283,e-195,5];case 257>=e:return[284,e-227,5];case 258===e:return[285,e-258,0];default:throw\"invalid length: \"+e}}let t,n,a=[];for(t=3;258>=t;t++)n=e(t),a[t]=n[2]<<24|n[1]<<16|n[0];return a}(),U=a?new Uint32Array(d):d;function v(t,n){function i(e,t){let n,a,i,s,f=e.k,h=[],o=0;switch(n=U[e.length],h[o++]=65535&n,h[o++]=n>>16&255,h[o++]=n>>24,r){case 1===f:a=[0,f-1,0];break;case 2===f:a=[1,f-2,0];break;case 3===f:a=[2,f-3,0];break;case 4===f:a=[3,f-4,0];break;case 6>=f:a=[4,f-5,1];break;case 8>=f:a=[5,f-7,1];break;case 12>=f:a=[6,f-9,2];break;case 16>=f:a=[7,f-13,2];break;case 24>=f:a=[8,f-17,3];break;case 32>=f:a=[9,f-25,3];break;case 48>=f:a=[10,f-33,4];break;case 64>=f:a=[11,f-49,4];break;case 96>=f:a=[12,f-65,5];break;case 128>=f:a=[13,f-97,5];break;case 192>=f:a=[14,f-129,6];break;case 256>=f:a=[15,f-193,6];break;case 384>=f:a=[16,f-257,7];break;case 512>=f:a=[17,f-385,7];break;case 768>=f:a=[18,f-513,8];break;case 1024>=f:a=[19,f-769,8];break;case 1536>=f:a=[20,f-1025,9];break;case 2048>=f:a=[21,f-1537,9];break;case 3072>=f:a=[22,f-2049,10];break;case 4096>=f:a=[23,f-3073,10];break;case 6144>=f:a=[24,f-4097,11];break;case 8192>=f:a=[25,f-6145,11];break;case 12288>=f:a=[26,f-8193,12];break;case 16384>=f:a=[27,f-12289,12];break;case 24576>=f:a=[28,f-16385,13];break;case 32768>=f:a=[29,f-24577,13];break;default:throw\"invalid distance\"}for(n=a,h[o++]=n[0],h[o++]=n[1],h[o++]=n[2],i=0,s=h.length;i<s;++i)g[A++]=h[i];w[h[0]]++,d[h[3]]++,k=e.length+t-1,b=null}var s,f,h,o,u,c,l,b,y,p={},g=a?new Uint16Array(2*n.length):[],A=0,k=0,w=new(a?Uint32Array:Array)(286),d=new(a?Uint32Array:Array)(30),v=t.i;if(!a){for(h=0;285>=h;)w[h++]=0;for(h=0;29>=h;)d[h++]=0}for(w[256]=1,s=0,f=n.length;s<f;++s){for(h=u=0,o=3;h<o&&s+h!==f;++h)u=u<<8|n[s+h];if(p[u]===e&&(p[u]=[]),c=p[u],!(0<k--)){for(;0<c.length&&32768<s-c[0];)c.shift();if(s+3>=f){for(b&&i(b,-1),h=0,o=f-s;h<o;++h)y=n[s+h],g[A++]=y,++w[y];break}0<c.length?(l=m(n,s,c),b?b.length<l.length?(y=n[s-1],g[A++]=y,++w[y],i(l,0)):i(b,-1):l.length<v?b=l:i(l,0)):b?i(b,-1):(y=n[s],g[A++]=y,++w[y])}c.push(s)}return g[A++]=256,w[256]++,t.m=w,t.l=d,a?g.subarray(0,A):g}function m(e,r,t){let n,a,i,s,f,h,o=0,u=e.length;s=0,h=t.length;e:for(;s<h;s++){if(n=t[h-s-1],i=3,3<o){for(f=o;3<f;f--)if(e[n+f-1]!==e[r+f-1])continue e;i=o}for(;258>i&&r+i<u&&e[n+i]===e[r+i];)++i;if(i>o&&(a=n,o=i),258===i)break}return new w(o,r-a)}function x(e,r){let t,n,i,s,f,h=e.length,o=new b(572),u=new(a?Uint8Array:Array)(h);if(!a)for(s=0;s<h;s++)u[s]=0;for(s=0;s<h;++s)0<e[s]&&o.push(s,e[s]);if(t=Array(o.length/2),n=new(a?Uint32Array:Array)(o.length/2),1===t.length)return u[o.pop().index]=1,u;for(s=0,f=o.length/2;s<f;++s)t[s]=o.pop(),n[s]=t[s].value;for(i=function(e,r,t){function n(e){let t=y[e][p[e]];t===r?(n(e+1),n(e+1)):--l[t],++p[e]}var i,s,f,h,o,u=new(a?Uint16Array:Array)(t),c=new(a?Uint8Array:Array)(t),l=new(a?Uint8Array:Array)(r),b=Array(t),y=Array(t),p=Array(t),g=(1<<t)-r,A=1<<t-1;for(u[t-1]=r,s=0;s<t;++s)g<A?c[s]=0:(c[s]=1,g-=A),g<<=1,u[t-2-s]=(u[t-1-s]/2|0)+r;for(u[0]=c[0],b[0]=Array(u[0]),y[0]=Array(u[0]),s=1;s<t;++s)u[s]>2*u[s-1]+c[s]&&(u[s]=2*u[s-1]+c[s]),b[s]=Array(u[s]),y[s]=Array(u[s]);for(i=0;i<r;++i)l[i]=t;for(f=0;f<u[t-1];++f)b[t-1][f]=e[f],y[t-1][f]=f;for(i=0;i<t;++i)p[i]=0;for(1===c[t-1]&&(--l[0],++p[t-1]),s=t-2;0<=s;--s){for(h=i=0,o=p[s+1],f=0;f<u[s];f++)(h=b[s+1][o]+b[s+1][o+1])>e[i]?(b[s][f]=h,y[s][f]=r,o+=2):(b[s][f]=e[i],y[s][f]=i,++i);p[s]=0,1===c[s]&&n(s)}return l}(n,n.length,r),s=0,f=t.length;s<f;++s)u[t[s].index]=i[s];return u}function N(e){let r,t,n,i,s=new(a?Uint16Array:Array)(e.length),f=[],h=[],o=0;for(r=0,t=e.length;r<t;r++)f[e[r]]=1+(0|f[e[r]]);for(r=1,t=16;r<=t;r++)h[r]=o,o+=0|f[r],o<<=1;for(r=0,t=e.length;r<t;r++)for(o=h[e[r]],h[e[r]]+=1,n=s[r]=0,i=e[r];n<i;n++)s[r]=s[r]<<1|1&o,o>>>=1;return s}function D(e,r){this.input=e,this.a=new(a?Uint8Array:Array)(32768),this.d=E.g;let t,n={};for(t in!r&&(r={})||\"number\"!=typeof r.compressionType||(this.d=r.compressionType),r)n[t]=r[t];n.outputBuffer=this.a,this.j=new y(this.input,n)}var E=A;D.prototype.f=function(){let e,r,t,n,i,s,f=0;switch(s=this.a,e=Math.LOG2E*Math.log(32768)-8,r=e<<4|8,s[f++]=r,this.d){case E.NONE:n=0;break;case E.h:n=1;break;case E.g:n=2;break;default:throw Error(\"unsupported compression type\")}t=n<<6|0,s[f++]=t|31-(256*r+t)%31;let h=this.input;if(\"string\"==typeof h){let e,r,t=h.split(\"\");for(e=0,r=t.length;e<r;e++)t[e]=(255&t[e].charCodeAt(0))>>>0;h=t}for(var o,u=1,c=0,l=h.length,b=0;0<l;){l-=o=1024<l?1024:l;do{c+=u+=h[b++]}while(--o);u%=65521,c%=65521}return i=(c<<16|u)>>>0,this.j.c=f,s=this.j.f(),f=s.length,a&&(s=new Uint8Array(s.buffer),s.length<=f+4&&(this.a=new Uint8Array(s.length+4),this.a.set(s),s=this.a),s=s.subarray(0,f+4)),s[f++]=i>>24&255,s[f++]=i>>16&255,s[f++]=i>>8&255,s[f++]=255&i,s},n(\"Zlib.Deflate\",D),n(\"Zlib.Deflate.compress\",(function(e,r){return new D(e,r).f()})),n(\"Zlib.Deflate.prototype.compress\",D.prototype.f);let j,O,Z,B,C={NONE:E.NONE,FIXED:E.h,DYNAMIC:E.g};if(Object.keys)j=Object.keys(C);else for(O in j=[],Z=0,C)j[Z++]=O;for(Z=0,B=j.length;Z<B;++Z)O=j[Z],n(\"Zlib.Deflate.CompressionType.\"+O,C[O])}).call(this),this.addEventListener(\"message\",(function(e){const r=Uint8Array.from(encodeURIComponent(e.data.object).split(\"\"),(e=>e.charCodeAt(0))),t=e.data.type;if(\"json\"===t)this.postMessage({json:JSON.stringify({buffer:Array.from(new Zlib.Deflate(r).compress()),type:\"zlib\"}),type:t});else{const e=new Zlib.Deflate(r).compress();this.postMessage({buffer:e,type:t},[e.buffer])}}));"], { "type": "text/javascript" })
));

/**
 * @param {MessageEvent} event
 * @public
 */
Util.$zlibWorker.onmessage = (event) =>
{
    const type = event.data.type;
    switch (type) {

        case "json":
        case "n2d":
            {
                const anchor = document.getElementById("save-anchor");
                if (anchor.href) {
                    URL.revokeObjectURL(anchor.href);
                }

                anchor.download = `${Util.$currentWorkSpace().name}.${type}`;

                anchor.href = type === "json"
                    ? URL.createObjectURL(new Blob([event.data.json],   { "type" : "application/json" }))
                    : URL.createObjectURL(new Blob([event.data.buffer], { "type" : "text/plain" }));

                anchor.click();
            }
            break;

        case "local":
            {
                const buffer = event.data.buffer;

                let binary = "";
                for (let idx = 0; idx < buffer.length; idx += 4096) {
                    binary += String.fromCharCode.apply(null, buffer.slice(idx, idx + 4096));
                }

                const request = Util.$launchDB();

                request.onsuccess = (event) =>
                {
                    const db = event.target.result;
                    const transaction = db.transaction(
                        `${Util.DATABASE_NAME}`, "readwrite"
                    );

                    const store = transaction
                        .objectStore(`${Util.DATABASE_NAME}`);

                    store.put(binary, Util.STORE_KEY);

                    transaction.oncomplete = (event) =>
                    {
                        event.target.db.close();
                        Util.$updated = false;
                    };

                    transaction.commit();
                };
            }

            break;

    }

    if (Util.$zlibQueues.length) {

        Util.$zlibWorker.postMessage(Util.$zlibQueues.pop());

    } else {

        Util.$zlibWorkerActive = false;

    }
};

Util.$zlibQueues       = [];
Util.$zlibWorkerActive = false;

// Unzip Worker
Util.$unzipURL = URL.createObjectURL(
    new Blob(["const Util={};Util.$Uint8Array=Uint8Array,Util.$Uint16Array=Uint16Array,Util.$Int16Array=Int16Array,Util.$ArrayBuffer=ArrayBuffer,Util.$max=Math.max,Util.$min=Math.min,Util.$potArrayBuffers=new Map,Util.$codeTables=[],Util.$getCodeTable=function(t,e){const i=Util.$codeTables.pop()||{key:null,value:null};return i.key=t,i.value=e,i},Util.$poolCodeTable=function(t){Util.$codeTables.push(t)},Util.$poolTypedArrayBuffer=function(t){const e=t.buffer,i=e.byteLength;if(!i||i!==Util.$upperPowerOfTwo(i))return;let r=Util.$potArrayBuffers.get(i);r||(r=[],Util.$potArrayBuffers.set(i,r)),r.push(e)},Util.$upperPowerOfTwo=function(t){return t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t},Util.$getUint8Array=function(t){let e;const i=Util.$upperPowerOfTwo(t),r=Util.$potArrayBuffers.get(i),l=r&&r.pop();return l?(e=new Util.$Uint8Array(l,0,t),e.fill(0)):e=new Util.$Uint8Array(new Util.$ArrayBuffer(i),0,t),e},Util.$getUint16Array=function(t){let e;const i=Util.$upperPowerOfTwo(2*t),r=Util.$potArrayBuffers.get(i),l=r&&r.pop();return l?(e=new Util.$Uint16Array(l,0,t),e.fill(0)):e=new Util.$Uint16Array(new Util.$ArrayBuffer(i),0,t),e},Util.$fixedDistTable={key:new Util.$Uint16Array([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]),value:new Util.$Uint16Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31])},Util.$fixedLitTable={key:new Util.$Uint16Array([7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9]),value:new Util.$Uint16Array([256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,280,281,282,283,284,285,286,287,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255])},Util.$ORDER=new Util.$Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Util.$LEXT=new Util.$Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,99,99]),Util.$LENS=new Util.$Int16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Util.$DEXT=new Util.$Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),Util.$DISTS=new Util.$Int16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577]);class ByteStream{constructor(){this.initialization()}initialization(){this.data=null,this.bit_offset=0,this.byte_offset=0,this.bit_buffer=null}byteAlign(){this.bit_offset&&(this.byte_offset=this.byte_offset+(this.bit_offset+7)/8|0,this.bit_offset=0)}getData(t){this.byteAlign();const e=this.byte_offset+t,i=this.data.slice(this.byte_offset,e);return this.byte_offset=e,i}setOffset(t,e){this.byte_offset=t,this.bit_offset=e}unzip(t,e=0){let i=e;const r=Util.$getUint8Array(19);let l=null,a=null;for(;;){const e=this.readUB(1),s=this.readUB(2);if(l&&(Util.$poolCodeTable(l),Util.$poolCodeTable(a)),l=null,a=null,s){if(1===s)l=Util.$fixedDistTable,a=Util.$fixedLitTable;else{const t=this.readUB(5)+257,e=this.readUB(5)+1,i=this.readUB(4)+4;for(let t=0;t<i;++t)r[Util.$ORDER[t]]=this.readUB(3);const s=this.buildHuffTable(r);r.fill(0);const f=t+e|0,o=Util.$getUint8Array(f);let n=0;for(let t=0;t<f;){const e=this.decodeSymbol(s.key,s.value);switch(e){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:o[t++]=e,n=e;break;case 16:{let e=this.readUB(2)+3|0;for(;e;)--e,o[t++]=n}break;case 17:{let e=this.readUB(3)+3|0;for(;e;)--e,o[t++]=0}break;case 18:{let e=this.readUB(7)+11|0;for(;e;)--e,o[t++]=0}}}Util.$poolCodeTable(s),l=this.buildHuffTable(o.subarray(t)),a=this.buildHuffTable(o.subarray(0,t)),Util.$poolTypedArrayBuffer(o),Util.$poolTypedArrayBuffer(s.key),Util.$poolTypedArrayBuffer(s.value)}for(;;){const e=0|this.decodeSymbol(a.key,a.value);if(256===e)break;if(e<256)t[i++]=e;else{const r=e-257|0;let a=Util.$LENS[r]+this.readUB(Util.$LEXT[r])|0;const s=this.decodeSymbol(l.key,l.value);let f=i-(Util.$DISTS[s]+this.readUB(Util.$DEXT[s])|0)|0;for(;a;)--a,t[i++]=t[f++]}}}else{this.bit_offset=8,this.bit_buffer=null;const e=0|this.readNumber(2);this.byte_offset+=2;for(let r=0;r<e;++r)t[i++]=this.readNumber(1)}if(e)break}Util.$poolTypedArrayBuffer(r)}buildHuffTable(t){const e=t.length,i=Util.$max.apply(null,t),r=Util.$getUint8Array(i),l=Util.$getUint16Array(i+1);let a=0,s=0,f=e;for(;f;)s=t[--f],s&&++r[s];let o=0;for(let t=0;t<i;)a=a+r[t++]<<1,l[t]=a,o=Util.$max(o,a);const n=o+e,U=Util.$getUint16Array(n),u=Util.$getUint16Array(n);for(let i=0;i<e;++i)if(s=t[i],s){const t=l[s];U[t]=s,u[t]=i,l[s]=t+1|0}return Util.$poolTypedArrayBuffer(r),Util.$poolTypedArrayBuffer(l),Util.$getCodeTable(U,u)}decodeSymbol(t,e){let i=0,r=0;for(;;)if(i=i<<1|this.readUB(1),++r,t[i]===r)return e[i]}readUB(t){let e=0;for(let i=0;i<t;++i)8===this.bit_offset&&(this.bit_buffer=this.readNumber(1),this.bit_offset=0),e|=(this.bit_buffer&1<<this.bit_offset++?1:0)<<i;return e}readNumber(t){let e=0;const i=this.byte_offset;let r=i+t|0;for(;r>i;)e=e<<8|this.data[--r];return this.byte_offset+=t,e}}Util.$byteStream=new ByteStream,Util.$lossless=function(t,e,i,r,l,a){const s=new Util.$Uint8Array(e*i*4);if(3===r){const r=(e+3&-4)-e;let f=0;if(a){let a=4*l;for(let l=0;l<i;++l){for(let i=0;i<e;++i){const e=4*t[a++],i=t[e+3];if(0===i){s[f++]=0,s[f++]=0,s[f++]=0,s[f++]=0;continue}const r=t[e],l=t[e+1],o=t[e+2];255!==i?(s[f++]=255&Util.$min(r/i*255,255),s[f++]=255&Util.$min(l/i*255,255),s[f++]=255&Util.$min(o/i*255,255),s[f++]=i):(s[f++]=r,s[f++]=l,s[f++]=o,s[f++]=i)}a+=r}return s}let o=3*l;for(let l=0;l<i;++l){for(let i=0;i<e;++i){const e=3*t[o++];s[f++]=t[e],s[f++]=t[e+1],s[f++]=t[e+2],s[f++]=255}o+=r}return s}const f=e*i;if(a){for(let e=0;e<f;++e){const i=4*e,r=i,l=i+1,a=i+2,f=i+3,o=t[r];0!==o?255!==o?(s[r]=255&Util.$min(t[l]/o*255,255),s[l]=255&Util.$min(t[a]/o*255,255),s[a]=255&Util.$min(t[f]/o*255,255),s[f]=o):(s[r]=t[l],s[l]=t[a],s[a]=t[f],s[f]=o):(s[r]=0,s[l]=0,s[a]=0,s[f]=0)}return s}for(let e=0;e<f;++e){const i=4*e,r=i+1,l=i+2,a=i+3;s[i]=t[r],s[r]=t[l],s[l]=t[a],s[a]=255}return s},this.addEventListener(\"message\",(function(t){const e=Util.$byteStream;switch(t.data.mode){case\"swf\":{e.data=t.data.buffer;const i=t.data.fileSize,r=new Util.$Uint8Array(i),l=e.getData(8);e.setOffset(10,8),r.set(l,0),e.unzip(r,8),this.postMessage({buffer:r,mode:t.data.mode},[r.buffer])}break;case\"lossless\":{const i=t.data,r=new Util.$Uint8Array(i.fileSize);e.data=t.data.buffer,e.setOffset(2,8),e.unzip(r,0);const l=Util.$lossless(r,i.width,i.height,i.format,i.tableSize,i.isAlpha);this.postMessage({buffer:l,mode:t.data.mode},[l.buffer])}break;case\"jpegAlpha\":{const i=t.data.width*t.data.height,r=new Util.$Uint8Array(i);e.data=t.data.alphaData,e.setOffset(2,8),e.unzip(r,0),t.data.alphaData=r,this.postMessage(t.data,[t.data.buffer.buffer,t.data.alphaData.buffer])}}Util.$byteStream.initialization()}));"], { "type": "text/javascript" }
    ));
Util.$unzipWorker       = null;
Util.$unzipQueues       = [];
Util.$unzipWorkerActive = false;

/**
 * @return {IDBOpenDBRequest}
 * @static
 */
Util.$launchDB = () =>
{
    const request = indexedDB.open(
        `${Util.PREFIX}@${Util.DATABASE_NAME}`
    );

    request.onupgradeneeded = (event) =>
    {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(`${Util.DATABASE_NAME}`)) {
            db.createObjectStore(`${Util.DATABASE_NAME}`);
        }
    };

    return request;
};

/**
 * @param  {object} event
 * @return void
 * @static
 */
Util.$unzipHandler = function (event)
{
    const worker = event.target;

    // event end
    worker.onmessage = null;

    // setup
    switch (event.data.mode) {

        case "swf":
            this._$byteStream._$buffer = event.data.buffer;
            this.parseAndBuild();
            break;

        case "lossless":
            {
                const workSpace    = Util.$currentWorkSpace();
                const instance     = workSpace.getLibrary(this.libraryId);
                instance._$buffer  = event.data.buffer;
                instance._$command = null;
            }
            break;

        case "jpegAlpha":
            {
                const buffer    = event.data.buffer;
                const alphaData = event.data.alphaData;

                let index = 0;
                for (let idx = 0; idx < buffer.length; idx += 4) {
                    buffer[idx + 3] = alphaData[index++];
                }

                const workSpace    = Util.$currentWorkSpace();
                const instance     = workSpace.getLibrary(this.libraryId);
                instance._$buffer  = buffer;
                instance._$command = null;
            }
            break;

    }

    // next
    if (Util.$unzipQueues.length) {
        const object = Util.$unzipQueues.shift();
        worker.onmessage = Util.$unzipHandler.bind(object);
        switch (object.mode) {

            case "swf":
                {
                    const buffer = object._$byteStream._$buffer;
                    worker.postMessage({
                        "fileSize": object.fileSize,
                        "mode":     object.mode,
                        "buffer":   buffer
                    }, [buffer.buffer]);
                }
                break;

            case "lossless":
                worker.postMessage(object, [object.buffer.buffer]);
                break;

            case "jpegAlpha":
                worker.postMessage(object, [
                    object.buffer.buffer,
                    object.alphaData.buffer
                ]);
                break;

        }

    } else {

        Util.$unzipWorkerActive = false;

    }

};

Util.$unlzmaWorkerURL = URL.createObjectURL(
    new Blob(["const LZMA={init:function(e){const t=[];t.push(e[12],e[13],e[14],e[15],e[16],e[4],e[5],e[6],e[7]);let s=8;for(let e=5;e<9;++e){if(t[e]>=s){t[e]=t[e]-s|0;break}t[e]=256+t[e]-s|0,s=1}return t.push(0,0,0,0),e.set(t,4),e.subarray(4)},reverseDecode2:function(e,t,s,i){let r=1,o=0,d=0;for(;d<i;++d){const i=s.decodeBit(e,t+r);r=r<<1|i,o|=i<<d}return o},decompress:function(e,t){const s=new Decoder,i=s.decodeHeader(e),r=i.uncompressedSize;if(s.setProperties(i),!s.decodeBody(e,t,r))throw new Error(\"Error in lzma data stream\");return t}};class OutWindow{constructor(){this._buffer=null,this._stream=null,this._pos=0,this._streamPos=0,this._windowSize=0}create(e){this._buffer&&this._windowSize===e||(this._buffer=new Uint8Array(e)),this._windowSize=e}flush(){const e=this._pos-this._streamPos;e&&(this._stream.writeBytes(this._buffer,e),this._pos>=this._windowSize&&(this._pos=0),this._streamPos=this._pos)}releaseStream(){this.flush(),this._stream=null}setStream(e){this._stream=e}init(e=!1){e||(this._streamPos=0,this._pos=0)}copyBlock(e,t){let s=this._pos-e-1;for(s<0&&(s+=this._windowSize);t--;)s>=this._windowSize&&(s=0),this._buffer[this._pos++]=this._buffer[s++],this._pos>=this._windowSize&&this.flush()}putByte(e){this._buffer[this._pos++]=e,this._pos>=this._windowSize&&this.flush()}getByte(e){let t=this._pos-e-1;return t<0&&(t+=this._windowSize),this._buffer[t]}}class RangeDecoder{constructor(){this._stream=null,this._code=0,this._range=-1}setStream(e){this._stream=e}releaseStream(){this._stream=null}init(){let e=5;for(this._code=0,this._range=-1;e--;)this._code=this._code<<8|this._stream.readByte()}decodeDirectBits(e){let t=0,s=e;for(;s--;){this._range>>>=1;const e=this._code-this._range>>>31;this._code-=this._range&e-1,t=t<<1|1-e,0==(4278190080&this._range)&&(this._code=this._code<<8|this._stream.readByte(),this._range<<=8)}return t}decodeBit(e,t){const s=e[t],i=(this._range>>>11)*s;return(2147483648^this._code)<(2147483648^i)?(this._range=i,e[t]+=2048-s>>>5,0==(4278190080&this._range)&&(this._code=this._code<<8|this._stream.readByte(),this._range<<=8),0):(this._range-=i,this._code-=i,e[t]-=s>>>5,0==(4278190080&this._range)&&(this._code=this._code<<8|this._stream.readByte(),this._range<<=8),1)}}class BitTreeDecoder{constructor(e){this._models=Array(1<<e).fill(1024),this._numBitLevels=e}decode(e){let t=1,s=this._numBitLevels;for(;s--;)t=t<<1|e.decodeBit(this._models,t);return t-(1<<this._numBitLevels)}reverseDecode(e){let t=1,s=0,i=0;for(;i<this._numBitLevels;++i){const r=e.decodeBit(this._models,t);t=t<<1|r,s|=r<<i}return s}}class LenDecoder{constructor(){this._choice=[1024,1024],this._lowCoder=[],this._midCoder=[],this._highCoder=new BitTreeDecoder(8),this._numPosStates=0}create(e){for(;this._numPosStates<e;++this._numPosStates)this._lowCoder[this._numPosStates]=new BitTreeDecoder(3),this._midCoder[this._numPosStates]=new BitTreeDecoder(3)}decode(e,t){return 0===e.decodeBit(this._choice,0)?this._lowCoder[t].decode(e):0===e.decodeBit(this._choice,1)?8+this._midCoder[t].decode(e):16+this._highCoder.decode(e)}}class Decoder2{constructor(){this._decoders=Array(768).fill(1024)}decodeNormal(e){let t=1;do{t=t<<1|e.decodeBit(this._decoders,t)}while(t<256);return 255&t}decodeWithMatchByte(e,t){let s=1;do{const i=t>>7&1;t<<=1;const r=e.decodeBit(this._decoders,(1+i<<8)+s);if(s=s<<1|r,i!==r){for(;s<256;)s=s<<1|e.decodeBit(this._decoders,s);break}}while(s<256);return 255&s}}class LiteralDecoder{create(e,t){if(this._coders&&this._numPrevBits===t&&this._numPosBits===e)return;this._numPosBits=e,this._posMask=(1<<e)-1,this._numPrevBits=t,this._coders=[];let s=1<<this._numPrevBits+this._numPosBits;for(;s--;)this._coders[s]=new Decoder2}getDecoder(e,t){return this._coders[((e&this._posMask)<<this._numPrevBits)+((255&t)>>>8-this._numPrevBits)]}}class Decoder{constructor(){this._outWindow=new OutWindow,this._rangeDecoder=new RangeDecoder,this._isMatchDecoders=Array(192).fill(1024),this._isRepDecoders=Array(12).fill(1024),this._isRepG0Decoders=Array(12).fill(1024),this._isRepG1Decoders=Array(12).fill(1024),this._isRepG2Decoders=Array(12).fill(1024),this._isRep0LongDecoders=Array(192).fill(1024),this._posDecoders=Array(114).fill(1024),this._posAlignDecoder=new BitTreeDecoder(4),this._lenDecoder=new LenDecoder,this._repLenDecoder=new LenDecoder,this._literalDecoder=new LiteralDecoder,this._dictionarySize=-1,this._dictionarySizeCheck=-1,this._posSlotDecoder=[new BitTreeDecoder(6),new BitTreeDecoder(6),new BitTreeDecoder(6),new BitTreeDecoder(6)]}setDictionarySize(e){return!(e<0)&&(this._dictionarySize!==e&&(this._dictionarySize=e,this._dictionarySizeCheck=Math.max(this._dictionarySize,1),this._outWindow.create(Math.max(this._dictionarySizeCheck,4096))),!0)}setLcLpPb(e,t,s){if(e>8||t>4||s>4)return!1;const i=1<<s;return this._literalDecoder.create(t,e),this._lenDecoder.create(i),this._repLenDecoder.create(i),this._posStateMask=i-1,!0}setProperties(e){if(!this.setLcLpPb(e.lc,e.lp,e.pb))throw Error(\"Incorrect stream properties\");if(!this.setDictionarySize(e.dictionarySize))throw Error(\"Invalid dictionary size\")}decodeHeader(e){if(e._$size<13)return!1;let t=e.readByte();const s=t%9;t=~~(t/9);const i=t%5,r=~~(t/5);let o=e.readByte();o|=e.readByte()<<8,o|=e.readByte()<<16,o+=16777216*e.readByte();let d=e.readByte();return d|=e.readByte()<<8,d|=e.readByte()<<16,d+=16777216*e.readByte(),e.readByte(),e.readByte(),e.readByte(),e.readByte(),{lc:s,lp:i,pb:r,dictionarySize:o,uncompressedSize:d}}decodeBody(e,t,s){let i,r,o=0,d=0,h=0,c=0,n=0,_=0,a=0;for(this._rangeDecoder.setStream(e),this._rangeDecoder.init(),this._outWindow.setStream(t),this._outWindow.init(!1);_<s;){const e=_&this._posStateMask;if(0===this._rangeDecoder.decodeBit(this._isMatchDecoders,(o<<4)+e)){const e=this._literalDecoder.getDecoder(_++,a);a=o>=7?e.decodeWithMatchByte(this._rangeDecoder,this._outWindow.getByte(d)):e.decodeNormal(this._rangeDecoder),this._outWindow.putByte(a),o=o<4?0:o-(o<10?3:6)}else{if(1===this._rangeDecoder.decodeBit(this._isRepDecoders,o))i=0,0===this._rangeDecoder.decodeBit(this._isRepG0Decoders,o)?0===this._rangeDecoder.decodeBit(this._isRep0LongDecoders,(o<<4)+e)&&(o=o<7?9:11,i=1):(0===this._rangeDecoder.decodeBit(this._isRepG1Decoders,o)?r=h:(0===this._rangeDecoder.decodeBit(this._isRepG2Decoders,o)?r=c:(r=n,n=c),c=h),h=d,d=r),0===i&&(i=2+this._repLenDecoder.decode(this._rangeDecoder,e),o=o<7?8:11);else{n=c,c=h,h=d,i=2+this._lenDecoder.decode(this._rangeDecoder,e),o=o<7?7:10;const t=this._posSlotDecoder[i<=5?i-2:3].decode(this._rangeDecoder);if(t>=4){const e=(t>>1)-1;if(d=(2|1&t)<<e,t<14)d+=LZMA.reverseDecode2(this._posDecoders,d-t-1,this._rangeDecoder,e);else if(d+=this._rangeDecoder.decodeDirectBits(e-4)<<4,d+=this._posAlignDecoder.reverseDecode(this._rangeDecoder),d<0){if(-1===d)break;return!1}}else d=t}if(d>=_||d>=this._dictionarySizeCheck)return!1;this._outWindow.copyBlock(d,i),_+=i,a=this._outWindow.getByte(0)}}return this._outWindow.releaseStream(),this._rangeDecoder.releaseStream(),!0}}class InStream{constructor(e){this._$data=e,this._$size=e.length,this._$offset=0}readByte(){return this._$data[this._$offset++]}}class OutStream{constructor(e){this.size=8,this.buffers=e}writeBytes(e,t){e.length===t?this.buffers.set(e,this.size):this.buffers.set(e.subarray(0,t),this.size),this.size+=t}}this.addEventListener(\"message\",(function(e){const t=e.data.fileSize,s=e.data.buffer,i=new Uint8Array(t+8);i.set(s.slice(0,8),0),LZMA.decompress(new InStream(LZMA.init(s)),new OutStream(i)),this.postMessage(i,[i.buffer]),this.close()}));"], { "type": "text/javascript" })
);
Util.$unlzmaQueues       = [];
Util.$unlzmaWorkerActive = false;

Util.$parserURL = URL.createObjectURL(
    new Blob(["const Util={$tagObjects:[]};Util.$installed=new Map,Util.$swfParser=null,Util.$Rad2Deg=180/Math.PI,Util.$JCT11280=Function('var a=\"zKV33~jZ4zN=~ji36XazM93y!{~k2y!o~k0ZlW6zN?3Wz3W?{EKzK[33[`y|;-~j^YOTz$!~kNy|L1$353~jV3zKk3~k-4P4zK_2+~jY4y!xYHR~jlz$_~jk4z$e3X5He<0y!wy|X3[:~l|VU[F3VZ056Hy!nz/m1XD61+1XY1E1=1y|bzKiz!H034zKj~mEz#c5ZA3-3X$1~mBz$$3~lyz#,4YN5~mEz#{ZKZ3V%7Y}!J3X-YEX_J(3~mAz =V;kE0/y|F3y!}~m>z/U~mI~j_2+~mA~jp2;~m@~k32;~m>V}2u~mEX#2x~mBy+x2242(~mBy,;2242(~may->2&XkG2;~mIy-_2&NXd2;~mGz,{4<6:.:B*B:XC4>6:.>B*BBXSA+A:X]E&E<~r#z+625z s2+zN=`HXI@YMXIAXZYUM8X4K/:Q!Z&33 3YWX[~mB`{zKt4z (zV/z 3zRw2%Wd39]S11z$PAXH5Xb;ZQWU1ZgWP%3~o@{Dgl#gd}T){Uo{y5_d{e@}C(} WU9|cB{w}bzvV|)[} H|zT}d||0~{]Q|(l{|x{iv{dw}(5}[Z|kuZ }cq{{y|ij}.I{idbof%cu^d}Rj^y|-M{ESYGYfYsZslS`?ZdYO__gLYRZ&fvb4oKfhSf^d<Yeasc1f&a=hnYG{QY{D`Bsa|u,}Dl|_Q{C%xK|Aq}C>|c#ryW=}eY{L+`)][YF_Ub^h4}[X|?r|u_ex}TL@YR]j{SrXgo*|Gv|rK}B#mu{R1}hs|dP{C7|^Qt3|@P{YVV |8&}#D}ef{e/{Rl|>Hni}R1{Z#{D[}CQlQ||E}[s{SG_+i8eplY[=[|ec[$YXn#`hcm}YR|{Ci(_[ql|?8p3]-}^t{wy}4la&pc|3e{Rp{LqiJ],] `kc(]@chYnrM`O^,ZLYhZB]ywyfGY~aex!_Qww{a!|)*lHrM{N+n&YYj~Z b c#e_[hZSon|rOt`}hBXa^i{lh|<0||r{KJ{kni)|x,|0auY{D!^Sce{w;|@S|cA}Xn{C1h${E]Z-XgZ*XPbp]^_qbH^e[`YM|a||+=]!Lc}]vdBc=j-YSZD]YmyYLYKZ9Z>Xcczc2{Yh}9Fc#Z.l{}(D{G{{mRhC|L3b#|xK[Bepj#ut`H[,{E9Yr}1b{[e]{ZFk7[ZYbZ0XL]}Ye[(`d}c!|*y`Dg=b;gR]Hm=hJho}R-[n}9;{N![7k_{UbmN]rf#pTe[x8}!Qcs_rs[m`|>N}^V})7{^r|/E}),}HH{OYe2{Skx)e<_.cj.cjoMhc^d}0uYZd!^J_@g,[[[?{i@][|3S}Yl3|!1|eZ|5IYw|1D}e7|Cv{OHbnx-`wvb[6[4} =g+k:{C:}ed{S]|2M]-}WZ|/q{LF|dYu^}Gs^c{Z=}h>|/i|{W]:|ip{N:|zt|S<{DH[p_tvD{N<[8Axo{X4a.^o^X>Yfa59`#ZBYgY~_t^9`jZHZn`>G[oajZ;X,i)Z.^~YJe ZiZF^{][[#Zt^|]Fjx]&_5dddW]P0C[-]}]d|y {C_jUql] |OpaA[Z{lp|rz}:Mu#]_Yf6{Ep?f5`$[6^D][^u[$[6^.Z8]]ePc2U/=]K^_+^M{q*|9tYuZ,s(dS{i=|bNbB{uG}0jZOa:[-]dYtu3]:]<{DJ_SZIqr_`l=Yt`gkTnXb3d@kiq0a`Z{|!B|}e}Ww{Sp,^Z|0>_Z}36|]A|-t}lt{R6pi|v8hPu#{C>YOZHYmg/Z4nicK[}hF_Bg|YRZ7c|crkzYZY}_iXcZ.|)U|L5{R~qi^Uga@Y[xb}&qdbd6h5|Btw[}c<{Ds53[Y7]?Z<|e0{L[ZK]mXKZ#Z2^tavf0`PE[OSOaP`4gi`qjdYMgys/?[nc,}EEb,eL]g[n{E_b/vcvgb.{kcwi`~v%|0:|iK{Jh_vf5lb}KL|(oi=LrzhhY_^@`zgf[~g)[J_0fk_V{T)}I_{D&_/d9W/|MU[)f$xW}?$xr4<{Lb{y4}&u{XJ|cm{Iu{jQ}CMkD{CX|7A}G~{kt)nB|d5|<-}WJ}@||d@|Iy}Ts|iL|/^|no|0;}L6{Pm]7}$zf:|r2}?C_k{R(}-w|`G{Gy[g]bVje=_0|PT{^Y^yjtT[[[l!Ye_`ZN]@[n_)j3nEgMa]YtYpZy].d-Y_cjb~Y~[nc~sCi3|zg}B0}do{O^{|$`_|D{}U&|0+{J3|8*]iayx{a{xJ_9|,c{Ee]QXlYb]$[%YMc*]w[aafe]aVYi[fZEii[xq2YQZHg]Y~h#|Y:thre^@^|_F^CbTbG_1^qf7{L-`VFx Zr|@EZ;gkZ@slgko`[e}T:{Cu^pddZ_`yav^Ea+[#ZBbSbO`elQfLui}.F|txYcbQ`XehcGe~fc^RlV{D_0ZAej[l&jShxG[ipB_=u:eU}3e8[=j|{D(}dO{Do[BYUZ0/]AYE]ALYhZcYlYP/^-^{Yt_1_-;YT`P4BZG=IOZ&]H[e]YYd[9^F[1YdZxZ?Z{Z<]Ba2[5Yb[0Z4l?]d_;_)a?YGEYiYv`_XmZs4ZjY^Zb]6gqGaX^9Y}dXZr[g|]Y}K aFZp^k^F]M`^{O1Ys]ZCgCv4|E>}8eb7}l`{L5[Z_faQ|c2}Fj}hw^#|Ng|B||w2|Sh{v+[G}aB|MY}A{|8o}X~{E8paZ:]i^Njq]new)`-Z>haounWhN}c#{DfZ|fK]KqGZ=:u|fqoqcv}2ssm}.r{]{nIfV{JW)[K|,Z{Uxc|]l_KdCb%]cfobya3`p}G^|LZiSC]U|(X|kBlVg[kNo({O:g:|-N|qT}9?{MBiL}Sq{`P|3a|u.{Uaq:{_o|^S}jX{Fob0`;|#y_@[V[K|cw[<_ }KU|0F}d3|et{Q7{LuZttsmf^kYZ`Af`}$x}U`|Ww}d]| >}K,r&|XI|*e{C/a-bmr1fId4[;b>tQ_:]hk{b-pMge]gfpo.|(w[jgV{EC1Z,YhaY^q,_G[c_g[J0YX]`[h^hYK^_Yib,` {i6vf@YM^hdOKZZn(jgZ>bzSDc^Z%[[o9[2=/YHZ(_/Gu_`*|8z{DUZxYt^vuvZjhi^lc&gUd4|<UiA`z]$b/Z?l}YI^jaHxe|;F}l${sQ}5g}hA|e4}?o{ih}Uz{C)jPe4]H^J[Eg[|AMZMlc}:,{iz}#*|gc{Iq|/:|zK{l&}#u|myd{{M&v~nV};L|(g|I]ogddb0xsd7^V})$uQ{HzazsgxtsO^l}F>ZB]r|{7{j@cU^{{CbiYoHlng]f+nQ[bkTn/}<-d9q {KXadZYo+n|l[|lc}V2{[a{S4Zam~Za^`{HH{xx_SvF|ak=c^[v^7_rYT`ld@]:_ub%[$[m](Shu}G2{E.ZU_L_R{tz`vj(f?^}hswz}GdZ}{S:h`aD|?W|`dgG|if{a8|J1{N,}-Ao3{H#{mfsP|[ bzn+}_Q{MT{u4kHcj_q`eZj[8o0jy{p7}C|[}l){MuYY{|Ff!Ykn3{rT|m,^R|,R}$~Ykgx{P!]>iXh6[l[/}Jgcg{JYZ.^qYfYIZl[gZ#Xj[Pc7YyZD^+Yt;4;`e8YyZVbQ7YzZxXja.7SYl[s]2^/Ha$[6ZGYrb%XiYdf2]H]kZkZ*ZQ[ZYS^HZXcCc%Z|[(bVZ]]:OJQ_DZCg<[,]%Zaa [g{C00HY[c%[ChyZ,Z_`PbXa+eh`^&jPi0a[ggvhlekL]w{Yp^v}[e{~;k%a&k^|nR_z_Qng}[E}*Wq:{k^{FJZpXRhmh3^p>de^=_7`|ZbaAZtdhZ?n4ZL]u`9ZNc3g%[6b=e.ZVfC[ZZ^^^hD{E(9c(kyZ=bb|Sq{k`|vmr>izlH[u|e`}49}Y%}FT{[z{Rk}Bz{TCc/lMiAqkf(m$hDc;qooi[}^o:c^|Qm}a_{mrZ(pA`,}<2sY| adf_%|}`}Y5U;}/4|D>|$X{jw{C<|F.hK|*A{MRZ8Zsm?imZm_?brYWZrYx`yVZc3a@f?aK^ojEd {bN}/3ZH]/$YZhm^&j 9|(S|b]mF}UI{q&aM]LcrZ5^.|[j`T_V_Gak}9J[ ZCZD|^h{N9{~&[6Zd{}B}2O|cv]K}3s}Uy|l,fihW{EG`j_QOp~Z$F^zexS`dcISfhZBXP|.vn|_HYQ|)9|cr]<`&Z6]m_(ZhPcSg>`Z]5`~1`0Xcb4k1{O!bz|CN_T{LR|a/gFcD|j<{Z._[f)mPc:1`WtIaT1cgYkZOaVZOYFrEe[}T$}Ch}mk{K-^@]fH{Hdi`c*Z&|Kt{if[C{Q;{xYB`dYIX:ZB[}]*[{{p9|4GYRh2ao{DS|V+[zd$`F[ZXKadb*A] Ys]Maif~a/Z2bmclb8{Jro_rz|x9cHojbZ{GzZx_)]:{wAayeDlx}<=`g{H1{l#}9i|)=|lP{Qq}.({La|!Y{i2EZfp=c*}Cc{EDvVB|;g}2t{W4av^Bn=]ri,|y?|3+}T*ckZ*{Ffr5e%|sB{lx^0]eZb]9[SgAjS_D|uHZx]dive[c.YPkcq/}db{EQh&hQ|eg}G!ljil|BO]X{Qr_GkGl~YiYWu=c3eb}29v3|D|}4i||.{Mv})V{SP1{FX}CZW6{cm|vO{pS|e#}A~|1i}81|Mw}es|5[}3w{C`h9aL]o{}p[G`>i%a1Z@`Ln2bD[$_h`}ZOjhdTrH{[j_:k~kv[Sdu]CtL}41{I |[[{]Zp$]XjxjHt_eThoa#h>sSt8|gK|TVi[Y{t=}Bs|b7Zpr%{gt|Yo{CS[/{iteva|cf^hgn}($_c^wmb^Wm+|55jrbF|{9^ q6{C&c+ZKdJkq_xOYqZYSYXYl`8]-cxZAq/b%b*_Vsa[/Ybjac/OaGZ4fza|a)gY{P?| I|Y |,pi1n7}9bm9ad|=d{aV|2@[(}B`d&|Uz}B}{`q|/H|!JkM{FU|CB|.{}Az}#P|lk}K{|2rk7{^8^?`/|k>|Ka{Sq}Gz}io{DxZh[yK_#}9<{TRdgc]`~Z>JYmYJ]|`!ZKZ]gUcx|^E[rZCd`f9oQ[NcD_$ZlZ;Zr}mX|=!|$6ZPZYtIo%fj}CpcN|B,{VDw~gb}@hZg`Q{LcmA[(bo`<|@$|o1|Ss}9Z_}tC|G`{F/|9nd}i=}V-{L8aaeST]daRbujh^xlpq8|}zs4bj[S`J|]?G{P#{rD{]I`OlH{Hm]VYuSYUbRc*6[j`8]pZ[bt_/^Jc*[<Z?YE|Xb|?_Z^Vcas]h{t9|Uwd)_(=0^6Zb{Nc} E[qZAeX[a]P^|_J>e8`W^j_Y}R{{Jp__]Ee#e:iWb9q_wKbujrbR}CY`,{mJ}gz{Q^{t~N|? gSga`V_||:#mi}3t|/I`X{N*|ct|2g{km}gi|{={jC}F;|E}{ZZjYf*frmu}8Tdroi{T[|+~}HG{cJ}DM{Lp{Ctd&}$hi3|FZ| m}Kr|38}^c|m_|Tr{Qv|36}?Up>|;S{DV{k_as}BK{P}}9p|t`jR{sAm4{D=b4pWa[}Xi{EjwEkI}3S|E?u=X0{jf} S|NM|JC{qo^3cm]-|JUx/{Cj{s>{Crt[UXuv|D~|j|d{YXZR}Aq}0r}(_{pJfi_z}0b|-vi)Z mFe,{f4|q`b{}^Z{HM{rbeHZ|^x_o|XM|L%|uFXm}@C_{{Hhp%a7|0p[Xp+^K}9U{bP}: tT}B|}+$|b2|[^|~h{FAby[`{}xgygrt~h1[li`c4vz|,7p~b(|mviN}^pg[{N/|g3|^0c,gE|f%|7N{q[|tc|TKA{LU}I@|AZp(}G-sz{F |qZ{}F|f-}RGn6{Z]_5})B}UJ{FFb2]4ZI@v=k,]t_Dg5Bj]Z-]L]vrpdvdGlk|gF}G]|IW}Y0[G| /bo|Te^,_B}#n^^{QHYI[?hxg{[`]D^IYRYTb&kJ[cri[g_9]Ud~^_]<p@_e_XdNm-^/|5)|h_{J;{kacVopf!q;asqd}n)|.m|bf{QW|U)}b+{tL|w``N|to{t ZO|T]jF}CB|0Q{e5Zw|k |We}5:{HO{tPwf_uajjBfX}-V_C_{{r~gg|Ude;s+}KNXH}! `K}eW{Upwbk%ogaW}9EYN}YY|&v|SL{C3[5s.]Y]I]u{M6{pYZ`^,`ZbCYR[1mNg>rsk0Ym[jrE]RYiZTr*YJ{Ge|%-lf|y(`=[t}E6{k!|3)}Zk} ][G{E~cF{u3U.rJ|a9p#o#ZE|?|{sYc#vv{E=|LC}cu{N8`/`3`9rt[4|He{cq|iSYxY`}V |(Q|t4{C?]k_Vlvk)BZ^r<{CL}#h}R+[<|i=}X|{KAo]|W<`K{NW|Zx}#;|fe{IMr<|K~tJ_x}AyLZ?{GvbLnRgN}X&{H7|x~}Jm{]-| GpNu0}.ok>|c4{PYisrDZ|fwh9|hfo@{H~XSbO]Odv]%`N]b1Y]]|eIZ}_-ZA]aj,>eFn+j[aQ_+]h[J_m_g]%_wf.`%k1e#Z?{CvYu_B^|gk`Xfh^M3`afGZ-Z|[m{L}|k3cp[it ^>YUi~d>{T*}YJ{Q5{Jxa$hg|%4`}|LAgvb }G}{P=|<;Ux{_skR{cV|-*|s-{Mp|XP|$G|_J}c6cM{_=_D|*9^$ec{V;|4S{qO|w_|.7}d0|/D}e}|0G{Dq]Kdp{}dfDi>}B%{Gd|nl}lf{C-{y}|ANZr}#={T~|-(}c&{pI|ft{lsVP}){|@u}!W|bcmB{d?|iW|:dxj{PSkO|Hl]Li:}VYk@|2={fnWt{M3`cZ6|)}|Xj}BYa?vo{e4|L7|B7{L7|1W|lvYO}W8nJ|$Vih|{T{d*_1|:-n2dblk``fT{Ky|-%}m!|Xy|-a{Pz}[l{kFjz|iH}9N{WE{x,|jz}R {P|{D)c=nX|Kq|si}Ge{sh|[X{RF{t`|jsr*fYf,rK|/9}$}}Nf{y!1|<Std}4Wez{W${Fd_/^O[ooqaw_z[L`Nbv[;l7V[ii3_PeM}.h^viqYjZ*j1}+3{bt{DR[;UG}3Og,rS{JO{qw{d<_zbAh<R[1_r`iZTbv^^a}c{iEgQZ<exZFg.^Rb+`Uj{a+{z<[~r!]`[[|rZYR|?F|qppp]L|-d|}K}YZUM|=Y|ktm*}F]{D;g{uI|7kg^}%?Z%ca{N[_<q4xC]i|PqZC]n}.bDrnh0Wq{tr|OMn6tM|!6|T`{O`|>!]ji+]_bTeU}Tq|ds}n|{Gm{z,f)}&s{DPYJ`%{CGd5v4tvb*hUh~bf]z`jajiFqAii]bfy^U{Or|m+{I)cS|.9k:e3`^|xN}@Dnlis`B|Qo{`W|>||kA}Y}{ERYuYx`%[exd`]|OyiHtb}HofUYbFo![5|+]gD{NIZR|Go}.T{rh^4]S|C9_}xO^i`vfQ}C)bK{TL}cQ|79iu}9a];sj{P.o!f[Y]pM``Jda^Wc9ZarteBZClxtM{LW}l9|a.mU}KX}4@{I+f1}37|8u}9c|v${xGlz}jP{Dd1}e:}31}%3X$|22i<v+r@~mf{sN{C67G97855F4YL5}8f{DT|xy{sO{DXB334@55J1)4.G9A#JDYtXTYM4, YQD9;XbXm9SX]IB^4UN=Xn<5(;(F3YW@XkH-X_VM[DYM:5XP!T&Y`6|,^{IS-*D.H>:LXjYQ0I3XhAF:9:(==.F*3F1189K/7163D,:@|e2{LS36D4hq{Lw/84443@4.933:0307::6D7}&l{Mx657;89;,K5678H&93D(H<&<>0B90X^I;}Ag1{P%3A+>><975}[S{PZE453?4|T2{Q+5187;>447:81{C=hL6{Me^:=7ii{R=.=F<81;48?|h8}Uh{SE|,VxL{ST,7?9Y_5Xk3A#:$%YSYdXeKXOD8+TXh7(@>(YdXYHXl9J6X_5IXaL0N?3YK7Xh!1?XgYz9YEXhXaYPXhC3X`-YLY_XfVf[EGXZ5L8BXL9YHX]SYTXjLXdJ: YcXbQXg1PX]Yx4|Jr{Ys4.8YU+XIY`0N,<H%-H;:0@,74/:8546I=9177154870UC]d<C3HXl7ALYzXFXWP<<?E!88E5@03YYXJ?YJ@6YxX-YdXhYG|9o{`iXjY_>YVXe>AYFX[/(I@0841?):-B=14337:8=|14{c&93788|di{cW-0>0<097/A;N{FqYpugAFT%X/Yo3Yn,#=XlCYHYNX[Xk3YN:YRT4?)-YH%A5XlYF3C1=NWyY}>:74-C673<69545v {iT85YED=64=.F4..9878/D4378?48B3:7:7/1VX[f4{D,{l<5E75{dAbRB-8-@+;DBF/$ZfW8S<4YhXA.(5@*11YV8./S95C/0R-A4AXQYI7?68167B95HA1*<M3?1/@;/=54XbYP36}lc{qzSS38:19?,/39193574/66878Yw1X-87E6=;964X`T734:>86>1/=0;(I-1::7ALYGXhF+Xk[@W%TYbX7)KXdYEXi,H-XhYMRXfYK?XgXj.9HX_SX]YL1XmYJ>Y}WwIXiI-3-GXcYyXUYJ$X`Vs[7;XnYEZ;XF! 3;%8;PXX(N3Y[)Xi1YE&/ :;74YQ6X`33C;-(>Xm0(TYF/!YGXg8 9L5P01YPXO-5%C|qd{{/K/E6,=0144:361:955;6443@?B7*7:F89&F35YaX-CYf,XiFYRXE_e{}sF 0*7XRYPYfXa5YXXY8Xf8Y~XmA[9VjYj*#YMXIYOXk,HHX40YxYMXU8OXe;YFXLYuPXP?EB[QV0CXfY{:9XV[FWE0D6X^YVP*$4%OXiYQ(|xp|%c3{}V`1>Y`XH00:8/M6XhQ1:;3414|TE|&o@1*=81G8<3}6<|(f6>>>5-5:8;093B^3U*+*^*UT30XgYU&7*O1953)5@E78--F7YF*B&0:%P68W9Zn5974J9::3}Vk|-,C)=)1AJ4+<3YGXfY[XQXmT1M-XcYTYZXCYZXEYXXMYN,17>XIG*SaS|/eYJXbI?XdNZ+WRYP<F:R PXf;0Xg`$|1GX9YdXjLYxWX!ZIXGYaXNYm6X9YMX?9EXmZ&XZ#XQ>YeXRXfAY[4 ;0X!Zz0XdN$XhYL XIY^XGNXUYS/1YFXhYk.TXn4DXjB{jg|4DEX]:XcZMW=A.+QYL<LKXc[vV$+&PX*Z3XMYIXUQ:ZvW< YSXFZ,XBYeXMM)?Xa XiZ4/EXcP3%}&-|6~:1(-+YT$@XIYRBC<}&,|7aJ6}bp|8)K1|Xg|8C}[T|8Q.89;-964I38361<=/;883651467<7:>?1:.}le|:Z=39;1Y^)?:J=?XfLXbXi=Q0YVYOXaXiLXmJXO5?.SFXiCYW}-;|=u&D-X`N0X^,YzYRXO(QX_YW9`I|>hZ:N&X)DQXP@YH#XmNXi$YWX^=!G6YbYdX>XjY|XlX^XdYkX>YnXUXPYF)FXT[EVTMYmYJXmYSXmNXi#GXmT3X8HOX[ZiXN]IU2>8YdX1YbX<YfWuZ8XSXcZU%0;1XnXkZ_WTG,XZYX5YSX Yp 05G?XcYW(IXg6K/XlYP4XnI @XnO1W4Zp-9C@%QDYX+OYeX9>--YSXkD.YR%Q/Yo YUX].Xi<HYEZ2WdCE6YMXa7F)=,D>-@9/8@5=?7164;35387?N<618=6>7D+C50<6B03J0{Hj|N9$D,9I-,.KB3}m |NzE0::/81YqXjMXl7YG; [.W=Z0X4XQY]:MXiR,XgM?9$9>:?E;YE77VS[Y564760391?14941:0=:8B:;/1DXjFA-564=0B3XlH1+D85:0Q!B#:-6&N/:9<-R3/7Xn<*3J4.H:+334B.=>30H.;3833/76464665755:/83H6633:=;.>5645}&E|Y)?1/YG-,93&N3AE@5 <L1-G/8A0D858/30>8<549=@B8] V0[uVQYlXeD(P#ID&7T&7;Xi0;7T-$YE)E=1:E1GR):--0YI7=E<}n9|aT6783A>D7&4YG7=391W;Zx<5+>F#J39}o/|cc;6=A050EQXg8A1-}D-|d^5548083563695D?-.YOXd37I$@LYLWeYlX<Yd+YR A$;3-4YQ-9XmA0!9/XLY_YT(=5XdDI>YJ5XP1ZAW{9>X_6R(XhYO65&J%DA)C-!B:97#A9;@?F;&;(9=11/=657/H,<8}bz|j^5446>.L+&Y^8Xb6?(CYOXb*YF(8X`FYR(XPYVXmPQ%&DD(XmZXW??YOXZXfCYJ79,O)XnYF7K0!QXmXi4IYFRXS,6<%-:YO(+:-3Q!1E1:W,Zo}Am|n~;3580534*?3Zc4=9334361693:30C<6/717:<1/;>59&:4}6!|rS36=1?75<8}[B|s809983579I.A.>84758=108564741H*9E{L{|u%YQ<%6XfH.YUXe4YL@,>N}Tv|ve*G0X)Z;/)3@A74(4P&A1X:YVH97;,754*A66:1 D739E3553545558E4?-?K17/770843XAYf838A7K%N!YW4.$T19Z`WJ*0XdYJXTYOXNZ 1XaN1A+I&Xi.Xk3Z3GB&5%WhZ1+5#Y[X<4YMXhQYoQXVXbYQ8XSYUX4YXBXWDMG0WxZA[8V+Z8X;D],Va$%YeX?FXfX[XeYf<X:Z[WsYz8X_Y]%XmQ(!7BXIZFX]&YE3F$(1XgYgYE& +[+W!<YMYFXc;+PXCYI9YrWxGXY9DY[!GXiI7::)OC;*$.>N*HA@{C|}&k=:<TB83X`3YL+G4XiK]i}(fYK<=5$.FYE%4*5*H*6XkCYL=*6Xi6!Yi1KXR4YHXbC8Xj,B9ZbWx/XbYON#5B}Ue}+QKXnF1&YV5XmYQ0!*3IXBYb71?1B75XmF;0B976;H/RXU:YZX;BG-NXj;XjI>A#D3B636N;,*%<D:0;YRXY973H5)-4FXOYf0:0;/7759774;7;:/855:543L43<?6=E,.A4:C=L)%4YV!1(YE/4YF+ F3%;S;&JC:%/?YEXJ4GXf/YS-EXEYW,9;E}X$}547EXiK=51-?71C%?57;5>463553Zg90;6447?<>4:9.7538XgN{|!}9K/E&3-:D+YE1)YE/3;37/:05}n<}:UX8Yj4Yt864@JYK..G=.(A Q3%6K>3(P3#AYE$-6H/456*C=.XHY[#S.<780191;057C)=6HXj?955B:K1 E>-B/9,;5.!L?:0>/.@//:;7833YZ56<4:YE=/:7Z_WGC%3I6>XkC*&NA16X=Yz2$X:Y^&J48<99k8}CyB-61<18K946YO4{|N}E)YIB9K0L>4=46<1K0+R;6-=1883:478;4,S+3YJX`GJXh.Yp+Xm6MXcYpX(>7Yo,/:X=Z;Xi0YTYHXjYmXiXj;*;I-8S6N#XgY}.3XfYGO3C/$XjL$*NYX,1 6;YH&<XkK9C#I74.>}Hd`A748X[T450[n75<4439:18A107>|ET}Rf<1;14876/Yb983E<5.YNXd4149>,S=/4E/<306443G/06}0&}UkYSXFYF=44=-5095=88;63844,9E6644{PL}WA8:>)7+>763>>0/B3A545CCnT}Xm|dv}Xq1L/YNXk/H8;;.R63351YY747@15YE4J8;46;.38.>4A369.=-83,;Ye3?:3@YE.4-+N353;/;@(X[YYD>@/05-I*@.:551741Yf5>6A443<3535;.58/86=D4753442$635D1>0359NQ @73:3:>><Xn?;43C14 ?Y|X611YG1&<+,4<*,YLXl<1/AIXjF*N89A4Z576K1XbJ5YF.ZOWN.YGXO/YQ01:4G38Xl1;KI0YFXB=R<7;D/,/4>;$I,YGXm94@O35Yz66695385.>:6A#5}W7n^4336:4157597434433<3|XA}m`>=D>:4A.337370?-6Q96{`E|4A}C`|Qs{Mk|J+~r>|o,wHv>Vw}!c{H!|Gb|*Ca5}J||,U{t+{CN[!M65YXOY_*B,Y[Z9XaX[QYJYLXPYuZ%XcZ8LY[SYPYKZM<LMYG9OYqSQYM~[e{UJXmQYyZM_)>YjN1~[f3{aXFY|Yk:48YdH^NZ0|T){jVFYTZNFY^YTYN~[h{nPYMYn3I]`EYUYsYIZEYJ7Yw)YnXPQYH+Z.ZAZY]^Z1Y`YSZFZyGYHXLYG 8Yd#4~[i|+)YH9D?Y^F~Y7|-eYxZ^WHYdYfZQ~[j|3>~[k|3oYmYqY^XYYO=Z*4[]Z/OYLXhZ1YLZIXgYIHYEYK,<Y`YEXIGZI[3YOYcB4SZ!YHZ*&Y{Xi3~[l|JSY`Zz?Z,~[m|O=Yi>??XnYWXmYS617YVYIHZ(Z4[~L4/=~[n|Yu{P)|];YOHHZ}~[o33|a>~[r|aE]DH~[s|e$Zz~[t|kZFY~XhYXZB[`Y}~[u|{SZ&OYkYQYuZ2Zf8D~[v}% ~[w3},Q[X]+YGYeYPIS~[y}4aZ!YN^!6PZ*~[z}?E~[{3}CnZ=~[}}EdDZz/9A3(3S<,YR8.D=*XgYPYcXN3Z5 4)~[~}JW=$Yu.XX~] }KDX`PXdZ4XfYpTJLY[F5]X~[2Yp}U+DZJ::<446[m@~]#3}]1~]%}^LZwZQ5Z`/OT<Yh^ -~]&}jx[ ~m<z!%2+~ly4VY-~o>}p62yz!%2+Xf2+~ly4VY-zQ`z (=] 2z~o2\",C={\" \":0,\"!\":1},c=34,i=2,p,s=\"\",u=String.fromCharCode,t=u(12539);for(;++c<127;)C[u(c)]=c^39&&c^92?i++:0;i=0;for(;0<=(c=C[a.charAt(i++)]);)if(16===c)if((c=C[a.charAt(i++)])<87){if(86===c)c=1879;for(;c--;)s+=u(++p)}else s+=s.substr(8272,360);else if(c<86)s+=u(p+=c<51?c-16:(c-55)*92+C[a.charAt(i++)]);else if((c=((c-86)*92+C[a.charAt(i++)])*92+C[a.charAt(i++)])<49152)s+=u(p=c<40960?c:c|57344);else{c&=511;for(;c--;)s+=t;p=12539}return s')(),Util.$decodeToShiftJis=function(t){return t.replace(/%(8[1-9A-F]|[9E][0-9A-F]|F[0-9A-C])(%[4-689A-F][0-9A-F]|%7[0-9A-E]|[@-~])|%([0-7][0-9A-F]|A[1-9A-F]|[B-D][0-9A-F])/gi,(function(t){let e=parseInt(t.substring(1,3),16);const s=t.length;return 3===s?String.fromCharCode(e<160?e:e+65216):Util.$JCT11280.charAt(188*(e<160?e-129:e-193)+(4===s?t.charCodeAt(3)-64:(e=parseInt(t.substring(4),16))<127?e-64:e-65))}))},Util.$getTagObject=function(){return Util.$tagObjects.pop()||{placeObjects:[],sounds:[],removeObjects:[],frameLabel:[]}},Util.$poolTagObject=function(t){t.placeObjects.length=0,t.sounds.length=0,t.removeObjects.length=0,t.frameLabel.length=0,Util.$tagObjects.push(t)},Util.$createMovieClip=function(){const t={_$characterId:0,_$name:\"MovieClip\",_$controller:[],_$placeObjects:[],_$placeMap:[],_$labels:[],_$dictionary:[],_$sounds:[]};return t},Util.$getControllerAt=function(t,e,s){return s in t._$controller[e]?t._$controller[e][s]:null},Util.$addDictionary=function(t,e){const s=t._$dictionary.length,a={CharacterId:e.CharacterId,Depth:e.Depth,Name:null,ClipDepth:0,PlaceFlagHasImage:0|e.PlaceFlagHasImage,StartFrame:0|e.StartFrame,EndFrame:0|e.EndFrame};return e.PlaceFlagHasName&&(a.Name=e.Name),e.PlaceFlagHasClipDepth&&(a.ClipDepth=e.ClipDepth),t._$dictionary[s]=a,s},Util.$getBlendName=function(t){switch(t){case 1:case\"normal\":default:return\"normal\";case 2:case\"layer\":return\"layer\";case 3:case\"multiply\":return\"multiply\";case 4:case\"screen\":return\"screen\";case 5:case\"lighten\":return\"lighten\";case 6:case\"darken\":return\"darken\";case 7:case\"difference\":return\"difference\";case 8:case\"add\":return\"add\";case 9:case\"subtract\":return\"subtract\";case 10:case\"invert\":return\"invert\";case 11:case\"alpha\":return\"alpha\";case 12:case\"erase\":return\"erase\";case 13:case\"overlay\":return\"overlay\";case 14:case\"hardlight\":return\"hardlight\"}};class ByteStream{constructor(){this.clear()}clear(){this.data=null,this.bit_offset=0,this.byte_offset=0,this.bit_buffer=null}setData(t){this.data=t}getData(t){this.byteAlign();const e=this.byte_offset+t,s=this.data.subarray(this.byte_offset,e);return this.byte_offset=e,s}byteAlign(){this.bit_offset&&(this.byte_offset=this.byte_offset+(this.bit_offset+7)/8|0,this.bit_offset=0)}getDataUntil(t=0){this.byteAlign();let e=\"\";for(;;){const t=this.data[this.byte_offset++];if(!t)break;if(10===t||13===t){e+=\"\\n\";continue}let s=t.toString(16);1===s.length&&(s=\"0\"+s),e+=\"%\"+s}if(!e.length)return\"\";if(e.length>5&&\"\\n\"===e.substr(-5)&&(e=e.slice(0,-5)),t)return Util.$decodeToShiftJis(e);try{return decodeURIComponent(e)}catch(t){return Util.$decodeToShiftJis(e)}}byteCarry(){if(this.bit_offset>7)this.byte_offset=this.byte_offset+(0|(this.bit_offset+7)/8),this.bit_offset&=7;else for(;this.bit_offset<0;)--this.byte_offset,this.bit_offset+=8}getUIBits(t){let e=0;for(;t;)e<<=1,e|=this.getUIBit(),--t;return e}getUIBit(){return this.byteCarry(),this.data[this.byte_offset]>>7-this.bit_offset++&1}getSIBits(t){const e=this.getUIBits(t),s=e&1<<t-1;return s?-(e^2*s-1)-1:e}getUI8(){return this.byteAlign(),this.data[this.byte_offset++]}getUI16(){return this.byteAlign(),this.getUI8()|this.getUI8()<<8}getUI32(){return this.byteAlign(),this.getUI8()|(this.getUI8()|(this.getUI8()|this.getUI8()<<8)<<8)<<8}getFloat16(){const t=this.data[this.byte_offset++];let e=0;return e|=this.data[this.byte_offset++]<<8,e|=t<<0,e}getFloat32(){const t=this.data[this.byte_offset++],e=this.data[this.byte_offset++],s=this.data[this.byte_offset++];let a=0;a|=this.data[this.byte_offset++]<<24,a|=s<<16,a|=e<<8,a|=t<<0;const i=a>>23&255;return a&&2147483648!==a?(2147483648&a?-1:1)*(8388608|8388607&a)*Math.pow(2,i-127-23):0}incrementOffset(t,e){this.byte_offset+=t,this.bit_offset+=e,this.byteCarry()}setOffset(t,e){this.byte_offset=t,this.bit_offset=e}}class SwfParser{constructor(){this.byteStream=new ByteStream,this.currentPosition={x:0,y:0},this.jpegTables=null,this.characters=[],this.frameInfo=[],this.fonts=new Map,this.textSettings=new Map,this.grids=new Map,this.version=0}clear(){this.byteStream.clear(),this.currentPosition.x=0,this.currentPosition.y=0,this.jpegTables=null,this.characters.length=0,this.frameInfo.length=0,this.version=0}getCharacter(t){return this.characters[t]}setCharacter(t,e,s){this.characters[t]=e,globalThis.postMessage({infoKey:\"character\",characterId:t,piece:e},s)}getFont(t){return this.fonts.get(t)}setFont(t,e){this.fonts.set(t,e)}setTextSetting(t,e){this.textSettings.set(t,e)}setGrid(t,e){this.grids.set(t,e)}showFrame(t,e,s,a){let i,r;const h=s-1|0,o=e.frameLabel;i=o.length;for(let e=0;e<i;++e){const a=o[e];a.name in this.frameInfo&&(a.frame=this.frameInfo[\"@\"+a.name]),t._$labels.push({label:a.name,frame:a.frame||s})}const n=e.sounds;i=0|n.length,i&&t._$sounds.push({frame:s,data:n.slice(0)});const l=e.removeObjects;i=l.length;for(let e=0;e<i;++e){const a=l[e],i=Util.$getControllerAt(t,h,a.Depth);t._$dictionary[i].EndFrame=s,Util.$installed.set(a.Depth,1)}s in a||(a[s]=[]),s in t._$controller||(t._$controller[s]=[]),s in t._$placeMap||(t._$placeMap[s]=[]);const c=e.placeObjects,b=h?a[h]:null;i=c.length;for(let e=0;e<i;++e){let i=null;const r=c[e];let o=null;h&&r.Depth in b&&(o=b[r.Depth]),0===r.PlaceFlagHasCharacter&&o&&(r.CharacterId=o.CharacterId);let n=!1;if((0===r.PlaceFlagMove||1===r.PlaceFlagMove&&1===r.PlaceFlagHasCharacter)&&(n=!0),h&&!n&&(i=Util.$getControllerAt(t,h,r.Depth),null===i&&(n=!0)),1===r.PlaceFlagMove&&o&&(1!==o.PlaceFlagHasMatrix||r.PlaceFlagHasMatrix||(r.PlaceFlagHasMatrix=1,r.Matrix=o.Matrix),1!==o.PlaceFlagHasColorTransform||r.PlaceFlagHasColorTransform||(r.PlaceFlagHasColorTransform=1,r.ColorTransform=o.ColorTransform),1!==o.PlaceFlagHasClipDepth||r.PlaceFlagHasClipDepth||(r.PlaceFlagHasClipDepth=1,r.ClipDepth=o.ClipDepth),1!==o.PlaceFlagHasRatio||r.PlaceFlagHasRatio||(r.PlaceFlagHasRatio=1,r.Ratio=o.Ratio),1!==o.PlaceFlagHasFilterList||r.PlaceFlagHasFilterList||(r.PlaceFlagHasFilterList=1,r.SurfaceFilterList=o.SurfaceFilterList),1!==o.PlaceFlagHasBlendMode||r.PlaceFlagHasBlendMode||(r.PlaceFlagHasBlendMode=1,r.BlendMode=o.BlendMode)),h&&!Util.$installed.has(r.Depth)){const e=Util.$getControllerAt(t,h,r.Depth);if(null!==e){const a=t._$dictionary[e];!a||0!==r.PlaceFlagMove&&1!==r.PlaceFlagHasCharacter||(a.EndFrame=0|s,t._$dictionary[e]=a,n=!0)}}if(n){if(r.StartFrame=0|s,r.EndFrame=0,1===r.PlaceFlagHasCharacter&&1===r.PlaceFlagMove){const e=Util.$getControllerAt(t,h,r.Depth),a=t._$dictionary[e];a.EndFrame=0|s,t._$dictionary[e]=a}i=Util.$addDictionary(t,r)}t._$controller[s][r.Depth]=i;const l=t._$placeObjects.length;t._$placeObjects[l]=this.buildPlaceObject(r),t._$placeMap[s][r.Depth]=l,Util.$installed.set(r.Depth,1),a[s][r.Depth]=r}if(h){let e;const o=t._$controller[h];r=Object.keys(o),i=r.length;for(let n=0;n<i;++n)e=0|r[n],Util.$installed.has(e)||(a[s][e]=a[h][e],t._$controller[s][e]=o[e]);const n=t._$placeMap[h];r=Object.keys(n),i=r.length;for(let a=0;a<i;++a)e=r[a],e in t._$placeMap[s]||(t._$placeMap[s][e]=n[e])}Util.$installed.clear()}buildPlaceObject(t){const e={matrix:[1,0,0,1,0,0],colorTransform:[1,1,1,1,0,0,0,0],filters:null,blendMode:\"normal\"};return t.PlaceFlagHasMatrix&&(e.matrix=t.Matrix),t.PlaceFlagHasColorTransform&&(e.colorTransform=t.ColorTransform),t.PlaceFlagHasFilterList&&(e.surfaceFilterList=t.SurfaceFilterList),t.PlaceFlagHasBlendMode&&(e.blendMode=Util.$getBlendName(t.BlendMode)),t.PlaceFlagHasRatio&&(e.ratio=t.Ratio||0),e}postData(t){if(this.textSettings.size){for(let[t,e]of this.textSettings){const s=this.characters[t];s&&(s._$textSetting=e,globalThis.postMessage({infoKey:\"character\",characterId:t,piece:s}))}this.textSettings.clear()}if(this.grids.size){for(let[t,e]of this.grids){const s=this.characters[t];s&&(s._$grid=e,globalThis.postMessage({infoKey:\"character\",characterId:t,piece:s}))}this.grids.clear()}if(this.fonts.size){for(let[t,e]of this.fonts){if(!e._$hasLayout){globalThis.postMessage({infoKey:\"font\",index:t,piece:e});continue}const s=e._$glyphShapeTable,a=e._$zoneTable;e._$glyphShapeTable=[],e._$zoneTable=a?[]:null,globalThis.postMessage({infoKey:\"font\",index:t,piece:e},[e._$advanceTable.buffer,e._$codeTable.buffer]);const i=s.length;if(i){const e=[],a=[];for(let r=0;r<i;++r){const i=s[r];e.push(i),a.push(i.records.buffer),e.length>256&&(globalThis.postMessage({infoKey:\"font_shape\",index:t,pieces:e},a),a.length=0,e.length=0)}e.length&&globalThis.postMessage({infoKey:\"font_shape\",index:t,pieces:e},a)}if(a)for(;a.length;){const e=Math.min(256,a.length);globalThis.postMessage({infoKey:\"font_zone\",index:t,pieces:a.splice(0,e)})}}this.fonts.clear()}for(let e=1;e<t._$controller.length;++e){const s=t._$controller[e];t._$controller[e]=s.filter((()=>!0))}this.setCharacter(0,t)}parseTags(t,e){const s=Util.$getTagObject();let a=1;const i=[],r=this.byteStream;for(;r.byte_offset<t;){const h=r.byte_offset;if(h+2>t)break;const o=r.getUI16(),n=o>>6;let l=63&o;if(63===l){if(h+6>t){r.byte_offset=h,r.bit_offset=0;break}l=r.getUI32()}const c=r.byte_offset;this.parseTag(n,l,e,a,s,i),1===n&&(++a,s.placeObjects.length=0,s.sounds.length=0,s.removeObjects.length=0,s.frameLabel.length=0);const b=r.byte_offset-c|0;b!==l&&b<l&&(r.byte_offset=r.byte_offset+(l-b)),r.bit_offset=0}Util.$poolTagObject(s)}parseTag(t,e,s,a,i,r){switch(t){case 28:i.removeObjects.push({Frame:a,Depth:this.byteStream.getUI16()});break;case 4:case 26:case 70:i.placeObjects.push(this.parsePlaceObject(t,e));break;case 39:{const t=this.byteStream.byte_offset+e,s=this.byteStream.getUI16();this.byteStream.getUI16();const a=Util.$createMovieClip();a._$characterId=s,this.parseTags(t,a);for(let t=1;t<a._$controller.length;++t){const e=a._$controller[t];a._$controller[t]=e.filter((()=>!0))}this.setCharacter(s,a)}break;case 1:this.showFrame(s,i,a,r);break;case 2:case 22:case 32:case 83:e<10?this.byteStream.byte_offset+=e:this.parseDefineShape(t);break;case 20:case 36:this.parseDefineBitsLossLess(t,e);break;case 6:case 21:case 35:case 90:this.parseDefineBits(t,e,this.jpegTables);break;case 15:case 89:i.sounds.push(this.parseStartSound(t));break;case 10:case 48:case 75:this.parseDefineFont(t,e);break;case 14:this.parseDefineSound(e);break;case 13:case 62:this.parseDefineFontInfo(t,e);break;case 43:i.frameLabel.push(this.parseFrameLabel());break;case 11:case 33:this.parseDefineText(t);break;case 37:this.parseDefineEditText(t);break;case 7:case 34:this.parseDefineButton(t,e);break;case 88:this.parseDefineFontName();break;case 8:e&&(this.jpegTables=this.parseJPEGTables(e));break;case 46:case 84:this.parseDefineMorphShape(t);break;case 18:case 45:this.parseSoundStreamHead(t);break;case 17:this.parseDefineButtonSound();break;case 73:this.parseDefineFontAlignZones();break;case 74:this.parseCSMTextSettings(t);break;case 19:this.parseSoundStreamBlock(t,e);break;case 78:this.parseDefineScalingGrid();break;case 5:console.log(\"TODO RemoveObject type 5.\"),i.removeObjects.push({CharacterId:this.byteStream.getUI16(),Depth:this.byteStream.getUI16()});break;case 76:this.parseSymbolClass();break;case 0:case 27:case 30:case 67:case 68:case 79:case 80:case 81:case 85:case 92:default:break;case 86:case 56:case 9:case 40:case 24:case 63:case 64:case 69:case 65:case 77:case 60:case 61:case 41:case 87:case 59:case 12:case 72:case 82:this.byteStream.byte_offset+=e;break;case 3:case 16:case 23:case 25:case 29:case 31:case 38:case 42:case 44:case 47:case 49:case 52:case 53:case 54:case 55:case 57:case 58:case 66:case 71:case 91:case 93:console.log(\"[TODO] tagType -> \"+t)}}parseSymbolClass(){const t=this.byteStream.getUI16();if(t){const e=[];for(let s=0;s<t;++s){const t=this.byteStream.getUI16(),s=this.byteStream.getDataUntil();e[e.length]={tagId:t,ns:s},128===e.length&&(globalThis.postMessage({infoKey:\"_$symbols\",pieces:e}),e.length=0)}e.length&&globalThis.postMessage({infoKey:\"_$symbols\",pieces:e})}}parseDefineShape(t){const e=0|this.byteStream.getUI16(),s=this.rect();if(83===t){const t={};this.rect(),this.byteStream.getUIBits(5),t.UsesFillWindingRule=this.byteStream.getUIBits(1),t.UsesNonScalingStrokes=this.byteStream.getUIBits(1),t.UsesScalingStrokes=this.byteStream.getUIBits(1)}const a=this.shapeWithStyle(t);this.setCharacter(e,{_$records:a,_$name:\"Shape\",_$bounds:s,_$characterId:e},[a.ShapeData.records.buffer])}rect(){this.byteStream.byteAlign();const t=this.byteStream.getUIBits(5);return{xMin:this.byteStream.getSIBits(t)/20,xMax:this.byteStream.getSIBits(t)/20,yMin:this.byteStream.getSIBits(t)/20,yMax:this.byteStream.getSIBits(t)/20}}shapeWithStyle(t){const e={};switch(t){case 46:case 84:break;default:e.fillStyles=this.fillStyleArray(t),e.lineStyles=this.lineStyleArray(t)}const s=this.byteStream.getUI8(),a=s>>4,i=15&s;return e.ShapeData=this.shapeRecords(t,{FillBits:a,LineBits:i}),e}fillStyleArray(t){let e=0|this.byteStream.getUI8();t>2&&255===e&&(e=this.byteStream.getUI16());const s=[];for(let a=0;a<e;++a)s[s.length]=this.fillStyle(t);return s}fillStyle(t){const e=this.byteStream.getUI8(),s={};switch(s.fillStyleType=e,e){case 0:switch(t){case 32:case 83:s.Color=this.rgba();break;case 46:case 84:s.StartColor=this.rgba(),s.EndColor=this.rgba();break;default:s.Color=this.rgb()}break;case 16:case 18:switch(t){case 46:case 84:s.startGradientMatrix=this.matrix(),s.endGradientMatrix=this.matrix(),s.gradient=this.gradient(t);break;default:s.gradientMatrix=this.matrix(),s.gradient=this.gradient(t)}break;case 19:s.gradientMatrix=this.matrix(),s.gradient=this.focalGradient(t);break;case 64:case 65:case 66:case 67:switch(s.bitmapId=this.byteStream.getUI16(),t){case 46:case 84:s.startBitmapMatrix=this.matrix(),s.endBitmapMatrix=this.matrix();break;default:s.bitmapMatrix=this.matrix()}}return s}rgb(){return{R:0|this.byteStream.getUI8(),G:0|this.byteStream.getUI8(),B:0|this.byteStream.getUI8(),A:1}}rgba(){return{R:this.byteStream.getUI8(),G:this.byteStream.getUI8(),B:this.byteStream.getUI8(),A:this.byteStream.getUI8()/255}}matrix(){this.byteStream.byteAlign();const t=[1,0,0,1,0,0];if(this.byteStream.getUIBit()){const e=this.byteStream.getUIBits(5);t[0]=this.byteStream.getSIBits(e)/65536,t[3]=this.byteStream.getSIBits(e)/65536}if(this.byteStream.getUIBit()){const e=this.byteStream.getUIBits(5);t[1]=this.byteStream.getSIBits(e)/65536,t[2]=this.byteStream.getSIBits(e)/65536}const e=this.byteStream.getUIBits(5);return t[4]=this.byteStream.getSIBits(e)/20,t[5]=this.byteStream.getSIBits(e)/20,t}gradient(t){let e,s=0,a=0;switch(this.byteStream.byteAlign(),t){case 46:case 84:e=this.byteStream.getUI8();break;default:s=this.byteStream.getUIBits(2),a=this.byteStream.getUIBits(2),e=this.byteStream.getUIBits(4)}const i=[];for(let s=0;s<e;++s)i[i.length]=this.gradientRecord(t);return{SpreadMode:s,InterpolationMode:a,GradientRecords:i,FocalPoint:0}}gradientRecord(t){switch(t){case 46:case 84:return{StartRatio:this.byteStream.getUI8()/255,StartColor:this.rgba(),EndRatio:this.byteStream.getUI8()/255,EndColor:this.rgba()};default:return{Ratio:this.byteStream.getUI8()/255,Color:t<32?this.rgb():this.rgba()}}}focalGradient(t){this.byteStream.byteAlign();const e=this.byteStream.getUIBits(2),s=this.byteStream.getUIBits(2),a=this.byteStream.getUIBits(4),i=[];for(let e=0;e<a;++e)i[i.length]=this.gradientRecord(t);return{SpreadMode:e,InterpolationMode:s,GradientRecords:i,FocalPoint:this.byteStream.getFloat16()}}lineStyleArray(t){let e=this.byteStream.getUI8();t>2&&255===e&&(e=this.byteStream.getUI16());const s=[];for(let a=0;a<e;++a)s[s.length]=this.lineStyles(t);return s}lineStyles(t){const e={fillStyleType:0};switch(t){case 46:e.StartWidth=this.byteStream.getUI16()/20,e.EndWidth=this.byteStream.getUI16()/20,e.StartColor=this.rgba(),e.EndColor=this.rgba();break;case 84:e.StartWidth=this.byteStream.getUI16()/20,e.EndWidth=this.byteStream.getUI16()/20,e.StartCapStyle=this.byteStream.getUIBits(2),e.JoinStyle=this.byteStream.getUIBits(2),e.HasFillFlag=this.byteStream.getUIBit(),e.NoHScaleFlag=this.byteStream.getUIBit(),e.NoVScaleFlag=this.byteStream.getUIBit(),e.PixelHintingFlag=this.byteStream.getUIBit(),this.byteStream.getUIBits(5),e.NoClose=this.byteStream.getUIBit(),e.EndCapStyle=this.byteStream.getUIBits(2),2===e.JoinStyle&&(e.MiterLimitFactor=this.byteStream.getUI16()/20),e.HasFillFlag?e.FillType=this.fillStyle(t):(e.StartColor=this.rgba(),e.EndColor=this.rgba());break;case 83:e.Width=this.byteStream.getUI16()/20,e.StartCapStyle=this.byteStream.getUIBits(2),e.JoinStyle=this.byteStream.getUIBits(2),e.HasFillFlag=this.byteStream.getUIBit(),e.NoHScaleFlag=this.byteStream.getUIBit(),e.NoVScaleFlag=this.byteStream.getUIBit(),e.PixelHintingFlag=this.byteStream.getUIBit(),this.byteStream.getUIBits(5),e.NoClose=this.byteStream.getUIBit(),e.EndCapStyle=this.byteStream.getUIBits(2),2===e.JoinStyle&&(e.MiterLimitFactor=this.byteStream.getUI16()),e.HasFillFlag?e.FillType=this.fillStyle(t):e.Color=this.rgba();break;case 32:e.Width=this.byteStream.getUI16()/20,e.Color=this.rgba(),e.JoinStyle=0,e.StartCapStyle=0,e.EndCapStyle=0;break;default:e.Width=this.byteStream.getUI16()/20,e.Color=this.rgb(),e.JoinStyle=0,e.StartCapStyle=0,e.EndCapStyle=0}return e}shapeRecords(t,e){this.currentPosition.x=0,this.currentPosition.y=0;const s=[],a=[];for(;;){const i=this.byteStream.getUIBits(6);if(32&i){const e=15&i;if(16&i){this.straightEdgeRecord(t,e,s);continue}this.curvedEdgeRecord(t,e,s)}else{if(!i){s.push(-1),this.byteStream.byteAlign();break}this.styleChangeRecord(t,i,e,s,a)}}const i={records:new Int32Array(s)};return a.length&&(i.styles=a),i}straightEdgeRecord(t,e,s){let a=0,i=0;this.byteStream.getUIBit()?(a=this.byteStream.getSIBits(e+2),i=this.byteStream.getSIBits(e+2)):this.byteStream.getUIBit()?i=this.byteStream.getSIBits(e+2):a=this.byteStream.getSIBits(e+2);let r=a,h=i;switch(t){case 46:case 84:break;default:r=this.currentPosition.x+a,h=this.currentPosition.y+i,this.currentPosition.x=r,this.currentPosition.y=h}s.push(0,0,r,h)}curvedEdgeRecord(t,e,s){const a=this.byteStream.getSIBits(e+2),i=this.byteStream.getSIBits(e+2),r=this.byteStream.getSIBits(e+2),h=this.byteStream.getSIBits(e+2);let o=a,n=i,l=r,c=h;switch(t){case 46:case 84:break;default:o=this.currentPosition.x+a,n=this.currentPosition.y+i,l=o+r,c=n+h,this.currentPosition.x=l,this.currentPosition.y=c}s.push(0,1,o,n,l,c)}styleChangeRecord(t,e,s,a,i){const r=e>>4&1,h=e>>3&1,o=e>>2&1,n=e>>1&1,l=1&e;let c=0,b=0;if(l){const t=this.byteStream.getUIBits(5);c=this.byteStream.getSIBits(t),b=this.byteStream.getSIBits(t),this.currentPosition.x=c,this.currentPosition.y=b}const g=n?this.byteStream.getUIBits(s.FillBits):0,y=o?this.byteStream.getUIBits(s.FillBits):0,S=h?this.byteStream.getUIBits(s.LineBits):0;let m=null,f=null,d=0,Y=0;if(r){m=this.fillStyleArray(t),f=this.lineStyleArray(t);const e=this.byteStream.getUI8();s.FillBits=d=e>>4,s.LineBits=Y=15&e}a.push(1,r),r&&(a.push(d,Y),i.push({FillStyles:m,LineStyles:f})),a.push(l),l&&a.push(c,b),a.push(n),n&&a.push(g),a.push(o),o&&a.push(y),a.push(h),h&&a.push(S)}parseDefineBitsLossLess(t,e){const s=this.byteStream.byte_offset,a=this.byteStream.getUI16(),i=this.byteStream.getUI8(),r=this.byteStream.getUI16(),h=this.byteStream.getUI16(),o=36===t,n=3===i?this.byteStream.getUI8()+1:0;let l=r*h*4;if(3===i){l=(r+((r+3&-4)-r|0))*h+n*(o?4:3)}const c=e-(this.byteStream.byte_offset-s),b=this.byteStream.byte_offset;this.byteStream.byte_offset+=c;const g=this.byteStream.data.slice(b,this.byteStream.byte_offset),y={width:r,height:h,format:i,fileSize:l,tableSize:n,isAlpha:o,color:o?4278190080:0,_$name:\"lossless\",_$characterId:a,buffer:g};this.setCharacter(a,y,[g.buffer])}parseJPEGTables(t){const e=this.byteStream.byte_offset;return this.byteStream.byte_offset+=t,{offset:e,length:this.byteStream.byte_offset}}parseDefineBits(t,e,s=null){const a=this.byteStream.byte_offset,i=this.byteStream.getUI16(),r=this.byteStream.byte_offset-a,h=35===t||90===t?this.byteStream.getUI32():e-r;if(90===t){const t=this.byteStream.getUI16();console.log(\"TODO DeblockParam\",t)}const o=this.byteStream.byte_offset;this.byteStream.byte_offset+=h;let n=this.byteStream.data.slice(o,this.byteStream.byte_offset);if(s){const t=this.byteStream.data.subarray(s.offset,s.length);if(t.length>4&&255===n[0]&&216===n[1]){const e=t.length-2,s=n.length,a=new Uint8Array(e+s);a.set(t.subarray(0,e),0),a.set(n.subarray(2,s),e),n=a}}const l={infoKey:\"character\",_$name:\"imageData\",_$characterId:i,jpegData:n,alphaData:null},c=[];c.push(n.buffer);let b=!1;const g=a+e-this.byteStream.byte_offset;if(g){b=!0;const t=this.byteStream.byte_offset;this.byteStream.byte_offset+=g;const e=this.byteStream.data.slice(t,this.byteStream.byte_offset);l.alphaData=e,c.push(e.buffer)}l.isAlpha=b,l.color=b?4278190080:0,this.setCharacter(i,l,c)}parseDefineFont(t,e){const s=this.byteStream.byte_offset+e|0,a=this.byteStream.getUI16(),i=this.getFont(a)||{};let r=0,h=0,o=0;if(48===t||75===t){const t=this.byteStream.getUI8();i._$hasLayout=t>>>7&1,i._$shiftJIS=t>>>6&1,i._$smallText=t>>>5&1,i._$ANSI=t>>>4&1,h=t>>>3&1,o=t>>>2&1,i._$italic=t>>>1&1,i._$bold=1&t,this.byteStream.byteAlign(),i._$languageCode=this.byteStream.getUI8();const e=this.byteStream.getUI8();if(e){const t=0|this.byteStream.byte_offset;i._$fontName=this.getFontName(this.byteStream.getDataUntil()),this.byteStream.byte_offset=t+e|0}r=this.byteStream.getUI16(),i._$numGlyphs=r}const n=0|this.byteStream.byte_offset;if(10===t&&(r=this.byteStream.getUI16()),r){const e=[];10===t&&(e[0]=r,r/=2,r-=1);let s=0;if(1===h){for(let t=0;t<r;++t)e[e.length]=this.byteStream.getUI32();10!==t&&(s=this.byteStream.getUI32())}else{for(let t=0;t<r;++t)e[e.length]=this.byteStream.getUI16();10!==t&&(s=this.byteStream.getUI16())}const a=[];10===t&&(r+=1);for(let s=0;s<r;++s){this.byteStream.setOffset(e[s]+n,0);const i=this.byteStream.getUI8(),r={FillBits:i>>4,LineBits:15&i};a[a.length]=this.shapeRecords(t,r)}switch(i._$glyphShapeTable=a,t){case 48:case 75:if(this.byteStream.setOffset(s+n,0),1===o){const t=new Uint16Array(r);for(let e=0;e<r;++e)t[e]=this.byteStream.getUI16();i._$codeTable=t}else{const t=new Uint8Array(r);for(let e=0;e<r;++e)t[e]=this.byteStream.getUI8();i._$codeTable=t}if(i._$hasLayout){i._$ascent=this.byteStream.getUI16(),i._$descent=this.byteStream.getUI16(),i._$leading=this.byteStream.getUI16();const e=new Uint16Array(r);for(let t=0;t<r;++t)e[t]=this.byteStream.getUI16();i._$advanceTable=e;const s=[];for(let t=0;t<r;++t)s[s.length]=this.rect();if(75===t){const t=this.byteStream.getUI16(),e=[];for(let s=0;s<t;++s){const t=o?this.byteStream.getUI16():this.byteStream.getUI8(),s=o?this.byteStream.getUI16():this.byteStream.getUI8(),a=this.byteStream.getSIBits(16);e[e.length]={FontKerningCode1:t,FontKerningCode2:s,FontKerningAdjustment:a}}i._$kerningRecords=e}}}}this.byteStream.byte_offset=0|s,this.setFont(a,i)}parseDefineFontInfo(t,e){const s=this.byteStream.byte_offset+e|0,a=this.byteStream.getUI16();let i=this.getFont(a);i||(i={});const r=this.byteStream.getUI8(),h=this.byteStream.getData(r);let o=\"\";for(let t=0;t<r;++t)h[t]>127||(o+=String.fromCharCode(h[t]));this.byteStream.getUIBits(2),i._$smallText=this.byteStream.getUIBits(1),i._$shiftJIS=this.byteStream.getUIBits(1),i._$ANSI=this.byteStream.getUIBits(1),i._$italic=this.byteStream.getUIBits(1),i._$bold=this.byteStream.getUIBits(1);const n=this.byteStream.getUIBits(1);62===t&&(i._$languageCode=this.byteStream.getUI8());const l=i._$shiftJIS||2===i._$languageCode?Util.$decodeToShiftJis(o):decodeURIComponent(o);i._$fontName=this.getFontName(l),this.byteStream.byteAlign();const c=[];let b=null;if(!0==(1===n||62===t)){for(;this.byteStream.byte_offset<s;)c[c.length]=this.byteStream.getUI16();b=new Uint16Array(c)}else{for(;this.byteStream.byte_offset<s;)c[c.length]=this.byteStream.getUI8();b=new Uint8Array(c)}i._$codeTable=b,this.setFont(a,i)}getFontName(t){const e=0|t.length;switch(0===t.substr(e-1).charCodeAt(0)&&(t=t.slice(0,-1)),t){case\"_sans\":return\"_sans\";case\"_serif\":return\"_serif\";case\"_typewriter\":return\"_typewriter\";case\"_等幅\":return\"Osaka\";default:return\"_\"===t.substr(0,1)?\"sans-serif\":t}}parseDefineFontName(){this.byteStream.getUI16(),this.byteStream.getDataUntil(),this.byteStream.getDataUntil()}parseDefineText(t){const e={_$name:\"StaticText\"};e._$characterId=0|this.byteStream.getUI16(),e._$bounds=this.rect(),e._$baseMatrix=this.matrix(),e._$shapeRecords=null;const s=this.byteStream.getUI8(),a=this.byteStream.getUI8();e._$textRecords=this.getTextRecords(t,s,a),this.setCharacter(e._$characterId,e)}getTextRecords(t,e,s){const a=[];for(;0!==this.byteStream.getUI8();){this.byteStream.incrementOffset(-1,0);const i={};i.TextRecordType=this.byteStream.getUIBits(1),i.StyleFlagsReserved=this.byteStream.getUIBits(3),i.StyleFlagsHasFont=this.byteStream.getUIBits(1),i.StyleFlagsHasColor=this.byteStream.getUIBits(1),i.StyleFlagsHasYOffset=this.byteStream.getUIBits(1),i.StyleFlagsHasXOffset=this.byteStream.getUIBits(1),i.StyleFlagsHasFont&&(i.FontId=this.byteStream.getUI16()),i.StyleFlagsHasColor&&(i.TextColor=11===t?this.rgb():this.rgba()),i.StyleFlagsHasXOffset&&(i.XOffset=this.byteStream.getUI16()/20),i.StyleFlagsHasYOffset&&(i.YOffset=this.byteStream.getUI16()/20),i.StyleFlagsHasFont&&(i.TextHeight=this.byteStream.getUI16()),i.GlyphCount=this.byteStream.getUI8(),i.GlyphEntries=this.getGlyphEntries(i.GlyphCount,e,s),a[a.length]=i}return a}getGlyphEntries(t,e,s){const a=[];for(let i=0;i<t;++i)a[a.length]={GlyphIndex:this.byteStream.getUIBits(e),GlyphAdvance:this.byteStream.getSIBits(s)/20};return a}parseDefineEditText(){const t={_$ns:[\"flash\",\"text\"],_$name:\"TextField\"},e={},s=this.byteStream.getUI16();t._$characterId=s,t._$bounds=this.rect();const a=this.byteStream.getUI8(),i=a>>>7&1;t._$wordWrap=a>>>6&1,t._$multiline=a>>>5&1,t._$displayAsPassword=a>>>4&1;const r=a>>>3&1;t._$type=\"dynamic\",r||(t._$type=\"input\");const h=a>>>2&1,o=a>>>1&1,n=1&a,l=this.byteStream.getUI8(),c=l>>>7&1,b=l>>>5&1;t._$selectable=l>>>4&1,t._$border=l>>>3&1;const g=l>>>1&1,y=1&l;t._$border&&(t._$background=!0);let S=0;if(n){const s=this.byteStream.getUI16(),a=this.getFont(s);if(a){if(S=a._$shiftJIS,c){const t=this.byteStream.getDataUntil();console.log(\"TODO HasFontClass: \",t)}e._$font=a._$fontName,e._$size=this.byteStream.getUI16()/20,t._$fontId=0|s,t._$embedFonts=!(!y&&\"embedded\"!==a.fontType||t.displayAsPassword)}}if(h){const e=this.rgba();t._$textColor=(e.R<<16)+(e.G<<8)+e.B+255*e.A*16777216}if(o&&(t._$maxChars=this.byteStream.getUI16()),b){switch(this.byteStream.getUI8()){case 0:e._$align=\"left\";break;case 1:e._$align=\"right\";break;case 2:e._$align=\"center\";break;case 3:e._$align=\"justify\"}e._$leftMargin=this.byteStream.getUI16()/20,e._$rightMargin=this.byteStream.getUI16()/20,e._$indent=this.byteStream.getUI16(),e._$indent>=32768&&(e._$indent-=65536),e._$leading=this.byteStream.getUI16(),e._$leading>=32768&&(e._$leading-=65536),e._$indent/=20,e._$leading/=20}const m=this.byteStream.getDataUntil(S)+\"\";if(t._$text=\"\",i){const e=this.byteStream.getDataUntil(S);if(!0==(1===g))t._$htmlText=e,t._$initText=!0;else t._$text=e}\"\"!==m&&console.log(\"VariableName: \",m),t._$defaultTextFormat=[null,e._$font,e._$size,e._$color,e._$bold,e._$italic,e._$underline,e._$url,e._$target,e._$align,e._$leftMargin,e._$rightMargin,0,e._$leading,e._$indent],this.setCharacter(s,t)}parseDefineMorphShape(t){const e={};e.CharacterId=this.byteStream.getUI16(),e.StartBounds=this.rect(),e.EndBounds=this.rect(),84===t&&(e.StartEdgeBounds=this.rect(),e.EndEdgeBounds=this.rect(),this.byteStream.getUIBits(6),e.UsesNonScalingStrokes=this.byteStream.getUIBits(1),e.UsesScalingStrokes=this.byteStream.getUIBits(1));const s=this.byteStream.getUI32(),a=this.byteStream.byte_offset+s;e.MorphFillStyles=this.fillStyleArray(t),e.MorphLineStyles=this.lineStyleArray(t),e.StartEdges=this.shapeWithStyle(t),this.byteStream.byte_offset!==a&&(this.byteStream.byte_offset=a),e.EndEdges=this.shapeWithStyle(t);const i={x:0,y:0},r={x:0,y:0},h=e.StartEdges.ShapeData.records,o=e.EndEdges.ShapeData.records,n=h.length,l=o.length;let c=Math.max(n,l);const b=[],g=[];let y=0,S=0;for(;c>y||c>S;){const t=h[y++],e=o[S++];if(-1===t&&-1===e)break;switch(!0){case-1===t:case void 0===t:if(e){const t=o[S++];if(g.push(1,t),b.push(1,t),t){const t=o[S++],e=o[S++];g.push(t,e),b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const e=o[S++];if(g.push(e),b.push(e),e){const t=o[S++],e=o[S++];r.x=t,r.y=e,g.push(t,e),b.push(t,e)}const s=o[S++];if(g.push(s),b.push(s),s){const t=o[S++];g.push(t),b.push(t)}const a=o[S++];if(g.push(a),b.push(a),a){const t=o[S++];g.push(t),b.push(t)}const i=o[S++];if(g.push(i),b.push(i),i){const t=o[S++];g.push(t),b.push(t)}break}if(o[S++]){const t=o[S++],e=o[S++],s=o[S++],a=o[S++];r.x+=t+s,r.y+=e+a,g.push(0,1,t,e,s,a),b.push(0,1,t,e,s,a)}else{const t=o[S++],e=o[S++];r.x+=t,r.y+=e,g.push(0,0,t,e),b.push(0,0,t,e)}break;case-1===e:case void 0===e:if(t){const t=h[y++];if(g.push(1,t),b.push(1,t),t){const t=h[y++],e=h[y++];g.push(t,e),b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const e=h[y++];if(g.push(e),b.push(e),e){const t=h[y++],e=h[y++];i.x=t,i.y=e,g.push(t,e),b.push(t,e)}const s=h[y++];if(g.push(s),b.push(s),s){const t=h[y++];g.push(t),b.push(t)}const a=h[y++];if(g.push(a),b.push(a),a){const t=h[y++];g.push(t),b.push(t)}const r=h[y++];if(g.push(r),b.push(r),r){const t=h[y++];g.push(t),b.push(t)}break}if(h[y++]){const t=h[y++],e=h[y++],s=h[y++],a=h[y++];i.x+=t+s,i.y+=e+a,g.push(0,1,t,e,s,a),b.push(0,1,t,e,s,a)}else{const t=h[S++],e=h[S++];i.x+=t,i.y+=e,g.push(0,0,t,e),b.push(0,0,t,e)}break;case 1===t&&1===e:const s=h[y++];if(b.push(1,s),s){const t=h[y++],e=h[y++];b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const a=h[y++];if(b.push(a),a){const t=h[y++],e=h[y++];i.x=t,i.y=e,b.push(t,e)}const n=h[y++];if(b.push(n),n){const t=h[y++];b.push(t)}const l=h[y++];if(b.push(l),l){const t=h[y++];b.push(t)}const c=h[y++];if(b.push(c),c){const t=h[y++];b.push(t)}const m=o[S++];if(g.push(1,m),m){const t=o[S++],e=o[S++];g.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const f=o[S++];if(g.push(f),f){const t=o[S++],e=o[S++];i.x=t,i.y=e,g.push(t,e)}const d=o[S++];if(g.push(d),d){const t=o[S++];g.push(t)}const Y=o[S++];if(g.push(Y),Y){const t=o[S++];g.push(t)}const I=o[S++];if(g.push(I),I){const t=o[S++];g.push(t)}break;case 0===t&&0===e:if(h[y++]){const t=h[y++],e=h[y++],s=h[y++],a=h[y++];i.x=s,i.y=a,b.push(0,1,t,e,s,a)}else{const t=h[y++],e=h[y++];i.x=t,i.y=e,b.push(0,0,t,e)}if(o[S++]){const t=o[S++],e=o[S++],s=o[S++],a=o[S++];r.x=s,r.y=a,g.push(0,1,t,e,s,a)}else{const t=o[S++],e=o[S++];r.x=t,r.y=e,g.push(0,0,t,e)}break;case 1===t&&0===e:{const t=h[y++];if(g.push(1,t),b.push(1,t),t){const t=h[y++],e=h[y++];g.push(t,e),b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const e=h[y++];if(g.push(e),b.push(e),e){const t=h[y++],e=h[y++];i.x=t,i.y=e,g.push(t,e),b.push(t,e)}const s=h[y++];if(g.push(s),b.push(s),s){const t=h[y++];g.push(t),b.push(t)}const a=h[y++];if(g.push(a),b.push(a),a){const t=h[y++];g.push(t),b.push(t)}const r=h[y++];if(g.push(r),b.push(r),r){const t=h[y++];g.push(t),b.push(t)}--S}break;case 0===t&&1===e:{const t=o[S++];if(g.push(1,t),b.push(1,t),t){const t=o[S++],e=o[S++];g.push(t,e),b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const e=o[S++];if(g.push(e),b.push(e),e){const t=o[S++],e=o[S++];r.x=t,r.y=e,g.push(t,e),b.push(t,e)}const s=o[S++];if(g.push(s),b.push(s),s){const t=o[S++];g.push(t),b.push(t)}const a=o[S++];if(g.push(a),b.push(a),a){const t=o[S++];g.push(t),b.push(t)}const i=o[S++];if(g.push(i),b.push(i),i){const t=o[S++];g.push(t),b.push(t)}--y}}}b.push(-1),g.push(-1),e.StartEdges.ShapeData.records=new Int32Array(b),e.EndEdges.ShapeData.records=new Int32Array(g),this.setCharacter(e.CharacterId,{_$ns:[\"flash\",\"display\"],_$name:\"MorphShape\",_$characterId:e.CharacterId,_$endBounds:e.EndBounds,_$endEdges:e.EndEdges,_$fillStyles:e.MorphFillStyles,_$lineStyles:e.MorphLineStyles,_$startBounds:e.StartBounds,_$startEdges:e.StartEdges,_$shapes:null,_$frameData:[],_$frameCreated:!1},[e.StartEdges.ShapeData.records.buffer,e.EndEdges.ShapeData.records.buffer])}parseFrameLabel(){return{name:this.byteStream.getDataUntil(),frame:0}}parseDefineButton(t,e){const s=this.byteStream.byte_offset+e|0,a={_$ns:[\"flash\",\"display\"],_$name:\"SimpleButton\"};a._$characterId=0|this.byteStream.getUI16();let i=0;7!==t&&(this.byteStream.getUIBits(7),a._$trackAsMenu=!!this.byteStream.getUIBits(1),i=0|this.byteStream.getUI16()),a._$characters=this.buttonCharacters(s),7===t?(i=s-this.byteStream.byte_offset|0,this.byteStream.byte_offset+=i):i>0&&(a._$actions=this.buttonActions(s)),this.setCharacter(a._$characterId,a),this.byteStream.byte_offset!==s&&(this.byteStream.byte_offset=0|s)}buttonCharacters(t){const e=[];for(;0!==this.byteStream.getUI8();){this.byteStream.incrementOffset(-1,0);const s=0|this.byteStream.byte_offset,a=this.buttonRecord();if(this.byteStream.byte_offset>t){this.byteStream.byte_offset=0|s;break}e[e.length]=a}return e}buttonRecord(){this.byteStream.getUIBits(2);const t={};return t.PlaceFlagHasBlendMode=this.byteStream.getUIBits(1),t.PlaceFlagHasFilterList=this.byteStream.getUIBits(1),t.ButtonStateHitTest=this.byteStream.getUIBits(1),t.ButtonStateDown=this.byteStream.getUIBits(1),t.ButtonStateOver=this.byteStream.getUIBits(1),t.ButtonStateUp=this.byteStream.getUIBits(1),t.CharacterId=this.byteStream.getUI16(),t.Depth=this.byteStream.getUI16(),t.PlaceFlagHasMatrix=1,t.Matrix=this.matrix(),t.ColorTransform=this.colorTransform(),t.PlaceFlagHasColorTransform=void 0===t.ColorTransform?0:1,t.PlaceFlagHasBlendMode&&(t.BlendMode=this.byteStream.getUI8()),t.PlaceFlagHasFilterList&&(t.SurfaceFilterList=this.getFilterList()),t.PlaceFlagHasRatio=0,t.PlaceFlagHasClipDepth=0,t.Sound=null,t}buttonActions(t){for(;;){const e={},s=0|this.byteStream.byte_offset,a=this.byteStream.getUI16();e.CondIdleToOverDown=this.byteStream.getUIBits(1),e.CondOutDownToIdle=this.byteStream.getUIBits(1),e.CondOutDownToOverDown=this.byteStream.getUIBits(1),e.CondOverDownToOutDown=this.byteStream.getUIBits(1),e.CondOverDownToOverUp=this.byteStream.getUIBits(1),e.CondOverUpToOverDown=this.byteStream.getUIBits(1),e.CondOverUpToIdle=this.byteStream.getUIBits(1),e.CondIdleToOverUp=this.byteStream.getUIBits(1),e.CondKeyPress=this.byteStream.getUIBits(7),e.CondOverDownToIdle=this.byteStream.getUIBits(1);const i=t-this.byteStream.byte_offset+1|0;if(this.byteStream.byte_offset+=i,!a)break;this.byteStream.byte_offset=s+a|0}return[]}parsePlaceObject(t,e){const s=this.byteStream.byte_offset,a={};if(a.tagType=t,4===t)return a.CharacterId=this.byteStream.getUI16(),a.Depth=this.byteStream.getUI16(),a.Matrix=this.matrix(),a.PlaceFlagHasMatrix=1,this.byteStream.byteAlign(),this.byteStream.byte_offset-s<e&&(a.ColorTransform=this.colorTransform(),a.PlaceFlagHasColorTransform=1),this.byteStream.byteAlign(),this.byteStream.byte_offset=s+e,a;const i=this.swfVersion;if(a.PlaceFlagHasClipActions=this.byteStream.getUIBits(1),a.PlaceFlagHasClipDepth=this.byteStream.getUIBits(1),a.PlaceFlagHasName=this.byteStream.getUIBits(1),a.PlaceFlagHasRatio=this.byteStream.getUIBits(1),a.PlaceFlagHasColorTransform=this.byteStream.getUIBits(1),a.PlaceFlagHasMatrix=this.byteStream.getUIBits(1),a.PlaceFlagHasCharacter=this.byteStream.getUIBits(1),a.PlaceFlagMove=this.byteStream.getUIBits(1),70===t&&(this.byteStream.getUIBits(1),a.PlaceFlagOpaqueBackground=this.byteStream.getUIBits(1),a.PlaceFlagHasVisible=this.byteStream.getUIBits(1),a.PlaceFlagHasImage=this.byteStream.getUIBits(1),a.PlaceFlagHasClassName=this.byteStream.getUIBits(1),a.PlaceFlagHasCacheAsBitmap=this.byteStream.getUIBits(1),a.PlaceFlagHasBlendMode=this.byteStream.getUIBits(1),a.PlaceFlagHasFilterList=this.byteStream.getUIBits(1)),a.Depth=this.byteStream.getUI16(),a.PlaceFlagHasClassName&&(a.ClassName=this.byteStream.getDataUntil(),console.log(\"TODO \",a.ClassName)),a.PlaceFlagHasCharacter&&(a.CharacterId=this.byteStream.getUI16()),a.PlaceFlagHasMatrix&&(a.Matrix=this.matrix()),a.PlaceFlagHasColorTransform&&(a.ColorTransform=this.colorTransform()),a.PlaceFlagHasRatio&&(a.Ratio=this.byteStream.getUI16()),a.PlaceFlagHasName&&(a.Name=this.byteStream.getDataUntil()),a.PlaceFlagHasClipDepth&&(a.ClipDepth=this.byteStream.getUI16()),70===t&&(a.PlaceFlagHasFilterList&&(a.SurfaceFilterList=this.getFilterList()),a.PlaceFlagHasBlendMode&&(a.BlendMode=this.byteStream.getUI8()),a.PlaceFlagHasCacheAsBitmap&&(a.BitmapCache=this.byteStream.getUI8()),a.PlaceFlagHasVisible&&(a.Visible=this.byteStream.getUI8()),a.PlaceFlagOpaqueBackground&&(a.BackgroundColor=this.rgba())),a.PlaceFlagHasClipActions){this.byteStream.getUI16(),a.AllEventFlags=this.parseClipEventFlags();const t=s+e;for(;this.byteStream.byte_offset<t;){const e=this.parseClipActionRecord(t);if(t<=this.byteStream.byte_offset)break;if(!(i<=5?this.byteStream.getUI16():this.byteStream.getUI32()))break;this.byteStream.byte_offset-=i<=5?2:4,e.KeyCode&&(this.byteStream.byte_offset-=1)}}return this.byteStream.byteAlign(),this.byteStream.byte_offset=s+e,a}parseClipActionRecord(t){const e={},s=this.parseClipEventFlags();if(t>this.byteStream.byte_offset){const t=this.byteStream.getUI32();s.keyPress&&(e.KeyCode=this.byteStream.getUI8()),this.byteStream.byte_offset+=t}return e}parseClipEventFlags(){const t=this.swfVersion,e={};return e.keyUp=this.byteStream.getUIBits(1),e.keyDown=this.byteStream.getUIBits(1),e.mouseUp=this.byteStream.getUIBits(1),e.mouseDown=this.byteStream.getUIBits(1),e.mouseMove=this.byteStream.getUIBits(1),e.unload=this.byteStream.getUIBits(1),e.enterFrame=this.byteStream.getUIBits(1),e.load=this.byteStream.getUIBits(1),t>=6&&(e.dragOver=this.byteStream.getUIBits(1),e.rollOut=this.byteStream.getUIBits(1),e.rollOver=this.byteStream.getUIBits(1),e.releaseOutside=this.byteStream.getUIBits(1),e.release=this.byteStream.getUIBits(1),e.press=this.byteStream.getUIBits(1),e.initialize=this.byteStream.getUIBits(1)),e.data=this.byteStream.getUIBits(1),t>=6&&(this.byteStream.getUIBits(5),e.construct=this.byteStream.getUIBits(1),e.keyPress=this.byteStream.getUIBits(1),e.dragOut=this.byteStream.getUIBits(1),this.byteStream.getUIBits(8)),this.byteStream.byteAlign(),e}getFilterList(){const t=0|this.byteStream.getUI8(),e=[];for(let s=0;s<t;++s){const t=this.getFilter();t&&(e[e.length]=t)}return e.length?e:null}getFilter(){switch(0|this.byteStream.getUI8()){case 0:return this.dropShadowFilter();case 1:return this.blurFilter();case 2:return this.glowFilter();case 3:return this.bevelFilter();case 4:return this.gradientGlowFilter();case 5:return this.convolutionFilter();case 6:return this.colorMatrixFilter();case 7:return this.gradientBevelFilter()}}dropShadowFilter(){const t={},e=this.rgba(),s=e.A,a=e.R<<16|e.G<<8|e.B,i=this.byteStream.getUI32()/65536,r=this.byteStream.getUI32()/65536,h=this.byteStream.getUI32()/65536*Util.$Rad2Deg,o=this.byteStream.getUI32()/65536,n=this.byteStream.getFloat16()/256,l=!!this.byteStream.getUIBits(1),c=!!this.byteStream.getUIBits(1),b=!this.byteStream.getUIBits(1),g=this.byteStream.getUIBits(5);return t._$ns=[\"flash\",\"filters\"],t._$name=\"DropShadowFilter\",t.params=[null,o,h,a,s,i,r,n,g,l,c,b],t}blurFilter(){const t={},e=this.byteStream.getUI32()/65536,s=this.byteStream.getUI32()/65536,a=this.byteStream.getUIBits(5);return this.byteStream.getUIBits(3),t._$ns=[\"flash\",\"filters\"],t._$name=\"BlurFilter\",t.params=[null,e,s,a],t}glowFilter(){const t={},e=this.rgba(),s=e.A,a=e.R<<16|e.G<<8|e.B,i=this.byteStream.getUI32()/65536,r=this.byteStream.getUI32()/65536,h=this.byteStream.getFloat16()/256,o=!!this.byteStream.getUIBits(1),n=!!this.byteStream.getUIBits(1);this.byteStream.getUIBits(1);const l=this.byteStream.getUIBits(5);return t._$ns=[\"flash\",\"filters\"],t._$name=\"GlowFilter\",t.params=[null,a,s,i,r,h,l,o,n],t}bevelFilter(){const t={};let e=this.rgba();const s=e.A,a=e.R<<16|e.G<<8|e.B;e=this.rgba();const i=e.A,r=e.R<<16|e.G<<8|e.B,h=this.byteStream.getUI32()/65536,o=this.byteStream.getUI32()/65536,n=this.byteStream.getUI32()/65536*Util.$Rad2Deg,l=this.byteStream.getUI32()/65536,c=this.byteStream.getFloat16()/256,b=!!this.byteStream.getUIBits(1),g=!!this.byteStream.getUIBits(1);this.byteStream.getUIBits(1);const y=this.byteStream.getUIBits(1),S=this.byteStream.getUIBits(4);let m=\"inner\";return b||(m=y?\"full\":\"outer\"),t._$ns=[\"flash\",\"filters\"],t._$name=\"BevelFilter\",t.params=[null,l,n,a,s,r,i,h,o,c,S,m,g],t}gradientGlowFilter(){const t={},e=0|this.byteStream.getUI8(),s=[],a=[];for(let t=0;t<e;++t){const t=this.rgba();a[a.length]=t.A,s[s.length]=t.R<<16|t.G<<8|t.B|0}const i=[];for(let t=0;t<e;++t)i[i.length]=+this.byteStream.getUI8()/255;const r=this.byteStream.getUI32()/65536,h=this.byteStream.getUI32()/65536,o=this.byteStream.getUI32()/65536*Util.$Rad2Deg,n=this.byteStream.getUI32()/65536,l=this.byteStream.getFloat16()/256,c=!!this.byteStream.getUIBits(1),b=!!this.byteStream.getUIBits(1);this.byteStream.getUIBits(1);const g=this.byteStream.getUIBits(1),y=this.byteStream.getUIBits(4);let S=\"inner\";return c||(S=g?\"full\":\"outer\"),t._$ns=[\"flash\",\"filters\"],t._$name=\"GradientGlowFilter\",t.params=[null,n,o,s,a,i,r,h,l,y,S,b],t}convolutionFilter(){const t={},e=this.byteStream.getUI8(),s=this.byteStream.getUI8(),a=this.byteStream.getFloat32,i=this.byteStream.getFloat32,r=e*s,h=[];for(let t=0;t<r;++t)h[h.length]=this.byteStream.getFloat32();const o=this.rgba();this.byteStream.getUIBits(6);const n=!!this.byteStream.getUIBits(1),l=!!this.byteStream.getUIBits(1);return t._$ns=[\"flash\",\"filters\"],t._$name=\"ConvolutionFilter\",t.params=[null,e,s,h,a,i,l,n,o],t}gradientBevelFilter(){const t={},e=0|this.byteStream.getUI8(),s=[],a=[];for(let t=0;t<e;++t){const t=this.rgba();a[a.length]=t.A,s[s.length]=t.R<<16|t.G<<8|t.B|0}const i=[];for(let t=0;t<e;++t)i[i.length]=+this.byteStream.getUI8()/255;const r=this.byteStream.getUI32()/65536,h=this.byteStream.getUI32()/65536,o=this.byteStream.getUI32()/65536*Util.$Rad2Deg,n=this.byteStream.getUI32()/65536,l=this.byteStream.getFloat16()/256,c=!!this.byteStream.getUIBits(1),b=!!this.byteStream.getUIBits(1);this.byteStream.getUIBits(1);const g=this.byteStream.getUIBits(1),y=this.byteStream.getUIBits(4);let S=\"inner\";return c||(S=g?\"full\":\"outer\"),t._$ns=[\"flash\",\"filters\"],t._$name=\"GradientBevelFilter\",t.params=[null,n,o,s,a,i,r,h,l,y,S,b],t}colorMatrixFilter(){const t={},e=[];for(let t=0;t<20;t++)e[e.length]=this.byteStream.getFloat32();return t._$ns=[\"flash\",\"filters\"],t._$name=\"ColorMatrixFilter\",t.params=[null,e],t}colorTransform(){this.byteStream.byteAlign();const t=[1,1,1,1,0,0,0,0],e=this.byteStream.getUIBits(6),s=e>>5,a=15&e;return e>>4&1&&(t[0]=this.byteStream.getSIBits(a)/256,t[1]=this.byteStream.getSIBits(a)/256,t[2]=this.byteStream.getSIBits(a)/256,t[3]=this.byteStream.getSIBits(a)/256),s&&(t[4]=this.byteStream.getSIBits(a),t[5]=this.byteStream.getSIBits(a),t[6]=this.byteStream.getSIBits(a),t[7]=this.byteStream.getSIBits(a)),t}parseSoundStreamHead(t){const e={};e.tagType=t,this.byteStream.getUIBits(4),e.PlaybackSoundRate=this.byteStream.getUIBits(2),e.PlaybackSoundSize=this.byteStream.getUIBits(1),e.PlaybackSoundType=this.byteStream.getUIBits(1),e.StreamSoundCompression=this.byteStream.getUIBits(4),e.StreamSoundRate=this.byteStream.getUIBits(2),e.StreamSoundSize=this.byteStream.getUIBits(1),e.StreamSoundType=this.byteStream.getUIBits(1),e.StreamSoundSampleCount=this.byteStream.getUI16(),2===e.StreamSoundCompression&&(e.LatencySeek=this.byteStream.getSIBits(2))}parseDefineSound(t){const e=this.byteStream.byte_offset,s=this.byteStream.getUI16();this.byteStream.getUIBits(4),this.byteStream.getUIBits(2),this.byteStream.getUIBit(),this.byteStream.getUIBit(),this.byteStream.getUI32();const a=t-(this.byteStream.byte_offset-e),i={_$characterId:s,_$data:null,_$buffer:null};i._$length=this.byteStream.byte_offset+a,i._$offset=this.byteStream.byte_offset,this.byteStream.byte_offset=e+t,this.setCharacter(s,i)}parseStartSound(t){const e={};return e.SoundId=this.byteStream.getUI16(),89===t&&(e.SoundClassName=this.byteStream.getDataUntil()),e.SoundInfo=this.parseSoundInfo(),e}parseDefineButtonSound(){const t=this.byteStream.getUI16(),e=this.getCharacter(t);for(let t=0;t<4;t++){const s=this.byteStream.getUI16();if(s){const a=this.parseSoundInfo();switch(t){case 0:e.ButtonStateUpSoundInfo=a,e.ButtonStateUpSoundId=s;break;case 1:e.ButtonStateOverSoundInfo=a,e.ButtonStateOverSoundId=s;break;case 2:e.ButtonStateDownSoundInfo=a,e.ButtonStateDownSoundId=s;break;case 3:e.ButtonStateHitTestSoundInfo=a,e.ButtonStateHitTestSoundId=s}}}this.setCharacter(t,e)}parseSoundInfo(){this.byteStream.getUIBits(2);const t={};if(t.SyncStop=this.byteStream.getUIBit(),t.SyncNoMultiple=this.byteStream.getUIBit(),t.HasEnvelope=this.byteStream.getUIBit(),t.HasLoops=this.byteStream.getUIBit(),t.HasOutPoint=this.byteStream.getUIBit(),t.HasInPoint=this.byteStream.getUIBit(),t.HasInPoint&&(t.InPoint=this.byteStream.getUI32()),t.HasOutPoint&&(t.OutPoint=this.byteStream.getUI32()),t.HasLoops&&(t.LoopCount=this.byteStream.getUI16()),t.HasEnvelope){const e=this.byteStream.getUI8(),s=[];for(let t=0;t<e;++t)s[t]={Pos44:this.byteStream.getUI32(),LeftLevel:this.byteStream.getUI16(),RightLevel:this.byteStream.getUI16()};t.EnvPoints=e,t.EnvelopeRecords=s}return t}parseDefineFontAlignZones(){const t=this.byteStream.getUI16(),e=this.getFont(t)||{};e._$CSMTableHint=this.byteStream.getUIBits(2),this.byteStream.getUIBits(6);const s=0|e._$numGlyphs,a=[];for(let t=0;t<s;++t){const e=this.byteStream.getUI8(),s=[];for(let t=0;t<e;++t)s.push(this.byteStream.getFloat16()),s.push(this.byteStream.getFloat16());this.byteStream.getUIBits(6),this.byteStream.getUIBits(1),this.byteStream.getUIBits(1),a[t]=s}this.byteStream.byteAlign(),e._$zoneTable=a,this.setFont(t,e)}parseCSMTextSettings(t){const e=this.byteStream.getUI16(),s={};s.tagType=t,s.UseFlashType=this.byteStream.getUIBits(2),s.GridFit=this.byteStream.getUIBits(3),this.byteStream.getUIBits(3),s.Thickness=this.byteStream.getUI32(),s.Sharpness=this.byteStream.getUI32(),this.byteStream.getUI8(),this.setTextSetting(e,s)}parseSoundStreamBlock(t,e){const s={};s.tagType=t,s.compressed=this.byteStream.getData(e)}parseDefineScalingGrid(){const t=this.byteStream.getUI16(),e=this.rect();this.setGrid(t,e)}postCharacter(t,e){globalThis.postMessage({infoKey:\"_$characters\",characters:t},e),t.length=0,e&&(e.length=0)}}Util.$swfParser=new SwfParser,this.addEventListener(\"message\",(function(t){const e=Util.$swfParser;e.version=t.data.version,e.byteStream.setData(t.data.buffer),e.byteStream.byte_offset=t.data.offset;const s=Util.$createMovieClip();e.parseTags(t.data.buffer.length,s),e.postData(s),e.clear()}));"], { "type": "text/javascript" })
);
Util.$parserWorker     = null;
Util.$parserQueues     = [];
Util.$parserWorkerWait = false;

/**
 * @param  {object} event
 * @return void
 * @static
 */
Util.$unlzmaHandler = function (event)
{
    // event end
    event.target.onmessage = null;

    // next
    if (Util.$unlzmaQueues.length) {

        const object = Util.$unlzmaQueues.shift();

        const worker = new Worker(Util.$unlzmaWorkerURL);

        worker.onmessage = Util.$unlzmaHandler.bind(object);

        const data = object._$byteStream._$buffer;
        worker.postMessage({
            "fileSize": object.fileSize,
            "mode":     object.mode,
            "buffer":   data
        }, [data.buffer]);

    } else {

        Util.$unlzmaWorkerActive = false;

    }

    // setup
    this._$byteStream._$buffer = event.data;
    this.parseAndBuild();
};

/**
 * @param  {Uint8Array} data
 * @return {string|null}
 * @static
 */
Util.$getImageType = (data) =>
{
    switch (true) {

        // JPEG
        case data[0] === 0xff && data[1] === 0xd8:
            return "jpeg";

        // GIF
        case data[0] === 0x47 && data[1] === 0x49 && data[2] === 0x46:
            return "gif";

        // PNG
        case data[0] === 0x89 && data[1] === 0x50 &&
            data[2] === 0x4E && data[3] === 0x47 &&
            data[4] === 0x0D && data[5] === 0x0A &&
            data[6] === 0x1A && data[7] === 0x0A:
            return "png";

        // BMP
        case data[0] === 0x42 && data[1] === 0x4d:
            return "bmp";

        default:
            return null;

    }
};

/**
 * @return {void}
 * @static
 */
Util.$jpegDecodeHandler = () =>
{
    const image  = this.image;
    const width  = image.width;
    const height = image.height;

    const canvas  = document.createElement("canvas");
    canvas.width  = width;
    canvas.height = height;
    const context = canvas.getContext("2d");

    context.drawImage(image, 0, 0, width, height);
    const buffer = new Uint8Array(context
        .getImageData(0, 0, width, height)
        .data);

    // clear
    this.jpegData = null;
    this.image    = null;

    const workSpace = Util.$currentWorkSpace();
    const instance  = workSpace.getLibrary(this.libraryId);
    instance.width  = width;
    instance.height = height;

    if (this.isAlpha) {

        // set
        this.buffer = buffer;
        this.width  = width;
        this.height = height;

        if (Util.$unzipWorkerActive) {
            Util.$unzipQueues.push(this);
            return ;
        }

        Util.$unzipWorkerActive = true;

        if (!Util.$unzipWorker) {
            Util.$unzipWorker = new Worker(Util.$unzipURL);
        }

        const worker = Util.$unzipWorker;
        worker.onmessage = Util.$unzipHandler.bind(this);
        worker.postMessage(this, [
            this.buffer.buffer,
            this.alphaData.buffer
        ]);

    } else {

        instance._$buffer = buffer;

    }
};

/**
 * @type {Map}
 */
Util.$characters = new Map();
Util.$symbols    = new Map();
Util.$fonts      = new Map();
Util.$texts      = new Map();

/**
 * @param  {object} event
 * @return void
 * @static
 */
Util.$parserHandler = function (event)
{
    const worker = event.target;
    switch (event.data.infoKey) {

        case "character":
            {
                const character = event.data.piece;

                const workSpace = Util.$currentWorkSpace();
                const id = workSpace.nextLibraryId;
                character.libraryId = id;

                switch (character._$name) {

                    case "Shape":
                        {
                            const object = Util
                                .$libraryController
                                .createInstance("shape", `Shape_${id}`, id);

                            object.recodes  = Util.$vtc.convert(character._$records);
                            object.inBitmap = object.recodes.pop();
                            object.bounds   = {
                                "xMin": character._$bounds.xMin,
                                "xMax": character._$bounds.xMax,
                                "yMin": character._$bounds.yMin,
                                "yMax": character._$bounds.yMax
                            };

                            const shape = workSpace.addLibrary(object);
                            if (this._$folderId) {
                                shape.folderId = this._$folderId;
                            }

                            Util.$characters.set(character._$characterId, id);
                        }
                        break;

                    case "MovieClip":
                        {
                            for (let idx = 0; idx < character._$dictionary.length; ++idx) {
                                const object = character._$dictionary[idx];
                                object.LibraryId = Util.$characters.get(object.CharacterId);
                            }

                            const name = character._$characterId
                                ? `MovieClip_${id}`
                                : this._$fileName;

                            let libraryId = !character._$characterId && this._$libraryId
                                ? this._$libraryId
                                : id;

                            const object = Util
                                .$libraryController
                                .createInstance("container", name, libraryId);

                            // create MovieClip
                            const movieClip = workSpace.addLibrary(object);
                            if (this._$folderId) {
                                movieClip.folderId = this._$folderId;
                            }

                            // create layer
                            let clipMap = new Map();
                            let layerArray = [];
                            for (let idx = 0; idx < character._$dictionary.length; ++idx) {
                                const tag = character._$dictionary[idx];

                                if (layerArray.indexOf(tag.Depth) !== -1) {
                                    continue;
                                }
                                layerArray.push(tag.Depth);

                                if (tag.ClipDepth) {
                                    clipMap.set(tag.Depth, idx);
                                }

                            }

                            layerArray.sort((a, b) =>
                            {
                                switch (true) {

                                    case a > b:
                                        return 1;

                                    case a < b:
                                        return -1;

                                    default:
                                        return 0;

                                }
                            });

                            // adj clips
                            if (clipMap.size) {

                                for (const [depth, index] of clipMap) {

                                    const moveArray = [];

                                    const tag = character._$dictionary[index];
                                    for (let idx = 0; character._$dictionary.length > idx; ++idx) {

                                        const target = character._$dictionary[idx];
                                        if (target.Depth > tag.ClipDepth) {
                                            break;
                                        }

                                        if (target.Depth > depth) {
                                            moveArray.push(target);
                                        }
                                    }

                                    for (let idx = 0; idx < moveArray.length; ++idx) {

                                        const target = moveArray[idx];

                                        const index = layerArray.indexOf(target.Depth);
                                        const depth = layerArray.splice(index, 1)[0];
                                        const insertIndex = layerArray.indexOf(tag.Depth);

                                        layerArray.splice(insertIndex, 0, depth);
                                    }

                                }
                            }

                            let maskId     = -1;
                            let clipDepth  = -1;
                            const index    = layerArray.length - 1;
                            const layerMap = new Map();
                            const layers   = [];
                            for (let idx = index; idx > -1; --idx) {

                                const layer = new Layer();
                                layer.name  = `Layer_${index - idx}`;

                                const depth = layerArray[idx];
                                if (clipMap.size) {

                                    if (clipDepth > -1) {
                                        if (depth > clipDepth) {
                                            layer.mode   = Util.LAYER_MODE_MASK_IN;
                                            layer.maskId = maskId;
                                        } else {
                                            maskId    = -1;
                                            clipDepth = -1;
                                        }
                                    }

                                    if (clipMap.has(depth)) {
                                        clipDepth  = depth;
                                        maskId     = index - idx;
                                        layer.mode = Util.LAYER_MODE_MASK;
                                    }
                                }

                                layers.push(layer);
                                layerMap.set(depth, layer);
                            }

                            for (let idx = 0; idx < layerArray.length; ++idx) {
                                movieClip.setLayer(idx, layers[idx]);
                            }

                            // setup
                            const characters = [];
                            const totalFrame = character._$controller.length - 1;
                            for (let idx = 0; idx < character._$dictionary.length; ++idx) {

                                const tag = character._$dictionary[idx];

                                const instance = new Character();
                                instance.libraryId  = tag.LibraryId;
                                instance.startFrame = tag.StartFrame;
                                instance.endFrame   = tag.EndFrame || totalFrame + 1;
                                instance.name       = tag.Name || "";

                                characters.push(instance);
                            }

                            const dup = new Map();
                            for (let frame = 1; frame < character._$controller.length; ++frame) {

                                const controller = character._$controller[frame];
                                for (let idx = 0; idx < controller.length; ++idx) {

                                    const id  = controller[idx];
                                    const tag = character._$dictionary[id];

                                    const layer = layerMap.get(tag.Depth);

                                    const instance = characters[id];
                                    if (!dup.has(id)) {
                                        dup.set(id, -1);
                                        layer.addCharacter(instance);
                                    }

                                    const nextId    = character._$placeMap[frame][tag.Depth];
                                    const currentId = dup.get(id);
                                    if (currentId !== nextId) {
                                        const placeObject = character._$placeObjects[nextId];

                                        instance.setPlace(frame, {
                                            "frame": frame,
                                            "depth": 0,
                                            "matrix": placeObject.matrix,
                                            "colorTransform": placeObject.colorTransform,
                                            "blendMode": placeObject.blendMode,
                                            "filter": placeObject.filters ? placeObject.filters : [],
                                            "loop": Util.$getDefaultLoopConfig()
                                        });

                                        dup.set(id, nextId);
                                    }
                                }
                            }

                            for (let idx = 0; idx < layers.length; ++idx) {

                                const empty = {
                                    "startFrame": -1
                                };

                                const layer = layers[idx];
                                for (let frame = 1; frame <= totalFrame; ++frame) {

                                    const characters = layer.getActiveCharacter(frame);

                                    // 空白のフレーム処理
                                    if (!characters.length) {

                                        if (empty.startFrame === -1) {
                                            empty.startFrame = frame;
                                        }

                                    } else {

                                        // 空白のフレームがあれば登録して初期化
                                        if (empty.startFrame > 0) {
                                            layer.addEmptyCharacter(new EmptyCharacter({
                                                "startFrame": empty.startFrame,
                                                "endFrame": frame
                                            }));

                                            // 初期化
                                            empty.startFrame = -1;
                                        }

                                    }
                                }
                            }

                            Util.$characters.set(character._$characterId, id);
                        }
                        break;

                    case "lossless": // PNG
                        {

                            const object = Util
                                .$libraryController
                                .createInstance("bitmap", `Bitmap_${id}`, id);

                            character.mode   = "lossless";
                            object.imageType = "image/png";
                            object.buffer    = null;
                            object.width     = character.width;
                            object.height    = character.height;

                            const bitmap = workSpace.addLibrary(object);
                            if (this._$folderId) {
                                bitmap.folderId = this._$folderId;
                            }

                            Util.$characters.set(character._$characterId, id);

                            if (Util.$unzipWorkerActive) {
                                Util.$unzipQueues.push(character);
                                return ;
                            }

                            Util.$unzipWorkerActive = true;

                            if (!Util.$unzipWorker) {
                                Util.$unzipWorker = new Worker(Util.$unzipURL);
                            }

                            const worker = Util.$unzipWorker;
                            worker.onmessage = Util.$unzipHandler.bind(character);
                            worker.postMessage(character, [character.buffer.buffer]);
                        }
                        break;

                    case "imageData": // JPEG,GIF,PNG,etc...
                        {
                            const object = Util
                                .$libraryController
                                .createInstance("bitmap", `Bitmap_${id}`, id);

                            const imageType     = `image/${Util.$getImageType(character.jpegData)}`;
                            character.mode      = "jpegAlpha";
                            character.imageType = imageType;
                            object.imageType    = imageType;
                            object.buffer       = null;
                            object.width        = 0;
                            object.height       = 0;

                            const bitmap = workSpace.addLibrary(object);
                            if (this._$folderId) {
                                bitmap.folderId = this._$folderId;
                            }

                            Util.$characters.set(character._$characterId, id);

                            character.image = new Image();
                            character.image.decoding = "async";
                            character.image.src = URL.createObjectURL(
                                new Blob([character.jpegData], {
                                    "type": character.imageType
                                })
                            );

                            character.image.decode()
                                .then(Util.$jpegDecodeHandler.bind(character));

                        }
                        break;

                    case "StaticText":
                        {
                            const object = Util
                                .$libraryController
                                .createInstance("shape", `ShapeText_${id}`, id);

                            object.bounds  = {
                                "xMin": character._$bounds.xMin,
                                "xMax": character._$bounds.xMax,
                                "yMin": character._$bounds.yMin,
                                "yMax": character._$bounds.yMax
                            };

                            const text = workSpace.addLibrary(object);
                            if (this._$folderId) {
                                text.folderId = this._$folderId;
                            }

                            Util.$characters.set(character._$characterId, id);

                            Util.$texts.set(Util.$texts.size, character);
                        }
                        break;

                    case "SimpleButton":
                        {
                            console.log("TODO SimpleButton: ", character);

                            const object = Util
                                .$libraryController
                                .createInstance("button", `Button_${id}`, id);

                            object.bounds  = {
                                "xMin": character._$bounds.xMin,
                                "xMax": character._$bounds.xMax,
                                "yMin": character._$bounds.yMin,
                                "yMax": character._$bounds.yMax
                            };

                            // workSpace.addLibrary(object);

                            Util.$characters.set(character._$characterId, id);
                        }
                        break;

                    case "TextField":
                        {
                            const object = Util
                                .$libraryController
                                .createInstance("text", `Text_${id}`, id);

                            object.bounds  = {
                                "xMin": character._$bounds.xMin,
                                "xMax": character._$bounds.xMax,
                                "yMin": character._$bounds.yMin,
                                "yMax": character._$bounds.yMax
                            };

                            // attach
                            object.text          = character._$text;
                            object.inputType     = character._$type;
                            object.color         = character._$textColor;
                            object.font          = character._$defaultTextFormat[1];
                            object.size          = character._$defaultTextFormat[2];
                            object.align         = character._$defaultTextFormat[7];
                            object.leftMargin    = character._$defaultTextFormat[8];
                            object.rightMargin   = character._$defaultTextFormat[9];
                            object.leading       = character._$defaultTextFormat[10];
                            object.multiline     = character._$multiline === 1;
                            object.wordWrap      = character._$wordWrap === 1;
                            object.border        = character._$border === 1;

                            if (character._$defaultTextFormat[4]
                            && character._$defaultTextFormat[5]
                            ) {
                                object.fontType = 3;
                            } else if (character._$defaultTextFormat[4]) {
                                object.fontType = 2;
                            } else if (character._$defaultTextFormat[5]) {
                                object.fontType = 1;
                            }

                            // TODO
                            object.htmlText = character._$htmlText;

                            const text = workSpace.addLibrary(object);
                            if (this._$folderId) {
                                text.folderId = this._$folderId;
                            }

                            Util.$characters.set(character._$characterId, id);
                        }
                        break;

                    default:
                        console.log("TODO: ", character);
                        break;

                }

                if (character._$characterId) {
                    return ;
                }

                if (this._$libraryId) {

                    Util.$changeLibraryId = this._$libraryId;

                    workSpace
                        .scene
                        .changeFrame(
                            Util.$timelineFrame.currentFrame
                        );

                    Util.$changeLibraryId = 0;
                }
            }
            break;

        case "_$symbols":
            for (let idx = 0; idx < event.data.pieces.length; ++idx) {
                const piece = event.data.pieces[idx];
                Util.$symbols.set(piece.tagId, piece.ns);
            }
            return;

        case "font":
            Util.$fonts.set(event.data.index, event.data.piece);
            return;

        case "font_shape":
            {
                const font = Util.$fonts.get(event.data.index);
                font._$glyphShapeTable.push.apply(font._$glyphShapeTable, event.data.pieces);
                Util.$fonts.set(event.data.index, font);
            }
            return;

        case "font_zone":
            {
                const font = Util.$fonts.get(event.data.index);
                font._$zoneTable.push.apply(font._$zoneTable, event.data.pieces);
                Util.$fonts.set(event.data.index, font);
            }
            return;

        default:
            break;

    }

    // if (Util.$texts.size) {
    //
    //     const { Graphics } = window.next2d.display;
    //
    //     const workSpace = Util.$currentWorkSpace();
    //
    //     for (const character of Util.$texts.values()) {
    //
    //         const shape = workSpace.getLibrary(character.libraryId);
    //
    //         // build shape data
    //         let offsetX     = 0;
    //         let offsetY     = 0;
    //         let color       = null;
    //         let codeTables  = null;
    //         let shapeTables = null;
    //         let textHeight  = 0;
    //         let isZoneTable = false;
    //
    //         const baseMatrix = character._$baseMatrix;
    //
    //         // build shape data
    //         const records = character._$textRecords;
    //         for (let idx = 0; idx < records.length; ++idx) {
    //
    //             const record = records[idx];
    //
    //             if ("FontId" in record) {
    //                 const font  = Util.$fonts.get(record.FontId);
    //                 codeTables  = font._$codeTable;
    //                 shapeTables = font._$glyphShapeTable;
    //                 isZoneTable = font._$zoneTable !== null;
    //             }
    //
    //             if ("XOffset" in record) {
    //                 offsetX = record.XOffset;
    //             }
    //
    //             if ("YOffset" in record) {
    //                 offsetY = record.YOffset;
    //             }
    //
    //             if ("TextColor" in record) {
    //                 color = record.TextColor;
    //             }
    //
    //             if ("TextHeight" in record) {
    //                 textHeight = record.TextHeight;
    //                 if (isZoneTable) {
    //                     textHeight /= 20;
    //                 }
    //             }
    //
    //             const entries = record.GlyphEntries;
    //             const count   = record.GlyphCount;
    //             const scale   = textHeight / 1024;
    //             for (let idx = 0; idx < count; ++idx) {
    //
    //                 const entry = entries[idx];
    //                 const index = entry.GlyphIndex | 0;
    //
    //                 // add records
    //                 const shapeRecodes = Util.$vtc.convert({
    //                     "ShapeData": shapeTables[index],
    //                     "lineStyles": [],
    //                     "fillStyles": [{
    //                         "Color": color,
    //                         "fillStyleType": 0
    //                     }]
    //                 });
    //
    //                 const matrix = [
    //                     scale, baseMatrix[1], baseMatrix[2], scale,
    //                     baseMatrix[4] + offsetX,
    //                     baseMatrix[5] + offsetY
    //                 ];
    //
    //                 for (let idx = 0; idx < shapeRecodes.length;) {
    //
    //                     const code = shapeRecodes[idx++];
    //                     shape._$recodes.push(code);
    //                     switch (code) {
    //
    //                         case Graphics.MOVE_TO:
    //                         case Graphics.LINE_TO:
    //                             {
    //                                 const x  = shapeRecodes[idx++];
    //                                 const y  = shapeRecodes[idx++];
    //                                 const tx = x * matrix[0] + y * matrix[2] + matrix[4];
    //                                 const ty = x * matrix[1] + y * matrix[3] + matrix[5];
    //                                 shape._$recodes.push(tx, ty);
    //                             }
    //                             break;
    //
    //                         case Graphics.CURVE_TO:
    //                             {
    //                                 const cx  = shapeRecodes[idx++];
    //                                 const cy  = shapeRecodes[idx++];
    //                                 const ctx = cx * matrix[0] + cy * matrix[2] + matrix[4];
    //                                 const cty = cx * matrix[1] + cy * matrix[3] + matrix[5];
    //                                 shape._$recodes.push(ctx, cty);
    //
    //                                 const x  = shapeRecodes[idx++];
    //                                 const y  = shapeRecodes[idx++];
    //                                 const tx = x * matrix[0] + y * matrix[2] + matrix[4];
    //                                 const ty = x * matrix[1] + y * matrix[3] + matrix[5];
    //                                 shape._$recodes.push(tx, ty);
    //                             }
    //                             break;
    //
    //                         case Graphics.FILL_STYLE:
    //                             shape._$recodes.push(
    //                                 shapeRecodes[idx++], shapeRecodes[idx++],
    //                                 shapeRecodes[idx++], shapeRecodes[idx++]
    //                             );
    //                             break;
    //
    //                         case Graphics.BEGIN_PATH:
    //                         case Graphics.END_FILL:
    //                             break;
    //
    //                     }
    //                 }
    //
    //                 offsetX += entry.GlyphAdvance;
    //             }
    //         }
    //     }
    // }

    const workSpace = Util.$currentWorkSpace();
    for (const [id, name] of Util.$symbols) {
        const instance = workSpace.getLibrary(id);
        instance._$symbol = `${name}`;
    }

    // map clear
    Util.$characters.clear();
    Util.$symbols.clear();
    Util.$fonts.clear();
    Util.$texts.clear();

    Util.$libraryController.reload(
        Array.from(workSpace._$libraries.values())
    );

    // parser end
    worker.onmessage = null;

    // next
    if (Util.$parserQueues.length) {

        const object = Util.$parserQueues.shift();

        worker.onmessage = Util.$parserHandler.bind(object);

        const buffer = object._$byteStream._$buffer;
        worker.postMessage({
            "version": object._$swfVersion,
            "offset":  object._$offset,
            "buffer":  buffer
        }, [buffer.buffer]);

    } else {

        Util.$parserWorkerWait = false;

    }

};

/**
 * @param  {object} bounds
 * @param  {Float32Array} matrix
 * @return {object}
 * @method
 * @static
 */
Util.$boundsMatrix = (bounds, matrix) =>
{
    const x0 = bounds.xMax * matrix[0] + bounds.yMax * matrix[2] + matrix[4];
    const x1 = bounds.xMax * matrix[0] + bounds.yMin * matrix[2] + matrix[4];
    const x2 = bounds.xMin * matrix[0] + bounds.yMax * matrix[2] + matrix[4];
    const x3 = bounds.xMin * matrix[0] + bounds.yMin * matrix[2] + matrix[4];
    const y0 = bounds.xMax * matrix[1] + bounds.yMax * matrix[3] + matrix[5];
    const y1 = bounds.xMax * matrix[1] + bounds.yMin * matrix[3] + matrix[5];
    const y2 = bounds.xMin * matrix[1] + bounds.yMax * matrix[3] + matrix[5];
    const y3 = bounds.xMin * matrix[1] + bounds.yMin * matrix[3] + matrix[5];

    return {
        "xMin": Math.min( Number.MAX_VALUE, x0, x1, x2, x3),
        "xMax": Math.max(-Number.MAX_VALUE, x0, x1, x2, x3),
        "yMin": Math.min( Number.MAX_VALUE, y0, y1, y2, y3),
        "yMax": Math.max(-Number.MAX_VALUE, y0, y1, y2, y3)
    };
};

/**
 * @param   {number} color
 * @returns {object}
 * @method
 * @static
 */
Util.$intToRGB = (color) =>
{
    return {
        "R": (color & 0xff0000) >> 16,
        "G": (color & 0x00ff00) >> 8,
        "B": color & 0x0000ff
    };
};

/**
 * @param  {object} object
 * @param  {Map}    dup
 * @method
 * @static
 */
Util.$copyContainer = (object, dup) =>
{
    const workSpace       = Util.$currentWorkSpace();
    const targetWorkSpace = Util.$workSpaces[Util.$copyWorkSpaceId];

    if (!dup.has(object.id)) {
        dup.set(object.id, workSpace.nextLibraryId);
    }

    object.id = dup.get(object.id);
    workSpace.addLibrary(object);

    for (let idx = 0; idx < object.layers.length; ++idx) {

        const layer = object.layers[idx];
        for (let idx = 0; idx < layer.characters.length; ++idx) {

            const character = layer.characters[idx];
            if (!dup.has(character.libraryId)) {

                dup.set(character.libraryId, workSpace.nextLibraryId);

                const instance = targetWorkSpace
                    .getLibrary(character.libraryId);

                const object = instance.toObject();
                if (object.type === "container") {

                    Util.$copyContainer(object, dup);

                } else {

                    object.id = dup.get(character.libraryId);
                    workSpace.addLibrary(object);

                }
            }

            character.libraryId = dup.get(character.libraryId);
        }
    }

    workSpace.addLibrary(object);
};

/**
 * @return {void}
 * @static
 */
Util.$clearShapePointer = () =>
{
    const element  = document.getElementById("stage-area");
    const children = element.children;
    for (let idx = 0; children.length > idx; ++idx) {

        const node = children[idx];
        if (!node.dataset.shapePointer) {
            continue;
        }

        node.remove();
        --idx;
    }
};

/**
 * @return {object}
 * @static
 */
Util.$getDefaultLoopConfig = () =>
{
    return {
        "type": Util.DEFAULT_LOOP,
        "start": 1,
        "end": 0
    };
};

/**
 * @param  {object} place
 * @param  {object} range
 * @param  {number} parent_frame
 * @param  {number} total_frame
 * @return {number}
 * @static
 */
Util.$getFrame = (place, range, parent_frame, total_frame) =>
{
    // レンジ幅での移動数
    const length = parent_frame - range.startFrame;

    let frame = 1;
    switch (place.loop.type) {

        case 0:
            {
                const totalFrame = place.loop.end
                    ? place.loop.end
                    : total_frame;

                frame = place.loop.start;
                for (let idx = 0; idx < length; ++idx) {

                    ++frame;

                    if (frame > totalFrame) {
                        frame = place.loop.start;
                    }

                }
            }
            break;

        case 1:
            {
                const totalFrame = place.loop.end
                    ? place.loop.end
                    : total_frame;

                frame = place.loop.start;
                for (let idx = 0; idx < length; ++idx) {

                    ++frame;

                    // ループは一回だけなので最後のフレームで終了
                    if (frame > totalFrame) {
                        frame = totalFrame;
                        break;
                    }

                }
            }
            break;

        case 2:
            frame = place.loop.start;
            break;

        case 3:
            frame = place.loop.end
                ? place.loop.end
                : total_frame;

            for (let idx = 0; idx < length; ++idx) {

                --frame;

                // ループは一回だけなので最初のフレームにセットして終了
                if (place.loop.start > frame) {
                    frame = place.loop.start;
                    break;
                }
            }
            break;

        case 4:
            {
                const totalFrame = place.loop.end
                    ? place.loop.end
                    : total_frame;

                frame = totalFrame;
                for (let idx = 0; idx < length; ++idx) {

                    --frame;

                    if (place.loop.start > frame) {
                        frame = totalFrame;
                    }
                }
            }
            break;

        case 5:
            frame = 1;
            for (let idx = 0; idx < length; ++idx) {

                ++frame;

                if (frame > total_frame) {
                    frame = 1;
                }

            }
            break;

    }

    return frame;
};

/**
 * @class
 */
class GlobalKeyboardCommand
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$activeTool = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$executeMulti = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        // 元に戻す
        Util.$setShortcut(
            Util.$generateShortcutKey("z", { "ctrl": true }),
            this.undo
        );

        // 戻したデータを進める
        Util.$setShortcut(
            Util.$generateShortcutKey("z", { "ctrl": true, "shift": true }),
            this.redo
        );

        // データをローカルに保存
        Util.$setShortcut(
            Util.$generateShortcutKey("s", { "ctrl": true }),
            Util.$autoSave
        );

        Util.$setShortcut("Enter", () =>
        {
            Util.$timelinePlayer.executeTimelinePlay();
        });

        // プレビュー画面を起動
        Util.$setShortcut(
            Util.$generateShortcutKey("Enter", { "ctrl": true }),
            Util.$showPreview
        );

        // データの書き出し
        Util.$setShortcut(
            Util.$generateShortcutKey("Enter", { "ctrl": true, "shift": true }),
            Util.$project.publish
        );

        // プレビューを終了
        Util.$setShortcut("Escape", Util.$hidePreview);

        // リピートモードの切り替え
        Util.$setShortcut(
            Util.$generateShortcutKey("p", { "ctrl": true }),
            this.changeRepeatMode
        );

        // プロジェクト移動(タブ移動)
        Util.$setShortcut(
            Util.$generateShortcutKey("ArrowRight", { "ctrl": true }),
            this.changeProject
        );
        Util.$setShortcut(
            Util.$generateShortcutKey("ArrowLeft", { "ctrl": true }),
            this.changeProject
        );

        Util.$initializeEnd();
    }

    /**
     * @description redoを実行
     *
     * @return {void}
     * @method
     * @public
     */
    redo ()
    {
        const workSpace = Util.$currentWorkSpace();
        if (workSpace) {
            workSpace.redo();
        }
    }

    /**
     * @description undoを実行
     *
     * @return {void}
     * @method
     * @public
     */
    undo ()
    {
        const workSpace = Util.$currentWorkSpace();
        if (workSpace) {
            workSpace.undo();
        }
    }

    /**
     * @description リピートモードの切り替え
     *
     * @return {void}
     * @method
     * @public
     */
    changeRepeatMode ()
    {
        if (Util.$timelinePlayer.repeat) {
            Util.$timelinePlayer.executeTimelineRepeat();
        } else {
            Util.$timelinePlayer.executeTimelineNoRepeat();
        }
    }

    /**
     * @description プロジェクトの切り替え
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    changeProject (event)
    {
        const children = Array.from(document
            .getElementById("view-tab-area")
            .children);

        let index = 0;
        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];

            const tabId = node.dataset.tabId | 0;
            if (tabId === Util.$activeWorkSpaceId) {
                index = idx;
                break;
            }
        }

        let node = null;
        if (event.key === "ArrowLeft") {

            node = children[index - 1];
            if (!node) {
                node = children[children.length - 1];
            }

        } else {

            node = children[index + 1];
            if (!node) {
                node = children[0];
            }

        }

        if (node) {
            const tabId = node.dataset.tabId | 0;
            if (Util.$activeWorkSpaceId !== tabId) {
                Util.$screenTab.activeTab({
                    "currentTarget": {
                        "dataset": {
                            "tabId": tabId
                        }
                    }
                });
            }
        }
    }
}

Util.$globalKeyboardCommand = new GlobalKeyboardCommand();

/**
 * @class
 */
class ApngEncoder
{
    /**
     * @param {array}   pngs
     * @param {number}  [width = 0]
     * @param {number}  [height = 0]
     * @param {number}  [fps = 60]
     * @param {boolean} [loop = true]
     * @public
     */
    constructor (pngs, width = 0, height = 0, fps = 60, loop = true)
    {
        this._$pngs   = pngs;
        this._$width  = width;
        this._$height = height;
        this._$fps    = fps;
        this._$loop   = loop ? 0 : 1;

        this._$crcTable = new Uint32Array(256);
        for (let idx = 0; idx < 256; idx++) {

            let c = idx;
            for (let idx = 0; idx < 8; idx++) {
                c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;
            }

            this._$crcTable[idx] = c;
        }
    }

    /**
     * @param  {number} c
     * @param  {Uint8Array} buffer
     * @param  {number} offset
     * @param  {number} length
     * @return {number}
     * @private
     */
    _$crcUpdate (c, buffer, offset, length)
    {
        for (let idx = 0; idx < length; idx++) {
            c = this._$crcTable[(c ^ buffer[offset + idx]) & 0xff] ^ c >>> 8;
        }
        return c;
    }

    /**
     * @param  {Uint8Array} buffer
     * @param  {number} offset
     * @param  {number} length
     * @return {number}
     * @private
     */
    _$crc (buffer, offset, length)
    {
        return this._$crcUpdate(
            0xffffffff, buffer, offset, length
        ) ^ 0xffffffff;
    }

    /**
     * @param {Uint8Array} buffer
     * @param {number} pos
     * @param {string} value
     * @private
     */
    _$writeString (buffer, pos, value)
    {
        for (let idx = 0; idx < value.length; idx++) {
            buffer[pos + idx] = value.charCodeAt(idx);
        }
    }

    /**
     * @return {Promise}
     * @public
     */
    encode ()
    {
        return new Promise((resolve) =>
        {
            let sequenceNumber = 0;
            let frame = 0;

            const chunks = [];
            const reader = new FileReader();

            // PNG header (8 bytes)
            const header = new Uint8Array([
                137, 80, 78, 71, 13, 10, 26, 10
            ]);
            chunks.push(header.buffer);

            const IHDR     = new Uint8Array(25);
            const IHDRView = new DataView(IHDR.buffer);
            IHDRView.setUint32(0, 13);
            this._$writeString(IHDR, 4, "IHDR");
            IHDRView.setUint32(8, this._$width);
            IHDRView.setUint32(12, this._$height);
            IHDRView.setUint8(16, 8); // bit depth
            IHDRView.setUint8(17, 6); // color_type, 2 = RGB, 6 = RGBA
            IHDRView.setUint8(18, 0); // compression method
            IHDRView.setUint8(19, 0); // filter method
            IHDRView.setUint8(20, 0); // interlace method
            IHDRView.setUint32(21, this._$crc(IHDR, 4, 4 + 13));
            chunks.push(IHDR.buffer);

            // animation control
            const acTL   = new Uint8Array(20);
            const acView = new DataView(acTL.buffer);
            acView.setUint32(0, 8);
            this._$writeString(acTL, 4, "acTL");
            acView.setUint32(8, this._$pngs.length);
            acView.setUint32(12, this._$loop);
            acView.setUint32(16, this._$crc(acTL, 4, 4 + 8));
            chunks.push(acTL.buffer);

            reader.onload = () =>
            {
                const view = new DataView(reader.result);

                let pos = 8;

                // frame control
                const fcTL   = new Uint8Array(38);
                const fcView = new DataView(fcTL.buffer);
                fcView.setUint32(0, 26);
                this._$writeString(fcTL, 4, "fcTL");
                fcView.setUint32(8, sequenceNumber++);
                fcView.setUint32(12, this._$width);
                fcView.setUint32(16, this._$height);
                fcView.setUint32(20, 0);
                fcView.setUint32(24, 0);
                fcView.setUint16(28, 1000 / this._$fps); // delay_num
                fcView.setUint16(30, 1000); // delay_den
                fcView.setUint8(32, 0); // dispose_op
                fcView.setUint8(33, 0); // blend_op
                fcView.setUint32(34, this._$crc(fcTL, 4, 4 + 26));
                chunks.push(fcTL.buffer);

                const length = reader.result.byteLength;
                for (;;) {

                    const chunkLen = view.getUint32(pos);
                    if (view.getUint32(pos + 4) === 0x49444154) {

                        if (!frame) {

                            chunks.push(
                                reader.result.slice(pos, pos + chunkLen + 8 + 4)
                            );

                        } else {

                            let fdAT   = new Uint8Array(4);
                            let fdView = new DataView(fdAT.buffer);

                            fdView.setUint32(0, chunkLen + 4);
                            chunks.push(fdAT.buffer);

                            fdAT = new Uint8Array(
                                reader.result.slice(pos, pos + chunkLen + 8 + 4)
                            );

                            fdView = new DataView(fdAT.buffer);
                            this._$writeString(fdAT, 0, "fdAT");
                            fdView.setUint32(4, sequenceNumber++);
                            fdView.setUint32(
                                chunkLen + 8,
                                this._$crc(fdAT, 0, chunkLen + 8)
                            );
                            chunks.push(fdAT.buffer);
                        }
                    }

                    pos += chunkLen + 12;
                    if (pos >= length) {
                        break;
                    }
                }

                frame++;
                if (this._$pngs.length > frame) {

                    reader.readAsArrayBuffer(this._$pngs[frame]);

                } else {

                    chunks.push(new Uint8Array([
                        0, 0, 0, 0,
                        0x49, 0x45, 0x4E, 0x44,
                        0xAE, 0x42, 0x60, 0x82
                    ]).buffer);

                    resolve(new Blob(chunks, { "type" : "image/apng" }));
                }
            };

            reader.readAsArrayBuffer(this._$pngs[0]);
        });
    }
}

/**
 * @class
 */
class Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object)
    {
        this._$id       = object.id;
        this._$name     = object.name;
        this._$type     = object.type;
        this._$symbol   = object.symbol;
        this._$folderId = object.folderId | 0;
    }

    /**
     * @abstract
     */
    // eslint-disable-next-line no-empty-function
    initialize () {}

    /**
     * @param {object} place
     * @param {string} [name=""]
     * @public
     */
    showController (place, name = "")
    {
        Util.$controller.hideObjectSetting([
            "sound-setting",
            "ease-setting"
        ]);

        Util.$controller.showObjectSetting([
            "object-setting",
            "reference-setting",
            "transform-setting",
            "color-setting",
            "blend-setting",
            "filter-setting",
            "instance-setting"
        ]);

        // 選択されたインスタンス名をセット
        Util
            .$instanceSelectController
            .createInstanceSelect(this);

        // 名前とシンボルの値をセット
        document
            .getElementById("object-name")
            .value = name;

        document
            .getElementById("object-symbol")
            .value = this.symbol;

        // matrixの値をセット
        const matrix  = place.matrix;
        const xScale  = Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale  = Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);
        const radianX = Math.atan2( matrix[1], matrix[0]) * Util.$Rad2Deg;
        const radianY = Math.atan2(-matrix[2], matrix[3]) * Util.$Rad2Deg;

        document
            .getElementById("transform-scale-x")
            .value = Math.abs(Math.ceil(radianX - radianY)) >= 180
                ? xScale * -100
                : xScale * 100;

        document
            .getElementById("transform-scale-y")
            .value = yScale * 100;

        document
            .getElementById("transform-rotate")
            .value = radianX;

        // ColorTransformの値をセット
        const colorTransform = place.colorTransform;

        document
            .getElementById("color-red-multiplier")
            .value = colorTransform[0] * 100;
        document
            .getElementById("color-green-multiplier")
            .value = colorTransform[1] * 100;
        document
            .getElementById("color-blue-multiplier")
            .value = colorTransform[2] * 100;
        document
            .getElementById("color-alpha-multiplier")
            .value = colorTransform[3] * 100;

        document
            .getElementById("color-red-offset")
            .value = colorTransform[4];
        document
            .getElementById("color-green-offset")
            .value = colorTransform[5];
        document
            .getElementById("color-blue-offset")
            .value = colorTransform[6];
        document
            .getElementById("color-alpha-offset")
            .value = colorTransform[7];

        // 指定したブレンドモードにselectedを設定
        const children = document
            .getElementById("blend-select")
            .children;

        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];

            if (node.value !== place.blendMode) {
                continue;
            }

            node.selected = true;
            break;
        }

        // フィルター情報を初期化
        Util.$filterController.clearFilters();

        // フィルターがあれば対象のElementを追加
        const filterElement = document
            .getElementById("filter-setting-list");

        const length = place.filter.length;
        if (length) {
            document
                .querySelectorAll(".filter-none")[0]
                .style.display = "none";
        }

        for (let idx = 0; idx < length; ++idx) {
            const filter = place.filter[idx];
            Util
                .$filterController[`add${filter.name}`](
                    filterElement, filter, false
                );
        }
    }

    /**
     * @abstract
     */
    // eslint-disable-next-line no-empty-function
    toObject () {}

    /**
     * @param  {number} width
     * @param  {number} height
     * @param  {object} place
     * @param  {object} [range = null]
     * @param  {number} [dx = 0]
     * @param  {number} [dy = 0]
     * @return {HTMLImageElement}
     * @method
     * @public
     */
    toImage (width, height, place, range = null, dx = 0, dy = 0)
    {
        // empty image
        if (!width || !height) {
            return Util.$emptyImage;
        }

        const { Matrix } = window.next2d.geom;

        const instance = this.createInstance(place, range);

        const matrix = this.calcMatrix(
            instance, width, height, place, dx, dy
        );

        const object = this.calcFilter(width, height, place, matrix);
        instance.filters = object.filters;

        // fixed logic
        instance
            .transform
            .matrix = new Matrix(
                place.matrix[0], place.matrix[1],
                place.matrix[2], place.matrix[3],
                0, 0
            );

        // fixed logic
        instance
            .transform
            .colorTransform = this.calcColorTransform(place);

        const container  = this.createContainer(instance);
        const bitmapData = this.createBitmapData(object.width, object.height);
        bitmapData.draw(container, matrix);

        const image = new Image();
        image.src = bitmapData.toDataURL();
        bitmapData.dispose();

        image.width     = object.width;
        image.height    = object.height;
        image._$width   = object.width;
        image._$height  = object.height;
        image.draggable = false;

        const bounds = this.getBounds(place.matrix, place, range);

        image._$tx = bounds.xMin;
        image._$ty = bounds.yMin;

        image._$offsetX = 0 > object.offsetX ? object.offsetX : 0;
        image._$offsetY = 0 > object.offsetY ? object.offsetY : 0;

        return image;
    }

    /**
     * @param  {object} place
     * @return {next2d.geom.ColorTransform}
     * @method
     * @public
     */
    calcColorTransform (place)
    {
        const { ColorTransform } = window.next2d.geom;

        return new ColorTransform(
            place.colorTransform[0], place.colorTransform[1],
            place.colorTransform[2], place.colorTransform[3],
            place.colorTransform[4], place.colorTransform[5],
            place.colorTransform[6], place.colorTransform[7]
        );
    }

    /**
     * @param  {DisplayObject} instance
     * @param  {number} width
     * @param  {number} height
     * @param  {object} place
     * @param  {number} [dx = 0]
     * @param  {number} [dy = 0]
     * @return {next2d.geom.Matrix}
     * @method
     * @public
     */
    calcMatrix (instance, width, height, place, dx = 0, dy = 0)
    {
        const { Matrix } = window.next2d.geom;

        const rectangle = instance.getBounds();

        const ratio = window.devicePixelRatio * Util.$zoomScale;
        const multiMatrix = Util.$multiplicationMatrix(
            Util.$multiplicationMatrix(
                [ratio, 0, 0, ratio, 0, 0],
                [
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    0, 0
                ]
            ),
            [
                1, 0, 0, 1,
                -(rectangle.width  / 2) - rectangle.x,
                -(rectangle.height / 2) - rectangle.y
            ]
        );

        const matrix = new Matrix(ratio, 0, 0, ratio);

        matrix.translate(
            multiMatrix[4] + width  * ratio / 2 + dx,
            multiMatrix[5] + height * ratio / 2 + dy
        );

        return matrix;
    }

    /**
     * @param  {number} width
     * @param  {number} height
     * @param  {object} place
     * @param  {next2d.geom.Matrix} matrix
     * @return {object}
     * @method
     * @public
     */
    calcFilter (width, height, place, matrix)
    {
        const { Rectangle } = window.next2d.geom;

        let xScale = Math.sqrt(
            place.matrix[0] * place.matrix[0]
            + place.matrix[1] * place.matrix[1]
        );

        let yScale = Math.sqrt(
            place.matrix[2] * place.matrix[2]
            + place.matrix[3] * place.matrix[3]
        );

        const object = {
            "width":   width,
            "height":  height,
            "offsetX": 0,
            "offsetY": 0,
            "filters": []
        };

        if (place.filter.length) {

            const ratio = window.devicePixelRatio * Util.$zoomScale;

            let rect = new Rectangle(0, 0, width, height);

            for (let idx = 0; idx < place.filter.length; ++idx) {

                const filter = place.filter[idx];
                if (!filter.state) {
                    continue;
                }

                const instance = filter.createInstance();

                rect = instance._$generateFilterRect(rect, xScale, yScale);

                object.filters.push(instance);

            }

            object.width  = Math.ceil(rect.width);
            object.height = Math.ceil(rect.height);

            object.offsetX = rect.x;
            object.offsetY = rect.y;

            if (0 > object.offsetX) {
                matrix.translate(-object.offsetX * ratio, 0);
            }

            if (0 > object.offsetY) {
                matrix.translate(0, -object.offsetY * ratio);
            }
        }

        return object;
    }

    /**
     * @param  {DisplayObject} instance
     * @return {next2d.display.Sprite}
     * @method
     * @public
     */
    createContainer (instance)
    {
        const { Sprite } = window.next2d.display;

        const container = new Sprite();
        const sprite = container.addChild(new Sprite());
        sprite.addChild(instance);

        return container;
    }

    /**
     * @param  {number} width
     * @param  {number} height
     * @return {next2d.display.BitmapData}
     * @method
     * @public
     */
    createBitmapData (width, height)
    {
        const { BitmapData } = window.next2d.display;

        const ratio = window.devicePixelRatio * Util.$zoomScale;

        return new BitmapData(
            Math.ceil(width  * ratio),
            Math.ceil(height * ratio),
            true, 0
        );
    }

    /**
     * @abstract
     */
    // eslint-disable-next-line no-empty-function
    toPublish () {}

    /**
     * @abstract
     */
    // eslint-disable-next-line no-empty-function,getter-return
    get defaultSymbol () {}

    /**
     * @abstract
     */
    // eslint-disable-next-line no-empty-function
    createInstance () {}

    /**
     * @interface
     */
    // eslint-disable-next-line no-empty-function
    getBounds () {}

    /**
     * @description ライブラリからの削除処理、配置先からも削除を行う
     *
     * @return {void}
     * @method
     * @public
     */
    remove ()
    {
        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;
        for (let instance of workSpace._$libraries.values()) {

            if (instance.type !== "container") {
                continue;
            }

            for (let layer of instance._$layers.values()) {

                let reload = false;
                const characters = layer._$characters;
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];
                    if (this.id === character.libraryId) {

                        for (const keyFrame of character._$places.keys()) {

                            const range = character.getRange(keyFrame);

                            // 空のキーフレームがあればスキップ
                            if (layer.getActiveEmptyCharacter(keyFrame)) {
                                continue;
                            }

                            // DisplayObjectが配置されていればスキップ
                            const activeCharacters = layer.getActiveCharacter(keyFrame);
                            let done = false;
                            for (let idx = 0; idx < activeCharacters.length; ++idx) {

                                const activeCharacter = activeCharacters[idx];
                                if (activeCharacter.id === character.id) {
                                    continue;
                                }

                                done = true;
                            }

                            if (done) {
                                continue;
                            }

                            // 削除するレンジに空のキーフレームを登録
                            layer.addEmptyCharacter(new EmptyCharacter({
                                "startFrame": range.startFrame,
                                "endFrame": range.endFrame
                            }));
                        }

                        // 登録先のレイヤーから削除
                        layer.deleteCharacter(character.id);
                        reload = true;
                    }
                }

                // 表示中のレイヤーならスタイルを更新
                if (reload && scene.id === instance.id) {
                    layer.reloadStyle();
                }
            }

            if (instance._$sounds.size) {
                for (const [frame, sounds] of instance._$sounds) {

                    const pool = [];
                    for (let idx = 0; idx < sounds.length; ++idx) {

                        const sound = sounds[idx];
                        if (this.id === sound.characterId) {
                            continue;
                        }

                        pool.push(sound);
                    }

                    // 削除対象以外を再登録
                    instance._$sounds.set(frame, pool);
                }
            }
        }
    }

    /**
     * @description プレビュー画像を生成
     *
     * @return {HTMLImageElement}
     * @method
     * @public
     */
    getPreview ()
    {
        const bounds = this.getBounds([1, 0, 0, 1, 0, 0]);

        // size
        let width  = Math.abs(bounds.xMax - bounds.xMin);
        let height = Math.abs(bounds.yMax - bounds.yMin);
        if (!width || !height) {
            return Util.$emptyImage;
        }

        let scaleX   = 1;
        const scaleY = 150 / height;

        width  = width  * scaleY | 0;
        height = height * scaleY | 0;

        const controllerWidth = (document
            .documentElement
            .style
            .getPropertyValue("--controller-width")
            .split("px")[0] | 0) - 10;

        if (width > controllerWidth) {
            scaleX = controllerWidth / width;
            width  = width  * scaleX | 0;
            height = height * scaleX | 0;
        }

        const image = this.toImage(
            Math.ceil(width),
            Math.ceil(height),
            {
                "frame": 1,
                "matrix": [scaleY * scaleX, 0, 0, scaleY * scaleX, 0, 0],
                "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                "blendMode": "normal",
                "filter": []
            }
        );

        if (image.height !== height) {
            const height = Math.min(150, image.height);
            image.width  *= height / image.height;
            image.height  = height;
        }

        return image;
    }

    /**
     * @return {number}
     * @public
     */
    get id ()
    {
        return this._$id;
    }

    /**
     * @param  {number} id
     * @return {void}
     * @public
     */
    set id (id)
    {
        this._$id = id | 0;
    }

    /**
     * @return {number}
     * @public
     */
    get folderId ()
    {
        return this._$folderId;
    }

    /**
     * @param  {number} id
     * @return {void}
     * @public
     */
    set folderId (id)
    {
        this._$folderId = id | 0;
    }

    /**
     * @return {string}
     * @readonly
     * @public
     */
    get path ()
    {
        const workSpace = Util.$currentWorkSpace();

        let path = this.name;
        if (this._$folderId) {
            let parent = this;
            while (parent._$folderId) {
                parent = workSpace.getLibrary(parent._$folderId);
                path = `${parent.name}/${path}`;
            }
        }

        return path;
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @param  {string} name
     * @return {void}
     * @public
     */
    set name (name)
    {
        this._$name = `${name}`;

        if (this.id) {
            const libraryElement = document
                .getElementById(`library-name-${this.id}`);
            libraryElement.textContent = this._$name;
        }

        if (Util.$currentWorkSpace().scene.id === this.id) {
            document
                .getElementById("object-name")
                .value = this._$name;

            document
                .getElementById("scene-name")
                .textContent = this._$name;

        }

    }

    /**
     * @return {string}
     * @public
     */
    get type ()
    {
        return this._$type;
    }

    /**
     * @param  {string} type
     * @return {void}
     * @public
     */
    set type (type)
    {
        this._$type = `${type}`;
    }

    /**
     * @return {string}
     * @public
     */
    get symbol ()
    {
        return this._$symbol;
    }

    /**
     * @param  {string} symbol
     * @return {void}
     * @public
     */
    set symbol (symbol)
    {
        this._$symbol = `${symbol}`;

        if (this.id) {
            document
                .getElementById(`library-symbol-name-${this.id}`)
                .textContent = `${symbol}`;
        }
    }
}

/**
 * @class
 * @extends {Instance}
 */
class Bitmap extends Instance {
    /**
     * @param {object} object
     * @constructor
     */
    constructor(object) {
        super(object);

        this.imageType = object.imageType;
        this.width = object.width;
        this.height = object.height;

        this._$buffer = null;
        if (object.buffer) {
            this.buffer = object.buffer;
        }
        this._$command = null;
        this._$binary = "";
    }

    /**
     * @param  {object} place
     * @param  {string} [name=""]
     * @return {void}
     * @method
     * @public
     */
    showController(place, name = "")
    {
        super.showController(place, name);

        Util.$controller.hideObjectSetting([
            "text-setting",
            "loop-setting",
            "video-setting",
            "fill-color-setting",
            "nine-slice-setting"
        ]);
    }

    /**
     * @param  {array} [matrix=null]
     * @return {object}
     * @public
     */
    getBounds (matrix = null)
    {
        const bounds = {
            "xMin": 0,
            "xMax": this.width,
            "yMin": 0,
            "yMax": this.height
        };

        return matrix
            ? Util.$boundsMatrix(bounds, matrix)
            : bounds;
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.display.Shape.namespace;
    }

    /**
     * @return {string}
     * @public
     */
    get buffer ()
    {
        if (!this._$binary) {

            const length = this._$buffer.length;

            for (let idx = 0; idx < length; ++idx) {
                this._$binary += String.fromCharCode(this._$buffer[idx]);
            }

        }

        return this._$binary;
    }

    /**
     * @param  {string|Uint8Array} binary
     * @return {void}
     * @public
     */
    set buffer (binary)
    {

        switch (typeof binary) {

            case "object":
                if (binary.constructor === Uint8Array) {
                    this._$buffer = binary;
                }
                break;

            case "string":
                if (!this._$binary) {
                    let length = binary.length;

                    this._$buffer = new Uint8Array(length);
                    for (let idx = 0; idx < length; ++idx) {
                        this._$buffer[idx] = binary.charCodeAt(idx) & 0xff;
                    }

                    this._$binary = binary;
                }
                break;

            default:
                break;

        }
    }

    /**
     * @return {string}
     * @public
     */
    get imageType ()
    {
        return this._$imageType;
    }

    /**
     * @param  {string} image_type
     * @return {void}
     * @public
     */
    set imageType (image_type)
    {
        this._$imageType = image_type;
    }

    /**
     * @return {uint}
     * @public
     */
    get width ()
    {
        return this._$width;
    }

    /**
     * @param  {uint} width
     * @return {void}
     * @public
     */
    set width (width)
    {
        this._$width = width;
    }

    /**
     * @return {uint}
     * @public
     */
    get height ()
    {
        return this._$height;
    }

    /**
     * @param  {uint} height
     * @return {void}
     * @public
     */
    set height (height)
    {
        this._$height = height;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":        this.id,
            "name":      this.name,
            "type":      this.type,
            "symbol":    this.symbol,
            "folderId":  this.folderId,
            "width":     this.width,
            "height":    this.height,
            "imageType": this.imageType,
            "buffer":    this.buffer
        };
    }

    /**
     * @return {object}
     * @public
     */
    toPublish ()
    {
        return {
            "symbol":  this.symbol,
            "extends": this.defaultSymbol,
            "buffer":  Array.from(this._$buffer),
            "bounds":  this.getBounds()
        };
    }

    /**
     * @return {next2d.display.Shape}
     * @public
     */
    createInstance ()
    {
        const { Shape, BitmapData } = window.next2d.display;
        const { width, height } = this;

        const shape = new Shape();

        const bitmapData = new BitmapData(width, height, true, 0);
        bitmapData._$buffer = this._$buffer;

        shape
            .graphics
            .beginBitmapFill(bitmapData, null, false)
            .drawRect(0, 0, width, height)
            .endFill();

        // setup
        shape.graphics._$maxAlpha = 1;
        shape.graphics._$canDraw  = true;
        shape.graphics._$xMin     = 0;
        shape.graphics._$xMax     = this.width;
        shape.graphics._$yMin     = 0;
        shape.graphics._$yMax     = this.height;
        shape.graphics._$command  = this._$command;

        return shape;
    }
}

/**
 * @class
 */
class Character
{
    /**
     * @param {object} object
     *
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        this._$libraryId      = -1;
        this._$layerId        = -1;
        this._$places         = new Map();
        this._$image          = null;
        this._$currentFrame   = 0;
        this._$currentPlace   = null;
        this._$screenX        = 0;
        this._$screenY        = 0;
        this._$offsetX        = 0;
        this._$offsetY        = 0;
        this._$name           = "";
        this._$tween          = new Map();
        this._$referencePoint = { "x": 0, "y": 0 };

        if (object) {
            this._$id           = object.id;
            this._$libraryId    = object.libraryId;
            this.places         = object.places;
            this._$name         = object.name || "";
            this._$startFrame   = object.startFrame;
            this._$endFrame     = object.endFrame;
            this.tween          = object.tween;
            this.referencePoint = object.referencePoint;
        } else {
            this._$id         = Util.$currentWorkSpace()._$characterId++;
            this._$startFrame = 1;
            this._$endFrame   = 2;
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    showController ()
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(this.libraryId);

        const frame = Util.$timelineFrame.currentFrame;

        instance.showController(this.getPlace(frame), this.name);

        // tweenの設定があれば表示
        const range = this.getRange(frame);
        if (this.hasTween(range.startFrame)) {

            // コントローラーエリアを表示
            Util.$controller.showObjectSetting([
                "ease-setting"
            ]);

            // 選択中の関数をselectにセット
            const tweenObject = this.getTween(range.startFrame);

            const children = document
                .getElementById("ease-select")
                .children;

            for (let idx = 0; idx < children.length; ++idx) {

                const node = children[idx];
                if (node.value !== tweenObject.method) {
                    continue;
                }

                node.selected = true;
                break;
            }

            // カスタム設定であればcanvasを表示
            if (tweenObject.method === "custom") {

                Util.$tweenController.showCustomArea();

            } else {

                Util.$tweenController.hideCustomArea();

            }
        }
    }

    /**
     * @param {MouseEvent} event
     */
    showShapeColor (event)
    {
        Util.$controller.hideObjectSetting([
            "fill-color-setting"
        ]);

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(this.libraryId);

        if (instance.type !== "shape") {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;

        instance.showShapeColor(this.getPlace(frame), event);
    }

    /**
     * @return {Character}
     * @public
     */
    clone ()
    {
        const character = new Character(this.toObject());
        character._$layerId = -1;
        character._$id      = Util.$currentWorkSpace()._$characterId++;
        return character;
    }

    /**
     * @description タイムラインからDisplayObjectを削除
     *
     * @param  {Layer} layer
     * @return {void}
     * @method
     * @public
     */
    remove (layer)
    {
        if (this._$places.size === 1) {

            layer.deleteCharacter(this.id);

        } else {

            const range = this.getRange(
                Util.$timelineFrame.currentFrame
            );

            switch (true) {

                case range.startFrame === this.startFrame:
                    this._$places.delete(this.startFrame);
                    this.startFrame = range.endFrame;
                    break;

                case range.endFrame === this.endFrame:
                    this._$places.delete(range.startFrame);
                    this.endFrame = range.startFrame;
                    break;

                default:
                    {
                        const character = this.split(
                            layer, range.startFrame, range.endFrame
                        );

                        if (character._$tween.size) {
                            Util
                                .$tweenController
                                .clearPointer();
                        }
                    }
                    break;

            }

            // tween情報を削除
            if (this._$tween.has(range.startFrame)) {

                this._$tween.delete(range.startFrame);

                for (let keyFrame = range.startFrame; keyFrame < range.endFrame; ++keyFrame) {
                    if (!this._$places.has(keyFrame)) {
                        continue;
                    }
                    this._$places.delete(keyFrame);
                }

                Util
                    .$tweenController
                    .clearPointer();
            }

        }
    }

    /**
     * @description tweenの座標を再計算してポインターを再配置
     *
     * @param {number} frame
     * @method
     * @public
     */
    relocationTween (frame)
    {
        if (!this._$tween.size) {
            return ;
        }

        const range = this.getRange(frame);
        if (this.hasTween(range.startFrame)) {

            // 変更したフレームにキーフレームがなければ自動的に追加
            // 最後のフレームは対象外
            if (this.endFrame - 1 > frame && !this.hasTween(frame)) {
                Util
                    .$timelineTool
                    .executeTimelineKeyAdd();
            }

            Util
                .$tweenController
                .relocationPlace(this, range.startFrame);

            Util
                .$tweenController
                .clearPointer()
                .relocationPointer();
        }
    }

    /**
     * @description 指定したフレームをキーフレームの開始・終了のフレームを返す
     *
     * @param  {number} frame
     * @return {object}
     * @method
     * @public
     */
    getRange (frame)
    {
        if (this._$places.size === 1) {
            return {
                "startFrame": this.startFrame,
                "endFrame": this.endFrame
            };
        }

        const places = Array.from(this._$places.keys());

        // 降順
        places.sort((a, b) =>
        {
            switch (true) {

                case a > b:
                    return 1;

                case a < b:
                    return -1;

                default:
                    return 0;

            }
        });

        let prevFrame = 0;
        while (places.length) {

            const placeFrame = places.pop() | 0;

            if (frame >= placeFrame) {
                const place = this.getPlace(placeFrame);
                if (place.tweenFrame) {
                    const tweenObject = this.getTween(place.tweenFrame);
                    return {
                        "startFrame": tweenObject.startFrame,
                        "endFrame": tweenObject.endFrame
                    };
                }

                return {
                    "startFrame": placeFrame,
                    "endFrame": prevFrame ? prevFrame : this.endFrame
                };
            }

            prevFrame = placeFrame;
        }

        return {
            "startFrame": this.startFrame,
            "endFrame": this.endFrame
        };
    }

    /**
     * @description tweenオブジェクトを複製
     *
     * @param  {number} frame
     * @return {object}
     * @method
     * @public
     */
    getCloneTween (frame)
    {
        return JSON.parse(JSON.stringify(this.getTween(frame)));
    }

    /**
     * @param  {number} frame
     * @return {object}
     * @method
     * @public
     */
    getTween (frame)
    {
        return this.hasTween(frame)
            ? this._$tween.get(frame)
            : null;
    }

    /**
     * @param  {number} frame
     * @param  {object} object
     * @return {void}
     * @method
     * @public
     */
    setTween (frame, object)
    {
        this._$tween.set(frame, object);
    }

    /**
     * @param  {number} frame
     * @return {boolean}
     * @method
     * @public
     */
    hasTween (frame)
    {
        return this._$tween.has(frame);
    }

    /**
     * @param  {number} frame
     * @return {boolean}
     * @method
     * @public
     */
    deleteTween (frame)
    {
        return this._$tween.delete(frame);
    }

    /**
     * @return {object}
     * @method
     * @public
     */
    getBounds ()
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(this.libraryId);

        const frame = Util.$timelineFrame.currentFrame;
        const place = this.getPlace(frame);
        const range = place.loop && place.loop.type === 5
            ? { "startFrame": this.startFrame, "endFrame": this.endFrame }
            : this.getRange(frame);

        // cache
        const currentFrame = Util.$currentFrame;
        Util.$currentFrame = frame;

        const bounds = instance.getBounds(place.matrix, place, range);

        // reset
        Util.$currentFrame = currentFrame;

        return bounds;
    }

    /**
     * @return {number}
     * @public
     */
    get rotation ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        const matrix = this.getPlace(frame).matrix;
        return Math.atan2(matrix[1], matrix[0]) * Util.$Rad2Deg;
    }

    /**
     * @param  {number} rotate
     * @return {void}
     * @public
     */
    set rotation (rotate)
    {
        const frame = Util.$timelineFrame.currentFrame;

        const matrix = this.getPlace(frame).matrix;
        let radianX  = Math.atan2(matrix[1], matrix[0]);
        let radianY  = Math.atan2(-matrix[2], matrix[3]);

        const xScale = Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale = Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        const radian = rotate * Util.$Deg2Rad;
        radianY      = radianY + radian - radianX;
        radianX      = radian;

        matrix[0] = xScale  * Math.cos(radianX);
        matrix[1] = xScale  * Math.sin(radianX);
        matrix[2] = -yScale * Math.sin(radianY);
        matrix[3] = yScale  * Math.cos(radianY);
    }

    /**
     * @return {number}
     * @public
     */
    get width ()
    {
        const bounds = this.getBounds();
        const width  = +Math.abs(bounds.xMax - bounds.xMin);
        return width !== Infinity ? width : 0;
    }

    /**
     * @param  {number} width
     * @return {void}
     * @public
     */
    set width (width)
    {
        const bounds  = this.getBounds();
        const exWidth = Math.abs(bounds.xMax - bounds.xMin);
        this.scaleX   = width / exWidth;
    }

    /**
     * @return {number}
     * @public
     */
    get scaleX ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        const matrix = this.getPlace(frame).matrix;
        return Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
    }

    /**
     * @param  {number} scale_x
     * @return {void}
     * @public
     */
    set scaleX (scale_x)
    {
        const frame = Util.$timelineFrame.currentFrame;

        const matrix = this.getPlace(frame).matrix;
        if (matrix[1]) {

            const radianX = Math.atan2(matrix[1], matrix[0]);

            matrix[1] = scale_x * Math.sin(radianX);
            if (matrix[1] === 1 || matrix[1] === -1) {
                matrix[0] = 0;
            } else {
                matrix[0] = scale_x * Math.cos(radianX);
            }

        } else {

            matrix[0] = scale_x;

        }

    }

    /**
     * @return {number}
     * @public
     */
    get height ()
    {
        const bounds = this.getBounds();
        const height = +Math.abs(bounds.yMax - bounds.yMin);
        return height !== Infinity ? height : 0;
    }

    /**
     * @param  {number} height
     * @return {void}
     * @public
     */
    set height (height)
    {
        const bounds   = this.getBounds();
        const exHeight = Math.abs(bounds.yMax - bounds.yMin);
        this.scaleY    = height / exHeight;
    }

    /**
     * @return {number}
     * @public
     */
    get scaleY ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        const matrix = this.getPlace(frame).matrix;
        return Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);
    }

    /**
     * @param  {number} scale_y
     * @return {void}
     * @public
     */
    set scaleY (scale_y)
    {
        const frame = Util.$timelineFrame.currentFrame;

        const matrix = this.getPlace(frame).matrix;
        if (matrix[2]) {

            const radianY = Math.atan2(-matrix[2], matrix[3]);
            matrix[2] = -scale_y * Math.sin(radianY);
            if (matrix[2] === 1 || matrix[2] === -1) {
                matrix[3] = 0;
            } else {
                matrix[3] = scale_y * Math.cos(radianY);
            }

        } else {

            matrix[3] = scale_y;

        }
    }

    /**
     * @return {number}
     * @public
     */
    get x ()
    {
        const frame = Util.$timelineFrame.currentFrame;
        const place = this.getPlace(frame);
        return place.matrix[4];
    }

    /**
     * @param  {number} x
     * @return {void}
     * @public
     */
    set x (x)
    {
        const frame = Util.$timelineFrame.currentFrame;
        const place = this.getPlace(frame);
        place.matrix[4] = x;

        const bounds = this.getBounds();
        this.screenX = bounds.xMin;

        const element = document
            .getElementById(`character-${this.id}`);

        if (element) {
            element.style.left = `${Util.$offsetLeft + bounds.xMin * Util.$zoomScale}px`;
        }
    }

    /**
     * @return {number}
     * @public
     */
    get y ()
    {
        const frame = Util.$timelineFrame.currentFrame;
        const place = this.getPlace(frame);
        return place.matrix[5];
    }

    /**
     * @param  {number} y
     * @return {void}
     * @public
     */
    set y (y)
    {
        const frame = Util.$timelineFrame.currentFrame;
        const place = this.getPlace(frame);
        place.matrix[5] = y;

        const bounds = this.getBounds();
        this.screenY = bounds.yMin;

        const element = document
            .getElementById(`character-${this.id}`);

        if (element) {
            element.style.top = `${Util.$offsetTop + bounds.yMin * Util.$zoomScale}px`;
        }
    }

    /**
     * @description 表示画像を生成
     *
     * @return {HTMLImageElement}
     * @method
     * @public
     */
    getImage ()
    {
        if (!this._$image) {

            const workSpace = Util.$currentWorkSpace();
            const instance  = workSpace.getLibrary(this.libraryId);

            const frame = Util.$timelineFrame.currentFrame;

            const place = this.getPlace(frame);
            const range = place.loop && place.loop.type === 5
                ? { "startFrame": this.startFrame, "endFrame": this.endFrame }
                : this.getRange(frame);

            // reset
            Util.$currentFrame = frame;

            const bounds = instance.getBounds(place.matrix, place, range);
            const width  = +Math.ceil(Math.abs(bounds.xMax - bounds.xMin));
            const height = +Math.ceil(Math.abs(bounds.yMax - bounds.yMin));

            let image = null;
            switch (place.blendMode) {

                case "invert":
                    image = instance.toImage(width, height,
                        {
                            "frame": place.frame,
                            "matrix": place.matrix,
                            "colorTransform": [
                                0, 0, 0, place.colorTransform[3],
                                0, 0, 0, place.colorTransform[7]
                            ],
                            "blendMode": place.blendMode,
                            "filter": place.filter,
                            "tweenFrame": place.tweenFrame,
                            "loop": place.loop
                        },
                        range
                    );
                    break;

                case "alpha":
                case "erase":
                    image = new Image();
                    break;

                default:
                    image = instance
                        .toImage(width, height, place, range);
                    break;

            }

            this._$image = image;

            // set blend mode
            switch (place.blendMode) {

                case "add":
                    this._$image.style.mixBlendMode = "color-dodge";
                    break;

                case "subtract":
                    this._$image.style.filter = "invert(100%)";
                    this._$image.style.mixBlendMode = "multiply";
                    break;

                case "invert":
                    this._$image.style.filter = "invert(100%)";
                    this._$image.style.mixBlendMode = "difference";
                    break;

                case "hardlight":
                    this._$image.style.mixBlendMode = "hard-light";
                    break;

                case "alpha":
                case "erase":
                case "layer":
                    break;

                default:
                    this._$image.style.mixBlendMode = place.blendMode;
                    break;

            }

            this._$screenX = this._$image._$tx;
            this._$screenY = this._$image._$ty;
            this._$offsetX = this._$image._$offsetX;
            this._$offsetY = this._$image._$offsetY;

            this._$image.style.position = "relative";

            return this._$image;
        }

        return this._$image;
    }

    /**
     * @return {number}
     * @public
     */
    get offsetX ()
    {
        return this._$offsetX;
    }

    /**
     * @return {number}
     * @public
     */
    get offsetY ()
    {
        return this._$offsetY;
    }

    /**
     * @return {number}
     * @public
     */
    get screenX ()
    {
        return this._$screenX;
    }

    /**
     * @param  {number} screen_x
     * @return {void}
     * @public
     */
    set screenX (screen_x)
    {
        this._$screenX = screen_x;
    }

    /**
     * @return {number}
     * @readonly
     * @public
     */
    get screenY ()
    {
        return this._$screenY;
    }

    /**
     * @param  {number} screen_y
     * @return {void}
     * @public
     */
    set screenY (screen_y)
    {
        this._$screenY = screen_y;
    }

    /**
     * @return {number}
     * @readonly
     * @public
     */
    get id ()
    {
        return this._$id;
    }

    /**
     * @return {number}
     * @public
     */
    get libraryId ()
    {
        return this._$libraryId;
    }

    /**
     * @param  {number} library_id
     * @return {void}
     * @public
     */
    set libraryId (library_id)
    {
        this._$libraryId = library_id | 0;
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @param  {string} name
     * @return {void}
     * @public
     */
    set name (name)
    {
        name += "";
        name.replace(" ", "");
        this._$name = name.trim();
    }

    /**
     * @return {object}
     * @public
     */
    get referencePoint ()
    {
        return {
            "x": this._$referencePoint.x,
            "y": this._$referencePoint.y
        };
    }

    /**
     * @param {object} point
     * @public
     */
    set referencePoint (point)
    {
        if (point) {
            this._$referencePoint.x = point.x;
            this._$referencePoint.y = point.y;
        }
    }

    /**
     * @return {array}
     * @public
     */
    get tween ()
    {
        const values = [];
        for (let [frame, value] of this._$tween) {
            values.push({
                "frame": frame,
                "value": value
            });
        }
        return values;
    }

    /**
     * @param  {array} values
     * @return {void}
     * @public
     */
    set tween (values)
    {
        for (let idx = 0; idx < values.length; ++idx) {
            const object = values[idx];
            if (!object.value.custom) {
                object.value.custom = Util
                    .$tweenController
                    .createEasingObject();
            }
            this._$tween.set(object.frame | 0, object.value);
        }
    }

    /**
     * @return {array}
     * @public
     */
    get places ()
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(this.libraryId);

        const places = [];
        for (let [frame, place] of this._$places) {

            place.frame = frame;

            const filters = [];
            for (let idx = 0; idx < place.filter.length; ++idx) {
                filters.push(place.filter[idx].toObject());
            }

            const object = {
                "frame": frame,
                "depth": place.depth,
                "blendMode": place.blendMode,
                "filter": filters,
                "matrix": place.matrix.slice(0),
                "colorTransform": place.colorTransform.slice(0)
            };

            if (place.tweenFrame) {
                object.tweenFrame = place.tweenFrame;
            }

            if (instance.type === "container") {

                if (place.loop) {

                    object.loop = {
                        "type": place.loop.type,
                        "start": place.loop.start,
                        "end": place.loop.end
                    };

                } else {

                    object.loop = Util.$getDefaultLoopConfig();

                }
            }

            places.push(object);
        }
        return places;
    }

    /**
     * @param  {array} places
     * @return {void}
     * @public
     */
    set places (places)
    {
        for (let idx = 0; idx < places.length; ++idx) {

            const place = places[idx];

            const filters = [];
            for (let idx = 0; place.filter.length > idx; ++idx) {
                const object = place.filter[idx];
                filters.push(new Util.$filterClasses[object.name](object));
            }

            place.filter = null;
            place.filter = filters;

            if (!place.loop) {
                place.loop = Util.$getDefaultLoopConfig();
            }

            this._$places.set(place.frame | 0, place);
        }
    }

    /**
     * @param  {number} frame
     * @return {object}
     * @public
     */
    getClonePlace (frame)
    {
        return JSON.parse(JSON.stringify(this.getPlace(frame)));
    }

    /**
     * @param  {number} frame
     * @return {object}
     * @public
     */
    getPlace (frame)
    {
        return this._$places.get(
            this.getNearPlaceFrame(frame | 0)
        );
    }

    /**
     * @description 指定したフレームより若く一番近いキーフレーム番号を返す
     *
     * @param  {number} frame
     * @return {number}
     * @method
     * @public
     */
    getNearPlaceFrame (frame)
    {
        if (this.hasPlace(frame)) {
            return frame;
        }

        const places = Array.from(this._$places.keys());
        if (this._$places.size === 1) {
            return places[0];
        }

        // 降順
        places.sort((a, b) =>
        {
            switch (true) {

                case a > b:
                    return 1;

                case a < b:
                    return -1;

                default:
                    return 0;

            }
        });

        while (places.length) {

            const placeFrame = places.pop() | 0;

            if (frame > placeFrame) {
                return placeFrame;
            }

        }

        return 1;
    }

    /**
     * @param  {number} frame
     * @param  {object} place
     * @return {void}
     * @public
     */
    setPlace (frame, place)
    {
        place.frame = frame | 0;
        this._$places.set(frame | 0, place);
    }

    /**
     * @param  {number} frame
     * @return {boolean}
     * @public
     */
    hasPlace (frame)
    {
        return this._$places.has(frame | 0);
    }

    /**
     * @param  {number} frame
     * @return {void}
     * @public
     */
    deletePlace (frame)
    {
        this._$places.delete(frame | 0);
    }

    /**
     * @return {number}
     * @public
     */
    get startFrame ()
    {
        return this._$startFrame;
    }

    /**
     * @param  {number} start_frame
     * @return {void}
     * @public
     */
    set startFrame (start_frame)
    {
        this._$startFrame = start_frame | 0;
    }

    /**
     * @return {number}
     * @public
     */
    get endFrame ()
    {
        return this._$endFrame;
    }

    /**
     * @param  {number} end_frame
     * @return {void}
     * @public
     */
    set endFrame (end_frame)
    {
        this._$endFrame = end_frame | 0;
    }

    /**
     * @description tweenのplace objectを構築
     *
     * @param  {number} start_frame
     * @param  {number} end_frame
     * @return {void}
     * @method
     * @public
     */
    updateTweenPlace (start_frame, end_frame)
    {
        for (let frame = start_frame; frame < end_frame; ++frame) {

            const place = this.hasPlace(frame)
                ? this.getPlace(frame)
                : this.getClonePlace(end_frame);

            place.tweenFrame = start_frame;

            this.setPlace(frame, place);
        }
    }

    /**
     * @description ブレンドモード追加時にレンジ内のplace objectを更新
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    updateTweenBlend (frame)
    {
        if (!this._$tween.size) {
            return ;
        }

        const range    = this.getRange(frame);
        const keyPlace = this.getPlace(range.startFrame);

        for (let frame = range.startFrame; frame < range.endFrame; ++frame) {

            if (!this.hasPlace(frame)) {

                const clonePlace = this.getClonePlace(range.startFrame);
                clonePlace.blendMode = keyPlace.blendMode;
                this.setPlace(frame, clonePlace);

            } else {

                this
                    .getPlace(frame)
                    .blendMode = keyPlace.blendMode;

            }
        }
    }

    /**
     * @description filter追加時にレンジ内のplace objectにfilterを追加
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    updateTweenFilter (frame)
    {
        if (!this._$tween.size) {
            return ;
        }

        const range    = this.getRange(frame);
        const keyPlace = this.getPlace(range.startFrame);

        for (let frame = range.startFrame; frame < range.endFrame; ++frame) {

            const filters = [];
            const length = keyPlace.filter.length;
            for (let idx = 0; idx < length; ++idx) {
                filters.push(keyPlace.filter[idx].clone());
            }

            if (!this.hasPlace(frame)) {

                const clonePlace  = this.getClonePlace(range.startFrame);
                clonePlace.filter = filters;
                this.setPlace(frame, clonePlace);

            } else {

                this
                    .getPlace(frame)
                    .filter = filters;

            }

        }
    }

    /**
     * @description 指定フレームに移動
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    move (frame)
    {
        const places = new Map();
        for (const [keyFrame, place] of this._$places) {

            place.frame = keyFrame + frame;

            // tweenの情報があればtweenも移動
            if (place.tweenFrame) {
                place.tweenFrame += frame;
            }

            places.set(place.frame, place);
        }

        // キーフレームの情報を上書き
        this._$places = places;

        if (this._$tween.size) {

            const tween = new Map();
            for (const [keyFrame, tweenObject] of this._$tween) {
                tweenObject.startFrame += frame;
                tweenObject.endFrame   += frame;
                tween.set(keyFrame + frame, tweenObject);
            }

            // tweenの情報を上書き
            this._$tween = tween;
        }

        // 開始位置と終了位置を移動
        this.startFrame += frame;
        this.endFrame   += frame;
    }

    /**
     * @description DisplayObjectを指定フレームで分割
     *
     * @param  {Layer} layer
     * @param  {number} start_frame
     * @param  {number} end_frame
     * @return {Character}
     * @public
     */
    split (layer, start_frame, end_frame)
    {
        // 開始と終了位置が一致したらLayerから削除
        if (start_frame === this.startFrame
            && end_frame === this.endFrame
        ) {
            console.log("delete");
            layer.deleteCharacter(this.id);
            return this;
        }

        // 開始位置より先のフレームを指定した場合は分割
        if (start_frame > this.startFrame) {

            // 分離用のobject
            const character = new Character();
            character._$libraryId  = this._$libraryId;
            character._$startFrame = this.startFrame;
            character._$endFrame   = start_frame;

            // object placeを分割して再登録
            const places = new Map();
            for (const [keyFrame, place] of this._$places) {

                if (start_frame > keyFrame) {

                    character.setPlace(keyFrame, place);

                } else {

                    places.set(keyFrame, place);

                }
            }

            const tweenMap = new Map();
            for (const [keyFrame, tween] of this._$tween) {

                if (start_frame > keyFrame) {

                    character.setTween(keyFrame, tween);

                } else {

                    tweenMap.set(keyFrame, tween);

                }

            }

            // レイヤーに設置
            layer.addCharacter(character);

            // 分割したDisplayObjectの情報を更新
            this._$tween      = tweenMap;
            this._$places     = places;
            this._$startFrame = start_frame;
        }

        // 返却用のDisplayObject
        const character = new Character();
        character._$libraryId  = this._$libraryId;
        character._$startFrame = start_frame;
        character._$endFrame   = end_frame;

        const removeFrames = [];
        for (const [keyFrame, place] of this._$places) {

            if (start_frame > keyFrame) {
                continue;
            }

            if (keyFrame >= end_frame) {
                continue;
            }

            removeFrames.push(keyFrame);
            character._$places.set(keyFrame, place);
        }

        // 分割したplace objectは削除
        for (let idx = 0; idx < removeFrames.length; ++idx) {
            this._$places.delete(removeFrames[idx]);
        }

        // 初期化
        removeFrames.length = 0;
        for (const [keyFrame, tween] of this._$tween) {

            if (start_frame > keyFrame) {
                continue;
            }

            if (keyFrame >= end_frame) {
                continue;
            }

            removeFrames.push(keyFrame);
            character._$tween.set(keyFrame, tween);
        }

        // 分割したtween objectは削除
        for (let idx = 0; idx < removeFrames.length; ++idx) {
            this._$tween.delete(removeFrames[idx]);
        }

        // キーフレームがなければ削除
        if (!this._$places.size) {

            layer.deleteCharacter(this.id);

        } else {

            // キーフレームを配列変換
            const keys = Array.from(this._$places.keys());

            // 昇順に並び替え
            if (this._$places.size > 1) {
                keys.sort((a, b) =>
                {
                    switch (true) {

                        case a > b:
                            return 1;

                        case a < b:
                            return -1;

                        default:
                            return 0;

                    }
                });
            }

            this._$startFrame = keys[0] | 0;
        }

        return character;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":             this.id,
            "name":           this.name,
            "libraryId":      this.libraryId,
            "places":         this.places,
            "startFrame":     this.startFrame,
            "endFrame":       this.endFrame,
            "tween":          this.tween,
            "referencePoint": this.referencePoint
        };
    }
}

/**
 * @class
 */
class EmptyCharacter
{
    /**
     * @param {object} object
     *
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        if (object) {
            this._$startFrame = object.startFrame;
            this._$endFrame   = object.endFrame;
        } else {
            this._$startFrame = 1;
            this._$endFrame   = 2;
        }
    }

    /**
     * @return {number}
     * @public
     */
    get startFrame ()
    {
        return this._$startFrame;
    }

    /**
     * @param  {number} start_frame
     * @return {void}
     * @public
     */
    set startFrame (start_frame)
    {
        this._$startFrame = start_frame | 0;
    }

    /**
     * @return {number}
     * @public
     */
    get endFrame ()
    {
        return this._$endFrame;
    }

    /**
     * @param  {number} end_frame
     * @return {void}
     * @public
     */
    set endFrame (end_frame)
    {
        this._$endFrame = end_frame | 0;
    }

    /**
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "startFrame": this.startFrame,
            "endFrame": this.endFrame
        };
    }

    /**
     * @description 指定フレームに移動
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    move (frame)
    {
        this._$startFrame += frame;
        this._$endFrame   += frame;
    }

    /**
     * @description 指定フレームの幅を削除して分割
     *
     * @param  {Layer} layer
     * @param  {number} start_frame
     * @param  {number} end_frame
     * @return {void}
     * @method
     * @public
     */
    split (layer, start_frame, end_frame)
    {
        // 一旦削除
        layer.deleteEmptyCharacter(this);

        if (start_frame > this.startFrame) {
            layer.addEmptyCharacter(new EmptyCharacter({
                "startFrame": this.startFrame,
                "endFrame": start_frame
            }));
        }

        if (this.endFrame > end_frame) {
            layer.addEmptyCharacter(new EmptyCharacter({
                "startFrame": end_frame,
                "endFrame": this.endFrame
            }));
        }

    }
}

/**
 * @class
 * @extends {Instance}
 */
class Folder extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object)
    {
        super(object);

        this._$mode = "clone";
        if (object.mode) {
            this._$mode = object.mode;
        }
    }

    /**
     * @return {string}
     * @public
     */
    get mode ()
    {
        return this._$mode;
    }

    /**
     * @param  {string} mode
     * @return {void}
     * @public
     */
    set mode (mode)
    {
        this._$mode = mode;
    }

    /**
     * @description フォルダーの中身の削除処理
     *
     * @return {void}
     * @method
     * @public
     */
    remove ()
    {
        const workSpace = Util.$currentWorkSpace();
        for (let instance of workSpace._$libraries.values()) {

            // フォルダの中にないか、IDが一致ない時はスキップ
            if (!instance.folderId || instance.folderId !== this.id) {
                continue;
            }

            instance.remove();

            // 内部データからも削除
            workSpace.removeLibrary(instance.id);
        }
    }

    /**
     * @description セーブデータに変換
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "id":       this.id,
            "name":     this.name,
            "type":     this.type,
            "symbol":   this.symbol,
            "folderId": this.folderId,
            "mode":     this.mode
        };
    }

    /**
     * @description フォルダ内のアイテムIDを配列に格納
     *
     * @return {void}
     * @method
     * @public
     */
    getInstanceIds (instance_ids)
    {
        const workSpace = Util.$currentWorkSpace();
        for (const instance of workSpace._$libraries.values()) {

            if (!instance.folderId || instance.folderId !== this.id) {
                continue;
            }

            if (instance.type === "folder") {
                instance.getInstanceIds(instance_ids);
                continue;
            }

            instance_ids.push(instance.id);
        }
    }
}

/**
 * @class
 */
class FolderType
{
    /**
     * @return {string}
     * @static
     * @const
     */
    static get OPEN ()
    {
        return "open";
    }

    /**
     * @return {string}
     * @static
     * @const
     */
    static get CLOSE ()
    {
        return "close";
    }
}

/**
 * @class
 */
class Layer
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        this._$id         = 0;
        this._$characters = [];
        this._$emptys     = [];
        this._$instances  = new Map();

        this._$maskId     = null;
        this._$guideId    = null;
        this._$name       = null;
        this._$light      = false;
        this._$disable    = false;
        this._$lock       = false;
        this._$mode       = Util.LAYER_MODE_NORMAL;
        this._$color      = TimelineHighlight.color;

        if (object) {
            this._$name          = object.name;
            this._$light         = object.light;
            this._$disable       = object.disable;
            this._$lock          = object.lock;
            this._$mode          = object.mode;
            this._$maskId        = object.maskId;
            this._$guideId       = object.guideId;
            this._$color         = object.color || this._$color;
            this.characters      = object.characters;
            this.emptyCharacters = object.emptyCharacters || [];
        }
    }

    /**
     * @return {void}
     * @public
     */
    initialize ()
    {
        // レイヤに必要なフレームをタイムラインに生成
        Util.$timelineLayer.create();

        const element = document
            .getElementById("timeline-content")
            .lastElementChild;

        // set id
        this.id = element.dataset.layerId | 0;

        const name = document.getElementById(`layer-name-${this.id}`);
        if (this.name) {
            name.textContent = this.name;
            document
                .getElementById(`layer-name-input-${this.id}`)
                .value = this.name;
        } else {
            this.name = name.textContent;
        }

        const lightIcon = document
            .getElementById(`layer-light-icon-${this.id}`);

        lightIcon
            .style
            .backgroundImage = `url('${this.getHighlightURL()}')`;

        if (this.light) {

            lightIcon
                .classList
                .remove("icon-disable");

            lightIcon
                .classList
                .add("light-icon-active");

            element
                .style
                .borderBottom = `1px solid ${this.color}`;
        }

        if (this.disable) {

            const disableIcon = document
                .getElementById(`layer-disable-icon-${this.id}`);

            disableIcon
                .classList
                .remove("icon-disable");

            disableIcon
                .classList
                .add("icon-active");
        }

        if (this.lock) {

            const lockIcon = document
                .getElementById(`layer-lock-icon-${this.id}`);

            lockIcon
                .classList
                .remove("icon-disable");

            lockIcon
                .classList
                .add("icon-active");
        }

        // view
        this.showIcon();
        this.reloadStyle();
    }

    /**
     * @description ハイライトカラーをセットしたsvgのパスを返す
     *
     * @return {string}
     * @method
     * @public
     */
    getHighlightURL ()
    {
        const object = Util.$intToRGB(
            `0x${this.color.slice(1)}` | 0
        );
        return `data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="13" height="13" viewBox="0 0 24 24"><path fill="rgb(${object.R},${object.G},${object.B})" d="M14 19h-4c-.276 0-.5.224-.5.5s.224.5.5.5h4c.276 0 .5-.224.5-.5s-.224-.5-.5-.5zm0 2h-4c-.276 0-.5.224-.5.5s.224.5.5.5h4c.276 0 .5-.224.5-.5s-.224-.5-.5-.5zm.25 2h-4.5l1.188.782c.154.138.38.218.615.218h.895c.234 0 .461-.08.615-.218l1.187-.782zm3.75-13.799c0 3.569-3.214 5.983-3.214 8.799h-1.989c-.003-1.858.87-3.389 1.721-4.867.761-1.325 1.482-2.577 1.482-3.932 0-2.592-2.075-3.772-4.003-3.772-1.925 0-3.997 1.18-3.997 3.772 0 1.355.721 2.607 1.482 3.932.851 1.478 1.725 3.009 1.72 4.867h-1.988c0-2.816-3.214-5.23-3.214-8.799 0-3.723 2.998-5.772 5.997-5.772 3.001 0 6.003 2.051 6.003 5.772zm4-.691v1.372h-2.538c.02-.223.038-.448.038-.681 0-.237-.017-.464-.035-.69h2.535zm-10.648-6.553v-1.957h1.371v1.964c-.242-.022-.484-.035-.726-.035-.215 0-.43.01-.645.028zm-3.743 1.294l-1.04-1.94 1.208-.648 1.037 1.933c-.418.181-.822.401-1.205.655zm10.586 1.735l1.942-1.394.799 1.115-2.054 1.473c-.191-.43-.423-.827-.687-1.194zm-3.01-2.389l1.038-1.934 1.208.648-1.041 1.941c-.382-.254-.786-.473-1.205-.655zm-10.068 3.583l-2.054-1.472.799-1.115 1.942 1.393c-.264.366-.495.763-.687 1.194zm13.707 6.223l2.354.954-.514 1.271-2.425-.982c.21-.397.408-.812.585-1.243zm-13.108 1.155l-2.356 1.06-.562-1.251 2.34-1.052c.173.433.371.845.578 1.243zm-1.178-3.676h-2.538v-1.372h2.535c-.018.226-.035.454-.035.691 0 .233.018.458.038.681z"/></svg>`;
    }

    /**
     * @description レイヤーを複製
     *
     * @return {Layer}
     * @method
     * @public
     */
    clone ()
    {
        return new Layer(this.toObject());
    }

    /**
     * @param  {number} [frame=1]
     * @return {void}
     * @public
     */
    appendCharacter (frame = 1)
    {
        if (this.disable) {
            return ;
        }

        const element = document
            .getElementById("timeline-onion-skin");

        if (element.classList.contains("onion-skin-active")
            && Util.$timelinePlayer.stopFlag
        ) {

            const cacheFrame = Util.$timelineFrame.currentFrame;

            // レイヤーのキーフレームをセット
            const keyMap = new Map();
            for (let idx = 0; idx < this._$characters.length; ++idx) {

                const character = this._$characters[idx];

                for (let keyFrame of character._$places.keys()) {
                    keyMap.set(keyFrame, true);
                }

            }

            // 選択中のキーフレームは排除
            const activeCharacters = this.getActiveCharacter(cacheFrame);
            if (activeCharacters.length) {
                const range = activeCharacters[0].getRange(cacheFrame);
                keyMap.delete(range.startFrame);
            }

            for (const frame of keyMap.keys()) {

                Util.$timelineFrame.currentFrame = frame;

                const characters = this.getActiveCharacter(frame);
                if (!characters.length) {
                    continue;
                }

                if (characters.length > 1) {
                    this.sort(characters, frame);
                }

                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];
                    character._$image = null;

                    Util.$screen.appendOnionCharacter(character, this.id);
                }
            }

            Util.$timelineFrame.currentFrame = cacheFrame;

            const characters = this.getActiveCharacter(cacheFrame);
            if (characters.length) {

                if (characters.length > 1) {
                    this.sort(characters, cacheFrame);
                }

                const event = this.lock ? "none" : "auto";
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];
                    character._$image = null;

                    Util.$screen.appendCharacter(
                        character, cacheFrame, this.id, event
                    );
                }

            }

        } else {

            const characters = this.getActiveCharacter(frame);
            if (characters.length) {

                if (characters.length > 1) {
                    this.sort(characters, frame);
                }

                const event = this.lock ? "none" : "auto";
                for (let idx = 0; idx < characters.length; ++idx) {
                    Util.$screen.appendCharacter(
                        characters[idx], frame, this.id, event
                    );
                }

            }
        }
    }

    /**
     * @param {array}  characters
     * @param {number} frame
     * @public
     */
    sort (characters, frame)
    {
        characters.sort((a, b) =>
        {
            const depthA = a.getPlace(frame).depth;
            const depthB = b.getPlace(frame).depth;
            switch (true) {

                case depthA > depthB:
                    return 1;

                case depthA < depthB:
                    return -1;

                default:
                    return 0;

            }
        });
    }

    /**
     * @param  {number} [frame=1]
     * @return {array}
     * @public
     */
    getActiveCharacter (frame = 1)
    {
        const characters = [];
        for (let idx = 0; idx < this._$characters.length; ++idx) {

            const character = this._$characters[idx];

            if (character.startFrame > frame) {
                continue;
            }

            if (frame >= character.endFrame) {
                continue;
            }

            characters.push(character);
        }
        return characters;
    }

    /**
     * @description 指定したフレームに空のキャラクターオブジェクトがあれば返す
     *
     * @param  {number} [frame=1]
     * @return {object}
     * @public
     */
    getActiveEmptyCharacter (frame = 1)
    {
        for (let idx = 0; idx < this._$emptys.length; ++idx) {

            const character = this._$emptys[idx];

            if (character.startFrame > frame) {
                continue;
            }

            if (frame >= character.endFrame) {
                continue;
            }

            return character;
        }
        return null;
    }

    /**
     * @return {void}
     * @public
     */
    clearActiveCharacter ()
    {
        for (let idx = 0; idx < this._$characters.length; ++idx) {

            const character = this._$characters[idx];

            const element = document
                .getElementById(`character-${character.id}`);

            if (element) {
                element.style.border = "";
            }
        }
    }

    /**
     * @return {void}
     * @public
     */
    showIcon ()
    {

        // default
        const layerNameElement = document
            .getElementById(`layer-name-${this.id}`);

        layerNameElement
            .classList
            .remove("in-view-text");

        layerNameElement
            .classList
            .add("view-text");

        const inputElement = document
            .getElementById(`layer-name-input-${this.id}`);

        inputElement
            .classList
            .remove("in-view-text-input");

        switch (this._$mode) {

            case Util.LAYER_MODE_NORMAL:

                document
                    .getElementById(`layer-icon-${this.id}`)
                    .style.display = "";
                document
                    .getElementById(`layer-mask-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`layer-mask-in-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`layer-guide-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`layer-guide-in-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`timeline-exit-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`timeline-exit-in-icon-${this.id}`)
                    .style.display = "none";

                break;

            case Util.LAYER_MODE_MASK:
                {
                    document
                        .getElementById(`layer-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-icon-${this.id}`)
                        .style.display = "";
                    document
                        .getElementById(`layer-mask-in-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-guide-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-guide-in-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`timeline-exit-in-icon-${this.id}`)
                        .style.display = "none";

                    const exitIcon = document
                        .getElementById(`timeline-exit-icon-${this.id}`);

                    exitIcon.style.display = "";
                    exitIcon.style.opacity = "0";
                }
                break;

            case Util.LAYER_MODE_MASK_IN:
                {
                    document
                        .getElementById(`layer-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-in-icon-${this.id}`)
                        .style.display = "";
                    document
                        .getElementById(`layer-guide-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-guide-in-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`timeline-exit-icon-${this.id}`)
                        .style.display = "none";

                    const exitInIcon = document
                        .getElementById(`timeline-exit-in-icon-${this.id}`);

                    exitInIcon.style.display = "";
                    exitInIcon.style.opacity = "0";

                    const layerNameElement = document
                        .getElementById(`layer-name-${this.id}`);

                    layerNameElement
                        .classList
                        .remove("view-text");

                    layerNameElement
                        .classList
                        .add("in-view-text");

                    const inputElement = document
                        .getElementById(`layer-name-input-${this.id}`);

                    inputElement
                        .classList
                        .add("in-view-text-input");

                }
                break;

            case Util.LAYER_MODE_GUIDE:
                {
                    document
                        .getElementById(`layer-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-in-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-guide-icon-${this.id}`)
                        .style.display = "";
                    document
                        .getElementById(`layer-guide-in-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`timeline-exit-in-icon-${this.id}`)
                        .style.display = "none";

                    const exitIcon = document
                        .getElementById(`timeline-exit-icon-${this.id}`);

                    exitIcon.style.display = "";
                    exitIcon.style.opacity = "0";
                }
                break;

            case Util.LAYER_MODE_GUIDE_IN:
                {
                    document
                        .getElementById(`layer-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-in-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-guide-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-guide-in-icon-${this.id}`)
                        .style.display = "";

                    const exitInIcon = document
                        .getElementById(`timeline-exit-in-icon-${this.id}`);

                    exitInIcon.style.display = "";
                    exitInIcon.style.opacity = "0";

                    const layerNameElement = document
                        .getElementById(`layer-name-${this.id}`);

                    layerNameElement
                        .classList
                        .remove("view-text");

                    layerNameElement
                        .classList
                        .add("in-view-text");

                    const inputElement = document
                        .getElementById(`layer-name-input-${this.id}`);

                    inputElement
                        .classList
                        .add("in-view-text-input");
                }
                break;

            default:
                break;

        }
    }

    /**
     * @description タイムラインのCSSを再配置する
     *
     * @return {void}
     * @method
     * @public
     */
    reloadStyle ()
    {
        // 初期化
        this.resetStyle();

        // 空のフレーム
        this.setEmptyStyle();

        // DisplayObjectを配置したフレーム
        this.setCharacterStyle();
    }

    /**
     * @description DisplayObjectを配置したフレームのスタイルをセット
     *
     * @return {void}
     * @method
     * @public
     */
    setCharacterStyle ()
    {
        const layerId = this.id;
        const duplication = new Map();
        for (let idx = 0; idx < this._$characters.length; ++idx) {

            const character = this._$characters[idx];
            const places = Array.from(character._$places.keys());

            // 昇順
            places.sort((a, b) =>
            {
                switch (true) {

                    case a > b:
                        return 1;

                    case a < b:
                        return -1;

                    default:
                        return 0;

                }
            });

            for (let idx = 0; idx < places.length; ++idx) {

                const startFrame = places[idx];
                if (duplication.has(startFrame)) {
                    continue;
                }

                // スタイル処理完了用のフラグ
                duplication.set(startFrame, true);

                const endFrame = places[idx + 1] || character.endFrame;
                if (startFrame === endFrame - 1) {

                    const element = document
                        .getElementById(`${layerId}-${startFrame}`);

                    element
                        .dataset
                        .frameState = "key-frame";

                    if (character.hasTween(startFrame)) {

                        element
                            .classList
                            .add("tween-key-frame");

                        const tweenObject = character.getTween(startFrame);
                        const rangeFrame  = tweenObject.endFrame - tweenObject.startFrame;

                        if (rangeFrame > 1 || character.hasTween(tweenObject.endFrame)) {
                            element
                                .classList
                                .add("tween-key-frame-join");
                        }

                    } else {

                        const place = character.getPlace(startFrame);
                        if (place.tweenFrame) {

                            const tweenObject = character
                                .getTween(place.tweenFrame);

                            if (tweenObject.endFrame - 1 === startFrame) {

                                if (character.hasTween(tweenObject.endFrame)) {

                                    element
                                        .classList
                                        .add("tween-space-frame");

                                } else {

                                    element
                                        .classList
                                        .add("tween-frame-end");

                                }

                            } else {

                                element
                                    .classList
                                    .add("tween-space-frame");

                            }

                        } else {

                            element
                                .classList
                                .add("key-frame");

                        }
                    }

                    continue;
                }

                // 複数フレームの場合のスタイル
                let frame = startFrame;

                // 開始フレーム
                const startElement = document
                    .getElementById(`${layerId}-${frame++}`);

                startElement
                    .dataset
                    .frameState = "key-frame";

                if (character.hasTween(startFrame)) {

                    startElement
                        .classList
                        .add(
                            "tween-key-frame",
                            "tween-key-frame-join"
                        );

                } else {

                    startElement
                        .classList
                        .add(
                            "key-frame",
                            "key-frame-join"
                        );

                }

                // 間のフレーム
                const spaceTotalFrame = endFrame - 1;
                for (; frame < spaceTotalFrame; ) {

                    const element = document
                        .getElementById(`${layerId}-${frame++}`);

                    element
                        .dataset
                        .frameState = "key-space-frame";

                    if (character.hasTween(startFrame)) {

                        element
                            .classList
                            .add("tween-space-frame");

                    } else {

                        element
                            .classList
                            .add("key-space-frame");

                    }

                }

                // 終了フレーム
                const endElement = document
                    .getElementById(`${layerId}-${frame++}`);

                endElement
                    .dataset
                    .frameState = "key-space-frame-end";

                if (character.hasTween(startFrame)) {

                    endElement
                        .classList
                        .add("tween-frame-end");

                } else {

                    endElement
                        .classList
                        .add("key-space-frame-end");

                }
            }
        }
    }

    /**
     * @description 空フレームのスタイルをセット
     *
     * @return {void}
     * @method
     * @public
     */
    setEmptyStyle ()
    {
        const layerId = this.id;
        for (let idx = 0; idx < this._$emptys.length; ++idx) {

            const character = this._$emptys[idx];

            // 1フレームの場合
            if (character.startFrame === character.endFrame - 1) {

                const element = document
                    .getElementById(`${layerId}-${character.startFrame}`);

                element
                    .dataset
                    .frameState = "empty-key-frame";

                element
                    .classList
                    .add("empty-key-frame");

                continue;

            }

            // 複数フレームの場合のスタイル
            let frame = character.startFrame;

            // 開始フレーム
            const startElement = document
                .getElementById(`${layerId}-${frame++}`);

            startElement
                .dataset
                .frameState = "empty-key-frame";

            startElement
                .classList
                .add(
                    "empty-key-frame",
                    "empty-key-frame-join"
                );

            // 間のフレーム
            const endFrame =  character.endFrame - 1;
            for (; frame < endFrame; ) {

                const element = document
                    .getElementById(`${layerId}-${frame++}`);

                element
                    .dataset
                    .frameState = "empty-space-frame";

                element
                    .classList
                    .add("empty-space-frame");

            }

            // 終了フレーム
            const endElement = document
                .getElementById(`${layerId}-${frame++}`);

            endElement
                .dataset
                .frameState = "empty-space-frame-end";

            endElement
                .classList
                .add("empty-space-frame-end");

        }
    }

    /**
     * @description レイヤーのタイムラインのスタイルを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    resetStyle ()
    {
        const layerId = this.id;

        let frame = 1;
        for (;;) {

            const element = document
                .getElementById(`${layerId}-${frame++}`);

            // Emptyフレームを見つけたら終了
            if (!element || element.dataset.frameState === "empty") {
                return ;
            }

            // 状態とクラスを初期化
            element.dataset.frameState = "empty";
            element.setAttribute("class", "frame");

            // 5の倍数のフレームにはポインター用のスタイルを追加する
            if (element.dataset.type === "frame-pointer") {
                element.classList.add("frame-pointer");
            }
        }
    }

    /**
     * @return {number}
     * @public
     */
    get id ()
    {
        return this._$id;
    }

    /**
     * @param  {number} id
     * @return {void}
     * @public
     */
    set id (id)
    {
        this._$id = id | 0;
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @param  {string} name
     * @return {void}
     * @public
     */
    set name (name)
    {
        this._$name = name;
    }

    /**
     * @return {boolean}
     * @public
     */
    get light ()
    {
        return this._$light;
    }

    /**
     * @param  {boolean} light
     * @return {void}
     * @public
     */
    set light (light)
    {
        this._$light = light;
    }

    /**
     * @return {boolean}
     * @public
     */
    get disable ()
    {
        return this._$disable;
    }

    /**
     * @param  {boolean} disable
     * @return {void}
     * @public
     */
    set disable (disable)
    {
        this._$disable = disable;
    }

    /**
     * @return {boolean}
     * @public
     */
    get lock ()
    {
        return this._$lock;
    }

    /**
     * @param  {boolean} lock
     * @return {void}
     * @public
     */
    set lock (lock)
    {
        this._$lock = lock;
    }

    /**
     * @return {array}
     * @public
     */
    get emptyCharacters ()
    {
        const characters = [];
        for (let idx = 0; idx < this._$emptys.length; ++idx) {
            characters.push(this._$emptys[idx].toObject());
        }
        return characters;
    }

    /**
     * @param  {array} characters
     * @return {void}
     * @public
     */
    set emptyCharacters (characters)
    {
        for (let idx = 0; idx < characters.length; ++idx) {
            const character = new EmptyCharacter(characters[idx]);
            this._$emptys.push(character);
        }
    }

    /**
     * @return {array}
     * @public
     */
    get characters ()
    {
        const characters = [];
        for (let idx = 0; idx < this._$characters.length; ++idx) {
            characters.push(this._$characters[idx].toObject());
        }
        return characters;
    }

    /**
     * @param  {array} characters
     * @return {void}
     * @public
     */
    set characters (characters)
    {
        for (let idx = 0; idx < characters.length; ++idx) {

            const character = new Character(characters[idx]);
            character._$layerId = this.id;

            this._$instances.set(character.id, character);
            this._$characters.push(character);
        }
    }

    /**
     * @param  {number} character_id
     * @return {Character}
     * @public
     */
    getCharacter (character_id)
    {
        return this._$instances.get(character_id | 0);
    }

    /**
     * @param  {Character} character
     * @return {void}
     * @public
     */
    addCharacter (character)
    {
        character._$layerId = this.id;
        this._$characters.push(character);
        this._$instances.set(character.id, character);
    }

    /**
     * @param  {number} character_id
     * @return {void}
     * @public
     */
    deleteCharacter (character_id)
    {
        if (this._$instances.has(character_id | 0)) {

            const character = this._$instances.get(character_id | 0);
            character._$layerId = -1;

            this._$characters.splice(this._$characters.indexOf(character), 1);

            this._$instances.delete(character_id | 0);
        }
    }

    /**
     * @param  {EmptyCharacter} character
     * @return {void}
     * @public
     */
    addEmptyCharacter (character)
    {
        this._$emptys.push(character);
    }

    /**
     * @param  {EmptyCharacter} character
     * @return {void}
     * @public
     */
    deleteEmptyCharacter (character)
    {
        const index = this._$emptys.indexOf(character);
        if (index > -1) {
            this._$emptys.splice(index, 1);
        }
    }

    /**
     * @description 現在のフレームを起点に追加できるフレームを調整して
     *              追加できるフレームの幅を返す
     *
     * @param  {number} frame
     * @return {object}
     * @method
     * @public
     */
    adjustmentLocation (frame)
    {
        // 空のフレームがあれば削除して、範囲を返す
        const emptyCharacter = this.getActiveEmptyCharacter(frame);
        if (emptyCharacter) {

            this.deleteEmptyCharacter(emptyCharacter);

            return {
                "startFrame": emptyCharacter.startFrame,
                "endFrame": emptyCharacter.endFrame
            };
        }

        // 既存のDisplayObjectがあればキーフームから幅を算出
        const characters = this.getActiveCharacter(frame);
        if (characters.length) {

            let startFrame = 1;
            let endFrame   = Number.MAX_VALUE;
            for (let idx = 0; idx < characters.length; ++idx) {

                const character = characters[idx];

                startFrame = Math.max(startFrame, character.startFrame);
                endFrame   = Math.min(endFrame, character.endFrame);
                for (const keyFrame of character._$places.keys()) {

                    if (keyFrame > frame) {
                        endFrame = Math.min(endFrame, keyFrame);
                    }

                    if (frame >= keyFrame) {
                        startFrame = Math.max(startFrame, keyFrame);
                    }

                }
            }

            return {
                "startFrame": startFrame,
                "endFrame": endFrame
            };
        }

        // 前方のフレームの補完
        if (frame > 1) {

            const layerId = this.id;
            let idx = 1;
            for (; frame - idx > 1; ++idx) {

                const element = document
                    .getElementById(`${layerId}-${frame - idx}`);

                // 未設定のフレームでない時は終了
                if (element.dataset.frameState !== "empty") {
                    break;
                }

            }

            // 同じフレームでなければ補正を実行
            if (frame - idx !== frame) {

                // 終了フラグ
                let done = false;

                // 空のフレームがあれば、フレームを伸ばす
                const emptyCharacter = this
                    .getActiveEmptyCharacter(frame - idx);

                if (emptyCharacter) {

                    emptyCharacter.endFrame = frame;

                    done = true;
                }

                if (!done) {

                    // 設定済みのフレームがあれば、フレームを伸ばす
                    const characters = this.getActiveCharacter(frame - idx);
                    if (characters.length) {
                        for (let idx = 0; idx < characters.length; ++idx) {
                            characters[idx].endFrame = frame;
                        }

                        done = true;
                    }
                }

                // 前方のフレームが未設定の場合は空のフレームを追加
                if (!done) {
                    this.addEmptyCharacter(new EmptyCharacter({
                        "startFrame": frame - idx,
                        "endFrame": frame
                    }));
                }

            }
        }

        return {
            "startFrame": frame,
            "endFrame": frame + 1
        };
    }

    /**
     * @return {number}
     * @readonly
     * @public
     */
    get totalFrame ()
    {
        let frame = 0;
        for (let idx = 0; idx < this._$characters.length; ++idx) {

            const character = this._$characters[idx];
            frame = Math.max(frame, character.endFrame);

        }

        for (let idx = 0; idx < this._$emptys.length; ++idx) {

            const character = this._$emptys[idx];
            frame = Math.max(frame, character.endFrame);

        }

        return frame;
    }

    /**
     * @return {number}
     * @public
     */
    get mode ()
    {
        return this._$mode;
    }

    /**
     * @param  {number} mode
     * @return {void}
     * @public
     */
    set mode (mode)
    {
        this._$mode = mode;
    }

    /**
     * @return {number|null}
     * @public
     */
    get maskId ()
    {
        return this._$maskId;
    }

    /**
     * @param  {number|null} mask_id
     * @return {void}
     * @public
     */
    set maskId (mask_id)
    {
        this._$maskId = mask_id === null
            ? null
            : mask_id | 0;
    }

    /**
     * @return {number|null}
     * @public
     */
    get guideId ()
    {
        return this._$guideId;
    }

    /**
     * @param  {number|null} guide_id
     * @return {void}
     * @public
     */
    set guideId (guide_id)
    {
        this._$guideId = guide_id === null
            ? null
            : guide_id | 0;
    }

    /**
     * @return {string}
     * @public
     */
    get color ()
    {
        return this._$color;
    }

    /**
     * @param  {string} color
     * @return {void}
     * @public
     */
    set color (color)
    {
        this._$color = color;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "name":            this.name,
            "light":           this.light,
            "disable":         this.disable,
            "lock":            this.lock,
            "mode":            this.mode,
            "maskId":          this.maskId,
            "guideId":         this.guideId,
            "color":           this.color,
            "characters":      this.characters,
            "emptyCharacters": this.emptyCharacters
        };
    }
}

/**
 * @class
 * @extends {Instance}
 */
class MovieClip extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object)
    {
        super(object);

        // default
        this._$currentFrame = 1;
        this._$layerId      = 0;
        this._$parent       = null;
        this._$labels       = new Map();
        this._$layers       = new Map();
        this._$actions      = new Map();
        this._$sounds       = new Map();

        if (object.layers) {
            this.layers = object.layers;
        }

        if (object.labels) {
            this.labels = object.labels;
        }

        if (object.placeMap) {
            this.placeMap = object.placeMap;
        }

        if (object.sounds) {
            this.sounds = object.sounds;
        }

        if (object.actions) {
            this.actions = object.actions;
        }

        if (object.currentFrame) {
            this._$currentFrame = Math.max(1, object.currentFrame | 0);
        }
    }

    /**
     * @param  {object} place
     * @param  {string} [name=""]
     * @return {void}
     * @method
     * @public
     */
    showController(place, name = "")
    {
        super.showController(place, name);

        Util.$controller.hideObjectSetting([
            "text-setting",
            "video-setting",
            "fill-color-setting",
            "nine-slice-setting"
        ]);

        Util.$controller.showObjectSetting([
            "loop-setting"
        ]);

        // カスタムループコントローラーを初期化
        Util.$loopController.reload(place.loop);

        // フレームピッカーの画像表示を非表示に
        document
            .getElementById("loop-image-list")
            .style.display = "none";
    }

    /**
     * @param  {boolean} [init=false]
     * @return {void}
     * @public
     */
    initialize (init = false)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        // 選択中のアクティブ表示を初期化
        tool.clear();

        // ツールを初期化
        Util.$tools.reset();

        // スクリーンを初期化
        this.clearStageArea();
        Util.$clearShapePointer();

        // object setting
        document
            .getElementById("scene-name")
            .textContent = this.name;

        document
            .getElementById("object-name")
            .value = this.name;

        document
            .getElementById("object-symbol")
            .value = this.symbol;

        // シーンの初期化
        if (this.id === 0) {
            const scenes = document
                .getElementById("scene-name-menu-list");

            while (scenes.children.length) {
                scenes.children[0].remove();
            }
        }

        // フレームを登録してヘッダーを再編成
        Util.$timelineFrame.currentFrame = this.currentFrame;
        Util.$timelineHeader.create(init);

        // init label
        for (const frame of this._$labels.keys()) {

            const element = document
                .getElementById(`frame-label-marker-${frame}`);

            element.setAttribute("class", "frame-border-box-marker");

        }

        // init action
        for (const frame of this._$actions.keys()) {

            const element = document
                .getElementById(`frame-label-action-${frame}`);

            element.setAttribute("class", "frame-border-box-action");

        }

        // init sound
        for (const frame of this._$sounds.keys()) {

            const element = document
                .getElementById(`frame-label-sound-${frame}`);

            element.setAttribute("class", "frame-border-box-sound");

        }

        // frame1 label
        const labelElement = document.getElementById("label-name");
        labelElement.value = "";
        if (this._$labels.has(1)) {
            labelElement.value = this._$labels.get(1);
        }

        // タイムラインを初期化
        Util.$timelineLayer.removeAll();

        // insert layer
        this._$layerId = 0;
        for (const layer of this._$layers.values()) {
            layer.initialize();
        }

        // タイムラインが空の時は初期レイヤーをセットする
        if (!this._$layers.size) {
            this.addLayer();
        }

        Util.$controller.default();
        if (this.id) {

            // スクリーンに表示されてるシーンはドラッグできないようロック
            document
                .getElementById(`library-child-id-${this.id}`)
                .draggable = false;

        }

        // サウンド設定を反映
        Util.$soundController.createSoundElements();

        this.changeFrame(
            Util.$timelineFrame.currentFrame
        );

    }

    /**
     * @return {number}
     * @readonly
     * @public
     */
    get currentFrame ()
    {
        return this._$currentFrame;
    }

    /**
     * @return {number}
     * @readonly
     * @public
     */
    get totalFrame ()
    {
        let frame = 1;
        for (const layer of this._$layers.values()) {
            frame = Math.max(frame, layer.totalFrame - 1);
        }
        return frame;
    }

    /**
     * @return {void}
     * @public
     */
    clearStageArea ()
    {
        const stageArea = document.getElementById("stage-area");

        let idx = 0;
        while (stageArea.children.length > idx) {

            const node = stageArea.children[idx];
            if (!node.dataset.child || node.dataset.child === "tween") {
                idx++;
                continue;
            }

            node.remove();
        }
    }

    /**
     * @param  {number} [frame=1]
     * @return {void}
     * @public
     */
    changeFrame (frame = 1)
    {
        // clear
        this.clearStageArea();

        const element = document.getElementById("stage-area");

        const pointers = [];
        const children = element.children;
        for (let idx = 0; children.length > idx; ++idx) {

            const node = children[idx];
            if (!node.dataset.shapePointer) {
                continue;
            }

            node.remove();
            pointers.push(node);
            --idx;
        }

        const layers = Array.from(this._$layers.values());
        while (layers.length) {
            const layer = layers.pop();
            if (layer.mode === Util.LAYER_MODE_MASK && layer.lock) {
                continue;
            }
            layer.appendCharacter(frame);
        }

        this._$currentFrame = frame;

        // スクリーンエリアの変形Elementの配置を再計算
        // 非表示の時は何もしない
        Util.$transformController.relocation();
        Util.$gridController.relocation();

        for (let idx = 0; pointers.length > idx; ++idx) {
            element.appendChild(pointers[idx]);
        }

        // tweenのポインターを再配置
        Util
            .$tweenController
            .clearPointer()
            .relocationPointer();
    }

    /**
     * @return {void}
     * @public
     */
    clearActiveCharacter ()
    {
        for (const layer of this._$layers.values()) {
            layer.clearActiveCharacter();
        }
    }

    /**
     * @return {void}
     * @public
     */
    addSceneName ()
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(this.id | 0);

        // add menu
        const htmlTag = `
<div id="scene-instance-id-${instance.id}" data-library-id="${instance.id}">${instance.name}</div>
`;

        document
            .getElementById("scene-name-menu-list")
            .insertAdjacentHTML("beforeend", htmlTag);

        const element = document
            .getElementById(`scene-instance-id-${instance.id}`);

        element.addEventListener("mousedown", (event) =>
        {
            // 全てのイベントを中止
            event.stopPropagation();
            event.preventDefault();
        });

        element.addEventListener("click", (event) =>
        {
            // モーダル終了
            Util.$endMenu();

            const element = event.currentTarget;

            // シーン移動
            Util.$sceneChange.execute(
                element.dataset.libraryId | 0
            );

            // リストから削除
            element.remove();
        });

    }

    /**
     * @return {void}
     * @public
     */
    stop ()
    {
        const layers = [];
        for (const layer of this._$layers.values()) {
            layers.push(layer);

            const characters =  layer._$characters;
            for (let idx = 0; idx < characters.length; ++idx) {
                characters[idx]._$image = null;
            }

        }

        this._$layers.clear();
        for (let idx = 0; idx < layers.length; ++idx) {
            this._$layers.set(idx, layers[idx]);
        }

        if (this.id) {

            const element = document
                .getElementById(`library-child-id-${this.id}`);

            element.draggable = true;

        }
    }

    /**
     * @return {array}
     * @public
     */
    get labels ()
    {
        const labels = [];
        for (let [frame, value] of this._$labels) {
            labels.push({
                "frame": frame,
                "name": value
            });
        }
        return labels;
    }

    /**
     * @param  {array} labels
     * @return {void}
     * @public
     */
    set labels (labels)
    {
        for (let idx = 0; idx < labels.length; ++idx) {

            const object = labels[idx];

            this._$labels.set(
                object.frame | 0,
                object.name
            );

        }
    }

    /**
     * @param  {number} frame
     * @param  {string} value
     * @return {void}
     * @public
     */
    setLabel (frame, value)
    {
        this._$labels.set(frame | 0, value);
    }

    /**
     * @param  {number} frame
     * @return {object}
     * @public
     */
    gerLabel (frame)
    {
        return this._$labels.has(frame)
            ? this._$labels.get(frame | 0)
            : null;
    }

    /**
     * @param  {number} frame
     * @return {void}
     * @public
     */
    deleteLabel (frame)
    {
        this._$labels.delete(frame | 0);
    }

    /**
     * @return {object}
     * @public
     */
    get parent ()
    {
        return this._$parent;
    }

    /**
     * @return {array}
     * @public
     */
    get layers ()
    {
        let index = 0;
        let parentId = null;
        const layers = [];
        for (const value of this._$layers.values()) {

            const object = value.toObject();
            switch (object.mode) {

                case Util.LAYER_MODE_MASK:
                case Util.LAYER_MODE_GUIDE:
                    parentId = index;
                    break;

                case Util.LAYER_MODE_MASK_IN:
                    object.maskId = parentId;
                    break;

                case Util.LAYER_MODE_GUIDE_IN:
                    object.guideId = parentId;
                    break;

                default:
                    parentId = null;
                    break;

            }

            layers.push(object);
            index++;
        }
        return layers;
    }

    /**
     * @param  {array} layers
     * @return {void}
     * @public
     */
    set layers (layers)
    {
        for (let idx = 0; idx < layers.length; ++idx) {
            this._$layers.set(idx, new Layer(layers[idx]));
        }
    }

    /**
     * @param  {Layer} [layer=null]
     * @return {void}
     * @public
     */
    addLayer (layer = null)
    {
        if (!layer) {
            layer = new Layer();
        }
        this._$layers.set(this._$layerId, layer);
        layer.initialize();
    }

    /**
     * @param  {number} layer_id
     * @return {Layer}
     * @public
     */
    getLayer (layer_id)
    {
        return this._$layers.get(layer_id | 0);
    }

    /**
     * @param  {number} layer_id
     * @param  {Layer}  layer
     * @return {void}
     * @public
     */
    setLayer (layer_id, layer)
    {
        this._$layers.set(layer_id | 0, layer);
    }

    /**
     * @param  {number} layer_id
     * @return {void}
     * @public
     */
    deleteLayer (layer_id)
    {
        this._$layers.delete(layer_id | 0);
    }

    /**
     * @return {void}
     * @public
     */
    clearLayer ()
    {
        this._$layers.clear();
    }

    /**
     * @return {array}
     * @public
     */
    get sounds ()
    {
        const sounds = [];
        for (let [frame, sound] of this._$sounds) {
            sounds.push({
                "frame": frame,
                "sound": sound
            });
        }
        return sounds;
    }

    /**
     * @param  {array} sounds
     * @return {void}
     * @public
     */
    set sounds (sounds)
    {
        for (let idx = 0; idx < sounds.length; ++idx) {
            const object = sounds[idx];
            this._$sounds.set(object.frame | 0, object.sound);
        }
    }

    /**
     * @return {array}
     * @public
     */
    get actions ()
    {
        const actions = [];
        for (let [frame, action] of this._$actions) {
            actions.push({
                "frame": frame,
                "action": action
            });
        }
        return actions;
    }

    /**
     * @param  {array} actions
     * @return {void}
     * @public
     */
    set actions (actions)
    {
        for (let idx = 0; idx < actions.length; ++idx) {
            const object = actions[idx];
            this._$actions.set(object.frame | 0, object.action);
        }
    }

    /**
     * @param  {number} frame
     * @return {array}
     * @public
     */
    getSound (frame)
    {
        return this._$sounds.get(frame);
    }

    /**
     * @param  {number} frame
     * @param  {array} sounds
     * @return {void}
     * @public
     */
    setSound (frame, sounds)
    {
        return this._$sounds.set(frame, sounds);
    }

    /**
     * @param  {number} frame
     * @return {boolean}
     * @public
     */
    hasSound (frame)
    {
        return this._$sounds.has(frame);
    }

    /**
     * @param  {number} frame
     * @return {void}
     * @public
     */
    deleteSound (frame)
    {
        this._$sounds.delete(frame);
    }

    /**
     * @param  {number} frame
     * @return {string}
     * @public
     */
    getAction (frame)
    {
        return this._$actions.get(frame);
    }

    /**
     * @param  {number} frame
     * @param  {string} script
     * @return {void}
     * @public
     */
    setAction (frame, script)
    {
        this._$actions.set(frame, script);

        Util
            .$javascriptController
            .reload();
    }

    /**
     * @param  {number} frame
     * @return {boolean}
     * @public
     */
    hasAction (frame)
    {
        return this._$actions.has(frame);
    }

    /**
     * @param  {number} frame
     * @return {void}
     * @public
     */
    deleteAction (frame)
    {
        this._$actions.delete(frame);

        Util
            .$javascriptController
            .reload();
    }

    /**
     * @param  {array}  [matrix=null]
     * @param  {object} [place=null]
     * @param  {object} [range=null]
     * @return {object}
     * @method
     * @public
     */
    getBounds (matrix = [1, 0, 0, 1, 0, 0], place = null, range = null)
    {
        if (!this._$layers.size) {
            return {
                "xMin": 0,
                "xMax": 0,
                "yMin": 0,
                "yMax": 0
            };
        }

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        const currentFrame = Util.$currentFrame;

        let frame = 1;
        if (place && range) {
            frame = Util.$getFrame(
                place, range, currentFrame, this.totalFrame
            );
        }

        const parentMatrix = matrix;

        Util.$currentFrame = frame;

        const workSpace = Util.$currentWorkSpace();

        // over write
        for (const layer of this._$layers.values()) {

            if (layer.disable) {
                continue;
            }

            const characters = layer.getActiveCharacter(frame);

            const length = characters.length;
            for (let idx = 0; idx < length; ++idx) {

                const character = characters[idx];
                const place     = character.getPlace(frame);
                const range     = place.loop && place.loop.type === 5
                    ? {
                        "startFrame": character.startFrame,
                        "endFrame": character.endFrame
                    }
                    : character.getRange(frame);

                const instance = workSpace
                    .getLibrary(character.libraryId | 0);

                const matrix = Util.$multiplicationMatrix(parentMatrix, place.matrix);
                const bounds = instance.getBounds(matrix, place, range);

                const width  = bounds.xMax - bounds.xMin;
                const height = bounds.yMax - bounds.yMin;
                if (!width || !height) {
                    bounds.xMin = matrix[4];
                    bounds.xMax = matrix[4];
                    bounds.yMin = matrix[5];
                    bounds.yMax = matrix[5];
                }

                xMin = Math.min(bounds.xMin, xMin);
                xMax = Math.max(bounds.xMax, xMax);
                yMin = Math.min(bounds.yMin, yMin);
                yMax = Math.max(bounds.yMax, yMax);
            }
        }

        // reset
        Util.$currentFrame = currentFrame;

        return {
            "xMin": xMin,
            "xMax": xMax,
            "yMin": yMin,
            "yMax": yMax
        };
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":           this.id,
            "name":         this.name,
            "type":         this.type,
            "symbol":       this.symbol,
            "folderId":     this.folderId,
            "currentFrame": this.currentFrame,
            "parent":       this.parent,
            "layers":       this.layers,
            "labels":       this.labels,
            "sounds":       this.sounds,
            "actions":      this.actions
        };
    }

    /**
     * @return {object}
     * @public
     */
    toPublish ()
    {
        const dictionary   = [];
        const controller   = [];
        const placeMap     = [];
        const placeObjects = [];

        const workSpace  = Util.$currentWorkSpace();
        const libraryMap = new Map();

        let index = 0;
        for (const id of workSpace._$libraries.keys()) {
            libraryMap.set(id, index++);
        }

        // setup
        let currentPlaceId = 0;
        let clipStart      = false;
        let clipIndex      = 0;
        const setting      = Util.$userSetting.getPublishSetting();

        const layers = Array.from(this._$layers);

        const clipLayers = [];
        let clipCount    = 0;
        let depth        = 0;
        for (let idx = layers.length - 1; idx > -1; --idx) {

            if (clipIndex && !clipLayers.length) {
                clipIndex = 0;
                clipCount = 0;
                continue;
            }

            const layer = !clipStart && clipLayers.length
                ? clipLayers.shift()
                : layers[idx][1];

            // 非表示レイヤー処理
            if (!setting.layer && layer.disable) {
                continue;
            }

            // ガイドレイヤーは描画に含めない
            if (layer.mode === Util.LAYER_MODE_GUIDE) {
                continue;
            }

            if (layer.mode === Util.LAYER_MODE_MASK_IN
                && !clipStart && !clipIndex
            ) {
                clipStart = true;
                clipIndex = idx;
            }

            if (clipStart && layer.mode === Util.LAYER_MODE_MASK_IN) {
                clipCount += layer._$characters.length;
                clipLayers.push(layer);
                continue;
            }

            const characters = layer._$characters;

            const length = layer.mode === Util.LAYER_MODE_MASK
                ? Math.min(1, characters.length)
                : characters.length;

            let index = layer.mode === Util.LAYER_MODE_MASK
                ? length - 1
                : 0;

            for (;;) {

                const id = dictionary.length;

                const character = characters[index];
                if (!character) {
                    break;
                }

                const startFrame = character.startFrame;
                const endFrame   = character.endFrame;

                const instance = workSpace._$libraries.get(character.libraryId);
                if (!Util.$useIds.has(instance.id)) {
                    Util.$useIds.set(instance.id, true);
                }

                dictionary.push({
                    "name": character.name,
                    "characterId": instance.id,
                    "endFrame": endFrame,
                    "startFrame": startFrame,
                    "clipDepth": layer.mode === Util.LAYER_MODE_MASK
                        ? index + clipCount + currentPlaceId
                        : 0
                });

                let placeIndex = 0;
                for (let frame = startFrame; frame < endFrame; ++frame) {

                    if (!(frame in controller)) {
                        controller[frame] = [];
                    }

                    if (!(frame in placeMap)) {
                        placeMap[frame] = [];
                    }

                    const place = character.getPlace(frame);
                    if (character.hasPlace(frame)) {

                        placeIndex = placeObjects.length;

                        const filters = [];
                        for (let idx = 0; idx < place.filter.length; ++idx) {
                            const filter = place.filter[idx];
                            if (!filter.state) {
                                continue;
                            }

                            filters.push({
                                "class": filter.name,
                                "params": filter.toParamArray()
                            });
                        }

                        const placeObject = {
                            "matrix": place.matrix,
                            "colorTransform": place.colorTransform,
                            "blendMode": place.blendMode,
                            "surfaceFilterList": filters
                        };

                        if (instance.type === "container"
                            && Util.DEFAULT_LOOP > place.loop.type
                        ) {

                            if (place.loop.referenceFrame) {

                                const referencePlace = character.getPlace(
                                    place.loop.referenceFrame
                                );

                                placeObject.loop = {
                                    "type": referencePlace.loop.type,
                                    "frame": referencePlace.frame,
                                    "start": referencePlace.loop.start,
                                    "end": referencePlace.loop.end
                                };

                            } else {

                                placeObject.loop = {
                                    "type": place.loop.type,
                                    "frame": place.frame,
                                    "start": place.loop.start,
                                    "end": place.loop.end
                                };
                            }

                            if (place.loop.tweenFrame) {
                                placeObject.loop.tweenFrame = place.loop.tweenFrame;
                            }
                        }

                        placeObjects.push(placeObject);
                    }

                    controller[frame][depth + place.depth] = id;
                    placeMap[frame][depth   + place.depth] = placeIndex;
                }

                if (layer.mode === Util.LAYER_MODE_MASK) {
                    --index;
                    if (-1 === index) {
                        break;
                    }
                } else {
                    ++index;
                    if (index === length) {
                        break;
                    }
                }
            }

            currentPlaceId += length;
            depth += length;

            if (clipStart && clipLayers.length) {
                idx = clipIndex + 1;
                clipStart = false;
            }
        }

        // empty keyを詰める
        for (let frame = 1; controller.length > frame; ++frame) {

            if (!(frame in controller)) {
                continue;
            }

            const characters = controller[frame];
            const placeMaps  = placeMap[frame];

            controller[frame] = characters.filter((value) => { return typeof value === "number" });
            placeMap[frame]   = placeMaps.filter((value)  => { return typeof value === "number" });
        }

        const sounds = [];
        for (let [frame, values] of this._$sounds) {

            const object = {
                "frame": frame,
                "sound": []
            };

            for (let idx = 0; idx < values.length; ++idx) {

                const sound = values[idx];

                const characterId = sound.characterId | 0;
                object.sound.push({
                    "characterId": characterId,
                    "volume":      sound.volume / 100,
                    "autoPlay":    sound.autoPlay,
                    "loopCount":   sound.loopCount
                });

                if (!Util.$useIds.has(characterId)) {
                    Util.$useIds.set(characterId, true);
                }
            }

            sounds.push(object);
        }

        const actions = [];
        for (let [frame, action] of this._$actions) {

            const scriptList = action
                .replace(/("[^"]*\/\/.*?")|\/\/(?:.|\r?\n)*?(?:\r?\n|.*)?/g, "$1")
                .replace(/(["'][^"']*\/\*.*?\*\/[^"']*["'])|\/\*(?:.|\r?\n)*?\*\//g, "$1")
                .replace(/^\s+|\s+$/g, "")
                .replace(/ +/g, " ")
                .split(/\r?\n/);

            let list = [];
            for (let idx = 0; idx < scriptList.length; ++idx) {
                const value = scriptList[idx].trim();
                if (!value.length) {
                    continue;
                }

                list.push(value);
            }

            actions.push({
                "frame": frame,
                "action": list.join("\n")
            });
        }

        return {
            "actions": actions,
            "symbol":  this.symbol,
            "extends": this.defaultSymbol,
            "totalFrame": this.totalFrame,
            "controller": controller,
            "dictionary": dictionary,
            "labels": this.labels,
            "placeMap": placeMap,
            "placeObjects": placeObjects,
            "sounds": sounds
        };
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.display.MovieClip.namespace;
    }

    /**
     * @param  {object} place
     * @param  {object} range
     * @return {next2d.display.Sprite}
     * @public
     */
    createInstance (place, range)
    {
        const { MovieClip } = window.next2d.display;
        const { Matrix, ColorTransform } = window.next2d.geom;

        const workSpace = Util.$currentWorkSpace();
        const movieClip = new MovieClip();

        // cache
        const currentFrame = Util.$currentFrame;

        Util.$useIds.clear();
        const object = this.toPublish();

        let frame = 1;
        if (place && range) {
            frame = Util.$getFrame(
                place, range, currentFrame, this.totalFrame
            );
        }

        Util.$currentFrame = frame;
        movieClip._$currentFrame = frame;

        const controller = object.controller[frame];
        if (!controller) {
            return movieClip;
        }

        const placeMap = object.placeMap[frame];
        for (let idx = 0; controller.length > idx; ++idx) {

            const tag      = object.dictionary[controller[idx]];
            const instance = workSpace.getLibrary(tag.characterId);

            const place = object.placeObjects[placeMap[idx]];
            if (!place.loop) {
                place.loop = Util.$getDefaultLoopConfig();
            }

            let displayObject = null;
            switch (instance.type) {

                case "container":
                    displayObject = new MovieClip();
                    if (instance._$layers.size) {

                        const layers = Array.from(
                            instance._$layers.values()
                        ).reverse();

                        let childRange = null;
                        let depth = -1;
                        for (let i = 0; i < layers.length; ++i) {

                            depth++;

                            if (depth !== idx) {
                                continue;
                            }

                            const layer = layers[i];
                            const activeCharacters = layer.getActiveCharacter(frame);
                            if (activeCharacters.length > 1) {
                                // 昇順
                                activeCharacters.sort((a, b) =>
                                {
                                    const aDepth = a.getPlace(frame).depth;
                                    const bDepth = b.getPlace(frame).depth;
                                    switch (true) {

                                        case aDepth > bDepth:
                                            return 1;

                                        case aDepth < bDepth:
                                            return -1;

                                        default:
                                            return 0;

                                    }
                                });
                            }

                            if (activeCharacters.length) {
                                childRange = activeCharacters[0].getRange(frame);
                            }
                        }

                        if (place) {
                            place.frame = frame;

                            if (place.loop.type === 5) {
                                childRange = range;
                            }
                        }

                        displayObject = instance.createInstance(place, childRange);
                    }
                    break;

                case "shape":
                    displayObject = instance.createInstance();
                    displayObject._$bitmapId = instance._$bitmapId;
                    break;

                default:
                    displayObject = instance.createInstance();
                    break;

            }

            // matrix
            displayObject.transform.matrix = new Matrix(
                place.matrix[0], place.matrix[1],
                place.matrix[2], place.matrix[3],
                place.matrix[4], place.matrix[5]
            );

            // colorTransform
            displayObject.transform.colorTransform = new ColorTransform(
                place.colorTransform[0], place.colorTransform[1],
                place.colorTransform[2], place.colorTransform[3],
                place.colorTransform[4], place.colorTransform[5],
                place.colorTransform[6], place.colorTransform[7]
            );

            // blendMode
            displayObject.blendMode = place.blendMode;

            // filters
            const filters = [];
            for (let idx = 0; idx < place.surfaceFilterList.length; ++idx) {

                const filterTag = place.surfaceFilterList[idx];
                const filterClass = window.next2d.filters[filterTag.class];

                filters.push(
                    new (filterClass.bind.apply(filterClass, filterTag.params))()
                );
            }
            displayObject.filters = filters;

            // tag data
            displayObject._$placeId     = idx;
            displayObject._$clipDepth   = tag.clipDepth;

            // player use cache
            displayObject._$loaderInfo  = { "_$id": 0 };
            displayObject._$characterId = tag.characterId;

            // added
            movieClip.addChild(displayObject);
        }

        // reset
        Util.$currentFrame = currentFrame;

        return movieClip;
    }
}

/**
 * @class
 * @extends {Instance}
 */
class Shape extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object = null)
    {
        super(object);

        this._$bitmapId = 0;
        this._$bounds   = null;
        this._$grid     = null;
        this._$inBitmap = false;
        this._$recodes  = [];

        if (object.inBitmap) {
            this.inBitmap = object.inBitmap;
        }

        if (object.recodes) {
            this.recodes = object.recodes;
        }

        if (object.bounds) {
            this.bounds = object.bounds;
        }

        if (object.bitmapId) {
            this.bitmapId = object.bitmapId;
        }

        if (object.grid) {
            this.grid = object.grid;
        }
    }

    /**
     * @param  {object} place
     * @param  {string} [name=""]
     * @return {void}
     * @method
     * @public
     */
    showController(place, name = "")
    {
        super.showController(place, name);

        // 9スライスの値を初期化
        document
            .getElementById("nine-slice-setting-x")
            .value = "0";

        document
            .getElementById("nine-slice-setting-y")
            .value = "0";

        document
            .getElementById("nine-slice-setting-w")
            .value = "0";

        document
            .getElementById("nine-slice-setting-h")
            .value = "0";

        // Shapeに必要なコントローラーを表示する
        Util.$controller.showObjectSetting([
            "nine-slice-setting"
        ]);

        // Shapeに不要なコントローラーを非表示にする
        Util.$controller.hideObjectSetting([
            "text-setting",
            "loop-setting",
            "video-setting",
            "fill-color-setting"
        ]);
    }

    /**
     * @param {object} place
     * @param {MouseEvent} [event=null]
     * @public
     */
    showShapeColor (place, event)
    {
        // マウスのタッチポイントがShapeの描画範囲か判定する
        this.setHitColor(event.offsetX, event.offsetY, place.matrix);

        // 9スライスの設定があれば値をセット
        const grid = this._$grid;
        if (grid && grid.x && grid.y) {

            document
                .getElementById("nine-slice-setting-x")
                .value = `${grid.x}`;

            document
                .getElementById("nine-slice-setting-y")
                .value = `${grid.y}`;

            document
                .getElementById("nine-slice-setting-w")
                .value = `${grid.w}`;

            document
                .getElementById("nine-slice-setting-h")
                .value = `${grid.h}`;

            Util
                .$gridController
                .show()
                .relocation();
        }

        // マウスポイントがShapeの描画範囲にヒットしていれば
        // 必要なコントローラーを表示して値をセットする
        if (Util.$hitColor) {
            Util.$controller.showObjectSetting([
                "fill-color-setting",
                "nine-slice-setting"
            ]);
        }
    }

    /**
     * @param  {array} [matrix=null]
     * @return {object}
     * @public
     */
    getBounds (matrix = null)
    {
        return matrix
            ? Util.$boundsMatrix(this._$bounds, matrix)
            : this._$bounds;
    }

    /**
     * @return {boolean}
     * @public
     */
    get inBitmap ()
    {
        return this._$inBitmap;
    }

    /**
     * @param  {boolean} in_bitmap
     * @return {void}
     * @public
     */
    set inBitmap (in_bitmap)
    {
        this._$inBitmap = !!in_bitmap;
    }

    /**
     * @return {number}
     * @public
     */
    get width ()
    {
        return Math.abs(this._$bounds.xMax - this._$bounds.xMin);
    }

    /**
     * @return {number}
     * @public
     */
    get height ()
    {
        return Math.abs(this._$bounds.yMax - this._$bounds.yMin);
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.display.Shape.namespace;
    }

    /**
     * @return {array}
     * @public
     */
    get recodes ()
    {
        if (!this._$inBitmap) {
            return this._$recodes;
        }

        const recodes = [];
        const { BitmapData } = window.next2d.display;
        for (let idx = 0; this._$recodes.length > idx; ++idx) {

            const value = this._$recodes[idx];
            recodes[idx] = value;

            if (typeof value !== "object") {
                continue;
            }

            if (value.namespace !== BitmapData.namespace) {
                continue;
            }

            recodes[idx] = {
                "buffer": Array.from(value._$buffer),
                "width": value.width,
                "height": value.height
            };
        }

        return recodes;
    }

    /**
     * @param {array} recodes
     * @public
     */
    set recodes (recodes)
    {
        this._$recodes = recodes;
        if (this._$inBitmap) {

            const { BitmapData } = window.next2d.display;
            for (let idx = 0; this._$recodes.length > idx; ++idx) {

                const value = this._$recodes[idx];

                if (typeof value !== "object") {
                    continue;
                }

                if (value.namespace === BitmapData.namespace) {
                    continue;
                }

                if (!value.buffer) {
                    continue;
                }

                const bitmapData = new BitmapData(
                    value.width, value.height, true, 0
                );
                bitmapData._$buffer = new Uint8Array(value.buffer);

                this._$recodes[idx] = bitmapData;
            }
        }
    }

    /**
     * @return {object|null}
     * @public
     */
    get bounds ()
    {
        return this._$bounds;
    }

    /**
     * @param {object} [bounds=null]
     * @public
     */
    set bounds (bounds)
    {
        this._$bounds = bounds;
    }

    /**
     * @return {object}
     * @public
     */
    get offset ()
    {
        return this._$offset;
    }

    /**
     * @param  {object} offset
     * @return {void}
     * @public
     */
    set offset (offset)
    {
        this._$offset = offset;
    }

    /**
     * @return {number}
     * @public
     */
    get bitmapId ()
    {
        return this._$bitmapId;
    }

    /**
     * @param  {number} bitmap_id
     * @return {void}
     * @public
     */
    set bitmapId (bitmap_id)
    {
        this._$bitmapId = bitmap_id | 0;
    }

    /**
     * @return {object|null}
     * @public
     */
    get grid ()
    {
        return this._$grid;
    }

    /**
     * @param {object} [grid=null]
     * @public
     */
    set grid (grid)
    {
        this._$grid = grid;
    }

    /**
     * @param  {array}  matrix
     * @param  {number} layer_id
     * @param  {number} character_id
     * @return {void}
     * @public
     */
    createPointer (matrix, layer_id, character_id)
    {
        Util.$clearShapePointer();

        const element = document.getElementById("stage-area");

        let syncId = 2;
        const { Graphics } = window.next2d.display;
        for (let idx = 0; idx < this._$recodes.length; ) {

            switch (this._$recodes[idx++]) {

                case Graphics.MOVE_TO:
                    syncId = idx;
                    idx += 2;
                    break;

                case Graphics.LINE_TO:

                    this.addPointer(
                        layer_id,
                        character_id,
                        idx,
                        this._$recodes[idx++],
                        this._$recodes[idx++],
                        matrix,
                        Graphics.LINE_TO
                    );

                    this.adjustmentPointer(idx, matrix, layer_id, character_id, syncId);

                    break;

                case Graphics.CUBIC:

                    for (let jdx = 0; 2 > jdx; ++jdx) {
                        this.addPointer(
                            layer_id,
                            character_id,
                            idx,
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            matrix,
                            Graphics.CUBIC,
                            true
                        );
                    }

                    this.addPointer(
                        layer_id,
                        character_id,
                        idx,
                        this._$recodes[idx++],
                        this._$recodes[idx++],
                        matrix,
                        Graphics.CUBIC,
                        false
                    );

                    this.adjustmentPointer(idx, matrix, layer_id, character_id, syncId);

                    break;

                case Graphics.CURVE_TO:

                    this.addPointer(
                        layer_id,
                        character_id,
                        idx,
                        this._$recodes[idx++],
                        this._$recodes[idx++],
                        matrix,
                        Graphics.CURVE_TO,
                        true
                    );

                    this.addPointer(
                        layer_id,
                        character_id,
                        idx,
                        this._$recodes[idx++],
                        this._$recodes[idx++],
                        matrix,
                        Graphics.CURVE_TO
                    );

                    this.adjustmentPointer(idx, matrix, layer_id, character_id, syncId);

                    break;

                case Graphics.FILL_STYLE:
                    idx += 4;
                    break;

                case Graphics.STROKE_STYLE:
                    idx += 8;
                    break;

                case Graphics.GRADIENT_FILL:
                    idx += 6;
                    break;

                case Graphics.GRADIENT_STROKE:
                    idx += 10;
                    break;

                case Graphics.BEGIN_PATH:
                case Graphics.END_FILL:
                case Graphics.END_STROKE:
                    break;

                default:
                    break;

            }

        }

        Util.$addModalEvent(element);
    }

    /**
     * @param  {number} index
     * @param  {array}  matrix
     * @param  {number} layer_id
     * @param  {number} character_id
     * @param  {number} sync_id
     * @return {void}
     * @public
     */
    adjustmentPointer (index, matrix, layer_id, character_id, sync_id)
    {
        const { Graphics } = window.next2d.display;
        switch (this._$recodes[index]) {

            case Graphics.MOVE_TO:
            case Graphics.FILL_STYLE:
            case Graphics.GRADIENT_FILL:
                {
                    const children = document
                        .getElementById("stage-area")
                        .children;

                    const node = children[children.length - 1];
                    node.dataset.syncId = `${sync_id}`;
                }
                break;

            case Graphics.STROKE_STYLE:
            case Graphics.GRADIENT_STROKE:
                this.addPointer(
                    layer_id,
                    character_id,
                    5,
                    this._$recodes[5],
                    this._$recodes[6],
                    matrix,
                    Graphics.MOVE_TO
                );
                break;

            default:
                break;

        }
    }

    /**
     * @param  {number}  layer_id
     * @param  {number}  character_id
     * @param  {number}  index
     * @param  {number}  x
     * @param  {number}  y
     * @param  {array}   matrix
     * @param  {number}  type
     * @param  {boolean} [curve=false]
     * @return {void}
     * @public
     */
    addPointer (
        layer_id, character_id, index, x, y, matrix, type, curve = false
    ) {

        const stageArea = document
            .getElementById("stage-area");

        const div = document.createElement("div");

        div.classList.add("transform");

        // dataset
        div.dataset.shapePointer = "true";
        div.dataset.layerId      = `${layer_id}`;
        div.dataset.characterId  = `${character_id}`;
        div.dataset.index        = `${index}`;
        div.dataset.libraryId    = `${this.id}`;
        div.dataset.curve        = `${curve}`;
        div.dataset.type         = `${type}`;
        div.dataset.position     = `${stageArea.children.length}`;

        // css
        const tx = x * matrix[0] + y * matrix[2] + matrix[4];
        const ty = x * matrix[1] + y * matrix[3] + matrix[5];

        div.style.left = `${tx * Util.$zoomScale + Util.$offsetLeft - 3}px`;
        div.style.top  = `${ty * Util.$zoomScale + Util.$offsetTop  - 3}px`;

        if (curve) {
            div.style.borderRadius = "5px";
        } else {
            div.dataset.detail = "{{ダブルクリックでカーブポイントが追加されます}}";
        }

        div.addEventListener("mousedown", (event) =>
        {
            if (event.button) {
                return ;
            }

            // 親のイベントを中止する
            event.stopPropagation();

            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                event.shapePointer = true;
                activeTool.dispatchEvent(
                    EventType.MOUSE_DOWN,
                    event
                );
            }
        });

        div.addEventListener("dblclick", (event) =>
        {
            // 親のイベントを中止する
            event.stopPropagation();

            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                event.shapePointer = true;
                event.matrix       = matrix;
                activeTool.dispatchEvent(
                    EventType.DBL_CLICK,
                    event
                );
            }
        });

        stageArea.appendChild(div);
    }

    /**
     * @return {object}
     * @public
     */
    reloadBounds (stroke = 0)
    {
        const { Graphics, Shape } = window.next2d.display;
        const shape = new Shape();

        if (stroke) {
            shape
                .graphics
                .lineStyle(stroke);
        } else {
            shape
                .graphics
                .beginFill();
        }

        for (let idx = 0; idx < this._$recodes.length; ) {

            switch (this._$recodes[idx++]) {

                case Graphics.MOVE_TO:
                    shape
                        .graphics
                        .moveTo(
                            this._$recodes[idx++],
                            this._$recodes[idx++]
                        );
                    break;

                case Graphics.LINE_TO:
                    shape
                        .graphics
                        .lineTo(
                            this._$recodes[idx++],
                            this._$recodes[idx++]
                        );
                    break;

                case Graphics.CUBIC:
                    shape
                        .graphics
                        .cubicCurveTo(
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++]
                        );
                    break;

                case Graphics.CURVE_TO:
                    shape
                        .graphics
                        .curveTo(
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++]
                        );
                    break;

                case Graphics.FILL_STYLE:
                    idx += 4;
                    break;

                case Graphics.STROKE_STYLE:
                    idx += 8;
                    break;

                case Graphics.GRADIENT_FILL:
                    {
                        const { Matrix } = window.next2d.geom;
                        const matrix = new Matrix();
                        const xScale = this.width  / 2 / 819.2;
                        const yScale = this.height / 2 / 819.2;
                        matrix.scale(xScale, yScale);
                        matrix.translate(
                            this.width  / 2 + shape.graphics._$xMin,
                            this.height / 2 + shape.graphics._$yMin
                        );

                        this._$recodes[idx + 2] = Array.from(matrix._$matrix);
                        idx += 6;
                    }
                    break;

                case Graphics.GRADIENT_STROKE:
                    {
                        const { Matrix } = window.next2d.geom;
                        const matrix = new Matrix();
                        const xScale = this.width  / 2 / 819.2;
                        const yScale = this.height / 2 / 819.2;
                        matrix.scale(xScale, yScale);
                        matrix.translate(
                            this.width  / 2 + shape.graphics._$xMin,
                            this.height / 2 + shape.graphics._$yMin
                        );

                        this._$recodes[idx + 6] = Array.from(matrix._$matrix);
                        idx += 10;
                    }
                    break;

                case Graphics.BEGIN_PATH:
                case Graphics.END_FILL:
                case Graphics.END_STROKE:
                    break;

                default:
                    break;

            }

        }

        return {
            "xMin": shape.graphics._$xMin,
            "xMax": shape.graphics._$xMax,
            "yMin": shape.graphics._$yMin,
            "yMax": shape.graphics._$yMax
        };
    }

    /**
     * @return {Shape}
     * @public
     */
    copyFrom (shape)
    {
        shape._$recodes  = this._$recodes.slice();
        shape._$bounds   = {
            "xMin": this._$bounds.xMin,
            "xMax": this._$bounds.xMax,
            "yMin": this._$bounds.yMin,
            "yMax": this._$bounds.yMax
        };
        shape._$bitmapId = this._$bitmapId;

        return shape;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":       this.id,
            "name":     this.name,
            "type":     this.type,
            "symbol":   this.symbol,
            "folderId": this.folderId,
            "bitmapId": this.bitmapId,
            "grid":     this.grid,
            "inBitmap": this.inBitmap,
            "recodes":  this.recodes,
            "bounds":   this.bounds
        };
    }

    /**
     * @return {object}
     * @public
     */
    toPublish ()
    {
        if (this._$bitmapId) {
            Util.$useIds.set(this._$bitmapId, true);
        }

        return {
            "symbol":   this.symbol,
            "extends":  this.defaultSymbol,
            "bitmapId": this.bitmapId,
            "grid":     this.grid,
            "inBitmap": this.inBitmap,
            "recodes":  this.recodes,
            "bounds": {
                "xMin": this._$bounds.xMin,
                "xMax": this._$bounds.xMax,
                "yMin": this._$bounds.yMin,
                "yMax": this._$bounds.yMax
            }
        };
    }

    /**
     * @param {string} style
     * @return {void}
     * @public
     */
    changeStyle (style)
    {
        const { Graphics, GradientType } = window.next2d.display;

        const index = Util.$hitColor.index;
        const currentStyle = Util.$hitColor.style;
        switch (currentStyle) {

            case Graphics.BITMAP_FILL:
            case Graphics.FILL_STYLE:
                {
                    const element = document
                        .getElementById("fill-color-type-select");

                    switch (element.value) {

                        case GradientType.LINEAR:
                        case GradientType.RADIAL:
                            {
                                const colorValue = document
                                    .getElementById("fill-color-value")
                                    .value;

                                const color = Util.$intToRGB(
                                    `0x${colorValue.slice(1)}` | 0
                                );

                                const alpha = (document
                                    .getElementById("fill-alpha-value")
                                    .value | 0) / 100 * 255;

                                this.changeGradient(
                                    index, style, Graphics.GRADIENT_FILL,
                                    6, color, alpha
                                );
                            }
                            break;

                        default:
                            break;

                    }
                }
                break;

            case Graphics.GRADIENT_FILL:
                {
                    const element = document
                        .getElementById("fill-color-type-select");

                    const stops = this._$recodes[index + 1];
                    const color = stops.pop();
                    switch (element.value) {

                        case "bitmap":
                        case "rgba":
                            this._$recodes.splice(index - 1, 12,
                                Graphics.FILL_STYLE,
                                color.R, color.G,
                                color.B, color.A,
                                Graphics.END_FILL
                            );

                            Util.$hitColor = {
                                "index": index,
                                "style": Graphics.FILL_STYLE,
                                "shape": this
                            };
                            break;

                        default:
                            this.changeGradient(
                                index, style, Graphics.GRADIENT_FILL,
                                12, color, color.A
                            );
                            break;

                    }
                }
                break;

            case Graphics.STROKE_STYLE:
                {
                    const element = document
                        .getElementById("fill-color-type-select");

                    switch (element.value) {

                        case GradientType.LINEAR:
                        case GradientType.RADIAL:
                            {
                                const colorValue = document
                                    .getElementById("fill-color-value")
                                    .value;

                                const color = Util.$intToRGB(
                                    `0x${colorValue.slice(1)}` | 0
                                );

                                const alpha = (document
                                    .getElementById("fill-alpha-value")
                                    .value | 0) / 100 * 255;

                                this.changeGradient(
                                    index, style, Graphics.GRADIENT_STROKE,
                                    5, color, alpha
                                );
                            }
                            break;

                        default:
                            break;

                    }
                }
                break;

            case Graphics.GRADIENT_STROKE:
                {
                    const element = document
                        .getElementById("fill-color-type-select");

                    const stops      = this._$recodes[index + 5];
                    const color      = stops.pop();
                    const width      = this._$recodes[index];
                    const caps       = this._$recodes[index + 1];
                    const joints     = this._$recodes[index + 2];
                    const miterLimit = this._$recodes[index + 3];
                    switch (element.value) {

                        case "bitmap":
                        case "rgba":
                            this._$recodes.splice(index - 1, 11,
                                Graphics.STROKE_STYLE,
                                width, caps,
                                joints, miterLimit,
                                color.R, color.G,
                                color.B, color.A,
                                Graphics.END_STROKE
                            );

                            Util.$hitColor = {
                                "index": index,
                                "width": width,
                                "style": Graphics.STROKE_STYLE,
                                "shape": this
                            };
                            break;

                        default:
                            this.changeGradient(
                                index, style, Graphics.GRADIENT_STROKE,
                                6, color, color.A
                            );
                            break;

                    }
                }
                break;

        }

        this.cacheClear();

        const frame = Util.$timelineFrame.currentFrame;

        Util.$currentWorkSpace().scene.changeFrame(frame);
    }

    /**
     * @param  {number} index
     * @param  {string} style
     * @param  {number} graphics_type
     * @param  {number} delete_number
     * @param  {object} color
     * @param  {number} alpha
     * @return {void}
     * @public
     */
    changeGradient (index, style, graphics_type, delete_number, color, alpha)
    {
        const { Graphics, SpreadMethod, InterpolationMethod } = window.next2d.display;
        const { Matrix } = window.next2d.geom;

        const matrix = new Matrix();
        const xScale = this.width  / 2 / 819.2;
        const yScale = this.height / 2 / 819.2;
        matrix.scale(xScale, yScale);
        matrix.translate(
            this.width  / 2 + this._$bounds.xMin,
            this.height / 2 + this._$bounds.yMin
        );

        const ratios = [{
            "ratio": 0,
            "R": 255,
            "G": 255,
            "B": 255,
            "A": 255
        }, {
            "ratio": 1,
            "R": color.R,
            "G": color.G,
            "B": color.B,
            "A": alpha
        }];

        Util.$hitColor = {
            "index"  : index,
            "style"  : graphics_type,
            "type"   : style,
            "ratios" : ratios,
            "shape"  : this
        };

        if (Graphics.GRADIENT_STROKE === graphics_type) {

            this._$recodes[index - 1] = Graphics.GRADIENT_STROKE;

            this._$recodes.splice(index + 4, delete_number,
                style, ratios,
                Array.from(matrix._$matrix),
                SpreadMethod.PAD,
                InterpolationMethod.RGB,
                0
            );

            Util.$hitColor.width = this._$recodes[index];

        } else {

            this._$recodes.splice(index - 1, delete_number,
                graphics_type, style, ratios,
                Array.from(matrix._$matrix),
                SpreadMethod.PAD,
                InterpolationMethod.RGB,
                0
            );

        }

        Util
            .$shapeController
            .initializeGradient();

    }

    /**
     * @param  {number} [color_index=-1]
     * @return {void}
     * @method
     * @public
     */
    changeColor (color_index = -1)
    {
        const { Graphics } = window.next2d.display;

        const index = Util.$hitColor.index;
        switch (Util.$hitColor.style) {

            case Graphics.BITMAP_FILL:
                break;

            case Graphics.BITMAP_STROKE:
                {
                    const width = Util.$clamp(document
                        .getElementById("fill-stroke-width-value")
                        .value | 0, 1, 255);

                    if (this._$recodes[index] !== width) {

                        Util.$hitColor.width  = width;
                        this._$recodes[index] = width;

                        const bounds = this.reloadBounds(width);
                        this._$bounds.xMin = bounds.xMin;
                        this._$bounds.xMax = bounds.xMax;
                        this._$bounds.yMin = bounds.yMin;
                        this._$bounds.yMax = bounds.yMax;

                        this.cacheClear();
                    }
                }
                break;

            case Graphics.FILL_STYLE:
                {
                    const colorValue = document
                        .getElementById("fill-color-value")
                        .value;

                    const color = Util.$intToRGB(
                        `0x${colorValue.slice(1)}` | 0
                    );

                    this._$recodes[index    ] = color.R;
                    this._$recodes[index + 1] = color.G;
                    this._$recodes[index + 2] = color.B;
                    this._$recodes[index + 3] = Util.$clamp((document
                        .getElementById("fill-alpha-value")
                        .value | 0) / 100 * 255, 0, 255);
                }
                break;

            case Graphics.GRADIENT_FILL:
                {
                    const colors = this._$recodes[index + 1];

                    const colorIndex = color_index > -1
                        ? color_index
                        : colors.length - 1;

                    const object = colors[colorIndex];

                    const colorValue = document
                        .getElementById("fill-color-value")
                        .value;

                    const color = Util.$intToRGB(
                        `0x${colorValue.slice(1)}` | 0
                    );

                    object.R = color.R;
                    object.G = color.G;
                    object.B = color.B;
                    object.A = Util.$clamp((document
                        .getElementById("fill-alpha-value")
                        .value | 0) / 100 * 255, 0, 255);
                }

                break;

            case Graphics.STROKE_STYLE:
                {
                    const colorValue = document
                        .getElementById("fill-color-value")
                        .value;

                    const color = Util.$intToRGB(
                        `0x${colorValue.slice(1)}` | 0
                    );

                    this._$recodes[index + 4] = color.R;
                    this._$recodes[index + 5] = color.G;
                    this._$recodes[index + 6] = color.B;
                    this._$recodes[index + 7] = Util.$clamp((document
                        .getElementById("fill-alpha-value")
                        .value | 0) / 100 * 255, 0, 255);

                    const width = Util.$clamp(document
                        .getElementById("fill-stroke-width-value")
                        .value | 0, 1, 255);

                    if (this._$recodes[index] !== width) {

                        Util.$hitColor.width  = width;
                        this._$recodes[index] = width;

                        const bounds = this.reloadBounds(width);
                        this._$bounds.xMin = bounds.xMin;
                        this._$bounds.xMax = bounds.xMax;
                        this._$bounds.yMin = bounds.yMin;
                        this._$bounds.yMax = bounds.yMax;

                        this.cacheClear();
                    }

                }
                break;

            case Graphics.GRADIENT_STROKE:
                {
                    const colors = this._$recodes[index + 5];

                    const colorIndex = color_index > -1
                        ? color_index
                        : colors.length - 1;

                    const object = colors[colorIndex];

                    const colorValue = document
                        .getElementById("fill-color-value")
                        .value;

                    const color = Util.$intToRGB(
                        `0x${colorValue.slice(1)}` | 0
                    );

                    object.R = color.R;
                    object.G = color.G;
                    object.B = color.B;
                    object.A = Util.$clamp((document
                        .getElementById("fill-alpha-value")
                        .value | 0) / 100 * 255, 0, 255);

                    const width = Util.$clamp(document
                        .getElementById("fill-stroke-width-value")
                        .value | 0, 1, 255);

                    if (this._$recodes[index] !== width) {

                        Util.$hitColor.width  = width;
                        this._$recodes[index] = width;

                        const bounds = this.reloadBounds(width);
                        this._$bounds.xMin = bounds.xMin;
                        this._$bounds.xMax = bounds.xMax;
                        this._$bounds.yMin = bounds.yMin;
                        this._$bounds.yMax = bounds.yMax;

                        this.cacheClear();
                    }
                }
                break;

        }

        this.cacheClear();
    }

    /**
     * @return {void}
     * @public
     */
    cacheClear ()
    {
        const scene =  Util.$currentWorkSpace().scene;
        for (const layer of scene._$layers.values()) {

            const length = layer._$characters.length;
            for (let idx = 0; idx < length; ++idx) {

                const character = layer._$characters[idx];

                if (character.libraryId !== this.id) {
                    continue;
                }

                character._$image = null;
            }
        }
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @param  {array} place_matrix
     * @return {void}
     * @public
     */
    setHitColor (x, y, place_matrix)
    {
        const { Graphics, GradientType } = window.next2d.display;
        const { Point, Matrix } = window.next2d.geom;

        const matrix = new Matrix();

        const xScale = Math.sqrt(
            place_matrix[0] * place_matrix[0]
            + place_matrix[1] * place_matrix[1]
        ) * Util.$zoomScale;

        const yScale = Math.sqrt(
            place_matrix[2] * place_matrix[2]
            + place_matrix[3] * place_matrix[3]
        ) * Util.$zoomScale;
        matrix.scale(xScale, yScale);

        const radian = Math.atan2(place_matrix[1], place_matrix[0]);
        if (radian) {
            matrix.translate(-this.width / 2, -this.height / 2);
            matrix.rotate(radian);
            matrix.translate(this.width / 2, this.height / 2);
        }

        const topLeft     = matrix.transformPoint(new Point(0, 0));
        const topRight    = matrix.transformPoint(new Point(this.width, 0));
        const bottomLeft  = matrix.transformPoint(new Point(0, this.height));
        const bottomRight = matrix.transformPoint(new Point(this.width, this.height));

        const left = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
        const top  = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
        matrix.translate(-left, -top);

        // reset
        Util.$hitColor = null;

        Util.$hitContext.lineWidth = 0;
        Util.$hitContext.beginPath();
        Util.$hitContext.setTransform(
            matrix._$matrix[0], matrix._$matrix[1],
            matrix._$matrix[2], matrix._$matrix[3],
            -this._$bounds.xMin * xScale + matrix._$matrix[4],
            -this._$bounds.yMin * yScale + matrix._$matrix[5]
        );

        const recode = this._$recodes;
        const length  = recode.length;
        for (let idx = 0; idx < length; ) {
            switch (recode[idx++]) {

                case Graphics.BEGIN_PATH:
                    Util.$hitContext.beginPath();
                    break;

                case Graphics.MOVE_TO:
                    Util.$hitContext.moveTo(recode[idx++], recode[idx++]);
                    break;

                case Graphics.LINE_TO:
                    Util.$hitContext.lineTo(recode[idx++], recode[idx++]);
                    break;

                case Graphics.CURVE_TO:
                    Util.$hitContext.quadraticCurveTo(
                        recode[idx++], recode[idx++],
                        recode[idx++], recode[idx++]
                    );
                    break;

                case Graphics.CUBIC:
                    Util.$hitContext.bezierCurveTo(
                        recode[idx++], recode[idx++],
                        recode[idx++], recode[idx++],
                        recode[idx++], recode[idx++]
                    );
                    break;

                case Graphics.FILL_STYLE:
                    if (Util.$hitContext.isPointInPath(x, y)) {
                        if (this._$bitmapId) {

                            Util.$hitColor = {
                                "index": idx,
                                "style": Graphics.BITMAP_FILL,
                                "shape": this
                            };

                            document
                                .getElementById("fill-color-type-select")[1]
                                .selected = true;

                        } else {

                            Util.$hitColor = {
                                "index": idx,
                                "style": Graphics.FILL_STYLE,
                                "shape": this
                            };

                            const R = recode[idx    ].toString(16).padStart(2, "0");
                            const G = recode[idx + 1].toString(16).padStart(2, "0");
                            const B = recode[idx + 2].toString(16).padStart(2, "0");

                            document
                                .getElementById("fill-color-type-select")[0]
                                .selected = true;

                            document
                                .getElementById("fill-color-value")
                                .value = `#${R}${G}${B}`;

                            document
                                .getElementById("fill-alpha-value")
                                .value = `${recode[idx + 3] / 255 * 100}`;

                        }

                        Util
                            .$shapeController
                            .changeFillColorTypeSelect();

                    }
                    idx += 4;
                    break;

                case Graphics.GRADIENT_FILL:
                    if (Util.$hitContext.isPointInPath(x, y)) {

                        document
                            .getElementById("fill-color-type-select")[
                                recode[idx] === GradientType.LINEAR ? 2 : 3
                            ]
                            .selected = true;

                        Util.$hitColor = {
                            "index"  : idx,
                            "style"  : Graphics.GRADIENT_FILL,
                            "type"   : recode[idx],
                            "ratios" : recode[idx + 1],
                            "shape"  : this
                        };

                        Util
                            .$shapeController
                            .changeFillColorTypeSelect();

                    }
                    idx += 6;
                    break;

                case Graphics.STROKE_STYLE:
                    Util.$hitContext.lineWidth = recode[idx] | 0;
                    if (Util.$hitContext.isPointInStroke(x, y)) {

                        if (this._$bitmapId) {

                            Util.$hitColor = {
                                "index": idx,
                                "width": Util.$hitContext.lineWidth,
                                "style": Graphics.BITMAP_STROKE,
                                "shape": this
                            };

                            document
                                .getElementById("fill-color-type-select")[1]
                                .selected = true;

                        } else {

                            Util.$hitColor = {
                                "index": idx,
                                "width": Util.$hitContext.lineWidth,
                                "style": Graphics.STROKE_STYLE,
                                "shape": this
                            };

                            const R = recode[idx + 4].toString(16).padStart(2, "0");
                            const G = recode[idx + 5].toString(16).padStart(2, "0");
                            const B = recode[idx + 6].toString(16).padStart(2, "0");

                            document
                                .getElementById("fill-color-type-select")[0]
                                .selected = true;

                            document
                                .getElementById("fill-color-value")
                                .value = `#${R}${G}${B}`;

                            document
                                .getElementById("fill-alpha-value")
                                .value = `${recode[idx + 7] / 255 * 100}`;
                        }

                        document
                            .getElementById("fill-stroke-width-value")
                            .value = `${Util.$hitContext.lineWidth}`;

                        Util
                            .$shapeController
                            .changeFillColorTypeSelect();

                    }
                    idx += 8;
                    break;

                case Graphics.GRADIENT_STROKE:
                    Util.$hitContext.lineWidth = recode[idx];
                    if (Util.$hitContext.isPointInStroke(x, y)) {

                        document
                            .getElementById("fill-color-type-select")[
                                recode[idx + 4] === GradientType.LINEAR ? 2 : 3
                            ]
                            .selected = true;

                        Util.$hitColor = {
                            "index"  : idx,
                            "width"  : recode[idx],
                            "style"  : Graphics.GRADIENT_STROKE,
                            "type"   : recode[idx + 4],
                            "ratios" : recode[idx + 5],
                            "shape"  : this
                        };

                        Util
                            .$shapeController
                            .changeFillColorTypeSelect();

                    }
                    idx += 10;
                    break;

                case Graphics.CLOSE_PATH:
                case Graphics.END_STROKE:
                case Graphics.END_FILL:
                    break;

                default:
                    break;

            }
        }
    }

    /**
     * @return {next2d.display.Shape}
     * @public
     */
    createInstance ()
    {
        const { Shape, Graphics } = window.next2d.display;

        const shape = new Shape();

        if (this._$grid) {
            const { Rectangle } = window.next2d.geom;
            shape.scale9Grid = new Rectangle(
                this._$grid.x, this._$grid.y,
                this._$grid.w, this._$grid.h
            );
        }

        const graphics = shape.graphics;

        graphics._$maxAlpha = 1;
        graphics._$canDraw  = true;
        graphics._$xMin     = this._$bounds.xMin;
        graphics._$xMax     = this._$bounds.xMax;
        graphics._$yMin     = this._$bounds.yMin;
        graphics._$yMax     = this._$bounds.yMax;

        if (this._$bitmapId) {

            const { BitmapData } = window.next2d.display;

            const instance = Util
                .$currentWorkSpace()
                .getLibrary(this._$bitmapId);

            if (instance) {

                shape._$bitmapId = this._$bitmapId;

                // setup
                graphics._$recode = [];

                const bitmapData = new BitmapData(
                    instance.width, instance.height, true, 0
                );
                bitmapData._$buffer = instance._$buffer;

                // clone
                const recodes = this._$recodes;
                if (recodes[recodes.length - 1] === Graphics.END_FILL) {

                    const length  = recodes.length - 6;
                    for (let idx = 0; idx < length; ++idx) {
                        graphics._$recode.push(recodes[idx]);
                    }

                    // add Bitmap Fill
                    graphics._$recode.push(
                        Graphics.BITMAP_FILL,
                        bitmapData,
                        null,
                        "repeat",
                        false
                    );

                } else {

                    const width      = this._$recodes[recodes.length - 9];
                    const caps       = this._$recodes[recodes.length - 8];
                    const joints     = this._$recodes[recodes.length - 7];
                    const miterLimit = this._$recodes[recodes.length - 6];

                    const length  = recodes.length - 10;
                    for (let idx = 0; idx < length; ++idx) {
                        graphics._$recode.push(recodes[idx]);
                    }

                    graphics._$recode.push(
                        Graphics.BITMAP_STROKE,
                        width,
                        caps,
                        joints,
                        miterLimit,
                        bitmapData,
                        [1, 0, 0, 1, graphics._$xMin, graphics._$yMin],
                        "repeat",
                        false
                    );

                }

            } else {

                graphics._$recode = this._$recodes.slice(0);

            }

        } else {

            graphics._$recode = this._$recodes.slice(0);

        }

        return shape;
    }
}

/**
 * @class
 * @extends {Instance}
 */
class Sound extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object)
    {
        super(object);
        this.buffer = object.buffer;

        this._$binary    = "";
        this._$volume    = 100;
        this._$loopCount = 0;

        if ("volume" in object) {
            this.volume = object.volume;
        }

        if ("loopCount" in object) {
            this.loopCount = object.loopCount;
        }

        this._$audio = document.createElement("audio");

        this._$audio.preload  = "auto";
        this._$audio.autoplay = false;
        this._$audio.loop     = false;
        this._$audio.controls = true;

        this._$audio.src = URL.createObjectURL(new Blob(
            [new Uint8Array(this._$buffer)],
            { "type": "audio/mp3" }
        ));
        this._$audio.load();
    }

    /**
     * @return {HTMLAudioElement}
     * @method
     * @public
     */
    getPreview ()
    {
        return this._$audio;
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.media.Sound.namespace;
    }

    /**
     * @return {string}
     * @public
     */
    get buffer ()
    {
        if (!this._$binary) {

            const length = this._$buffer.length;

            for (let idx = 0; idx < length; ++idx) {
                this._$binary += String.fromCharCode(this._$buffer[idx]);
            }

        }

        return this._$binary;
    }

    /**
     * @param  {string|Uint8Array} binary
     * @return {void}
     * @public
     */
    set buffer (binary)
    {

        switch (typeof binary) {

            case "object":
                if (binary.constructor === Uint8Array) {
                    this._$buffer = binary;
                }
                break;

            case "string":
                if (!this._$binary) {
                    let length = binary.length;

                    this._$buffer = new Uint8Array(length);
                    for (let idx = 0; idx < length; ++idx) {
                        this._$buffer[idx] = binary.charCodeAt(idx) & 0xff;
                    }

                    this._$binary = binary;
                }
                break;

            default:
                break;

        }
    }

    /**
     * @return {number}
     * @public
     */
    get volume ()
    {
        return this._$volume;
    }

    /**
     * @param  {number} volume
     * @return {void}
     * @public
     */
    set volume (volume)
    {
        this._$volume = volume;
    }

    /**
     * @return {number}
     * @public
     */
    get loopCount ()
    {
        return this._$loopCount;
    }

    /**
     * @param  {number} loop_count
     * @return {void}
     * @public
     */
    set loopCount (loop_count)
    {
        this._$loopCount = loop_count;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":        this.id,
            "name":      this.name,
            "type":      this.type,
            "symbol":    this.symbol,
            "folderId":  this.folderId,
            "buffer":    this.buffer,
            "volume":    this.volume,
            "loopCount": this.loopCount
        };
    }

    /**
     * @return {object}
     * @public
     */
    toPublish ()
    {
        return {
            "buffer": Array.from(this._$buffer),
            "audioBuffer": null,
            "init": false
        };
    }
}

/**
 * @class
 */
class Stage
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        if (object) {
            this._$width   = object.width;
            this._$height  = object.height;
            this._$fps     = object.fps;
            this._$bgColor = object.bgColor;
            this._$lock    = object.lock;
        } else {
            this._$width   = Stage.STAGE_DEFAULT_WIDTH;
            this._$height  = Stage.STAGE_DEFAULT_HEIGHT;
            this._$fps     = Stage.STAGE_DEFAULT_FPS;
            this._$bgColor = "#ffffff";
            this._$lock    = false;
        }
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get STAGE_DEFAULT_WIDTH ()
    {
        return 550;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get STAGE_DEFAULT_HEIGHT ()
    {
        return 400;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get STAGE_DEFAULT_FPS ()
    {
        return 24;
    }

    /**
     * @return {void}
     * @public
     */
    initialize ()
    {
        // reset
        Util.$zoomScale = 1;
        document
            .getElementById("screen-scale")
            .value = "100";

        // canvas
        const stage = document.getElementById("stage");
        stage.style.width           = `${this.width}px`;
        stage.style.height          = `${this.height}px`;
        stage.style.backgroundColor = this.bgColor;

        document
            .getElementById("library-preview-area")
            .style.backgroundColor = this.bgColor;

        // stage area
        const area = document.getElementById("stage-area");
        area.style.transformOrigin = "50% 50%";
        area.style.width  = `${this.width  + window.screen.width}px`;
        area.style.height = `${this.height + window.screen.height}px`;

        // DOM
        document
            .getElementById("label-name")
            .value = "";

        document
            .getElementById("stage-width")
            .value = this.width;

        document
            .getElementById("stage-height")
            .value = this.height;

        document
            .getElementById("stage-fps")
            .value = this.fps;

        document
            .getElementById("stage-bgColor")
            .value = this.bgColor;

        const element = document
            .getElementById("stage-lock")
            .childNodes[1];

        element
            .setAttribute("class", this.lock ? "active" : "disable");

        Util.$controller._$stageLock = this.lock;

        // set xy
        const screen = document.getElementById("screen");
        screen.scrollLeft = window.screen.width  / 2 - (screen.clientWidth  - this.width)  / 2;
        screen.scrollTop  = window.screen.height / 2 - (screen.clientHeight - this.height) / 2;

        Util.$offsetLeft = stage.offsetLeft;
        Util.$offsetTop  = stage.offsetTop;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "width": this.width,
            "height": this.height,
            "fps": this.fps,
            "bgColor": this.bgColor,
            "lock": this.lock
        };
    }

    /**
     * @return {number}
     * @public
     */
    get width ()
    {
        return this._$width;
    }

    /**
     * @param  {number} width
     * @return {void}
     * @public
     */
    set width (width)
    {
        this._$width = width;
    }

    /**
     * @return {number}
     * @public
     */
    get height ()
    {
        return this._$height;
    }

    /**
     * @param  {number} height
     * @return {void}
     * @public
     */
    set height (height)
    {
        this._$height = height;
    }

    /**
     * @return {number}
     * @public
     */
    get fps ()
    {
        return this._$fps;
    }

    /**
     * @param  {number} fps
     * @return {void}
     * @public
     */
    set fps (fps)
    {
        this._$fps = fps;
    }

    /**
     * @return {string}
     * @public
     */
    get bgColor ()
    {
        return this._$bgColor;
    }

    /**
     * @param  {string} color
     * @return {void}
     * @public
     */
    set bgColor (color)
    {
        this._$bgColor = color;
    }

    /**
     * @return {boolean}
     * @public
     */
    get lock ()
    {
        return this._$lock;
    }

    /**
     * @param  {boolean} lock
     * @return {void}
     * @public
     */
    set lock (lock)
    {
        this._$lock = lock;
    }
}

/**
 * @class
 * @extends {Instance}
 */
class TextField extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object = null)
    {
        super(object);

        this._$text           = "";
        this._$font           = "sans-serif";
        this._$size           = 12;
        this._$align          = "left";
        this._$color          = 0;
        this._$fontType       = 0;
        this._$inputType      = "static";
        this._$leading        = 0;
        this._$letterSpacing  = 0;
        this._$leftMargin     = 0;
        this._$rightMargin    = 0;
        this._$autoSize       = 0;
        this._$multiline      = true;
        this._$wordWrap       = true;
        this._$border         = false;
        this._$scroll         = true;
        this._$cache          = null;
        this._$htmlText       = null;
        this._$thickness      = 0;
        this._$thicknessColor = 0;

        this._$bounds = {
            "xMin": 0,
            "xMax": TextField.FONT_DEFAULT_SIZE,
            "yMin": 0,
            "yMax": TextField.FONT_DEFAULT_SIZE
        };

        this._$originBounds = {
            "xMin": 0,
            "xMax": TextField.FONT_DEFAULT_SIZE,
            "yMin": 0,
            "yMax": TextField.FONT_DEFAULT_SIZE
        };

        if (object.text) {
            this.text = object.text;
        }

        if (object.font) {
            this.font = object.font;
        }

        if (object.fontType) {
            this.fontType = object.fontType;
        }

        if (object.inputType) {
            this.inputType = object.inputType;
        }

        if (object.size) {
            this.size = object.size;
        }

        if (object.align) {
            this.align = object.align;
        }

        if (object.color) {
            this.color = object.color;
        }

        if (object.leading) {
            this.leading = object.leading;
        }

        if (object.letterSpacing) {
            this.letterSpacing = object.letterSpacing;
        }

        if (object.leftMargin) {
            this.leftMargin = object.leftMargin;
        }

        if (object.rightMargin) {
            this.rightMargin = object.rightMargin;
        }

        if ("multiline" in object) {
            this.multiline = object.multiline;
        }

        if ("wordWrap" in object) {
            this.wordWrap = object.wordWrap;
        }

        if (object.autoFontSize) {
            this.autoFontSize = object.autoFontSize;
        }

        if ("scroll" in object) {
            this.scroll = object.scroll;
        }

        if (object.border) {
            this.border = object.border;
        }

        if (object.bounds) {
            this.bounds = object.bounds;
        }

        if (object.originBounds) {
            this.originBounds = object.originBounds;
        }

        if (object.autoSize) {
            this.autoSize = object.autoSize;
        }

        if (object.thickness) {
            this.thickness = object.thickness;
        }

        if (object.thicknessColor) {
            this.thicknessColor = object.thicknessColor;
        }
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get FONT_DEFAULT_SIZE ()
    {
        return 200;
    }

    /**
     * @param  {object} place
     * @param  {string} [name=""]
     * @return {void}
     * @method
     * @public
     */
    showController(place, name = "")
    {
        super.showController(place, name);

        Util.$controller.hideObjectSetting([
            "video-setting",
            "loop-setting",
            "fill-color-setting",
            "nine-slice-setting"
        ]);

        Util.$controller.showObjectSetting([
            "text-setting"
        ]);

        const fontSelect = document
            .getElementById("font-select");

        // font
        fontSelect.children[0].selected = true;
        for (let idx = 0; idx < fontSelect.children.length; ++idx) {

            const node = fontSelect.children[idx];

            if (node.value !== this._$font) {
                continue;
            }

            node.selected = true;
            break;
        }

        const fontStyleSelect = document
            .getElementById("font-style-select");

        for (let idx = 0; idx < fontStyleSelect.children.length; ++idx) {

            const node = fontStyleSelect.children[idx];

            if ((node.value | 0) !== this._$fontType) {
                continue;
            }

            node.selected = true;
            break;
        }

        const fontAlignSelect = document
            .getElementById("font-align-select");

        for (let idx = 0; idx < fontAlignSelect.children.length; ++idx) {

            const node = fontAlignSelect.children[idx];

            if (node.value !== this._$align) {
                continue;
            }

            node.selected = true;
            break;
        }

        const fontWrapSelect = document
            .getElementById("font-wrap-select");

        switch (true) {

            case !this._$wordWrap && !this._$multiline:
                fontWrapSelect.children[0].selected = true;
                break;

            case !this._$wordWrap && this._$multiline:
                fontWrapSelect.children[1].selected = true;
                break;

            case this._$wordWrap && this._$multiline:
                fontWrapSelect.children[2].selected = true;
                break;

        }

        const fontInputSelect = document
            .getElementById("font-input-select");

        fontInputSelect.children[
            this._$inputType === "static" ? 0 : 1
        ].selected = true;

        document
            .getElementById("font-size")
            .value = `${this._$size}`;

        document
            .getElementById("font-color")
            .value = `#${this._$color.toString(16).padStart(6, "0")}`;

        document
            .getElementById("font-stroke-size")
            .value = `${this._$thickness}`;

        document
            .getElementById("font-stroke-color")
            .value = `#${this._$thicknessColor.toString(16).padStart(6, "0")}`;

        const params = [
            "font-leading",
            "font-letterSpacing",
            "font-leftMargin",
            "font-rightMargin"
        ];

        for (let idx = 0; idx < params.length; ++idx) {

            const name = params[idx];

            document
                .getElementById(name)
                .value = `${this[name.split("-")[1]]}`;

        }

        document
            .getElementById("font-auto-size-select")
            .children[this._$autoSize].selected = true;

        if (this._$border) {
            document
                .getElementById("font-border-select")
                .children[1].selected = true;
        }

        if (this._$scroll) {
            document
                .getElementById("font-scroll-select")
                .children[0].selected = true;
        }
    }

    /**
     * @param  {array} [matrix=null]
     * @return {object}
     * @public
     */
    getBounds (matrix = null)
    {
        const bounds = {
            "xMin": -this._$thickness,
            "xMax": this._$bounds.xMax + this._$thickness,
            "yMin": -this._$thickness,
            "yMax": this._$bounds.yMax + 4 + this._$thickness
        };

        return matrix
            ? Util.$boundsMatrix(bounds, matrix)
            : bounds;
    }

    /**
     * @return {string}
     * @public
     */
    get text ()
    {
        return this._$text;
    }

    /**
     * @param {string} text
     * @public
     */
    set text (text)
    {
        this._$text = text;
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get size ()
    {
        return this._$size;
    }

    /**
     * @param {number} size
     * @public
     */
    set size (size)
    {
        this._$size = size | 0;
        this.resize();
    }

    /**
     * @return {string}
     * @public
     */
    get font ()
    {
        return this._$font;
    }

    /**
     * @param {string} font
     * @public
     */
    set font (font)
    {
        this._$font = font;
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get fontType ()
    {
        return this._$fontType;
    }

    /**
     * @param {number} font_type
     * @public
     */
    set fontType (font_type)
    {
        this._$fontType = font_type | 0;
        this.resize();
    }

    /**
     * @return {string}
     * @public
     */
    get inputType ()
    {
        return this._$inputType;
    }

    /**
     * @param {string} input_type
     * @public
     */
    set inputType (input_type)
    {
        this._$inputType = input_type;
    }

    /**
     * @return {string}
     * @public
     */
    get align ()
    {
        return this._$align;
    }

    /**
     * @param {string} align
     * @public
     */
    set align (align)
    {
        this._$align = align;
    }

    /**
     * @return {number}
     * @public
     */
    get color ()
    {
        return this._$color;
    }

    /**
     * @param {number} color
     * @public
     */
    set color (color)
    {
        this._$color = color | 0;
    }

    /**
     * @return {number}
     * @public
     */
    get leading ()
    {
        return this._$leading;
    }

    /**
     * @param {number} leading
     * @public
     */
    set leading (leading)
    {
        this._$leading = leading | 0;
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get letterSpacing ()
    {
        return this._$letterSpacing;
    }

    /**
     * @param {number} letter_spacing
     * @public
     */
    set letterSpacing (letter_spacing)
    {
        this._$letterSpacing = letter_spacing | 0;
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get leftMargin ()
    {
        return this._$leftMargin;
    }

    /**
     * @param {number} left_margin
     * @public
     */
    set leftMargin (left_margin)
    {
        this._$leftMargin = left_margin | 0;
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get rightMargin ()
    {
        return this._$rightMargin;
    }

    /**
     * @param {number} right_margin
     * @public
     */
    set rightMargin (right_margin)
    {
        this._$rightMargin = right_margin | 0;
        this.resize();
    }

    /**
     * @return {boolean}
     * @public
     */
    get multiline ()
    {
        return this._$multiline;
    }

    /**
     * @param {boolean} multiline
     * @public
     */
    set multiline (multiline)
    {
        this._$multiline = !!multiline;
        this.resize();
    }

    /**
     * @return {boolean}
     * @public
     */
    get border ()
    {
        return this._$border;
    }

    /**
     * @param {boolean} border
     * @public
     */
    set border (border)
    {
        this._$border = !!border;
    }

    /**
     * @return {boolean}
     * @public
     */
    get scroll ()
    {
        return this._$scroll;
    }

    /**
     * @param {boolean} scroll
     * @public
     */
    set scroll (scroll)
    {
        this._$scroll = !!scroll;
    }

    /**
     * @return {boolean}
     * @public
     */
    get wordWrap ()
    {
        return this._$wordWrap;
    }

    /**
     * @param {boolean} word_wrap
     * @public
     */
    set wordWrap (word_wrap)
    {
        this._$wordWrap = !!word_wrap;
        this.resize();
    }

    /**
     * @return {object}
     * @public
     */
    get bounds ()
    {
        return this._$bounds;
    }

    /**
     * @param {object} [bounds=null]
     * @public
     */
    set bounds (bounds)
    {
        this._$bounds = bounds;
    }

    /**
     * @return {object}
     * @public
     */
    get originBounds ()
    {
        return this._$originBounds;
    }

    /**
     * @param {object} origin_bounds
     * @public
     */
    set originBounds (origin_bounds)
    {
        this._$originBounds = origin_bounds;
    }

    /**
     * @return {number}
     * @public
     */
    get autoSize ()
    {
        return this._$autoSize;
    }

    /**
     * @param {number} auto_size
     * @public
     */
    set autoSize (auto_size)
    {
        this._$autoSize = auto_size | 0;
        if (this._$autoSize !== 1) {
            this._$bounds.xMax = this._$originBounds.xMax;
            this._$bounds.yMax = this._$originBounds.yMax;
        }
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get thickness ()
    {
        return this._$thickness;
    }

    /**
     * @param {number} thickness
     * @public
     */
    set thickness (thickness)
    {
        this._$thickness = thickness | 0;
        this.resize();
    }

    /**
     * @return {number}
     * @public
     */
    get thicknessColor ()
    {
        return this._$thicknessColor;
    }

    /**
     * @param {number} thickness_color
     * @public
     */
    set thicknessColor (thickness_color)
    {
        this._$thicknessColor = thickness_color | 0;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":             this.id,
            "name":           this.name,
            "type":           this.type,
            "symbol":         this.symbol,
            "folderId":       this.folderId,
            "text":           this.text,
            "font":           this.font,
            "fontType":       this.fontType,
            "inputType":      this.inputType,
            "size":           this.size,
            "align":          this.align,
            "color":          this.color,
            "leading":        this.leading,
            "letterSpacing":  this.letterSpacing,
            "leftMargin":     this.leftMargin,
            "rightMargin":    this.rightMargin,
            "multiline":      this.multiline,
            "wordWrap":       this.wordWrap,
            "border":         this.border,
            "autoSize":       this.autoSize,
            "scroll":         this.scroll,
            "originBounds":   this.originBounds,
            "bounds":         this.bounds,
            "thickness":      this.thickness,
            "thicknessColor": this.thicknessColor
        };
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.text.TextField.namespace;
    }

    /**
     * @return {object}
     * @public
     */
    toPublish ()
    {
        return {
            "symbol":         this.symbol,
            "extends":        this.defaultSymbol,
            "text":           this.text,
            "font":           this.font,
            "fontType":       this.fontType,
            "inputType":      this.inputType,
            "size":           this.size,
            "align":          this.align,
            "color":          this.color,
            "leading":        this.leading,
            "letterSpacing":  this.letterSpacing,
            "leftMargin":     this.leftMargin,
            "rightMargin":    this.rightMargin,
            "multiline":      this.multiline,
            "wordWrap":       this.wordWrap,
            "border":         this.border,
            "autoSize":       this.autoSize,
            "scroll":         this.scroll,
            "originBounds":   this.originBounds,
            "bounds":         this.bounds,
            "thickness":      this.thickness,
            "thicknessColor": this.thicknessColor
        };
    }

    /**
     * @return {void}
     * @public
     */
    resize ()
    {
        const textField = this.createInstance();
        this._$bounds = {
            "xMin": textField._$bounds.xMin,
            "xMax": textField._$bounds.xMax,
            "yMin": textField._$bounds.yMin,
            "yMax": textField._$bounds.yMax
        };
    }

    /**
     * @return {next2d.text.TextField}
     * @public
     */
    createInstance ()
    {
        const { TextField } = window.next2d.text;
        const textField = new TextField();

        textField._$bounds = {
            "xMin": this._$originBounds.xMin,
            "xMax": this._$originBounds.xMax,
            "yMin": this._$originBounds.yMin,
            "yMax": this._$originBounds.yMax
        };
        textField._$originBounds = {
            "xMin": this._$originBounds.xMin,
            "xMax": this._$originBounds.xMax,
            "yMin": this._$originBounds.yMin,
            "yMax": this._$originBounds.yMax
        };

        const textFormat         = textField.defaultTextFormat;
        textFormat.font          = this._$font;
        textFormat.size          = this._$size;
        textFormat.align         = this._$align;
        textFormat.color         = this._$color;
        textFormat.leading       = this._$leading;
        textFormat.letterSpacing = this._$letterSpacing;
        textFormat.leftMargin    = this._$leftMargin;
        textFormat.rightMargin   = this._$rightMargin;

        switch (this._$fontType) {

            case 1:
                textFormat.bold = true;
                break;

            case 2:
                textFormat.italic = true;
                break;

            case 3:
                textFormat.bold   = true;
                textFormat.italic = true;
                break;

        }

        switch (this._$autoSize) {

            case 1:
                textField.autoSize = this._$align;
                break;

            case 2:
                textField.autoFontSize = true;
                break;

        }

        textField.multiline      = this._$multiline;
        textField.wordWrap       = this._$wordWrap;
        textField.border         = this._$border;
        textField.scroll         = this._$scroll;
        textField.thickness      = this._$thickness;
        textField.thicknessColor = this._$thicknessColor;
        textField.text           = this._$text;

        return textField;
    }

    /**
     * @param  {number} width
     * @param  {number} height
     * @param  {object} place
     * @return {Promise}
     * @public
     */
    toImage (width, height, place)
    {
        return super
            .toImage(width, height, place)
            .then((image) =>
            {
                image._$tx -= this._$thickness;
                image._$ty -= this._$thickness;

                let resizeX = 0;
                switch (this._$autoSize) {

                    case 0:
                        if (this._$align === "right") {
                            resizeX = -4;
                        }
                        break;

                    case 1:
                        switch (this._$align) {

                            case "center":
                                resizeX = (this._$bounds.xMax - this._$originBounds.xMax) / 2;
                                if (resizeX) {
                                    resizeX -= 2;
                                }
                                break;

                            case "right":
                                resizeX = this._$originBounds.xMax - this._$bounds.xMax;
                                if (resizeX) {
                                    resizeX += 2;
                                    resizeX *= -1;
                                }
                                break;

                        }
                        break;

                }

                if (this._$autoSize === 1) {
                    image._$tx -= resizeX;
                }

                return image;
            });
    }
}

/**
 * @class
 * @extends {Instance}
 */
class Video extends Instance
{
    /**
     * @param {object} object
     * @constructor
     */
    constructor (object)
    {
        super(object);

        this._$volume   = 100;
        this._$loop     = false;
        this._$autoPlay = true;
        this._$binary   = "";
        this._$queue    = [];
        this._$loaded   = false;

        this.buffer   = object.buffer;
        this.width    = object.width;
        this.height   = object.height;

        if ("volume" in object) {
            this.volume = object.volume;
        }

        if ("loop" in object) {
            this.loop = object.loop;
        }

        if ("autoPlay" in object) {
            this.autoPlay = object.autoPlay;
        }

        this._$video = document.createElement("video");
        this._$video.crossOrigin = "anonymous";
        this._$video.type        = "video/mp4";
        this._$video.muted       = true;
        this._$video.autoplay    = false;

        const start = (event) =>
        {
            event.target.removeEventListener("canplaythrough", start);

            event.target.play();
            event.target.currentTime = 1;
            event.target.pause();

            this._$loaded = true;
            setTimeout(() => { this.delayImage() }, 150);

        };
        this._$video.addEventListener("canplaythrough", start);

        this._$video.src = URL.createObjectURL(new Blob(
            [new Uint8Array(this._$buffer)],
            { "type": "video/mp4" }
        ));
        this._$video.load();
    }

    /**
     * @param  {object} place
     * @param  {string} [name=""]
     * @return {void}
     * @method
     * @public
     */
    showController(place, name = "")
    {
        super.showController(place, name);

        Util.$controller.hideObjectSetting([
            "text-setting",
            "loop-setting",
            "fill-color-setting",
            "nine-slice-setting"
        ]);

        Util.$controller.showObjectSetting([
            "video-setting"
        ]);

        document
            .getElementById("video-volume")
            .value = this.volume;

        document
            .getElementById("video-loop-select")
            .children[this.loop ? 1 : 0]
            .selected = true;

        document
            .getElementById("video-auto-select")
            .children[this.autoPlay ? 1 : 0]
            .selected = true;
    }

    /**
     * @return {HTMLVideoElement}
     * @method
     * @public
     */
    getPreview ()
    {
        const bounds = this.getBounds();

        // size
        let width  = Math.abs(bounds.xMax - bounds.xMin);
        let height = Math.abs(bounds.yMax - bounds.yMin);

        let scaleX   = 1;
        const scaleY = 150 / height;

        width  = width  * scaleY | 0;
        height = height * scaleY | 0;

        const controllerWidth = (document
            .documentElement
            .style
            .getPropertyValue("--controller-width")
            .split("px")[0] | 0) - 10;

        if (width > controllerWidth) {
            scaleX = controllerWidth / width;
            width  = width  * scaleX | 0;
            height = height * scaleX | 0;
        }

        this._$video.style.width  = `${width}px`;
        this._$video.style.height = `${height}px`;

        this._$video.controls = true;
        return this._$video;
    }

    /**
     * @param  {array} [matrix=null]
     * @return {object}
     * @public
     */
    getBounds (matrix = null)
    {
        const bounds = {
            "xMin": 0,
            "xMax": this.width,
            "yMin": 0,
            "yMax": this.height
        };

        return matrix
            ? Util.$boundsMatrix(bounds, matrix)
            : bounds;
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.media.Video.namespace;
    }

    /**
     * @return {string}
     * @public
     */
    get buffer ()
    {
        if (!this._$binary) {

            const length = this._$buffer.length;

            for (let idx = 0; idx < length; ++idx) {
                this._$binary += String.fromCharCode(this._$buffer[idx]);
            }

        }

        return this._$binary;
    }

    /**
     * @param  {string|Uint8Array} binary
     * @return {void}
     * @public
     */
    set buffer (binary)
    {

        switch (typeof binary) {

            case "object":
                if (binary.constructor === Uint8Array) {
                    this._$buffer = binary;
                }
                break;

            case "string":
                if (!this._$binary) {
                    let length = binary.length;

                    this._$buffer = new Uint8Array(length);
                    for (let idx = 0; idx < length; ++idx) {
                        this._$buffer[idx] = binary.charCodeAt(idx) & 0xff;
                    }

                    this._$binary = binary;
                }
                break;

            default:
                break;

        }
    }

    /**
     * @return {number}
     * @public
     */
    get volume ()
    {
        return this._$volume;
    }

    /**
     * @param  {number} volume
     * @return {void}
     * @public
     */
    set volume (volume)
    {
        this._$volume = volume;
    }

    /**
     * @return {boolean}
     * @public
     */
    get loop ()
    {
        return this._$loop;
    }

    /**
     * @param  {boolean} loop
     * @return {void}
     * @public
     */
    set loop (loop)
    {
        this._$loop = loop;
    }

    /**
     * @return {boolean}
     * @public
     */
    get autoPlay ()
    {
        return this._$autoPlay;
    }

    /**
     * @param  {boolean} auto_play
     * @return {void}
     * @public
     */
    set autoPlay (auto_play)
    {
        this._$autoPlay = auto_play;
    }

    /**
     * @return {uint}
     * @public
     */
    get width ()
    {
        return this._$width;
    }

    /**
     * @param  {uint} width
     * @return {void}
     * @public
     */
    set width (width)
    {
        this._$width = width;
    }

    /**
     * @return {uint}
     * @public
     */
    get height ()
    {
        return this._$height;
    }

    /**
     * @param  {uint} height
     * @return {void}
     * @public
     */
    set height (height)
    {
        this._$height = height;
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "id":        this.id,
            "name":      this.name,
            "type":      this.type,
            "symbol":    this.symbol,
            "folderId":  this.folderId,
            "width":     this.width,
            "height":    this.height,
            "buffer":    this.buffer,
            "volume":    this.volume,
            "loop":      this.loop,
            "autoPlay":  this.autoPlay
        };
    }

    /**
     * @return {object}
     * @public
     */
    toPublish ()
    {
        return {
            "symbol":   this.symbol,
            "extends":  this.defaultSymbol,
            "buffer":   Array.from(this._$buffer),
            "bounds":   this.getBounds(),
            "volume":   this.volume / 100,
            "loop":     this.loop,
            "autoPlay": this.autoPlay
        };
    }

    /**
     * @param  {object}  place
     * @param  {boolean} [preview=false]
     * @return {next2d.display.Shape}
     * @public
     */
    createInstance (place, preview = false)
    {
        if (!place) {
            console.log(place);
        }

        const { Video } = window.next2d.media;

        const video = this._$loaded
            ? new Video(this._$video.videoWidth, this._$video.videoHeight)
            : new Video(this.width, this.height);

        video._$characterId = this.id;
        video._$video       = this._$video;

        if (this._$loaded) {
            const context = Util.$root.stage._$player._$context;

            if (!preview) {

                const currentFrame = Util.$timelineFrame.currentFrame;

                video._$video.currentTime = currentFrame / 60;

            } else {

                video._$video.currentTime = 1;

            }

            video._$texture = context
                .frameBuffer
                .createTextureFromVideo(video._$video, video._$smoothing);
        }

        return video;
    }

    /**
     * @return {void}
     * @public
     */
    delayImage ()
    {
        for (let idx = 0; idx < this._$queue.length; ++idx) {
            const object = this._$queue[idx];
            object.image.src = this.toImage(
                object.width, object.height, object.place, object.preview
            ).src;
        }
        this._$queue.length = 0;
    }

    /**
     * @param  {number}  width
     * @param  {number}  height
     * @param  {object}  place
     * @param  {boolean} [preview=false]
     * @return {HTMLImageElement}
     * @public
     */
    toImage (width, height, place, preview = false)
    {
        const image = super.toImage(width, height, place, preview);
        if (this._$loaded) {
            return image;
        }

        this._$queue.push({
            "image": image,
            "width": width,
            "height": height,
            "preview": preview,
            "place": place
        });

        return image;
    }
}

/**
 * @class
 */
class Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor(object = null)
    {
        this._$blurX   = 4;
        this._$blurY   = 4;
        this._$quality = 1;
        this._$state   = true;
        this._$name    = "";

        if (object) {
            this.blurX   = object.blurX;
            this.blurY   = object.blurY;
            this.quality = object.quality | 0;
            this.state   = object.state;
        }
    }

    /**
     * @return {Filter}
     * @public
     */
    clone ()
    {
        return new this.constructor(this.toObject());
    }

    /**
     * @param  {Filter} filter
     * @return {boolean}
     * @public
     */
    isSame (filter)
    {
        if (this._$quality !== filter._$quality) {
            return false;
        }

        if (this._$blurX !== filter._$blurX) {
            return false;
        }

        if (this._$blurY !== filter._$blurY) {
            return false;
        }

        return true;
    }

    /**
     * @return {number}
     * @public
     */
    get blurX ()
    {
        return this._$blurX;
    }

    /**
     * @param  {number} blur_x
     * @return {void}
     * @public
     */
    set blurX (blur_x)
    {
        this._$blurX = Util.$clamp(
            +blur_x,
            FilterController.MIN_BLUR,
            FilterController.MAX_BLUR
        );
    }

    /**
     * @return {number}
     * @public
     */
    get blurY ()
    {
        return this._$blurY;
    }

    /**
     * @param  {number} blur_y
     * @return {void}
     * @public
     */
    set blurY (blur_y)
    {
        this._$blurY = Util.$clamp(
            +blur_y,
            FilterController.MIN_BLUR,
            FilterController.MAX_BLUR
        );
    }

    /**
     * @return {number}
     * @public
     */
    get quality ()
    {
        return this._$quality;
    }

    /**
     * @param  {number} quality
     * @return {void}
     * @public
     */
    set quality (quality)
    {
        this._$quality = Util.$clamp(quality | 0, 1, 3);
    }

    /**
     * @return {boolean}
     * @public
     */
    get state ()
    {
        return this._$state;
    }

    /**
     * @param  {boolean} state
     * @return {void}
     * @public
     */
    set state (state)
    {
        this._$state = state;
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @param  {string} name
     * @return {void}
     * @public
     */
    set name (name)
    {
        this._$name = name;
    }
}

/**
 * @class
 * @extends {Filter}
 */
class BevelFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        super(object);
        this.name = "BevelFilter";

        this._$distance       = 4;
        this._$angle          = 45;
        this._$highlightColor = 0xffffff;
        this._$highlightAlpha = 100;
        this._$shadowColor    = 0;
        this._$shadowAlpha    = 100;
        this._$strength       = 1;
        this._$type           = "inner";
        this._$knockout       = false;

        if (object) {
            this.distance       = object.distance;
            this.angle          = object.angle;
            this.highlightColor = object.highlightColor | 0;
            this.highlightAlpha = object.highlightAlpha * 100;
            this.shadowColor    = object.shadowColor | 0;
            this.shadowAlpha    = object.shadowAlpha * 100;
            this.strength       = object.strength;
            this.type           = object.type;
            this.knockout       = object.knockout;
        }
    }

    /**
     * @return {number}
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }

    /**
     * @param  {number} distance
     * @return {void}
     * @public
     */
    set distance (distance)
    {
        this._$distance = Util.$clamp(
            +distance,
            FilterController.MIN_DISTANCE,
            FilterController.MAX_DISTANCE
        );
    }

    /**
     * @return {number}
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }

    /**
     * @param  {number} angle
     * @return {void}
     * @public
     */
    set angle (angle)
    {
        this._$angle = +angle % 360;
    }

    /**
     * @return {number}
     * @public
     */
    get highlightColor ()
    {
        return this._$highlightColor;
    }

    /**
     * @param  {number} highlight_color
     * @return {void}
     * @public
     */
    set highlightColor (highlight_color)
    {
        this._$highlightColor = Util.$clamp(highlight_color | 0, 0, 0xffffff);
    }

    /**
     * @return {number}
     * @public
     */
    get highlightAlpha ()
    {
        return this._$highlightAlpha;
    }

    /**
     * @param  {number} highlight_alpha
     * @return {void}
     * @public
     */
    set highlightAlpha (highlight_alpha)
    {
        this._$highlightAlpha = Util.$clamp(+highlight_alpha, 0, 100);
    }

    /**
     * @return {number}
     * @public
     */
    get shadowColor ()
    {
        return this._$shadowColor;
    }

    /**
     * @param  {number} shadow_color
     * @return {void}
     * @public
     */
    set shadowColor (shadow_color)
    {
        this._$shadowColor = Util.$clamp(shadow_color | 0, 0, 0xffffff);
    }

    /**
     * @return {number}
     * @public
     */
    get shadowAlpha ()
    {
        return this._$shadowAlpha;
    }

    /**
     * @param  {number} shadow_alpha
     * @return {void}
     * @public
     */
    set shadowAlpha (shadow_alpha)
    {
        this._$shadowAlpha = Util.$clamp(+shadow_alpha, 0, 100);
    }

    /**
     * @return {number}
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }

    /**
     * @param  {number} strength
     * @return {void}
     * @public
     */
    set strength (strength)
    {
        this._$strength = Util.$clamp(
            +strength,
            FilterController.MIN_STRENGTH,
            FilterController.MAX_STRENGTH
        );
    }

    /**
     * @return {string}
     * @public
     */
    get type ()
    {
        return this._$type;
    }

    /**
     * @param  {string} type
     * @return {void}
     * @public
     */
    set type (type)
    {
        this._$type = type;
    }

    /**
     * @return {boolean}
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }

    /**
     * @param  {boolean} knockout
     * @return {void}
     * @public
     */
    set knockout (knockout)
    {
        this._$knockout = knockout;
    }

    /**
     * @param  {BevelFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        if (this._$highlightColor !== filter._$highlightColor) {
            return false;
        }

        if (this._$highlightAlpha !== filter._$highlightAlpha) {
            return false;
        }

        if (this._$shadowColor !== filter._$shadowColor) {
            return false;
        }

        if (this._$shadowAlpha !== filter._$shadowAlpha) {
            return false;
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$type !== filter._$type) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @return {window.next2d.filters.BevelFilter}
     * @public
     */
    createInstance ()
    {
        return new window.next2d.filters.BevelFilter(
            this.distance, this.angle, this.highlightColor, this.highlightAlpha / 100,
            this.shadowColor, this.shadowAlpha / 100, this.blurX, this.blurY,
            this.strength, this.quality, this.type, this.knockout
        );
    }

    /**
     * @return {array}
     */
    toParamArray ()
    {
        return [null,
            this.distance, this.angle, this.highlightColor, this.highlightAlpha / 100,
            this.shadowColor, this.shadowAlpha / 100, this.blurX, this.blurY,
            this.strength, this.quality, this.type, this.knockout
        ];
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "distance": this.distance,
            "angle": this.angle,
            "highlightColor": this.highlightColor,
            "highlightAlpha": this.highlightAlpha / 100,
            "shadowColor": this.shadowColor,
            "shadowAlpha": this.shadowAlpha / 100,
            "strength": this.strength,
            "type": this.type,
            "knockout": this.knockout
        };
    }
}

/**
 * @class
 * @extends {Filter}
 */
class BlurFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        super(object);
        this.name = "BlurFilter";
    }

    /**
     * @return {window.next2d.filters.BlurFilter}
     * @public
     */
    createInstance ()
    {
        return new window.next2d.filters.BlurFilter(
            this.blurX, this.blurY, this.quality
        );
    }

    /**
     * @return {array}
     */
    toParamArray ()
    {
        return [null, this.blurX, this.blurY, this.quality];
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state
        };
    }
}

/**
 * @class
 * @extends {Filter}
 */
class DropShadowFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        super(object);
        this.name = "DropShadowFilter";

        this._$distance   = 4;
        this._$angle      = 45;
        this._$color      = 0;
        this._$alpha      = 100;
        this._$strength   = 1;
        this._$inner      = false;
        this._$knockout   = false;
        this._$hideObject = false;

        if (object) {
            this.distance   = object.distance;
            this.angle      = object.angle;
            this.color      = object.color;
            this.alpha      = object.alpha * 100;
            this.strength   = object.strength;
            this.inner      = object.inner;
            this.knockout   = object.knockout;
            this.hideObject = object.hideObject;
        }
    }

    /**
     * @return {number}
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }

    /**
     * @param  {number} distance
     * @return {void}
     * @public
     */
    set distance (distance)
    {
        this._$distance = Util.$clamp(
            +distance,
            FilterController.MIN_DISTANCE,
            FilterController.MAX_DISTANCE
        );
    }

    /**
     * @return {number}
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }

    /**
     * @param  {number} angle
     * @return {void}
     * @public
     */
    set angle (angle)
    {
        this._$angle = +angle % 360;
    }

    /**
     * @return {number}
     * @public
     */
    get color ()
    {
        return this._$color;
    }

    /**
     * @param  {number} color
     * @return {void}
     * @public
     */
    set color (color)
    {
        this._$color = Util.$clamp(color | 0, 0, 0xffffff);
    }

    /**
     * @return {number}
     * @public
     */
    get alpha ()
    {
        return this._$alpha;
    }

    /**
     * @param  {number} alpha
     * @return {void}
     * @public
     */
    set alpha (alpha)
    {
        this._$alpha = Util.$clamp(+alpha, 0, 100);
    }

    /**
     * @return {number}
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }

    /**
     * @param  {number} strength
     * @return {void}
     * @public
     */
    set strength (strength)
    {
        this._$strength = Util.$clamp(
            +strength,
            FilterController.MIN_STRENGTH,
            FilterController.MAX_STRENGTH
        );
    }

    /**
     * @return {boolean}
     * @public
     */
    get inner ()
    {
        return this._$inner;
    }

    /**
     * @param  {boolean} inner
     * @return {void}
     * @public
     */
    set inner (inner)
    {
        this._$inner = inner;
    }

    /**
     * @return {boolean}
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }

    /**
     * @param  {boolean} knockout
     * @return {void}
     * @public
     */
    set knockout (knockout)
    {
        this._$knockout = knockout;
    }

    /**
     * @return {boolean}
     * @public
     */
    get hideObject ()
    {
        return this._$hideObject;
    }

    /**
     * @param  {boolean} hideObject
     * @return {void}
     * @public
     */
    set hideObject (hideObject)
    {
        this._$hideObject = hideObject;
    }

    /**
     * @param  {DropShadowFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        if (this._$color !== filter._$color) {
            return false;
        }

        if (this._$alpha !== filter._$alpha) {
            return false;
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$inner !== filter._$inner) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        if (this._$hideObject !== filter._$hideObject) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @return {window.next2d.filters.DropShadowFilter}
     * @public
     */
    createInstance ()
    {
        return new window.next2d.filters.DropShadowFilter(
            this.distance, this.angle, this.color, this.alpha / 100,
            this.blurX, this.blurY, this.strength, this.quality,
            this.inner, this.knockout, this.hideObject
        );
    }

    /**
     * @return {array}
     */
    toParamArray ()
    {
        return [null,
            this.distance, this.angle, this.color, this.alpha / 100,
            this.blurX, this.blurY, this.strength, this.quality,
            this.inner, this.knockout, this.hideObject
        ];
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "distance": this.distance,
            "angle": this.angle,
            "color": this.color,
            "alpha": this.alpha / 100,
            "strength": this.strength,
            "inner": this.inner,
            "knockout": this.knockout,
            "hideObject": this.hideObject
        };
    }
}

/**
 * @class
 * @extends {Filter}
 */
class GlowFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        super(object);
        this.name = "GlowFilter";

        this._$color      = 0;
        this._$alpha      = 100;
        this._$strength   = 1;
        this._$inner      = false;
        this._$knockout   = false;

        if (object) {
            this.color      = object.color;
            this.alpha      = object.alpha * 100;
            this.strength   = object.strength;
            this.inner      = object.inner;
            this.knockout   = object.knockout;
        }
    }

    /**
     * @return {number}
     * @public
     */
    get color ()
    {
        return this._$color;
    }

    /**
     * @param  {number} color
     * @return {void}
     * @public
     */
    set color (color)
    {
        this._$color = +color;
    }

    /**
     * @return {number}
     * @public
     */
    get alpha ()
    {
        return this._$alpha;
    }

    /**
     * @param  {number} alpha
     * @return {void}
     * @public
     */
    set alpha (alpha)
    {
        this._$alpha = Util.$clamp(+alpha, 0, 100);
    }

    /**
     * @return {number}
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }

    /**
     * @param  {number} strength
     * @return {void}
     * @public
     */
    set strength (strength)
    {
        this._$strength = Util.$clamp(
            +strength,
            FilterController.MIN_STRENGTH,
            FilterController.MAX_STRENGTH
        );
    }

    /**
     * @return {boolean}
     * @public
     */
    get inner ()
    {
        return this._$inner;
    }

    /**
     * @param  {boolean} inner
     * @return {void}
     * @public
     */
    set inner (inner)
    {
        this._$inner = inner;
    }

    /**
     * @return {boolean}
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }

    /**
     * @param  {boolean} knockout
     * @return {void}
     * @public
     */
    set knockout (knockout)
    {
        this._$knockout = knockout;
    }

    /**
     * @param  {GlowFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$color !== filter._$color) {
            return false;
        }

        if (this._$alpha !== filter._$alpha) {
            return false;
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$inner !== filter._$inner) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @return {window.next2d.filters.GlowFilter}
     * @public
     */
    createInstance ()
    {
        return new window.next2d.filters.GlowFilter(
            this.color, this.alpha / 100, this.blurX, this.blurY,
            this.strength, this.quality, this.inner, this.knockout
        );
    }

    /**
     * @return {array}
     */
    toParamArray ()
    {
        return [null,
            this.color, this.alpha / 100, this.blurX, this.blurY,
            this.strength, this.quality, this.inner, this.knockout
        ];
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "color": this.color,
            "alpha": this.alpha / 100,
            "strength": this.strength,
            "inner": this.inner,
            "knockout": this.knockout
        };
    }
}

/**
 * @class
 * @extends {Filter}
 */
class GradientBevelFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        super(object);
        this.name = "GradientBevelFilter";

        this._$distance = 4;
        this._$angle    = 45;
        this._$colors   = [0xffffff, 0xff0000, 0];
        this._$alphas   = [100, 0, 100];
        this._$ratios   = [0, 128, 255];
        this._$strength = 1;
        this._$type     = "inner";
        this._$knockout = false;

        if (object) {
            this.distance = +object.distance;
            this.angle    = +object.angle;
            this.colors   = object.colors;
            this.alphas   = object.alphas;
            this.ratios   = object.ratios;
            this.strength = +object.strength;
            this.type     = object.type;
            this.knockout = object.knockout;
        }
    }

    /**
     * @return {number}
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }

    /**
     * @param  {number} distance
     * @return {void}
     * @public
     */
    set distance (distance)
    {
        this._$distance = Util.$clamp(
            +distance,
            FilterController.MIN_DISTANCE,
            FilterController.MAX_DISTANCE
        );
    }

    /**
     * @return {number}
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }

    /**
     * @param  {number} angle
     * @return {void}
     * @public
     */
    set angle (angle)
    {
        this._$angle = +angle % 360;
    }

    /**
     * @return {array}
     * @public
     */
    get colors ()
    {
        return this._$colors;
    }

    /**
     * @param  {array} colors
     * @return {void}
     * @public
     */
    set colors (colors)
    {
        this._$colors.length = 0;
        this._$colors = colors;
    }

    /**
     * @return {array}
     * @public
     */
    get alphas ()
    {
        return this._$alphas;
    }

    /**
     * @param  {array} alphas
     * @return {void}
     * @public
     */
    set alphas (alphas)
    {
        this._$alphas.length = 0;
        for (let idx = 0; idx < alphas.length; ++idx) {
            this._$alphas.push(alphas[idx] * 100);
        }
    }

    /**
     * @return {array}
     * @public
     */
    get ratios ()
    {
        return this._$ratios;
    }

    /**
     * @param  {array} ratios
     * @return {void}
     * @public
     */
    set ratios (ratios)
    {
        this._$ratios.length = 0;
        for (let idx = 0; idx < ratios.length; ++idx) {
            this._$ratios.push(ratios[idx] * 255);
        }
    }

    /**
     * @return {number}
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }

    /**
     * @param  {number} strength
     * @return {void}
     * @public
     */
    set strength (strength)
    {
        this._$strength = Util.$clamp(
            +strength,
            FilterController.MIN_STRENGTH,
            FilterController.MAX_STRENGTH
        );
    }

    /**
     * @return {string}
     * @public
     */
    get type ()
    {
        return this._$type;
    }

    /**
     * @param  {string} type
     * @return {void}
     * @public
     */
    set type (type)
    {
        this._$type = type;
    }

    /**
     * @return {boolean}
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }

    /**
     * @param  {boolean} knockout
     * @return {void}
     * @public
     */
    set knockout (knockout)
    {
        this._$knockout = knockout;
    }

    /**
     * @return {object}
     * @public
     */
    adjustment ()
    {
        const ratios = [];
        const colors = [];
        const alphas = [];

        const ratioMap = new Map();
        for (let idx = 0; idx < this._$ratios.length; ++idx) {

            const ratio = this._$ratios[idx] / 255;

            ratios.push(ratio);
            ratioMap.set(ratio, idx);
        }

        ratios.sort(function (a, b)
        {
            switch (true) {

                case a > b:
                    return 1;

                case a < b:
                    return -1;

                default:
                    return 0;

            }
        });

        for (let idx = 0; idx < ratios.length; ++idx) {

            const index = ratioMap.get(ratios[idx]);

            colors.push(this._$colors[index]);
            alphas.push(this._$alphas[index] / 100);
        }

        return {
            "ratios": ratios,
            "colors": colors,
            "alphas": alphas
        };
    }

    /**
     * @param  {GradientBevelFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        for (let idx = 0; idx < this._$colors.length; ++idx) {
            if (this._$colors[idx] !== filter._$colors[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$alphas.length; ++idx) {
            if (this._$alphas[idx] !== filter._$alphas[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$ratios.length; ++idx) {
            if (this._$ratios[idx] !== filter._$ratios[idx]) {
                return false;
            }
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$type !== filter._$type) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @return {window.next2d.filters.GradientBevelFilter}
     * @public
     */
    createInstance ()
    {
        const object = this.adjustment();
        return new window.next2d.filters.GradientBevelFilter(
            this.distance, this.angle, object.colors, object.alphas,
            object.ratios, this.blurX, this.blurY, this.strength,
            this.quality, this.type, this.knockout
        );
    }

    /**
     * @return {array}
     */
    toParamArray ()
    {
        const object = this.adjustment();
        return [null,
            this.distance, this.angle, object.colors, object.alphas,
            object.ratios, this.blurX, this.blurY, this.strength,
            this.quality, this.type, this.knockout
        ];
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        const object = this.adjustment();
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "distance": this.distance,
            "angle": this.angle,
            "colors": object.colors,
            "alphas": object.alphas,
            "ratios": object.ratios,
            "strength": this.strength,
            "type": this.type,
            "knockout": this.knockout
        };
    }
}

/**
 * @class
 * @extends {Filter}
 */
class GradientGlowFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     */
    constructor (object = null)
    {
        super(object);
        this.name = "GradientGlowFilter";

        this._$distance = 4;
        this._$angle    = 45;
        this._$colors   = [0xffffff, 0];
        this._$alphas   = [0, 100];
        this._$ratios   = [0, 255];
        this._$strength = 1;
        this._$type     = "outer";
        this._$knockout = false;

        if (object) {
            this.distance = +object.distance;
            this.angle    = +object.angle;
            this.colors   = object.colors;
            this.alphas   = object.alphas;
            this.ratios   = object.ratios;
            this.strength = +object.strength;
            this.type     = object.type;
            this.knockout = object.knockout;
        }
    }

    /**
     * @return {number}
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }

    /**
     * @param  {number} distance
     * @return {void}
     * @public
     */
    set distance (distance)
    {
        this._$distance = Util.$clamp(
            +distance,
            FilterController.MIN_DISTANCE,
            FilterController.MAX_DISTANCE
        );
    }

    /**
     * @return {number}
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }

    /**
     * @param  {number} angle
     * @return {void}
     * @public
     */
    set angle (angle)
    {
        this._$angle = +angle % 360;
    }

    /**
     * @return {array}
     * @public
     */
    get colors ()
    {
        return this._$colors;
    }

    /**
     * @param  {array} colors
     * @return {void}
     * @public
     */
    set colors (colors)
    {
        this._$colors.length = 0;
        this._$colors = colors;
    }

    /**
     * @return {array}
     * @public
     */
    get alphas ()
    {
        return this._$alphas;
    }

    /**
     * @param  {array} alphas
     * @return {void}
     * @public
     */
    set alphas (alphas)
    {
        this._$alphas.length = 0;
        for (let idx = 0; idx < alphas.length; ++idx) {
            this._$alphas.push(alphas[idx] * 100);
        }
    }

    /**
     * @return {array}
     * @public
     */
    get ratios ()
    {
        return this._$ratios;
    }

    /**
     * @param  {array} ratios
     * @return {void}
     * @public
     */
    set ratios (ratios)
    {
        this._$ratios.length = 0;
        for (let idx = 0; idx < ratios.length; ++idx) {
            this._$ratios.push(ratios[idx] * 255);
        }
    }

    /**
     * @return {number}
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }

    /**
     * @param  {number} strength
     * @return {void}
     * @public
     */
    set strength (strength)
    {
        this._$strength = Util.$clamp(
            +strength,
            FilterController.MIN_STRENGTH,
            FilterController.MAX_STRENGTH
        );
    }

    /**
     * @return {string}
     * @public
     */
    get type ()
    {
        return this._$type;
    }

    /**
     * @param  {string} type
     * @return {void}
     * @public
     */
    set type (type)
    {
        this._$type = type;
    }

    /**
     * @return {boolean}
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }

    /**
     * @param  {boolean} knockout
     * @return {void}
     * @public
     */
    set knockout (knockout)
    {
        this._$knockout = knockout;
    }

    /**
     * @return {object}
     * @public
     */
    adjustment ()
    {
        const ratios = [];
        const colors = [];
        const alphas = [];

        const ratioMap = new Map();
        for (let idx = 0; idx < this._$ratios.length; ++idx) {

            const ratio = this._$ratios[idx] / 255;

            ratios.push(ratio);
            ratioMap.set(ratio, idx);
        }

        ratios.sort(function (a, b)
        {
            switch (true) {

                case a > b:
                    return 1;

                case a < b:
                    return -1;

                default:
                    return 0;

            }
        });

        for (let idx = 0; idx < ratios.length; ++idx) {

            const index = ratioMap.get(ratios[idx]);

            colors.push(this._$colors[index]);
            alphas.push(this._$alphas[index] / 100);
        }

        return {
            "ratios": ratios,
            "colors": colors,
            "alphas": alphas
        };
    }

    /**
     * @param  {GradientGlowFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        for (let idx = 0; idx < this._$colors.length; ++idx) {
            if (this._$colors[idx] !== filter._$colors[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$alphas.length; ++idx) {
            if (this._$alphas[idx] !== filter._$alphas[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$ratios.length; ++idx) {
            if (this._$ratios[idx] !== filter._$ratios[idx]) {
                return false;
            }
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$type !== filter._$type) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @return {window.next2d.filters.GradientGlowFilter}
     * @public
     */
    createInstance ()
    {
        const object = this.adjustment();
        return new window.next2d.filters.GradientGlowFilter(
            this.distance, this.angle, object.colors, object.alphas,
            object.ratios, this.blurX, this.blurY, this.strength,
            this.quality, this.type, this.knockout
        );
    }

    /**
     * @return {array}
     */
    toParamArray ()
    {
        const object = this.adjustment();
        return [null,
            this.distance, this.angle, object.colors, object.alphas,
            object.ratios, this.blurX, this.blurY, this.strength,
            this.quality, this.type, this.knockout
        ];
    }

    /**
     * @return {object}
     * @public
     */
    toObject ()
    {
        const object = this.adjustment();
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "distance": this.distance,
            "angle": this.angle,
            "colors": object.colors,
            "alphas": object.alphas,
            "ratios": object.ratios,
            "strength": this.strength,
            "type": this.type,
            "knockout": this.knockout
        };
    }
}

/**
 * @class
 */
class ByteStream
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        this._$buffer     = null;
        this._$bitOffset  = 0;
        this._$byteOffset = 0;
    }

    /**
     * @param   {Uint8Array} data
     * @returns {void}
     */
    setData (data)
    {
        this._$buffer = data;
    }

    /**
     * @param   {number} length
     * @returns {Uint8Array}
     */
    getData (length)
    {
        this.byteAlign();

        const offset = this._$byteOffset + length;
        const array  = this._$buffer.slice(this._$byteOffset, offset);

        this._$byteOffset = offset;

        return array;
    }

    /**
     * @returns {string}
     */
    getHeaderSignature ()
    {
        let signature = "";

        let count = 3;
        while (count) {

            const code = this.getUI8();
            switch (code) {

                // trim
                case 32:
                case 96:
                case 127:
                    continue;

                default:
                    break;

            }

            signature += String.fromCharCode(code);

            --count;

        }

        return signature;
    }

    /**
     * @returns {number}
     */
    getVersion ()
    {
        return this.getUI8();
    }

    /**
     * @returns void
     */
    byteAlign ()
    {
        if (!this._$bitOffset) {
            return;
        }

        this._$byteOffset = this._$byteOffset + (this._$bitOffset + 7) / 8 | 0;
        this._$bitOffset  = 0;
    }

    /**
     * @returns void
     */
    byteCarry ()
    {
        if (this._$bitOffset > 7) {
            this._$byteOffset  = this._$byteOffset + (0 | (this._$bitOffset + 7) / 8);
            this._$bitOffset  &= 0x07;
        } else {
            while (this._$bitOffset < 0) {
                --this._$byteOffset;
                this._$bitOffset += 8;
            }
        }
    }

    /**
     * @param   {number} number
     * @returns {number}
     */
    getUIBits (number)
    {
        let value = 0;
        while (number) {

            value <<= 1;
            value |= this.getUIBit();

            --number;
        }
        return value;
    }

    /**
     * @returns {number}
     */
    getUIBit ()
    {
        this.byteCarry();
        return this._$buffer[this._$byteOffset] >> 7 - this._$bitOffset++ & 0x1;
    }

    /**
     * @param   {number} number
     * @returns {number}
     */
    getSIBits (number)
    {
        const value = this.getUIBits(number);
        const msb   = value & 0x1 << number - 1;
        if (msb) {
            return -(value ^ 2 * msb - 1) - 1;
        }
        return value;
    }

    /**
     * @returns {number}
     */
    getUI8 ()
    {
        this.byteAlign();
        return this._$buffer[this._$byteOffset++];
    }

    /**
     * @returns {number}
     */
    getUI16 ()
    {
        this.byteAlign();
        return this.getUI8() | this.getUI8() << 8;
    }

    /**
     * @returns {number}
     */
    getUI32 ()
    {
        this.byteAlign();
        return this.getUI8() | (this.getUI8()
            | (this.getUI8() | this.getUI8() << 8) << 8) << 8;
    }
}
/**
 * @class
 */
class ReComposition
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$folderId = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$libraryId = 0;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$fileName = "";

        /**
         * @type {ByteStream}
         * @private
         */
        this._$byteStream = new ByteStream();

        /**
         * @type {object}
         * @private
         */
        this._$bounds = {
            "xMin": 0,
            "xMax": 0,
            "yMin": 0,
            "yMax": 0
        };

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$swfVersion = 0;

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$info = null;

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$buildData = null;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$fileSize = 0;

        /**
         * @type {string}
         * @default "swf"
         * @private
         */
        this._$mode = "swf";

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$offset = 0;
    }

    /**
     * @return {string}
     * @public
     */
    get mode ()
    {
        return this._$mode;
    }

    /**
     * @return {number}
     * @public
     */
    get fileSize ()
    {
        return this._$fileSize;
    }

    /**
     * @param  {Uint8Array} buffer
     * @return {ReComposition}
     * @public
     */
    setData (buffer)
    {
        this._$byteStream.setData(buffer);
        return this;
    }

    /**
     * @param  {string} file_name
     * @param  {number} [folder_id=0]
     * @param  {number} [library_id=0]
     * @return {void}
     * @public
     */
    run (file_name, folder_id = 0, library_id = 0)
    {
        this._$fileName  = file_name.replace(".swf", "");
        this._$folderId  = folder_id;
        this._$libraryId = library_id;

        // signature
        const signature = this._$byteStream.getHeaderSignature();

        // version
        this._$byteStream.getVersion();

        // file size
        this._$fileSize = this._$byteStream.getUI32();
        this._$mode     = "swf";
        switch (signature) {

            // No ZIP
            case "FWS":
                return this.parseAndBuild();

            // ZLIB
            case "CWS":
                {
                    if (Util.$unzipWorkerActive) {
                        Util.$unzipQueues.push(this);
                        return ;
                    }

                    // start worker
                    Util.$unzipWorkerActive = true;

                    if (!Util.$unzipWorker) {
                        Util.$unzipWorker = new Worker(Util.$unzipURL);
                    }

                    const worker = Util.$unzipWorker;

                    // set message event
                    worker.onmessage = Util.$unzipHandler.bind(this);

                    const data = this._$byteStream._$buffer;
                    worker.postMessage({
                        "fileSize": this._$fileSize,
                        "mode":     this._$mode,
                        "buffer":   data
                    }, [data.buffer]);
                }

                break;

            // LZMA
            case "ZWS":
                {
                    if (Util.$unlzmaWorkerActive) {
                        Util.$unlzmaQueues.push(this);
                        return ;
                    }

                    // start worker
                    Util.$unlzmaWorkerActive = true;

                    const worker = new Worker(Util.$unlzmaWorkerURL);

                    // set message event
                    worker.onmessage = Util.$unlzmaHandler.bind(this);

                    const data = this._$byteStream._$buffer;
                    worker.postMessage({
                        "fileSize": this._$fileSize,
                        "mode":     this._$mode,
                        "buffer":   data
                    }, [data.buffer]);
                }

                break;

            // error
            default:
                throw new Error("this data is not swf.");

        }

    }

    /**
     * @returns void
     * @public
     */
    parseAndBuild ()
    {
        // set stage bounds
        this._$byteStream.byteAlign();

        const nBits = this._$byteStream.getUIBits(5);
        this._$bounds.xMin = this._$byteStream.getSIBits(nBits);
        this._$bounds.xMax = this._$byteStream.getSIBits(nBits);
        this._$bounds.yMin = this._$byteStream.getSIBits(nBits);
        this._$bounds.yMax = this._$byteStream.getSIBits(nBits);

        this._$byteStream.getUI16(); // frameRate
        this._$byteStream.getUI16(); // frameCount

        // current offset
        this._$offset = this._$byteStream._$byteOffset;

        if (Util.$parserWorkerWait) {
            Util.$parserQueues.push(this);
            return ;
        }

        Util.$parserWorkerWait = true;

        if (!Util.$parserWorker) {
            Util.$parserWorker = new Worker(Util.$parserURL);
        }

        Util.$parserWorker.onmessage = Util.$parserHandler.bind(this);

        const buffer = this._$byteStream._$buffer;
        Util.$parserWorker.postMessage({
            "version": this._$swfVersion,
            "offset":  this._$offset,
            "buffer":  buffer
        }, [buffer.buffer]);

    }

    /**
     * @return {MovieClip|DisplayObject}
     * @public
     */
    build ()
    {

        // setup
        const info   = this.buildData.info;
        const object = this.buildData.parent;

        this.loaderInfo._$bytes._$byteArray   = this.buildData.buffer;
        this.loaderInfo._$actionScriptVersion = info._$asv;

        // symbol copy and build
        let isMain = false;
        let length = this.loaderInfo._$symbols.length;
        if (length) {

            const applicationDomain = this.loaderInfo._$applicationDomain;
            const symbols   = Util.$getArray();
            for (let idx = 0; idx < length; ++idx) {

                const symbol = this.loaderInfo._$symbols[idx];

                const id = symbol.tagId;
                if (id === 0) {
                    isMain = true;
                }

                switch (true) {

                    case id in this.loaderInfo._$characters:
                    case this.loaderInfo._$fonts.has(id):
                        {

                            const instance = Util.$getPackage(applicationDomain, symbol.path);
                            if (instance._$loaderInfoId === this.loaderInfo._$id
                                || !("__$$characterId" in instance.prototype)
                            ) {

                                instance.prototype.__$$characterId  = id;
                                instance.prototype.__$$loaderInfoId = this.loaderInfo._$id;

                                const slots = instance.__$$slots;

                                const names  = Util.$Object.keys(slots);
                                const length = names.length;
                                for (let idx = 0; idx < length; ++idx) {

                                    const slot = slots[names[idx]];

                                    if (!slot.__$$classInit) {
                                        continue;
                                    }

                                    slot.__$$classInit();
                                }

                                Util.$poolArray(names);

                            }

                        }
                        break;

                    default:
                        break;

                }

                symbols[id] = symbol.path;
            }

            // set new symbol
            this.loaderInfo._$symbols = symbols;

        }

        // create main
        if (isMain) {

            const main = Util.$buildAVM2(
                this.loaderInfo._$applicationDomain,
                this.loaderInfo._$symbols[0]
            );
            main._$root = main;
            main._$symbolBuild(0, this.loaderInfo._$id, object);

            // init set
            this.loaderInfo._$content = main;

        } else {

            MovieClip._$targetBuild(this.loaderInfo._$content, object);
            this.loaderInfo._$content._$characterBuild();

        }

        // init scenes
        length = info._$sceneInfo.length;
        if (length) {

            const scenes = Util.$getArray();
            for (let idx = 0; idx < length; ++idx) {

                const sceneInfo = info._$sceneInfo[idx];

                // create Scene
                const scene    = new Scene(sceneInfo.name, Util.$getArray(), 1);
                scene._$offset = sceneInfo.offset;

                // set numFrames
                const next = idx + 1 | 0;

                let offset = this.loaderInfo._$content._$totalFrames;
                if (next in info._$sceneInfo) {
                    offset = info._$sceneInfo[next].offset | 0;
                }
                scene._$numFrames = offset - scene._$offset | 0;

                // set labels
                const labels = this.loaderInfo._$content.currentLabels;
                if (labels) {
                    const total  = labels.length;
                    const sceneLabels = Util.$getArray();
                    for (let idx = 0; idx < total; ++idx) {

                        const label = labels[idx];

                        if (label.frame > sceneInfo.offset && label.frame <= offset) {
                            sceneLabels[sceneLabels.length] = label;
                        }

                    }
                    scene._$labels = sceneLabels;
                }

                // set array
                scenes[scenes.length] = scene;

            }

            this.loaderInfo._$content._$scenes = scenes;
        }
    }
}

/**
 * @class
 */
class SVGToShape
{
    /**
     * @param  {string} value
     * @param  {MovieClip} movie_clip
     * @return {void}
     * @method
     * @static
     */
    static parse (value, movie_clip)
    {
        const defs  = /<defs>(.*)<\/defs>/sgi.exec(value);
        const paths = SVGToShape.parseXML(
            `${value.replace(/<defs>(.*)<\/defs>/sgi, "")}`
        );

        if (paths) {

            SVGToShape.parsePath(paths, movie_clip, defs ? defs[1] : null);

            const layers = [];
            for (const layer of movie_clip._$layers.values()) {
                layers.unshift(layer);
            }

            movie_clip.clearLayer();
            for (let idx = 0; idx < layers.length; ++idx) {
                movie_clip.setLayer(idx, layers[idx]);
            }
        }
    }

    /**
     * @param  {string} xml
     * @return {array}
     * @method
     * @static
     */
    static parseXML (xml)
    {
        const pathReg = /<((path|rect|circle|polygon).+?)\/>/gi;

        const paths = [];
        for (let reg = "1"; reg;) {
            reg = pathReg.exec(xml);
            reg && paths.push(reg[1]);
        }

        return paths;
    }

    /**
     * @param  {array}     paths
     * @param  {MovieClip} movie_clip
     * @param  {string}    [defs=null]
     * @method
     * @static
     */
    static parsePath (paths, movie_clip, defs = null)
    {
        const { Shape, Graphics } = window.next2d.display;
        const workSpace = Util.$currentWorkSpace();

        for (let idx = 0; idx < paths.length; ++idx) {

            const graphics = new Shape().graphics;

            const value = paths[idx];

            // STROKE
            let strokeWidth = /stroke-width=\"(.+?)\"/gi.exec(value);
            if (!strokeWidth) {
                strokeWidth = /stroke-width:(.+?)["|;]/gi.exec(value);
            }

            if (strokeWidth) {
                strokeWidth = +strokeWidth[1];
                if (strokeWidth) {
                    let color = /stroke=\"(.+?)\"/gi.exec(value);
                    if (!color) {
                        color = /stroke:(.+?)["|;]/gi.exec(value);
                    }

                    graphics.lineStyle(strokeWidth, color ? color[1] : 0);
                }
            }

            // FILL
            let color = /fill=\"(.+?)\"/gi.exec(value);
            if (!color) {
                color = /fill:(.+?)["|;]/gi.exec(value);
            }

            let alpha = 1;
            let style = /style=\"(.+?)\"/gi.exec(value);
            if (style && style[1].indexOf("opacity") > -1) {
                alpha = style[1].split(":")[1];
            }

            if (color) {
                graphics.beginFill(color[1], +alpha);
            } else {
                if (!strokeWidth) {
                    graphics.beginFill(0, +alpha);
                }
            }

            const id = workSpace.nextLibraryId;

            const shape = workSpace.addLibrary(
                Util
                    .$libraryController
                    .createInstance("shape", `Shape_${id}`, id)
            );

            const layer = new Layer();
            layer.name  = `Layer_${movie_clip._$layers.size}`;

            movie_clip.setLayer(movie_clip._$layers.size, layer);

            const character = new Character();
            character.libraryId  = shape.id;

            const location = layer.adjustmentLocation(1);
            character.startFrame = location.startFrame;
            character.endFrame   = location.endFrame;

            character.setPlace(location.startFrame, {
                "frame": location.startFrame,
                "matrix": [1, 0, 0, 1, 0, 0],
                "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                "blendMode": "normal",
                "filter": [],
                "depth": layer._$characters.length
            });
            layer.addCharacter(character);

            // draw rect
            if (value.indexOf("rect") > -1) {

                const param  = value.replace("rect", "");
                const x      = +/x=\"(.+?)\"/gi.exec(param)[1];
                const y      = +/y=\"(.+?)\"/gi.exec(param)[1];
                const width  = +/width=\"(.+?)\"/gi.exec(param)[1];
                const height = +/height=\"(.+?)\"/gi.exec(param)[1];
                const rx     = +/rx=\"(.+?)\"/gi.exec(param)[1];

                graphics
                    .drawRoundRect(x, y, width, height, rx * 2)
                    .endFill();

                shape._$recodes = graphics._$recode.slice();
                shape._$bounds = {
                    "xMin": graphics._$xMin,
                    "xMax": graphics._$xMax,
                    "yMin": graphics._$yMin,
                    "yMax": graphics._$yMax
                };

                continue;
            }

            if (value.indexOf("circle") > -1) {

                const param = value.replace("rect", "");
                const x     = +/cx=\"(.+?)\"/gi.exec(param)[1];
                const y     = +/cy=\"(.+?)\"/gi.exec(param)[1];
                const r     = +/r=\"(.+?)\"/gi.exec(param)[1];

                graphics
                    .drawCircle(x, y, r)
                    .endFill();

                shape._$recodes = graphics._$recode.slice();
                shape._$bounds = {
                    "xMin": graphics._$xMin,
                    "xMax": graphics._$xMax,
                    "yMin": graphics._$yMin,
                    "yMax": graphics._$yMax
                };

                continue;
            }

            if (value.indexOf("polygon") > -1) {

                const path = value.replace("polygon", "");

                let points = /points=\"(.+?)\"/gi.exec(path)[1];

                points = points.replace(/,/g, " ");
                points = points.replace(/-/g, " -");
                points = points.trim().split(" ");
                points = SVGToShape._$adjParam(points);

                graphics.moveTo(+points[0], +points[1]);
                for (let idx = 2; idx < points.length; idx += 2) {
                    graphics.lineTo(
                        +points[idx    ],
                        +points[idx + 1]
                    );
                }
                graphics.endFill();

                shape._$recodes = graphics._$recode.slice();
                shape._$bounds = {
                    "xMin": graphics._$xMin,
                    "xMax": graphics._$xMax,
                    "yMin": graphics._$yMin,
                    "yMax": graphics._$yMax
                };

                continue;
            }

            let start   = false;
            let startX  = 0;
            let startY  = 0;

            const currentPoint = [0, 0];
            const lastControl  = [0, 0];
            const actionReg = /([a-z])([^a-z]*)/gi;

            const d = / d=\"(.+?)\"/gi.exec(value)[1];
            for (let reg = "1"; reg;) {

                // TODO transform
                // let tx = 0;
                // let ty = 0;
                // if (value.indexOf("translate") > -1) {
                //
                //     let translate = /translate\((.+?)\)/gi.exec(value)[1];
                //     translate = translate.replace(/,/g, " ");
                //     translate = translate.replace(/-/g, " -");
                //     translate = translate.trim().split(" ");
                //     translate = SVGToShape._$adjParam(translate);
                //
                //     const param = [];
                //     for (let idx = 0; idx < translate.length; ++idx) {
                //
                //         const value = translate[idx];
                //         if (value === "") {
                //             continue;
                //         }
                //
                //         param.push(+value);
                //     }
                //
                //     tx = param[0];
                //     ty = param[1];
                // }

                reg = actionReg.exec(d);
                if (reg) {

                    const type = `${reg[1]}`;

                    let param = reg[2];
                    switch (type) {

                        case "m":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            currentPoint[0] += +param[0];
                            currentPoint[1] += +param[1];

                            if (!start) {
                                start = true;
                                startX = currentPoint[0];
                                startY = currentPoint[1];
                            }

                            graphics.moveTo(
                                currentPoint[0],
                                currentPoint[1]
                            );

                            for (let idx = 2; idx < param.length; idx += 2) {
                                currentPoint[0] += +param[idx    ];
                                currentPoint[1] += +param[idx + 1];
                                lastControl[0]   = currentPoint[0];
                                lastControl[1]   = currentPoint[1];
                                graphics.lineTo(
                                    currentPoint[0],
                                    currentPoint[1]
                                );
                            }
                            break;

                        case "M":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            currentPoint[0] = +param[0];
                            currentPoint[1] = +param[1];

                            if (!start) {
                                start = true;
                                startX = currentPoint[0];
                                startY = currentPoint[1];
                            }

                            graphics.moveTo(
                                currentPoint[0],
                                currentPoint[1]
                            );

                            for (let idx = 2; idx < param.length; idx += 2) {
                                currentPoint[0] = +param[idx    ];
                                currentPoint[1] = +param[idx + 1];
                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                                graphics.lineTo(
                                    currentPoint[0],
                                    currentPoint[1]
                                );
                            }
                            break;

                        case "l":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 2) {
                                currentPoint[0] += +param[idx    ];
                                currentPoint[1] += +param[idx + 1];
                                lastControl[0]   = currentPoint[0];
                                lastControl[1]   = currentPoint[1];
                                graphics.lineTo(
                                    currentPoint[0],
                                    currentPoint[1]
                                );
                            }
                            break;

                        case "L":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 2) {
                                currentPoint[0] = +param[idx    ];
                                currentPoint[1] = +param[idx + 1];
                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                                graphics.lineTo(
                                    currentPoint[0],
                                    currentPoint[1]
                                );
                            }
                            break;

                        case "h":
                            currentPoint[0] += +param;
                            lastControl[0]   = currentPoint[0];
                            graphics.lineTo(
                                currentPoint[0],
                                currentPoint[1]
                            );
                            break;

                        case "H":
                            currentPoint[0] = +param;
                            lastControl[0]  = currentPoint[0];
                            graphics.lineTo(
                                currentPoint[0],
                                currentPoint[1]
                            );
                            break;

                        case "v":
                            currentPoint[1] += +param;
                            lastControl[1]   = currentPoint[1];
                            graphics.lineTo(
                                currentPoint[0],
                                currentPoint[1]
                            );
                            break;

                        case "V":
                            currentPoint[1] = +param;
                            lastControl[1]  = currentPoint[1];
                            graphics.lineTo(currentPoint[0], currentPoint[1]);
                            break;

                        case "q":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 4) {

                                param[idx    ] = +param[idx    ] + currentPoint[0];
                                param[idx + 1] = +param[idx + 1] + currentPoint[1];
                                param[idx + 2] = +param[idx + 2] + currentPoint[0];
                                param[idx + 3] = +param[idx + 3] + currentPoint[1];

                                graphics.curveTo(
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2], param[idx + 3]
                                );

                                currentPoint[0] = param[idx + 2];
                                currentPoint[1] = param[idx + 3];

                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                            }
                            break;

                        case "Q":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 4) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];

                                graphics.curveTo(
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2], param[idx + 3]
                                );

                                currentPoint[0] = param[idx + 2];
                                currentPoint[1] = param[idx + 3];

                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                            }
                            break;

                        case "c":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 6) {

                                param[idx    ] = +param[idx    ] + currentPoint[0];
                                param[idx + 1] = +param[idx + 1] + currentPoint[1];
                                param[idx + 2] = +param[idx + 2] + currentPoint[0];
                                param[idx + 3] = +param[idx + 3] + currentPoint[1];
                                param[idx + 4] = +param[idx + 4] + currentPoint[0];
                                param[idx + 5] = +param[idx + 5] + currentPoint[1];

                                graphics.cubicCurveTo(
                                    param[idx    ], param[idx + 1], param[idx + 2],
                                    param[idx + 3], param[idx + 4], param[idx + 5]
                                );

                                currentPoint[0] = param[idx + 4];
                                currentPoint[1] = param[idx + 5];

                                lastControl[0] = 2 * param[idx + 4] - param[idx + 2];
                                lastControl[1] = 2 * param[idx + 5] - param[idx + 3];
                            }

                            break;

                        case "C":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 6) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];
                                param[idx + 4] = +param[idx + 4];
                                param[idx + 5] = +param[idx + 5];

                                graphics.cubicCurveTo(
                                    param[idx    ], param[idx + 1], param[idx + 2],
                                    param[idx + 3], param[idx + 4], param[idx + 5]
                                );

                                currentPoint[0] = param[idx + 4];
                                currentPoint[1] = param[idx + 5];

                                lastControl[0] = 2 * param[idx + 4] - param[idx + 2];
                                lastControl[1] = 2 * param[idx + 5] - param[idx + 3];

                            }
                            break;

                        case "s":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 4) {

                                param[idx    ] = +param[idx    ] + currentPoint[0];
                                param[idx + 1] = +param[idx + 1] + currentPoint[1];
                                param[idx + 2] = +param[idx + 2] + currentPoint[0];
                                param[idx + 3] = +param[idx + 3] + currentPoint[1];

                                graphics.cubicCurveTo(
                                    lastControl[0], lastControl[1],
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2], param[idx + 3]
                                );

                                currentPoint[0] = param[idx + 2];
                                currentPoint[1] = param[idx + 3];

                                lastControl[0] = 2 * param[idx + 2] - param[idx    ];
                                lastControl[1] = 2 * param[idx + 3] - param[idx + 1];
                            }

                            break;

                        case "S":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 4) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];

                                graphics.cubicCurveTo(
                                    lastControl[0], lastControl[1],
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2], param[idx + 3]
                                );

                                currentPoint[0] = param[idx + 2];
                                currentPoint[1] = param[idx + 3];

                                lastControl[0] = 2 * param[idx + 2] - param[idx    ];
                                lastControl[1] = 2 * param[idx + 3] - param[idx + 1];
                            }
                            break;

                        case "a":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 7) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];
                                param[idx + 4] = +param[idx + 4];
                                param[idx + 5] = +param[idx + 5] + currentPoint[0];
                                param[idx + 6] = +param[idx + 6] + currentPoint[1];

                                const curves = SVGToShape._$arcToCurve(
                                    currentPoint[0], currentPoint[1],
                                    param[idx + 5], param[idx + 6],
                                    param[idx + 3], param[idx + 4],
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2]
                                );

                                for (let idx = 0; idx < curves.length; ++idx) {
                                    const curve = curves[idx];
                                    graphics.cubicCurveTo(
                                        curve[0], curve[1],
                                        curve[2], curve[3],
                                        curve[4], curve[5]
                                    );
                                }

                                currentPoint[0] = param[idx + 5];
                                currentPoint[1] = param[idx + 6];

                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                            }

                            break;

                        case "A":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 7) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];
                                param[idx + 4] = +param[idx + 4];
                                param[idx + 5] = +param[idx + 5];
                                param[idx + 6] = +param[idx + 6];

                                const curves = SVGToShape._$arcToCurve(
                                    currentPoint[0], currentPoint[1],
                                    param[idx + 5], param[idx + 6],
                                    param[idx + 3], param[idx + 4],
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2]
                                );

                                for (let idx = 0; idx < curves.length; ++idx) {
                                    const curve = curves[idx];
                                    graphics.cubicCurveTo(
                                        curve[0], curve[1],
                                        curve[2], curve[3],
                                        curve[4], curve[5]
                                    );
                                }

                                currentPoint[0] = param[idx + 5];
                                currentPoint[1] = param[idx + 6];

                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                            }
                            break;

                        case "z":
                        case "Z":
                            if (graphics._$fills) {
                                graphics._$fills.push(Graphics.CLOSE_PATH);
                            }
                            if (graphics._$lines) {
                                graphics._$lines.push(Graphics.CLOSE_PATH);
                            }

                            currentPoint[0] = startX;
                            currentPoint[1] = startY;
                            lastControl[0]  = currentPoint[0];
                            lastControl[1]  = currentPoint[1];
                            start = false;
                            break;

                        default:
                            console.log("TODO: ", type, param);
                            break;

                    }
                }
            }
            graphics.endLine();
            graphics.endFill();

            if (graphics._$recode) {
                shape._$recodes = graphics._$recode.slice();
            }

            shape._$bounds = {
                "xMin": graphics._$xMin,
                "xMax": graphics._$xMax,
                "yMin": graphics._$yMin,
                "yMax": graphics._$yMax
            };
        }
    }

    /**
     * @param  {array} param
     * @return {array}
     * @private
     */
    static _$adjParam (param)
    {
        for (;;) {
            let count = 0;
            for (let idx = 0; idx < param.length; ++idx) {

                const value = param[idx];
                if (!isNaN(value)) {
                    count++;
                    continue;
                }

                const values = value.split(".");
                param.splice(idx + 1, 0, `0.${values.pop()}`);
                param[idx] = values.join(".");
            }

            if (param.length === count) {
                break;
            }
        }
        return param;
    }

    /**
     * @param {next2d.display.Graphics} graphics
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {number} start_ang
     * @param {number} end_ang
     * @private
     * @static
     */
    static _$arc (graphics, x, y, radius, start_ang, end_ang)
    {
        let num = Math.min(Math.ceil(radius * 2 + 1), 1024);
        if (num < 1) {
            return;
        }

        start_ang = start_ang === undefined
            ? 0
            : start_ang;

        end_ang = end_ang === undefined
            ? Math.PI * 2
            : end_ang;

        const delta = (end_ang - start_ang) / num;
        for (let idx = 0; idx <= num; idx++) {
            const f = start_ang + idx * delta;
            graphics.lineTo(x + Math.cos(f) * radius, y + Math.sin(f) * radius);
        }
    }

    /**
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} fa
     * @param {number} fs
     * @param {number} rx
     * @param {number} ry
     * @param {number} phi
     * @private
     * @static
     */
    static _$arcToCurve (x1, y1, x2, y2, fa, fs, rx, ry, phi)
    {
        const TAU = Math.PI * 2;
        const sin_phi = Math.sin(phi * TAU / 360);
        const cos_phi = Math.cos(phi * TAU / 360);

        const x1p = cos_phi  * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
        const y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;

        if (x1p === 0 && y1p === 0 || rx === 0 || ry === 0) {
            return [];
        }

        rx = Math.abs(rx);
        ry = Math.abs(ry);

        const lambda = x1p * x1p / (rx * rx) + y1p * y1p / (ry * ry);
        if (lambda > 1) {
            rx *= Math.sqrt(lambda);
            ry *= Math.sqrt(lambda);
        }

        const cc = SVGToShape._$getArcCenter(
            x1, y1, x2, y2, fa, fs,
            rx, ry, sin_phi, cos_phi
        );

        const result = [];
        let theta1 = cc[2];
        let delta_theta = cc[3];

        const segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);
        delta_theta /= segments;

        for (let idx = 0; idx < segments; idx++) {
            result.push(SVGToShape._$approximateUnitArc(theta1, delta_theta));
            theta1 += delta_theta;
        }

        return result.map((curve) =>
        {
            for (let idx = 0; idx < curve.length; idx += 2) {

                let x = curve[idx    ];
                let y = curve[idx + 1];

                // scale
                x *= rx;
                y *= ry;

                // rotate
                const xp = cos_phi * x - sin_phi * y;
                const yp = sin_phi * x + cos_phi * y;

                // translate
                curve[idx    ] = xp + cc[0];
                curve[idx + 1] = yp + cc[1];
            }

            curve.shift();
            curve.shift();

            return curve;
        });
    }

    /**
     * @param {number} theta1
     * @param {number} delta_theta
     * @return {array}
     * @private
     * @static
     */
    static _$approximateUnitArc (theta1, delta_theta)
    {
        const alpha = 4 / 3 * Math.tan(delta_theta / 4);

        const x1 = Math.cos(theta1);
        const y1 = Math.sin(theta1);
        const x2 = Math.cos(theta1 + delta_theta);
        const y2 = Math.sin(theta1 + delta_theta);

        return [
            x1, y1,
            x1 - y1 * alpha,
            y1 + x1 * alpha,
            x2 + y2 * alpha,
            y2 - x2 * alpha,
            x2, y2
        ];
    }

    /**
     *
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} fa
     * @param {number} fs
     * @param {number} rx
     * @param {number} ry
     * @param {number} sin_phi
     * @param {number} cos_phi
     * @return {array}
     * @private
     * @static
     */
    static _$getArcCenter (x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi)
    {
        const TAU = Math.PI * 2;

        const x1p = cos_phi  * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
        const y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;

        const rx_sq  = rx * rx;
        const ry_sq  = ry * ry;
        const x1p_sq = x1p * x1p;
        const y1p_sq = y1p * y1p;

        let radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;

        if (radicant < 0) {
            radicant = 0;
        }

        radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;
        radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);

        const cxp = radicant *  rx / ry * y1p;
        const cyp = radicant * -ry / rx * x1p;

        const cx = cos_phi * cxp - sin_phi * cyp + (x1 + x2) / 2;
        const cy = sin_phi * cxp + cos_phi * cyp + (y1 + y2) / 2;

        const v1x = (x1p - cxp)  / rx;
        const v1y = (y1p - cyp)  / ry;
        const v2x = (-x1p - cxp) / rx;
        const v2y = (-y1p - cyp) / ry;

        const theta1 = SVGToShape._$unitVectorAngle(1, 0, v1x, v1y);
        let delta_theta = SVGToShape._$unitVectorAngle(v1x, v1y, v2x, v2y);

        if (fs === 0 && delta_theta > 0) {
            delta_theta -= TAU;
        }
        if (fs === 1 && delta_theta < 0) {
            delta_theta += TAU;
        }

        return [cx, cy, theta1, delta_theta];
    }

    /**
     * @param  {number} ux
     * @param  {number} uy
     * @param  {number} vx
     * @param  {number} vy
     * @return {number}
     * @static
     * @private
     */
    static _$unitVectorAngle (ux, uy, vx, vy)
    {
        const sign = ux * vy - uy * vx < 0 ? -1 : 1;
        let dot = ux * vx + uy * vy;

        if (dot > 1.0) {
            dot = 1.0;
        }

        if (dot < -1.0) {
            dot = -1.0;
        }

        return sign * Math.acos(dot);
    }
}

/**
 * @class
 */
class VectorToCanvas
{
    /**
     * @param   {object} src
     * @returns {object}
     * @public
     */
    clone (src)
    {
        const execute = function (src, obj)
        {
            const keys   = Object.keys(src);
            const length = keys.length | 0;
            for (let idx = 0; idx < length; ++idx) {

                const prop  = keys[idx];
                const value = src[prop];

                switch (true) {

                    case Util.$isArray(value):
                        obj[prop] = [];
                        execute(value, obj[prop]);
                        break;

                    case typeof value === "object":
                        obj[prop] = {};
                        execute(value, obj[prop]);
                        break;

                    default:
                        obj[prop] = value;
                        break;

                }
            }
        };

        const obj = {};
        execute(src, obj);

        return obj;
    }

    /**
     * @param   {object}  shapes
     * @param   {boolean} [is_morph=false]
     * @returns {array}
     * @public
     */
    convert (shapes, is_morph = false)
    {
        let lineStyles = shapes.lineStyles;
        let fillStyles = shapes.fillStyles;
        let idx        = 0;
        let obj        = {};
        let cache      = [];
        let AnchorX    = 0;
        let AnchorY    = 0;
        let MoveX      = 0;
        let MoveY      = 0;
        let LineX      = 0;
        let LineY      = 0;
        let FillStyle0 = 0;
        let FillStyle1 = 0;
        let LineStyle  = 0;
        let fills0     = [];
        let fills1     = [];
        let lines      = [];
        let stack      = [];
        let depth      = 0;

        // setup
        const shapeData = shapes.ShapeData;
        const records   = shapeData.records;
        const newStyles = shapeData.styles;

        let i = 0;
        let s = 0;
        for (;;) {

            const state = records[i++];

            // end
            if (state === -1) {
                stack = this.setStack(stack, this.fillMerge(fills0, fills1, is_morph));
                stack = this.setStack(stack, lines);
                break;
            }

            // data change
            if (state) {

                ++depth;

                // StateNewStyles
                if (records[i++]) {

                    //  build data
                    stack   = this.setStack(stack, this.fillMerge(fills0, fills1, is_morph));
                    stack   = this.setStack(stack, lines);

                    // reset
                    AnchorX = 0;
                    AnchorY = 0;
                    fills0  = [];
                    fills1  = [];
                    lines   = [];

                    const styles = newStyles[s++];
                    if (records[i++]) {
                        fillStyles = styles.FillStyles;
                    }

                    if (records[i++]) {
                        lineStyles = styles.LineStyles;
                    }

                }

                // default
                MoveX = AnchorX;
                MoveY = AnchorY;

                // override
                if (records[i++]) {
                    MoveX = AnchorX = records[i++] / 20;
                    MoveY = AnchorX = records[i++] / 20;
                }

                LineX = MoveX;
                LineY = MoveY;

                // StateFillStyle0
                if (records[i++]) {
                    FillStyle0 = records[i++];
                }

                // StateFillStyle1
                if (records[i++]) {
                    FillStyle1 = records[i++];
                }

                // StateLineStyle
                if (records[i++]) {
                    LineStyle = records[i++];
                }

                continue;
            }

            const isCurved = records[i++];
            const ControlX = isCurved ? records[i++] / 20 : 0;
            const ControlY = isCurved ? records[i++] / 20 : 0;
            AnchorX        = records[i++] / 20;
            AnchorY        = records[i++] / 20;

            const record = {
                "isCurved": isCurved,
                "ControlX": ControlX,
                "ControlY": ControlY,
                "AnchorX":  AnchorX,
                "AnchorY":  AnchorY
            };

            // fill0
            if (FillStyle0) {

                idx = FillStyle0 - 1 | 0;
                if (!(idx in fills0)) {
                    fills0[idx] = [];
                }

                if (!(depth in fills0[idx])) {
                    fills0[idx][depth] = {
                        "obj":    fillStyles ? fillStyles[idx] : null,
                        "startX": MoveX,
                        "startY": MoveY,
                        "endX":   0,
                        "endY":   0,
                        "cache":  []
                    };
                }

                obj   = fills0[idx][depth];
                cache = obj.cache;
                cache[cache.length] = this.clone(record);

                obj.endX = AnchorX;
                obj.endY = AnchorY;
            }

            // fill1
            if (FillStyle1) {

                idx = FillStyle1 - 1 | 0;
                if (!(idx in fills1)) {
                    fills1[idx] = [];
                }

                if (!(depth in fills1[idx])) {
                    fills1[idx][depth] = {
                        "obj":    fillStyles ? fillStyles[idx] : null,
                        "startX": MoveX,
                        "startY": MoveY,
                        "endX":   0,
                        "endY":   0,
                        "cache":  []
                    };
                }

                obj   = fills1[idx][depth];
                cache = obj.cache;
                cache[cache.length] = this.clone(record);

                obj.endX = AnchorX;
                obj.endY = AnchorY;
            }

            // lines
            if (LineStyle) {

                idx = LineStyle - 1 | 0;
                if (!(idx in lines)) {
                    lines[idx] = {
                        "obj":   lineStyles ? lineStyles[idx] : null,
                        "cache": []
                    };
                }

                obj   = lines[idx];
                cache = obj.cache;
                cache[cache.length] = [0, LineX, LineY];

                let code = [2, AnchorX, AnchorY];
                if (isCurved) {
                    code = [1, ControlX, ControlY, AnchorX, AnchorY];
                }

                cache[cache.length] = code;
            }

            LineX = AnchorX;
            LineY = AnchorY;
        }

        return this.toGraphicPath(stack);
    }

    /**
     * @param  {array} stack
     * @return {array}
     * @public
     */
    toGraphicPath (stack)
    {
        const {
            Graphics,
            GradientType,
            InterpolationMethod,
            SpreadMethod,
            CapsStyle,
            JointStyle
        } = window.next2d.display;

        let inBitmap = false;
        const recodes = [];
        for (let idx = 0; idx < stack.length; ++idx) {

            const data = stack[idx];

            recodes.push(Graphics.BEGIN_PATH);

            for (let idx = 0; idx < data.recode.length; ++idx) {
                recodes.push.apply(recodes, data.recode[idx]);
            }

            const isStroke = "Width" in data.object;
            let lineWidth  = 0;
            let capsStyle  = CapsStyle.NONE;
            let miterLimit = 0;
            let jointStyle = JointStyle.ROUND;
            if (isStroke) {

                lineWidth = data.object.Width;

                switch (data.object.StartCapStyle) {

                    case 0:
                        capsStyle = CapsStyle.ROUND;
                        break;

                    case 1:
                        capsStyle = CapsStyle.NONE;
                        break;

                    case 2:
                        capsStyle = CapsStyle.SQUARE;
                        break;

                }

                switch (data.object.JoinStyle) {

                    case 0:
                        jointStyle = JointStyle.ROUND;
                        break;

                    case 1:
                        jointStyle = JointStyle.BEVEL;
                        break;

                    case 2:
                        jointStyle = JointStyle.MITER;
                        miterLimit = data.object.MiterLimitFactor;
                        break;

                }
            }

            const styleObject = data.object.HasFillFlag
                ? data.object.FillType
                : data.object;

            switch (styleObject.fillStyleType) {

                case 0x00: // solid fill

                    if (isStroke) {

                        recodes.push(
                            Graphics.STROKE_STYLE,
                            lineWidth,
                            capsStyle,
                            jointStyle,
                            miterLimit,
                            styleObject.Color.R,
                            styleObject.Color.G,
                            styleObject.Color.B,
                            styleObject.Color.A * 255,
                            Graphics.END_STROKE
                        );

                    } else {

                        recodes.push(
                            Graphics.FILL_STYLE,
                            styleObject.Color.R,
                            styleObject.Color.G,
                            styleObject.Color.B,
                            styleObject.Color.A * 255,
                            Graphics.END_FILL
                        );

                    }

                    break;

                case 0x10: // linear gradient fill
                case 0x12: // radial gradient fill
                case 0x13: // radial gradient fill
                    {
                        const gradient = styleObject.gradient;

                        const colorStops = [];
                        const gradientRecords = gradient.GradientRecords;
                        for (let idx = 0; idx < gradientRecords.length; ++idx) {
                            const recode = gradientRecords[idx];
                            colorStops.push({
                                "ratio": recode.Ratio,
                                "R": recode.Color.R,
                                "G": recode.Color.G,
                                "B": recode.Color.B,
                                "A": recode.Color.A * 255
                            });
                        }

                        const interpolationMode = gradient.InterpolationMode === 0
                            ? InterpolationMethod.RGB
                            : InterpolationMethod.LINEAR_RGB;

                        let spreadMode = SpreadMethod.PAD;
                        switch (gradient.SpreadMode) {

                            case 0:
                                spreadMode = SpreadMethod.PAD;
                                break;

                            case 1:
                                spreadMode = SpreadMethod.REFLECT;
                                break;

                            case 2:
                                spreadMode = SpreadMethod.REPEAT;
                                break;

                        }

                        if (isStroke) {

                            recodes.push(
                                Graphics.GRADIENT_STROKE,
                                lineWidth,
                                capsStyle,
                                jointStyle,
                                miterLimit,
                                styleObject.fillStyleType === 0x10
                                    ? GradientType.LINEAR
                                    : GradientType.RADIAL,
                                colorStops,
                                styleObject.gradientMatrix,
                                spreadMode,
                                interpolationMode,
                                gradient.FocalPoint
                            );

                        } else {

                            recodes.push(
                                Graphics.GRADIENT_FILL,
                                styleObject.fillStyleType === 0x10
                                    ? GradientType.LINEAR
                                    : GradientType.RADIAL,
                                colorStops,
                                styleObject.gradientMatrix,
                                spreadMode,
                                interpolationMode,
                                gradient.FocalPoint
                            );

                        }
                    }
                    break;

                case 0x40: // repeating bitmap fill
                case 0x41: // clipped bitmap fill
                case 0x42: // non-smoothed repeating bitmap fill
                case 0x43: // non-smoothed clipped bitmap fill
                    {
                        inBitmap = true;
                        const bitmap = Util
                            .$currentWorkSpace()
                            .getLibrary(
                                Util.$characters.get(styleObject.bitmapId)
                            );

                        // eslint-disable-next-line no-loop-func
                        const wait = function (recodes, style_object)
                        {
                            if (!this._$buffer) {
                                return requestAnimationFrame(wait);
                            }

                            const smooth =
                                style_object.fillStyleType === 0x40
                                || style_object.fillStyleType === 0x41;

                            const repeat =
                                style_object.fillStyleType === 0x40
                                || style_object.fillStyleType === 0x42;

                            const matrix = Util.$multiplicationMatrix(
                                style_object.bitmapMatrix,
                                [0.05, 0, 0, 0.05, 0, 0]
                            );

                            const { BitmapData } = window.next2d.display;
                            const bitmapData = new BitmapData(
                                this.width, this.height, true, 0
                            );
                            bitmapData._$buffer = this._$buffer;

                            recodes.push(
                                Graphics.BITMAP_FILL,
                                bitmapData,
                                Array.from(matrix),
                                repeat ? "repeat" : "no-repeat",
                                smooth
                            );

                        }.bind(bitmap, recodes, styleObject);
                        wait();
                    }
                    break;

                default:
                    break;

            }
        }

        recodes.push(inBitmap);
        return recodes;
    }

    /**
     * @param   {array}   fills0
     * @param   {array}   fills1
     * @param   {boolean} is_morph
     * @returns {array}
     * @public
     */
    fillMerge (fills0, fills1, is_morph)
    {
        fills0 = this.fillReverse(fills0);

        if (fills0.length) {

            const keys   = Object.keys(fills0);
            const length = keys.length | 0;
            for (let key = 0; key < length; ++key) {

                const idx   = keys[key];
                const fills = fills0[idx];

                if (idx in fills1) {

                    const fill1 = fills1[idx];
                    const fKeys = Object.keys(fills);
                    const kLen  = fKeys.length | 0;
                    for (let kIdx = 0; kIdx < kLen; ++kIdx) {
                        fill1[fill1.length] = fills[fKeys[kIdx]];
                    }

                } else {

                    fills1[idx] = fills;

                }
            }
        }

        return this.coordinateAdjustment(fills1, is_morph);
    }

    /**
     * @param   {array} fills0
     * @returns {array}
     * @public
     */
    fillReverse (fills0)
    {
        if (!fills0.length) {
            return fills0;
        }

        const f0Keys = Object.keys(fills0);
        const f0Len  = f0Keys.length | 0;
        for (let f0Idx = 0; f0Idx < f0Len; ++f0Idx) {

            const i     = f0Keys[f0Idx];
            const fills = fills0[i];
            const fKeys = Object.keys(fills);
            const fLen  = fKeys.length | 0;
            for (let fIdx = 0; fIdx < fLen; ++fIdx) {

                const depth   = fKeys[fIdx];

                let AnchorX = 0;
                let AnchorY = 0;
                const obj   = fills[depth];
                let cacheX  = obj.startX;
                let cacheY  = obj.startY;
                const cache = obj.cache;
                let length  = cache.length | 0;
                if (length) {

                    const cKeys = Object.keys(cache);
                    const cLen  = cKeys.length | 0;
                    for (let cIdx = 0; cIdx < cLen; ++cIdx) {
                        const idx      = cKeys[cIdx];
                        const recode   = cache[idx];
                        AnchorX        = recode.AnchorX;
                        AnchorY        = recode.AnchorY;
                        recode.AnchorX = cacheX;
                        recode.AnchorY = cacheY;
                        cacheX         = AnchorX;
                        cacheY         = AnchorY;
                    }

                    const array = [];
                    if (length > 0) {

                        while (length) {

                            --length;

                            array[array.length] = cache[length];

                        }

                    }

                    obj.cache = array;

                }

                // set
                cacheX     = obj.startX;
                cacheY     = obj.startY;
                obj.startX = obj.endX;
                obj.startY = obj.endY;
                obj.endX   = cacheX;
                obj.endY   = cacheY;
            }
        }

        return fills0;
    }

    /**
     * @param   {array}   fills1
     * @param   {boolean} is_morph
     * @returns {array}
     * @public
     */
    coordinateAdjustment (fills1, is_morph)
    {
        const f1Keys = Object.keys(fills1);
        const f1Len  = f1Keys.length | 0;
        for (let f1Idx = 0; f1Idx < f1Len; ++f1Idx) {

            // setup
            const i     = f1Keys[f1Idx];
            const array = [];
            const fills = fills1[i];

            const fKeys = Object.keys(fills);
            const fLen  = fKeys.length | 0;
            for (let fIdx = 0; fIdx < fLen; ++fIdx) {
                array[array.length] = fills[fKeys[fIdx]];
            }

            let adjustment = [];
            switch (true) {

                case array.length > 1 && !is_morph:

                    for (;;) {

                        if (!array.length) {
                            break;
                        }

                        const fill = array.shift();
                        if (fill.startX === fill.endX && fill.startY === fill.endY) {
                            adjustment[adjustment.length] = fill;
                            continue;
                        }

                        let isMatch = 0;
                        let length  = array.length | 0;
                        while (length) {

                            --length;

                            const comparison = array[length];
                            if (comparison.startX === fill.endX && comparison.startY === fill.endY) {

                                fill.endX  = comparison.endX;
                                fill.endY  = comparison.endY;

                                const cache0 = fill.cache;
                                const cache1 = comparison.cache;
                                const cLen   = cache1.length | 0;
                                for (let cIdx = 0; cIdx < cLen; ++cIdx) {
                                    cache0[cache0.length] = cache1[cIdx];
                                }

                                array.splice(length, 1);
                                array.unshift(fill);
                                isMatch = 1;

                                break;
                            }
                        }

                        if (!isMatch) {
                            array.unshift(fill);
                        }

                    }

                    break;

                default:
                    adjustment = array;
                    break;

            }

            const aLen  = adjustment.length | 0;
            const cache = [];

            let obj = {};
            for (let idx = 0; idx < aLen; ++idx) {

                const data = adjustment[idx];
                obj        = data.obj;

                const caches = data.cache;
                const cacheLength = caches.length | 0;
                cache[cache.length] = [0, data.startX, data.startY];

                for (let compIdx = 0; compIdx < cacheLength; ++compIdx) {
                    const r = caches[compIdx];
                    cache[cache.length] = r.isCurved
                        ? [1, r.ControlX, r.ControlY, r.AnchorX, r.AnchorY]
                        : [2, r.AnchorX, r.AnchorY];
                }
            }

            fills1[i] = {
                "cache": cache,
                "obj":   obj
            };

        }

        return fills1;
    }

    /**
     * @param   {array} stack
     * @param   {array} array
     * @returns {array}
     * @public
     */
    setStack (stack, array)
    {
        if (array.length) {
            const keys   = Object.keys(array);
            const length = keys.length | 0;
            for (let idx = 0; idx < length; ++idx) {

                const data = array[keys[idx]];

                stack.push({
                    "object": data.obj,
                    "recode": data.cache
                });
            }
        }

        return stack;
    }
}
Util.$vtc = new VectorToCanvas();

/**
 * @class
 */
class WorkSpace
{
    /**
     * @param {string} [json=""]
     *
     * @constructor
     * @public
     */
    constructor (json = "")
    {
        this._$name            = "";
        this._$stage           = null;
        this._$libraries       = new Map();
        this._$nameMap         = new Map();
        this._$plugins         = new Map();
        this._$position        = 0;
        this._$characterId     = 0;
        this._$revision        = [];
        this._$currentData     = null;
        this._$timelineHeight  = TimelineAdjustment.TIMELINE_DEFAULT_SIZE;
        this._$controllerWidth = ControllerAdjustment.CONTROLLER_DEFAULT_SIZE;

        if (json) {
            this.load(json);
        }

        if (!this._$libraries.has(0)) {

            const root = new MovieClip({
                "id": 0,
                "type": "container",
                "name": "main",
                "symbol": ""
            });

            this._$libraries.set(0, root);
        }

        if (!this._$stage) {
            this._$stage = new Stage();
        }
    }

    /**
     * @description rootのMovieClipを戻す
     *
     * @return {MovieClip}
     * @readonly
     * @public
     */
    get root ()
    {
        return this._$libraries.get(0);
    }

    /**
     * @description プロジェクトのStageオブジェクトを返す
     *
     * @return {Stage}
     * @readonly
     * @public
     */
    get stage ()
    {
        return this._$stage;
    }

    /**
     * @description プロジェクト名を返す
     *
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @description プロジェクト名をセット
     *
     * @param  {string} name
     * @return {void}
     * @public
     */
    set name (name)
    {
        this._$name = `${name}`;
    }

    /**
     * @description 現在表示中のシーン(MovieClip)を返す
     *
     * @return {MovieClip}
     * @public
     */
    get scene ()
    {
        return this._$scene;
    }

    /**
     * @description 指定のシーン(MovieClip)を起動する
     *
     * @param  {MovieClip} scene
     * @return {void}
     * @public
     */
    set scene (scene)
    {
        const init = !this._$scene;
        if (this._$scene) {
            this._$scene.stop();
        }

        this._$scene = scene;
        scene.initialize(init);
    }

    /**
     * @description ライブラリのユニークIDを生成
     *
     * @return {number}
     * @readonly
     * @public
     */
    get nextLibraryId ()
    {
        const keys = Array.from(this._$libraries.keys());
        keys.sort(function (a, b)
        {
            if (a > b) {
                return 1;
            }

            if (a < b) {
                return -1;
            }

            return 0;
        });

        const lastLibraryId = this._$libraries.get(keys.pop() | 0).id | 0;
        return lastLibraryId + 1;
    }

    /**
     * @description 初期起動関数
     *
     * @param  {MovieClip} scene
     * @return {void}
     * @public
     */
    initialize (scene)
    {
        // シーンをセット
        this.scene = scene;

        // 選択中のライブラリを非アクティブに
        Util.$libraryController.clearActive();

        // ライブラリを初期化
        Util.$libraryController.reload(
            Array.from(this._$libraries.values())
        );

        // 内部スクリプトを初期化
        Util.$javascriptController.reload();

        // プラグインを初期化
        Util.$pluginController.reload(
            Array.from(this._$plugins.values())
        );
    }

    /**
     * @description 起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    run ()
    {
        // ステージをセット
        this.stage.initialize();

        // 初期化
        this.initialize(this.root);

        document
            .documentElement
            .style
            .setProperty(
                "--timeline-height",
                `${this._$timelineHeight}px`
            );

        document
            .documentElement
            .style
            .setProperty(
                "--controller-width",
                `${this._$controllerWidth}px`
            );
    }

    /**
     * @description プロジェクトを停止
     *
     * @return {void}
     * @method
     * @public
     */
    stop ()
    {
        if (this._$scene) {
            this._$scene.stop();
            this._$scene = null;
        }
    }

    /**
     * @description 指定のプロジェクトJSONを読み込む
     *
     * @param  {string} json
     * @return {void}
     * @method
     * @public
     */
    load (json)
    {
        const object = JSON.parse(json);

        // copy
        this._$characterId = object.characterId | 0;
        this._$name        = object.name;
        this._$stage       = new Stage(object.stage);

        if (this._$plugins.size) {
            this._$plugins.clear();
        }

        if (object.plugins) {
            for (let idx = 0; idx < object.plugins.length; ++idx) {
                const plugin = object.plugins[idx];
                this._$plugins.set(plugin.name, plugin);
            }
        }

        if (this._$libraries.size) {
            this._$libraries.clear();
        }

        const libraries = object.libraries;
        for (let idx = 0; idx < libraries.length; ++idx) {
            this.addLibrary(libraries[idx]);
        }

        // settings
        if (object.setting) {
            this._$timelineHeight  = object.setting.timelineHeight;
            this._$controllerWidth = object.setting.controllerWidth;
        }
    }

    /**
     * @description プロジェクトのJSONを生成
     *
     * @return {string}
     * @method
     * @public
     */
    toJSON ()
    {
        // ライブラリデータ
        const libraries = [];
        for (const value of this._$libraries.values()) {
            libraries.push(value.toObject());
        }

        return JSON.stringify({
            "version": Util.VERSION,
            "name": this.name,
            "characterId": this._$characterId,
            "stage": this.stage.toObject(),
            "libraries": libraries,
            "plugins": Array.from(this._$plugins.values()),
            "setting": {
                "timelineHeight": this._$timelineHeight,
                "controllerWidth": this._$controllerWidth
            }
        });
    }

    /**
     * @description メモリに現在のプロジェクトデータを保存
     *
     * @return {void}
     * @method
     * @public
     */
    temporarilySaved ()
    {
        Util.$updated = true;
        if (this._$currentData) {
            this._$currentData = null;
        }

        if (this._$position !== this._$revision.length) {
            this._$revision.length = this._$position;
        }

        this._$revision.push(this.toJSON());
        this._$position++;

        // remove old data
        if (this._$revision.length > Util.REVISION_LIMIT) {

            this._$revision.shift();

            this._$position = this._$revision.length;
        }
    }

    /**
     * @description 保存した一個前のプロジェクトデータを読み込む
     *
     * @return {void}
     * @method
     * @public
     */
    undo ()
    {
        if (!this._$position) {
            return ;
        }

        if (!this._$currentData) {
            this._$currentData = this.toJSON();
        }

        this.reloadData(this._$revision[--this._$position]);
    }

    /**
     * @description 保存した一個先のプロジェクトデータを読み込む
     *
     * @return {void}
     * @method
     * @public
     */
    redo ()
    {
        if (!this._$revision.length
            || this._$position === this._$revision.length
        ) {
            return ;
        }

        let data = null;
        if (this._$position + 1 === this._$revision.length) {

            if (!this._$currentData) {
                return ;
            }

            data = this._$currentData;

            this._$position++;
            this._$currentData = null;

        } else {

            data = this._$revision[++this._$position];

        }

        if (!data) {
            return ;
        }

        this.reloadData(data);
    }

    /**
     * @description undo/redoのデータの再読み込み
     *
     * @param  {string} data
     * @return {void}
     * @method
     * @public
     */
    reloadData (data)
    {
        const layerIds = [];
        const targetLayers = Util.$timelineLayer.targetLayers;
        for (const layerId of targetLayers.keys()) {
            layerIds.push(layerId);
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();
        Util.$tools.reset();

        // 値をキャッシュ
        const currentFrame   = this._$scene.currentFrame;
        const currentSceneId = this._$scene.id;

        // シーンを初期化
        this._$scene.stop();
        this._$scene = null;

        // 再読み込み
        this.load(data);

        // loadしたデータでレイヤーを再構築
        const scene = this.getLibrary(currentSceneId);
        scene._$currentFrame = currentFrame;
        this.initialize(scene);

        // 再読み込み
        if (layerIds.length) {

            const ctrlKey = Util.$ctrlKey;
            Util.$ctrlKey = true;
            for (let idx = 0; idx < layerIds.length; ++idx) {

                const element = document
                    .getElementById(`${layerIds[idx]}`);

                if (!element) {
                    continue;
                }

                Util.$timelineLayer.activeLayer(element);
            }

            Util.$ctrlKey = ctrlKey;
        }
    }

    /**
     * @description ライブラリに追加されたObjectをプロジェクト内部に格納
     *
     * @param  {object} library
     * @return {object}
     * @method
     * @public
     */
    addLibrary (library)
    {
        let instance;
        switch (library.type) {

            case "container":
                instance = new MovieClip(library);
                break;

            case "bitmap":
                instance = new Bitmap(library);
                break;

            case "text":
                instance = new TextField(library);
                break;

            case "sound":
                instance = new Sound(library);
                break;

            case "video":
                instance = new Video(library);
                break;

            case "shape":
                instance = new Shape(library);
                break;

            case "folder":
                instance = new Folder(library);
                break;

        }

        this._$libraries.set(instance.id, instance);

        return instance;
    }

    /**
     * @description 指定のライブラリのアイテムを返す
     *
     * @param  {uint} id
     * @return {object}
     * @method
     * @public
     */
    getLibrary (id)
    {
        return this._$libraries.get(id | 0);
    }

    /**
     * @description 指定のライブラリのアイテムを削除
     *
     * @param  {uint} id
     * @return {void}
     * @method
     * @public
     */
    removeLibrary (id)
    {
        this._$libraries.delete(id | 0);
    }
}

/**
 * @class
 */
class EventDispatcher
{
    /**
     * @description イベント登録関数
     *
     * @param {string} type
     * @param {function} callback
     * @method
     * @public
     */
    addEventListener (type, callback)
    {
        if (!this._$events.has(type)) {
            this._$events.set(type, []);
        }

        this
            ._$events
            .get(type)
            .push(callback);
    }

    /**
     * @description イベント発火関数
     *
     * @param  {string} type
     * @param  {MouseEvent|Event} [event=null]
     * @return {void}
     * @method
     * @public
     */
    dispatchEvent (type, event = null)
    {
        if (!this._$events.has(type)) {
            return ;
        }

        const events = this._$events.get(type);
        for (let idx = 0; idx < events.length; ++idx) {
            const callback = events[idx];
            callback(event);
        }
    }
}

/**
 * @class
 */
class EventType
{
    /**
     * @return {string}
     * @static
     */
    static get MOUSE_DOWN ()
    {
        return "mousedown";
    }

    /**
     * @return {string}
     * @static
     */
    static get MOUSE_UP ()
    {
        return "mouseup";
    }

    /**
     * @return {string}
     * @static
     */
    static get MOUSE_MOVE ()
    {
        return "mousemove";
    }

    /**
     * @return {string}
     * @static
     */
    static get START ()
    {
        return "start";
    }
    /**
     * @return {string}
     * @static
     */
    static get END ()
    {
        return "end";
    }

    /**
     * @return {string}
     * @static
     */
    static get DBL_CLICK ()
    {
        return "dblclick";
    }

    /**
     * @return {string}
     * @static
     */
    static get CHANGE ()
    {
        return "change";
    }

    /**
     * @return {string}
     * @static
     */
    static get MOUSE_OVER ()
    {
        return "mouseover";
    }

    /**
     * @return {string}
     * @static
     */
    static get MOUSE_OUT ()
    {
        return "mouseout";
    }

    /**
     * @return {string}
     * @static
     */
    static get KEY_DOWN ()
    {
        return "keydown";
    }

    /**
     * @return {string}
     * @static
     */
    static get MOUSE_LEAVE ()
    {
        return "mouseleave";
    }
}


/**
 * @class
 */
class InputEvent
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @description 自動セーブの判定フラグ
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;

        /**
         * @description フォーカスされたかの判定変数
         * @type {boolean}
         * @default false
         * @private
         */
        this._$focus = false;

        /**
         * @description 発火したイベントオブジェクト
         * @type {Event}
         * @default null
         * @private
         */
        this._$currentEvent = null;

        /**
         * @description 指定されたInputElement
         *
         * @type {HTMLInputElement}
         * @default null
         * @private
         */
        this._$currentTarget = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;
    }

    /**
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setInputEvent (element)
    {
        if (!element) {
            return ;
        }

        element.addEventListener("mouseover", (event) =>
        {
            this.mouseOver(event);
        });
        element.addEventListener("mouseout", (event) =>
        {
            this.mouseOut(event);
        });
        element.addEventListener("mousedown", (event) =>
        {
            this.mouseDown(event);
        });
        element.addEventListener("focusin", (event) =>
        {
            this.focusIn(event);
        });
        element.addEventListener("focusout",  (event) =>
        {
            this.finishInput(event);
        });
        element.addEventListener("keypress",  (event) =>
        {
            this.finishInput(event);
        });
    }

    /**
     * @description Elementのid名をキャメルケースに変換して関数を実行
     *              例) font-select => changeFontSelectがコールされる
     *              valueはstringで渡すので、コール先の関数内で変換とバリデーションを行う必要がある
     *
     * @param  {string} name
     * @param  {string|number|Event} value
     * @return {*}
     * @method
     * @public
     */
    changeFunction (name, value)
    {
        const names = name.split("-");

        let functionName = names
            .map((value) =>
            {
                return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
            })
            .join("");

        return this[`change${functionName}`](value);
    }

    /**
     * @description Inputが数値の場合マウス動作で加算減算できればカーソルを変化させる
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseOver (event)
    {
        event.stopPropagation();

        switch (true) {

            case this._$focus:
            case this._$currentTarget !== null:
                return ;

            default:
                Util.$setCursor("ew-resize");
                event.target.style.cursor = "ew-resize";
                break;

        }
    }

    /**
     * @description Inputが数値の場合マウス動作終了関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseOut (event)
    {
        event.stopPropagation();

        if (this._$focus || !this._$currentTarget) {
            Util.$setCursor("auto");
            event.target.style.cursor = "";
        }
    }

    /**
     * @description 数値のInputElementの場合はマウスで値を変更可能
     *              状態に合わせてカーソルや変数を初期化する
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseDown (event)
    {
        // Inputモードなら何もしない
        if (this._$focus) {
            return ;
        }

        event.preventDefault();

        // 初期化
        this._$saved         = false;
        this._$pointX        = event.screenX;
        this._$currentTarget = event.target;

        Util.$setCursor("ew-resize");

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        Util.$setCursor("auto");

        if (this._$currentTarget) {
            this._$currentTarget.style.cursor = "";
            this._$currentTarget.focus();
        }
    }

    /**
     * @description マウスで数値の加算減算を行う
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseMove (event)
    {
        if (this._$focus || !this._$currentTarget) {
            return ;
        }

        window.requestAnimationFrame(() =>
        {
            if (this._$focus || !this._$currentTarget) {
                return ;
            }

            event.preventDefault();

            Util.$setCursor("ew-resize");

            const diff = event.screenX - this._$pointX;

            let currentValue = +this._$currentTarget.value;
            if (isNaN(currentValue)) {
                currentValue = 0;
            }

            // clampで補正された値をセット
            this._$currentTarget.value = this.changeFunction(
                this._$currentTarget.id,
                currentValue + diff
            );

            // 値を更新
            this._$pointX = event.screenX;
        });
    }

    /**
     * @description Inputにフォーカスされた時に変数を初期化する
     *
     * @return {void}
     * @method
     * @public
     */
    focusIn ()
    {
        this._$focus  = true;
        Util.$keyLock = true;
    }

    /**
     * @description Inputにフォーカス終了した時にロックを解放する
     *
     * @return {void}
     * @method
     * @public
     */
    focusOut ()
    {
        this._$saved         = false;
        this._$focus         = false;
        this._$currentTarget = null;
        Util.$keyLock        = false;
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    finishInput (event)
    {
        // Enterを押下したら、focusoutイベントを発火させる
        if (event.key === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        // focusoutなら更新関数を実行
        if (event.type === "focusout") {

            this._$currentTarget = event.target;

            // Inputの値を更新
            event.target.value = this.changeFunction(
                this._$currentTarget.id,
                this._$currentTarget.value
            );

            this.focusOut();
        }
    }

    /**
     * @description スクリーンエリアで変更があったElementを再描画
     *
     * @return {void}
     * @method
     * @public
     */
    reloadScreen ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        Util
            .$currentWorkSpace()
            .scene
            .changeFrame(frame);
    }

    /**
     * @description undo用にデータを内部保管する
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }
}

/**
 * @class
 */
class ToolEvent extends EventDispatcher
{
    /**
     * @description ツールのマウスイベントを管理するクラス
     *
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @description クラスのマウスイベントMap
         *              startは起動時に、endは終了時に発火するよう
         *
         * @type {Map}
         * @private
         */
        this._$events = new Map([
            [EventType.MOUSE_DOWN, [(event) =>
            {
                this.active = true;
                this.target = event.currentTarget;
            }]],
            [EventType.MOUSE_UP, [() =>
            {
                this.active = false;
                this.target = null;
            }]],
            [EventType.START, [() =>
            {
                // カーソルをリセット
                Util.$setCursor("auto");

                const element = document
                    .getElementById(`tools-${this._$name}`);

                if (element) {
                    element.classList.add("active");
                }
            }]],
            [EventType.END, [() =>
            {
                const element = document
                    .getElementById(`tools-${this._$name}`);

                if (element) {
                    element.classList.remove("active");
                }
            }]]
        ]);
    }
}

/**
 * @class
 */
class KeyboardCommand
{
    /**
     * @constructor
     * @public
     */
    constructor (name)
    {
        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$areaName = name;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$active = false;

        /**
         * @type {Map}
         * @private
         */
        this._$mapping = new Map();

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$execute = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @return {string}
     */
    get areaName ()
    {
        return this._$areaName;
    }

    /**
     * @return {boolean}
     * @public
     */
    get active ()
    {
        return this._$active;
    }

    /**
     * @param  {boolean} active
     * @return {void}
     * @public
     */
    set active (active)
    {
        this._$active = !!active;
        if (this._$active) {
            window.addEventListener("keydown", this._$execute);
        } else {
            window.removeEventListener("keydown", this._$execute);
        }
    }

    /**
     * @description 共通初期イベント登録関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        this._$execute = this.execute.bind(this);

        Util.$initializeEnd();
    }

    /**
     * @description イベントを登録
     *
     * @param  {string} code
     * @param  {function} callback
     * @return {void}
     * @method
     * @public
     */
    add (code, callback)
    {
        this._$mapping.set(code, callback);
    }

    /**
     * @description イベントを削除
     *
     * @param  {string} code
     * @return {void}
     * @method
     * @public
     */
    delete (code)
    {
        this._$mapping.delete(code);
    }

    /**
     * @description 登録されているcallbackをコール
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    execute (event)
    {
        if (Util.$keyLock || !this._$active) {
            return ;
        }

        let code = Util.$generateShortcutKey(event.key, {
            "alt": Util.$altKey,
            "shift": Util.$shiftKey,
            "ctrl": Util.$ctrlKey
        });

        // オリジナル設定があれば上書き
        const originMapping = Util
            .$shortcutSetting
            .commandMapping
            .get(this.areaName);

        if (originMapping.has(code)) {

            code = originMapping.get(code);

        } else {

            const viewMapping = Util
                .$shortcutSetting
                .viewMapping
                .get(this.areaName);

            if (viewMapping.has(code)) {
                return ;
            }

        }

        if (!this._$mapping.has(code)) {
            return ;
        }

        Util.$endMenu();

        event.stopPropagation();
        event.preventDefault();

        // 条件が一致したら実行
        this
            ._$mapping
            .get(code)(code);
    }
}

Util.$keyboardCommand = new KeyboardCommand();

/**
 * @class
 * @extends {InputEvent}
 */
class ColorTool extends InputEvent
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @return {string}
     * @const
     * @static
     */
    static get FILL_DEFAULT_COLOR ()
    {
        return "#000000";
    }

    /**
     * @return {string}
     * @const
     * @static
     */
    static get STROKE_DEFAULT_COLOR ()
    {
        return "#000000";
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get STROKE_DEFAULT_SIZE ()
    {
        return 0;
    }

    /**
     * @description 初回起動設定
     *
     * @return {void}
     * @public
     */
    initialize ()
    {
        // コントラクターでセットしたイベントを削除
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        // 塗りのカラーElementのイベントと初期値をセット
        const fillColor = document.getElementById("fill-color");
        if (fillColor) {

            fillColor.value = localStorage
                .getItem(`${Util.PREFIX}@${fillColor.id}`) || ColorTool.FILL_DEFAULT_COLOR;

            fillColor
                .addEventListener("change", (event) =>
                {
                    const element = event.target;

                    localStorage
                        .setItem(
                            `${Util.PREFIX}@${element.id}`,
                            event.target.value
                        );
                });
        }

        // 線のカラーElementのイベントと初期値をセット
        const strokeColor = document.getElementById("stroke-color");
        if (strokeColor) {

            strokeColor.value = localStorage
                .getItem(`${Util.PREFIX}@${strokeColor.id}`) || ColorTool.STROKE_DEFAULT_COLOR;

            strokeColor
                .addEventListener("change", (event) =>
                {
                    const element = event.target;

                    localStorage
                        .setItem(
                            `${Util.PREFIX}@${element.id}`,
                            element.value
                        );
                });
        }

        // 線の太さのElementのイベントと初期値をセット
        const strokeSize = document.getElementById("stroke-size");
        if (strokeSize) {

            strokeSize.value = localStorage
                .getItem(`${Util.PREFIX}@${strokeSize.id}`) || ColorTool.STROKE_DEFAULT_SIZE;

            this.setInputEvent(strokeSize);
        }

        // end
        Util.$initializeEnd();
    }

    /**
     * @description 線のInput処理
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeStrokeSize (value)
    {
        value = Util.$clamp(value | 0, 0, 255);

        localStorage.setItem(`${Util.PREFIX}@stroke-size`, value);

        return value;
    }
}

Util.$colorTool = new ColorTool();

/**
 * @class
 */
class CommonTool extends ToolEvent
{
    /**
     * @description ツールのElementを管理するクラス
     *
     * @param {string} name
     * @constructor
     * @public
     */
    constructor (name)
    {
        super();

        /**
         * @type {string}
         * @private
         */
        this._$name = name;

        /**
         * @type {string}
         * @private
         */
        this._$cursor = "auto";

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pageX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pageY = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$offsetX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$offsetY = 0;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$active = false;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$target = null;

        // toolsに登録
        if (name) {

            Util
                .$tools
                .setTool(name, this);

            // 初期ElementになければPluginとして登録
            let element = document.getElementById(`tools-${name}`);
            if (!element) {

                const pluginTools = document
                    .getElementById("plugin-tools");

                if (pluginTools) {

                    const div = document.createElement("div");
                    div.id = `tools-${name}`;
                    div.classList.add("item");
                    div.dataset.mode = "tool";
                    div.dataset.name = name;

                    pluginTools.appendChild(div);

                    element = div;
                }

            }

            // Elementにイベントを追加
            if (element) {
                element
                    .addEventListener(EventType.MOUSE_DOWN, () =>
                    {
                        if (Util.$tools.activeTool) {
                            Util
                                .$tools
                                .activeTool
                                .dispatchEvent(EventType.END);
                        }

                        this.dispatchEvent(EventType.START);
                        Util.$tools.activeTool = this;
                    });
            }
        }
    }

    /**
     * @return {string}
     * @readonly
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @return {number}
     * @public
     */
    get pageX ()
    {
        return this._$pageX;
    }

    /**
     * @param  {number} page_x
     * @return {void}
     * @public
     */
    set pageX (page_x)
    {
        this._$pageX = page_x;
    }

    /**
     * @return {number}
     * @public
     */
    get pageY ()
    {
        return this._$pageY;
    }

    /**
     * @param  {number} page_y
     * @return {void}
     * @public
     */
    set pageY (page_y)
    {
        this._$pageY = page_y;
    }

    /**
     * @return {number}
     * @public
     */
    get offsetX ()
    {
        return this._$offsetX;
    }

    /**
     * @param  {number} offset_x
     * @return {void}
     * @public
     */
    set offsetX (offset_x)
    {
        this._$offsetX = offset_x;
    }

    /**
     * @return {number}
     * @public
     */
    get offsetY ()
    {
        return this._$offsetY;
    }

    /**
     * @param  {number} offset_y
     * @return {void}
     * @public
     */
    set offsetY (offset_y)
    {
        this._$offsetY = offset_y;
    }

    /**
     * @return {boolean}
     * @public
     */
    get active ()
    {
        return this._$active;
    }

    /**
     * @param  {boolean} active
     * @return {void}
     * @public
     */
    set active (active)
    {
        this._$active = !!active;
    }

    /**
     * @return {HTMLDivElement}
     * @public
     */
    get target ()
    {
        return this._$target;
    }

    /**
     * @param  {HTMLDivElement} target
     * @return {void}
     * @public
     */
    set target (target)
    {
        this._$target = target;
    }

    /**
     * @description ElementにアイコンとなるElementを追加
     *
     * @param  {Element} element
     * @return {void}
     * @method
     * @public
     */
    setIcon (element)
    {
        const parent = document
            .getElementById(`tools-${this._$name}`);

        const children = parent.children;
        while (children.length) {
            children[0].remove();
        }

        parent.appendChild(element);
    }

    /**
     * @param  {string} tip
     * @return {void}
     * @method
     * @public
     */
    setToolTip (tip)
    {
        const element = document
            .getElementById(`tools-${this._$name}`);

        if (element) {
            element.dataset.detail = `${tip}`;
        }
    }

    /**
     * @description マウスオーバー、ムーブ時のカーソルを指定
     *
     * @param  {string} [cursor="auto"]
     * @return {void}
     * @method
     * @public
     */
    setCursor (cursor = "auto")
    {
        this._$cursor = `${cursor}`;
    }
}

/**
 * @class
 */
class Project
{
    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // ファイル読み込み
        const loadElement = document
            .getElementById("tools-load");

        if (loadElement) {
            loadElement
                .addEventListener("click", (event) =>
                {
                    event.preventDefault();
                    this.open();
                });
        }

        const fileInput = document
            .getElementById("tools-load-file-input");

        if (fileInput) {
            fileInput
                .addEventListener("change", (event) =>
                {
                    const files = event.target.files;
                    for (let idx = 0; idx < files.length; ++idx) {
                        this.load(files[idx]);
                    }

                    // reset
                    event.target.value = "";
                });
        }

        const saveElement = document
            .getElementById("tools-save");

        if (saveElement) {
            saveElement
                .addEventListener("click", (event) =>
                {
                    event.preventDefault();
                    this.save();
                });
        }

        const exportElement = document
            .getElementById("tools-export");

        if (exportElement) {
            exportElement
                .addEventListener("click", (event) =>
                {
                    event.preventDefault();
                    this.publish();
                });
        }

        const languageElement = document
            .getElementById("language-setting");

        if (languageElement) {

            const language = localStorage
                .getItem(`${Util.PREFIX}@language-setting`);

            if (language) {
                const children = languageElement.children;
                for (let idx = 0; idx < children.length; ++idx) {
                    const node = children[idx];
                    if (node.value === language) {
                        node.selected = true;
                        break;
                    }
                }
            }

            languageElement
                .addEventListener("change", (event) =>
                {
                    const language = event.target.value;

                    const LanguageClass = Util.$languages.get(language);
                    Util.$currentLanguage = new LanguageClass();

                    localStorage
                        .setItem(`${Util.PREFIX}@language-setting`, language);

                    Util.$addModalEvent(document);
                });
        }
    }

    /**
     * @description 指定したフォーマットで書き出し
     *
     * @return {void}
     * @method
     * @public
     */
    publish ()
    {
        // ダウンロードリンクを生成
        const anchor = document.getElementById("save-anchor");

        if (anchor.href) {
            URL.revokeObjectURL(anchor.href);
        }

        const type = document
            .getElementById("publish-type-setting")
            .value;

        switch (type) {

            case "json":
                anchor.download = `${Util.$currentWorkSpace().name}.json`;
                anchor.href     = URL.createObjectURL(new Blob(
                    [Publish.toJSON()],
                    { "type" : "application/json" }
                ));
                anchor.click();
                break;

            case "zlib":
                Publish.toZlib();
                break;

            case "webm":
                Publish.toWebM();
                break;

            case "gif-loop":
                Publish.toGIF();
                break;

            case "gif":
                Publish.toGIF(-1);
                break;

            case "png":
                Publish.toPng();
                break;

            case "apng-loop":
                Publish.toApng(true);
                break;

            case "apng":
                Publish.toApng(false);
                break;

            case "custom":
                if ("CustomPublish" in window) {
                    window
                        .CustomPublish
                        .execute(Publish.toObject());
                }
                break;

        }
    }

    /**
     * @description n2dファイルの読み込み処理、zipデータ解凍
     *
     * @param  {File} file
     * @return {void}
     * @public
     */
    load (file)
    {
        file
            .arrayBuffer()
            .then((buffer) =>
            {
                const uint8Array = new Uint8Array(buffer);
                Util.$unZlibWorker.postMessage({
                    "buffer": uint8Array,
                    "type": "n2d"
                }, [uint8Array.buffer]);
            });
    }

    /**
     * @description プロジェクトデータをローカルから選択する
     *
     * @return {void}
     * @method
     * @public
     */
    open ()
    {
        document
            .getElementById("tools-load-file-input")
            .click();
    }

    /**
     * @description プロジェクトデータをローカルへ保存
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        const postData = {
            "object": Util.$currentWorkSpace().toJSON(),
            "type": "n2d"
        };

        if (Util.$zlibWorkerActive) {

            Util.$zlibQueues.push(postData);

        } else {

            Util.$zlibWorkerActive = true;
            Util.$zlibWorker.postMessage(postData);

        }
    }
}

Util.$project = new Project();

/**
 * @class
 */
class Publish
{
    /**
     * @return {object}
     * @method
     * @static
     */
    static toObject ()
    {
        const workSpace = Util.$currentWorkSpace();

        const stage = workSpace.stage;
        const libraries = workSpace._$libraries;

        const characters = [];

        // character publish
        for (let [id, instance] of libraries) {

            switch (true) {

                case id === 0: // root
                case instance.type !== "folder": // folder
                case instance.symbol !== "": // symbol instance
                case Util.$useIds.has(id): // use character
                    {
                        const object = instance.toPublish();
                        if (object.symbol) {
                            Util.$symbols.set(object.symbol, characters.length);
                        }

                        characters[id] = object;
                    }
                    break;

                default:
                    characters[id] = null;
                    break;

            }

        }

        let size = Util.$useIds.size;
        for (;;) {

            for (let [id, instance] of libraries) {

                if (characters[id]) {
                    continue;
                }

                if (!Util.$useIds.has(id)) {
                    continue;
                }

                const object = instance.toPublish();
                if (object.symbol) {
                    Util.$symbols.set(object.symbol, characters.length);
                }

                characters[id] = object;
            }

            if (size === Util.$useIds.size) {
                break;
            }

            // update
            size = Util.$useIds.size;
        }

        return {
            "stage": {
                "width": stage.width,
                "height": stage.height,
                "fps": stage.fps,
                "bgColor": stage.bgColor
            },
            "characters": characters
        };
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static toJSON ()
    {
        if (Util.$symbols.size) {
            Util.$symbols.clear();
        }

        const object   = Publish.toObject();
        object.symbols = Array.from(Util.$symbols);
        object.type    = "json";

        return JSON.stringify(object);
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static toZlib ()
    {
        if (Util.$symbols.size) {
            Util.$symbols.clear();
        }

        const object   = Publish.toObject();
        object.symbols = Array.from(Util.$symbols);

        const postData = {
            "object": JSON.stringify(object),
            "type": "json"
        };

        if (Util.$zlibWorkerActive) {

            Util.$zlibQueues.push(postData);

        } else {

            Util.$zlibWorkerActive = true;
            Util.$zlibWorker.postMessage(postData);

        }
    }

    /**
     * @return {array}
     * @method
     * @static
     */
    static toWebM ()
    {
        const canvas = document.getElementById("__next2d__").children[0];
        const stream = canvas.captureStream(
            document.getElementById("stage-fps").value | 0
        );

        const chunks   = [];
        const mimeType = "video/webm;codecs=h264";
        const recorder = new MediaRecorder(stream, { "mimeType" : mimeType });

        recorder.addEventListener("dataavailable", (event) =>
        {
            chunks.push(event.data);
        });

        recorder.addEventListener("stop", () =>
        {
            Util.$hidePreview();

            const anchor    = document.getElementById("save-anchor");
            anchor.download = `${Util.$currentWorkSpace().name}.webm`;
            anchor.href     = URL.createObjectURL(new Blob(chunks, { "type" : mimeType }));
            anchor.click();
        });

        const watch = function ()
        {
            if (!Util.$root.numChildren) {
                requestAnimationFrame(watch);
                return ;
            }

            if (Util.$root.currentFrame >= Util.$root.totalFrames) {
                return recorder.stop();
            }

            requestAnimationFrame(watch);
        };
        watch();

        Util.$showPreview();
        recorder.start(0);
    }

    /**
     * @param  {number} [repeat=0]
     * @return {void}
     * @method
     * @static
     */
    static toGIF (repeat = 0)
    {
        const gif = new GIF({
            "repeat": repeat,
            "workerScript": "./assets/js/gif.worker.js"
        });

        gif.on("finished", (blob) =>
        {
            const anchor    = document.getElementById("save-anchor");
            anchor.download = `${Util.$currentWorkSpace().name}.gif`;
            anchor.href     = URL.createObjectURL(blob);
            anchor.click();
        });

        const watch = function ()
        {
            if (!Util.$root.numChildren) {
                requestAnimationFrame(watch);
                return ;
            }

            const canvas = document.getElementById("__next2d__").children[0];

            const cloneCanvas  = document.createElement("canvas");
            cloneCanvas.width  = canvas.width;
            cloneCanvas.height = canvas.height;

            const context = cloneCanvas.getContext("2d");
            context.drawImage(canvas, 0, 0, canvas.width, canvas.height);

            gif.addFrame(context.canvas, { "delay": 20 });

            if (Util.$root.currentFrame >= Util.$root.totalFrames) {
                Util.$hidePreview();
                gif.render();
                return;
            }

            requestAnimationFrame(watch);
        };
        watch();

        Util.$showPreview();
    }

    /**
     * @return {void}
     * @method
     * @static
     */
    static toPng ()
    {
        const snapshot = () =>
        {
            if (!Util.$root.numChildren) {
                requestAnimationFrame(snapshot);
                return ;
            }

            const stage = Util.$root.stage;
            if (!stage) {
                requestAnimationFrame(snapshot);
                return ;
            }

            const player = stage._$player;
            if (player._$stopFlag) {
                requestAnimationFrame(snapshot);
                return ;
            }

            const canvas    = document.getElementById("__next2d__").children[0];
            const anchor    = document.getElementById("save-anchor");
            anchor.download = `${Util.$currentWorkSpace().name}.png`;
            anchor.href     = canvas.toDataURL();
            anchor.click();

            Util.$hidePreview();
        };
        snapshot();

        Util.$showPreview();
    }

    /**
     * @param  {boolean} [loop = true]
     * @return {void}
     * @method
     * @static
     */
    static toApng (loop = true)
    {
        const buffer = [];
        let currentFrame = 0;
        const watch = () =>
        {
            const player = Util.$root.stage._$player;
            if (player._$stopFlag
                || !Util.$root.numChildren
                || currentFrame === Util.$root.currentFrame
            ) {
                requestAnimationFrame(watch);
                return ;
            }

            currentFrame = Util.$root.currentFrame;
            const canvas = document.getElementById("__next2d__").children[0];

            const cloneCanvas  = document.createElement("canvas");
            cloneCanvas.width  = canvas.width;
            cloneCanvas.height = canvas.height;

            const context = cloneCanvas.getContext("2d");
            context.drawImage(canvas, 0, 0, canvas.width, canvas.height);
            canvas.toBlob((blob) => { buffer.push(blob) });

            if (buffer.length + 1 === Util.$root.totalFrames) {

                Util.$hidePreview();

                return new ApngEncoder(
                    buffer, canvas.width, canvas.height,
                    document.getElementById("stage-fps").value | 0,
                    loop
                )
                    .encode()
                    .then((blob) =>
                    {
                        const anchor    = document.getElementById("save-anchor");
                        anchor.download = `${Util.$currentWorkSpace().name}.apng`;
                        anchor.href     = URL.createObjectURL(blob);
                        anchor.click();
                    });

            }

            requestAnimationFrame(watch);
        };
        watch();

        Util.$showPreview();
    }

}

/**
 * @class
 */
class ShortcutSetting
{

    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {array}
         * @private
         */
        this._$names = [
            "screen",
            "timeline",
            "library"
        ];

        /**
         * @type {object}
         * @private
         */
        this._$default = {
            "screen": [
                {
                    "key": "v",
                    "text": "V",
                    "css": "tools-arrow",
                    "description": "{{選択ツール}}"
                },
                {
                    "key": "a",
                    "text": "A",
                    "css": "tools-transform",
                    "description": "{{Shape変形ツール}}"
                },
                {
                    "key": "p",
                    "text": "P",
                    "css": "tools-pen",
                    "description": "{{ペンツール}}"
                },
                {
                    "key": "k",
                    "text": "K",
                    "css": "tools-bucket",
                    "description": "{{バケツツール}}"
                },
                {
                    "key": "r",
                    "text": "R",
                    "css": "tools-rectangle",
                    "description": "{{矩形ツール}}"
                },
                {
                    "key": "o",
                    "text": "O",
                    "css": "tools-circle",
                    "description": "{{楕円ツール}}"
                },
                {
                    "key": "rShift",
                    "text": "Shift + R",
                    "css": "tools-round-rect",
                    "description": "{{角丸矩形ツール}}"
                },
                {
                    "key": "t",
                    "text": "T",
                    "css": "tools-text",
                    "description": "{{テキストツール}}"
                },
                {
                    "key": "z",
                    "text": "Z",
                    "css": "tools-zoom",
                    "description": "{{ズームツール}}"
                },
                {
                    "key": "rCtrl",
                    "text": "Ctrl + R",
                    "css": "tools-load",
                    "description": "{{プロジェクトデータの読込}}"
                },
                {
                    "key": "sShiftCtrl",
                    "text": "Ctrl + Shift + S",
                    "css": "tools-save",
                    "description": "{{プロジェクトデータを保存}}"
                },
                {
                    "key": "EnterShiftCtrl",
                    "text": "Ctrl + Shift + Enter",
                    "css": "tools-export",
                    "description": "{{書き出し}}"
                },
                {
                    "key": "s",
                    "text": "S",
                    "css": "tools-setting",
                    "description": "{{設定}}"
                },
                {
                    "key": "ArrowUpShiftCtrl",
                    "text": "Ctrl + Shift + ArrowUp",
                    "css": "screen-front",
                    "description": "{{最前面}}"
                },
                {
                    "key": "ArrowUpCtrl",
                    "text": "Ctrl + ArrowUp",
                    "css": "screen-front-one",
                    "description": "{{ひとつ前面へ}}"
                },
                {
                    "key": "ArrowDownCtrl",
                    "text": "Ctrl + ArrowDown",
                    "css": "screen-menu-bottom",
                    "description": "{{ひとつ背面へ}}"
                },
                {
                    "key": "ArrowDownShiftCtrl",
                    "text": "Ctrl + Shift + ArrowDown",
                    "css": "screen-back",
                    "description": "{{最背面}}"
                },
                {
                    "key": "1",
                    "text": "1",
                    "css": "screen-position-left",
                    "description": "{{左揃え}}"
                },
                {
                    "key": "2",
                    "text": "2",
                    "css": "screen-position-center",
                    "description": "{{中央揃え(水平方向)}}"
                },
                {
                    "key": "3",
                    "text": "3",
                    "css": "screen-position-right",
                    "description": "{{右揃え}}"
                },
                {
                    "key": "4",
                    "text": "4",
                    "css": "screen-position-top",
                    "description": "{{上揃え}}"
                },
                {
                    "key": "5",
                    "text": "5",
                    "css": "screen-position-middle",
                    "description": "{{中央揃え(垂直方向)}}"
                },
                {
                    "key": "6",
                    "text": "6",
                    "css": "screen-position-bottom",
                    "description": "{{下揃え}}"
                },
                {
                    "key": "!Shift",
                    "text": "Shift + 1",
                    "css": "stage-position-left",
                    "description": "{{ステージ左揃え}}"
                },
                {
                    "key": "\"Shift",
                    "text": "Shift + 2",
                    "css": "stage-position-center",
                    "description": "{{ステージ中央揃え(水平方向)}}"
                },
                {
                    "key": "#Shift",
                    "text": "Shift + 3",
                    "css": "stage-position-right",
                    "description": "{{ステージ右揃え}}"
                },
                {
                    "key": "$Shift",
                    "text": "Shift + 4",
                    "css": "stage-position-top",
                    "description": "{{ステージ上揃え}}"
                },
                {
                    "key": "%Shift",
                    "text": "Shift + 5",
                    "css": "stage-position-middle",
                    "description": "{{ステージ中央揃え(垂直方向)}}"
                },
                {
                    "key": "&Shift",
                    "text": "Shift + 6",
                    "css": "stage-position-bottom",
                    "description": "{{ステージ下揃え}}"
                },
                {
                    "key": "dCtrl",
                    "text": "Ctrl + D",
                    "css": "screen-distribute-to-layers",
                    "description": "{{レイヤーに配分}}"
                },
                {
                    "key": "kCtrl",
                    "text": "Ctrl + K",
                    "css": "screen-distribute-to-keyframes",
                    "description": "{{キーフレームに配分}}"
                },
                {
                    "key": "iCtrl",
                    "text": "Ctrl + I",
                    "css": "screen-integrating-paths",
                    "description": "{{パスの結合}}"
                },
                {
                    "key": "pCtrl",
                    "text": "Ctrl + P",
                    "css": "screen-add-tween-curve-pointer",
                    "description": "{{カーブポインターの追加}}"
                },
                {
                    "key": "pShiftCtrl",
                    "text": "Ctrl + Shift + P",
                    "css": "screen-delete-tween-curve-pointer",
                    "description": "{{カーブポインターの削除}}"
                },
                {
                    "key": "mShift",
                    "text": "Shift + M",
                    "css": "screen-change-movie-clip",
                    "description": "{{MovieClipに変換}}"
                }
            ],
            "timeline": [
                {
                    "key": "nShift",
                    "text": "Shift + N",
                    "css": "timeline-layer-normal",
                    "description": "{{通常レイヤー}}"
                },
                {
                    "key": "mShift",
                    "text": "Shift + M",
                    "css": "timeline-layer-mask",
                    "description": "{{マスクレイヤー}}"
                },
                {
                    "key": "gShift",
                    "text": "Shift + G",
                    "css": "timeline-layer-guide",
                    "description": "{{ガイドレイヤー}}"
                },
                {
                    "key": ";Ctrl",
                    "text": "Ctrl + +",
                    "css": "timeline-layer-add",
                    "description": "{{レイヤーを追加}}"
                },
                {
                    "key": "BackspaceCtrl",
                    "text": "Ctrl + Delete",
                    "css": "timeline-layer-trash",
                    "description": "{{レイヤーを削除}}"
                },
                {
                    "key": "hShift",
                    "text": "Shift + H",
                    "css": "timeline-layer-light-all",
                    "description": "{{全てのレイヤーをハイライト}}"
                },
                {
                    "key": "dShift",
                    "text": "Shift + D",
                    "css": "timeline-layer-disable-all",
                    "description": "{{全てのレイヤーを非表示}}"
                },
                {
                    "key": "lShift",
                    "text": "Shift + L",
                    "css": "timeline-layer-lock-all",
                    "description": "{{全てのレイヤーをロック}}"
                },
                {
                    "key": "m",
                    "text": "M",
                    "css": "context-menu-tween-add",
                    "description": "{{モーショントゥイーンの追加}}"
                },
                {
                    "key": "mCtrl",
                    "text": "Ctrl + M",
                    "css": "context-menu-tween-delete",
                    "description": "{{モーショントゥイーンの削除}}"
                },
                {
                    "key": "s",
                    "text": "S",
                    "css": "timeline-script-add",
                    "description": "{{スクリプトを追加}}"
                },
                {
                    "key": "k",
                    "text": "K",
                    "css": "timeline-key-add",
                    "description": "{{キーフレームを追加}}"
                },
                {
                    "key": "kCtrl",
                    "text": "Ctrl + K",
                    "css": "timeline-key-delete",
                    "description": "{{キーフレームを削除}}"
                },
                {
                    "key": "e",
                    "text": "E",
                    "css": "timeline-empty-add",
                    "description": "{{空のキーフレームを追加}}"
                },
                {
                    "key": "f",
                    "text": "F",
                    "css": "timeline-frame-add",
                    "description": "{{フレームを追加}}"
                },
                {
                    "key": "fCtrl",
                    "text": "Ctrl + F",
                    "css": "timeline-frame-delete",
                    "description": "{{フレームを削除}}"
                },
                {
                    "key": "oCtrl",
                    "text": "Ctrl + O",
                    "css": "timeline-onion-skin",
                    "description": "{{オニオンスキン}}"
                },
                {
                    "key": "p",
                    "text": "P",
                    "css": "timeline-preview",
                    "description": "{{プレビューのON/OFF}}"
                },
                {
                    "key": "pCtrl",
                    "text": "Ctrl + P",
                    "css": "timeline-repeat",
                    "description": "{{ループ設定}}"
                },
                {
                    "key": "l",
                    "text": "L",
                    "css": "label-name",
                    "description": "{{フレームラベル}}"
                },
                {
                    "key": "z",
                    "text": "Z",
                    "css": "timeline-scale",
                    "description": "{{タイムライン幅の拡大・縮小}}"
                }
            ],
            "library": [
                {
                    "key": "mCtrl",
                    "text": "Ctrl + M",
                    "css": "library-menu-container-add",
                    "description": "{{新規MovieClip}}"
                },
                {
                    "key": "fCtrl",
                    "text": "Ctrl + F",
                    "css": "library-menu-folder-add",
                    "description": "{{新規フォルダー}}"
                },
                {
                    "key": "sAlt",
                    "text": "Alt + S",
                    "css": "library-menu-content-shape-clone",
                    "description": "{{Shapeを複製}}"
                },
                {
                    "key": "rCtrl",
                    "text": "Ctrl + R",
                    "css": "library-menu-file",
                    "description": "{{読み込み}}"
                },
                {
                    "key": "rCtrl",
                    "text": "Ctrl + R",
                    "css": "library-menu-export",
                    "description": "{{書き出し}}"
                },
                {
                    "key": "Backspace",
                    "text": "Delete",
                    "css": "library-menu-delete",
                    "description": "{{削除}}"
                },
                {
                    "key": "BackspaceShiftCtrl",
                    "text": "Shift + Ctrl + Delete",
                    "css": "library-menu-no-use-delete",
                    "description": "{{未使用のアイテムを削除}}"
                }
            ]
        };

        /**
         * @type {Map}
         * @private
         */
        this._$commandMapping = new Map([
            ["screen", new Map()],
            ["timeline", new Map()],
            ["library", new Map()],
            ["global", new Map()]
        ]);

        /**
         * @type {Map}
         * @private
         */
        this._$viewMapping = new Map([
            ["screen", new Map()],
            ["timeline", new Map()],
            ["library", new Map()],
            ["global", new Map()]
        ]);

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$active = false;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$selectNode = null;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$selectArea = "";

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$keydownEvent = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @return {Map}
     */
    get commandMapping ()
    {
        return this._$commandMapping;
    }

    /**
     * @return {Map}
     */
    get viewMapping ()
    {
        return this._$viewMapping;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const elementIds = [
            "shortcut-setting-screen",
            "shortcut-setting-timeline",
            "shortcut-setting-library",
            "shortcut-setting-reset",
            "shortcut-setting-save",
            "shortcut-setting-close"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            element.addEventListener("click", (event) =>
            {
                event.stopPropagation();
                event.preventDefault();

                this.executeFunction(event);
            });
        }

        // オリジナルのショートカットのマッピングを生成
        this.createShortcutMap();

        // イベント登録して、表示を更新
        for (let idx = 0; idx < this._$names.length; ++idx) {

            const name = this._$names[idx];

            const parent = document
                .getElementById(`shortcut-list-${name}`);

            if (!parent) {
                continue;
            }

            const mapping = this.viewMapping.get(name);

            const values = this._$default[name];
            for (let idx = 0; idx < values.length; ++idx) {

                const data = values[idx];

                const htmlTag = `
<div class="shortcut-item">
    <i class="${data.css}"></i>
    <div class="description">
        <span class="language" data-text="${data.description}">${Util.$currentLanguage.replace(data.description)}</span>
    </div>
    <div class="command" data-key="${data.key}" data-default-text="${data.text}">${data.text}</div>
</div>`;

                parent.insertAdjacentHTML("beforeend", htmlTag);

                const node = parent.lastElementChild;
                node.addEventListener("mousedown", (event) =>
                {
                    this.selectNode(event);
                });

                const cmdElement = node.lastElementChild;
                if (!mapping.has(cmdElement.dataset.key)) {
                    continue;
                }

                const object = mapping.get(cmdElement.dataset.key);
                cmdElement.dataset.map = object.map;
                cmdElement.textContent = object.text;
            }
        }

        // 登録用関数
        this._$keydownEvent = this.keydownEvent.bind(this);

        Util.$initializeEnd();
    }

    /**
     * @description 個別のショートカットをマッピング
     *
     * @return {void}
     * @method
     * @public
     */
    createShortcutMap ()
    {
        const data = localStorage.getItem(`${Util.PREFIX}@shortcut`);
        if (!data) {
            return ;
        }

        const object = JSON.parse(data);
        const keys = Object.keys(object);
        for (let idx = 0; idx < keys.length; ++idx) {

            const name = keys[idx];

            // リセット
            this.viewMapping.get(name).clear();
            this.commandMapping.get(name).clear();

            const values = object[name];
            for (let idx = 0; idx < values.length; ++idx) {

                const data = values[idx];

                this.viewMapping.get(name).set(data.key, {
                    "map": data.map,
                    "text": data.text
                });

                this.commandMapping.get(name).set(data.map, data.key);
            }
        }
    }

    /**
     * @description キーダウンイベントを受け取る
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    keydownEvent (event)
    {
        const element = document
            .getElementById("shortcut-setting-menu");

        if (element.classList.contains("fadeOut")) {
            Util.$useShortcutSetting = false;
            this._$active = false;
            window.removeEventListener("keydown", this._$keydownEvent);
            return ;
        }

        if (!this._$selectNode || !this._$selectArea) {
            return ;
        }

        const texts = [];
        if (Util.$shiftKey) {
            texts.push("Shift");
        }
        if (Util.$altKey) {
            texts.push("Alt");
        }
        if (Util.$ctrlKey) {
            texts.push("Ctrl");
        }

        switch (true) {

            case event.key === "ArrowRight":
            case event.key === "ArrowLeft":
            case event.key === "ArrowUp":
            case event.key === "ArrowDown":
                texts.push(event.key);
                break;

            case event.key === " ":
                texts.push(event.code);
                break;

            case event.key.length === 1:
                texts.push(event.key.toUpperCase());
                break;

            default:
                return ;

        }

        const cmdElement = this._$selectNode.lastElementChild;
        cmdElement.textContent = `${texts.join(" + ")}`;

        const key = Util.$generateShortcutKey(event.key, {
            "alt": Util.$altKey,
            "shift": Util.$shiftKey,
            "ctrl": Util.$ctrlKey
        });

        if (key !== cmdElement.dataset.key) {
            cmdElement.dataset.map  = key;
            cmdElement.dataset.text = cmdElement.textContent;
        } else {
            delete cmdElement.dataset.map;
            delete cmdElement.dataset.text;
        }
    }

    /**
     * @description 選択したElementをセット
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    selectNode (event)
    {
        if (this._$selectNode) {
            this
                ._$selectNode
                .classList
                .remove("shortcut-active");
        }

        this._$selectNode = event.target;

        this
            ._$selectNode
            .classList
            .add("shortcut-active");
    }

    /**
     * @description Elementのid名をキャメルケースに変換して関数を実行
     *              例) font-select => executeFontSelectがコールされる
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    executeFunction (event)
    {
        const names = event.target.id.split("-");

        let functionName = names
            .map((value) =>
            {
                return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
            })
            .join("");

        this[`execute${functionName}`](event);
    }

    /**
     * @description スクリーンエリアのショートカット情報を表示
     *
     * @return {void}
     * @method
     * @public
     */
    executeShortcutSettingScreen ()
    {
        document
            .getElementById("shortcut-setting-screen")
            .classList.add("shortcut-active");
        document
            .getElementById("shortcut-setting-timeline")
            .classList.remove("shortcut-active");
        document
            .getElementById("shortcut-setting-library")
            .classList.remove("shortcut-active");

        document
            .getElementById("shortcut-list-screen")
            .style.display = "";
        document
            .getElementById("shortcut-list-timeline")
            .style.display = "none";
        document
            .getElementById("shortcut-list-library")
            .style.display = "none";

        this._$selectArea = "screen";

        if (this._$selectNode) {
            this
                ._$selectNode
                .classList
                .remove("shortcut-active");
            this._$selectNode = null;
        }
    }

    /**
     * @description スクリーンエリアのショートカット情報を表示
     *
     * @return {void}
     * @method
     * @public
     */
    executeShortcutSettingTimeline ()
    {
        document
            .getElementById("shortcut-setting-screen")
            .classList.remove("shortcut-active");
        document
            .getElementById("shortcut-setting-timeline")
            .classList.add("shortcut-active");
        document
            .getElementById("shortcut-setting-library")
            .classList.remove("shortcut-active");

        document
            .getElementById("shortcut-list-screen")
            .style.display = "none";
        document
            .getElementById("shortcut-list-timeline")
            .style.display = "";
        document
            .getElementById("shortcut-list-library")
            .style.display = "none";

        this._$selectArea = "timeline";

        if (this._$selectNode) {
            this
                ._$selectNode
                .classList
                .remove("shortcut-active");
            this._$selectNode = null;
        }
    }

    /**
     * @description スクリーンエリアのショートカット情報を表示
     *
     * @return {void}
     * @method
     * @public
     */
    executeShortcutSettingLibrary ()
    {
        document
            .getElementById("shortcut-setting-screen")
            .classList.remove("shortcut-active");
        document
            .getElementById("shortcut-setting-timeline")
            .classList.remove("shortcut-active");
        document
            .getElementById("shortcut-setting-library")
            .classList.add("shortcut-active");

        document
            .getElementById("shortcut-list-screen")
            .style.display = "none";
        document
            .getElementById("shortcut-list-timeline")
            .style.display = "none";
        document
            .getElementById("shortcut-list-library")
            .style.display = "";

        this._$selectArea = "library";

        if (this._$selectNode) {
            this
                ._$selectNode
                .classList
                .remove("shortcut-active");
            this._$selectNode = null;
        }
    }

    /**
     * @description ショートカット情報を初期値に戻す
     *
     * @return {void}
     * @method
     * @public
     */
    executeShortcutSettingReset ()
    {
        // 初期化
        localStorage.removeItem(`${Util.PREFIX}@shortcut`);

        for (let idx = 0; idx < this._$names.length; ++idx) {

            const name = this._$names[idx];

            const children = document
                .getElementById(`shortcut-list-${name}`)
                .children;

            for (let idx = 0; idx < children.length; ++idx) {

                const node = children[idx];

                const cmdElement = node.lastElementChild;
                cmdElement.textContent = cmdElement.dataset.defaultText;
                if (!cmdElement.dataset.map) {
                    continue;
                }

                delete cmdElement.dataset.map;
                delete cmdElement.dataset.text;
            }

            this.viewMapping.get(name).clear();
            this.commandMapping.get(name).clear();
        }

        this.createShortcutMap();
    }

    /**
     * @description ショートカットの情報を保存
     *
     * @return {void}
     * @method
     * @public
     */
    executeShortcutSettingSave ()
    {
        // 初期化
        localStorage.removeItem(`${Util.PREFIX}@shortcut`);

        const object = {};
        for (let idx = 0; idx < this._$names.length; ++idx) {

            const name = this._$names[idx];

            const children = document
                .getElementById(`shortcut-list-${name}`)
                .children;

            for (let idx = 0; idx < children.length; ++idx) {

                const node = children[idx].lastElementChild;
                if (!node.dataset.map) {
                    continue;
                }

                if (!object[name]) {
                    object[name] = [];
                }

                object[name].push({
                    "key": node.dataset.key,
                    "map": node.dataset.map,
                    "text": node.textContent
                });
            }
        }

        localStorage
            .setItem(
                `${Util.PREFIX}@shortcut`,
                JSON.stringify(object)
            );

        this.createShortcutMap();
    }

    /**
     * @description ショートカットの設定画面を閉じる
     *
     * @return {void}
     * @method
     * @public
     */
    executeShortcutSettingClose ()
    {
        Util.$userSetting.show();

        if (this._$selectNode) {
            this
                ._$selectNode
                .classList
                .remove("shortcut-active");

            this._$selectNode = null;
            this._$selectArea = "";
        }
    }

    /**
     * @description 設定画面を表示
     *
     * @return {void}
     * @method
     * @public
     */
    show ()
    {
        const element = document
            .getElementById("shortcut-setting-menu");

        // 初期化
        if (this._$selectNode) {
            this
                ._$selectNode
                .classList
                .remove("shortcut-active");

            this._$selectNode = null;
            this._$selectArea = "";
        }

        this.executeShortcutSettingScreen();

        if (!this._$active) {
            Util.$useShortcutSetting = true;
            this._$active = true;
            window.addEventListener("keydown", this._$keydownEvent);
        }

        Util.$endMenu("shortcut-setting-menu");

        const userSetting = document
            .getElementById("user-setting");

        element.style.display = "";
        element.style.left    = `${userSetting.offsetLeft}px`;
        element.style.top     = `${userSetting.offsetTop}px`;

        element.setAttribute("class", "fadeIn");
    }
}

Util.$shortcutSetting = new ShortcutSetting();

/**
 * @class
 */
class Tools
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }

        /**
         * @description 選択中のツールオブジェクト
         * @type {CommonTool}
         * @default null
         * @private
         */
        this._$activeTool = null;

        /**
         * @description Toolクラス
         * @type {Map}
         * @private
         */
        this._$tools = new Map();

        /**
         * @description Toolクラス
         * @type {Map}
         * @private
         */
        this._$externalTools = new Map();
    }

    /**
     * @description 現在選択されているToolクラスを返します。
     *
     * @return {CommonTool}
     * @public
     */
    get activeTool ()
    {
        return this._$activeTool;
    }

    /**
     * @description 選択したToolクラスをセットします。
     *
     * @param  {CommonTool} tool
     * @return {void}
     * @public
     */
    set activeTool (tool)
    {
        this._$activeTool = tool;
    }

    /**
     * @description 初回起動設定
     *
     * @return {void}
     * @public
     */
    initialize ()
    {
        // コントラクターでセットしたイベントを削除
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        // ツールの初期起動
        // デフォルトツールクラス
        const defaultTools = [
            ArrowTool,
            TransformTool,
            RectangleTool,
            CircleTool,
            RoundRectTool,
            PenTool,
            BucketTool,
            TextTool,
            ZoomTool,
            HandTool
        ];

        // デフォルトツールを起動して、Mapに格納
        for (let idx = 0; idx < defaultTools.length; ++idx) {
            const DefaultToolClass = defaultTools[idx];
            const tool = new DefaultToolClass();
            this._$tools.set(tool.name, tool);
        }

        const element = document.getElementById("tools");
        if (element) {
            element
                .addEventListener("mousemove", (event) =>
                {
                    const activeTool = this.activeTool;
                    if (activeTool) {
                        event.tools = true;
                        activeTool.dispatchEvent(
                            EventType.MOUSE_MOVE,
                            event
                        );
                    }
                });

            element
                .addEventListener("mouseout", (event) =>
                {
                    Util.$setCursor("auto");

                    // 親のイベントを中止する
                    event.stopPropagation();
                });
        }

        // プロジェクトデータ関数の初期起動
        Util.$project.initialize();

        // ユーザー設定系の初期化
        Util.$userSetting.initialize();

        // end
        Util.$initializeEnd();
    }

    /**
     * @description 拡張ツールのクラスを登録する関数
     *
     * @param  {string} name
     * @param  {object} tool
     * @return {void}
     * @method
     * @public
     */
    setTool (name, tool)
    {
        this._$externalTools.set(name, tool);
    }

    /**
     * @description 拡張ツールの名前から取得
     *
     * @param  {string} name
     * @return {Tool|null}
     * @method
     * @public
     */
    getTool (name)
    {
        return this._$externalTools.has(name)
            ? this._$externalTools.get(name)
            : null;
    }

    /**
     * @description 名前からデフォルトToolクラスを取得
     *
     * @param  {string} name
     * @return {CommonTool}
     * @method
     * @public
     */
    getDefaultTool (name)
    {
        return this._$tools.get(name);
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    reset ()
    {
        const activeTool = this.activeTool;
        if (activeTool) {
            activeTool.dispatchEvent(EventType.END);
        }

        const tool = this.getDefaultTool("arrow");
        tool.dispatchEvent(EventType.START);
        this.activeTool = tool;
    }
}

Util.$tools = new Tools();

/**
 * @class
 */
class UserSetting
{
    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        const toolsSetting = document
            .getElementById("tools-setting");

        if (toolsSetting) {
            toolsSetting
                .addEventListener("click", (event) =>
                {
                    this.show(event);
                });
        }

        const object = this.getPublishSetting();

        const layerElement = document
            .getElementById("publish-layer-setting");

        if (layerElement) {
            layerElement
                .children[object.layer ? 1 : 0]
                .selected = true;

            layerElement
                .addEventListener("change", (event) =>
                {
                    const object = this.getPublishSetting();
                    object.layer = event.target.value === "1";

                    localStorage
                        .setItem(
                            `${Util.PREFIX}@user-publish-setting`,
                            JSON.stringify(object)
                        );

                });
        }

        const typeElement = document
            .getElementById("publish-type-setting");

        if (typeElement) {
            for (let idx = 0; idx < typeElement.children.length; ++idx) {

                const node = typeElement.children[idx];
                if (object.type !== node.value) {
                    continue;
                }

                node.selected = true;
                break;
            }

            typeElement
                .addEventListener("change", (event) =>
                {
                    const object = this.getPublishSetting();
                    object.type  = event.target.value;

                    localStorage
                        .setItem(
                            `${Util.PREFIX}@user-publish-setting`,
                            JSON.stringify(object)
                        );

                });
        }

        const modalElement = document
            .getElementById("modal-setting");

        if (modalElement) {

            if ("modal" in object) {
                modalElement.children[object.modal ? 0 : 1].selected = true;
            }

            modalElement
                .addEventListener("change", (event) =>
                {
                    const object = this.getPublishSetting();
                    object.modal = event.target.value === "1";

                    localStorage
                        .setItem(
                            `${Util.PREFIX}@user-publish-setting`,
                            JSON.stringify(object)
                        );

                });
        }

        const shortcutSetting = document
            .getElementById("shortcut-setting");

        if (shortcutSetting) {
            shortcutSetting
                .addEventListener("click", () =>
                {
                    Util.$shortcutSetting.show();
                });
        }
    }

    /**
     * @description 書き出し設定オブジェクトを返す
     *
     * @return {object}
     * @method
     * @public
     */
    getPublishSetting ()
    {
        const object = localStorage
            .getItem(`${Util.PREFIX}@user-publish-setting`);

        if (object) {
            return JSON.parse(object);
        }

        return {
            "layer": false,
            "type": "zlib"
        };
    }

    /**
     * @description ユーザー設定モーダルを表示
     *
     * @return {object}
     * @method
     * @public
     */
    show ()
    {
        const element = document
            .getElementById("user-setting");

        Util.$endMenu("user-setting");
        const toolsSetting = document
            .getElementById("tools-setting");

        element.style.display = "";
        element.style.left = `${toolsSetting.offsetLeft + 30}px`;
        element.style.top  = `${toolsSetting.offsetTop - element.clientHeight + 80}px`;

        element.setAttribute("class", "fadeIn");
    }
}

Util.$userSetting = new UserSetting();

/**
 * @class
 */
class BaseTool extends CommonTool
{
    /**
     * @description ツールのElementを管理するクラス
     *
     * @param {string} name
     * @constructor
     * @public
     */
    constructor (name)
    {
        super(name);
        this.initialize();
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @interface
     */
    // eslint-disable-next-line no-empty-function
    initialize () {}

    /**
     * @param {boolean} [active=true]
     * @method
     * @public
     */
    changeNodeEvent (active = true)
    {
        Util.$hitColor = null;

        const stageArea = document.getElementById("stage-area");
        if (stageArea) {
            const children = stageArea.children;
            for (let idx = 0; idx < children.length; ++idx) {

                const node = children[idx];
                if (node.dataset.shapePointer) {
                    node.remove();
                    --idx;
                    continue;
                }

                if (!node.dataset.child) {
                    continue;
                }

                node.style.pointerEvents = active ? "auto" : "none";

            }
        }
    }

    /**
     * @param  {object} object
     * @param  {number} x
     * @param  {number} y
     * @return {void}
     * @method
     * @public
     */
    createShape (object, x = 0, y = 0)
    {
        const scene   = Util.$currentWorkSpace().scene;
        const target  = Util.$timelineLayer.targetLayer;
        const layerId = target.dataset.layerId | 0;

        // ロック中のレイヤーの場合は何もしない
        const layer = scene.getLayer(layerId | 0);
        if (layer.lock) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const shape = workSpace.addLibrary(object);

        const frame = Util.$timelineFrame.currentFrame;

        // 挿入位置を取得
        const location = layer.adjustmentLocation(frame);

        // pointer
        const character = new Character();
        character.libraryId  = shape.id;
        character.startFrame = location.startFrame;
        character.endFrame   = location.endFrame;
        character.setPlace(location.startFrame, {
            "frame": location.startFrame,
            "matrix": [1, 0, 0, 1, x, y],
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": [],
            "depth": layer._$characters.length
        });

        // Shapeをレイヤーに追加して再描画
        layer.addCharacter(character);

        // タイムラインを再描画
        layer.reloadStyle();

        // ライブラリを再描画
        Util.$libraryController.reload();
    }

    /**
     * @param  {object} object
     * @param  {number} x
     * @param  {number} y
     * @return {void}
     * @public
     */
    createTextField (object, x = 0, y = 0)
    {
        const scene   = Util.$currentWorkSpace().scene;
        const target  = Util.$timelineLayer.targetLayer;
        const layerId = target.dataset.layerId | 0;

        const layer = scene.getLayer(layerId | 0);
        if (layer.lock) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const textField = workSpace.addLibrary(object);

        const frame = Util.$timelineFrame.currentFrame;

        // 挿入位置を取得
        const location = layer.adjustmentLocation(frame);

        // pointer
        const character = new Character();
        character.libraryId  = textField.id;
        character.startFrame = location.startFrame;
        character.endFrame   = location.endFrame;
        character.setPlace(location.startFrame, {
            "frame": location.startFrame,
            "matrix": [1, 0, 0, 1, x, y],
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": [],
            "depth": layer._$characters.length
        });

        // レイヤーに追加
        layer.addCharacter(character);

        // タイムラインを再描画
        layer.reloadStyle();

        // ライブラリを再描画
        Util.$libraryController.reload();
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    reloadScreen ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        Util
            .$currentWorkSpace()
            .scene
            .changeFrame(frame);
    }
}

/**
 * @class
 * @extends {BaseTool}
 */
class DrawTool extends BaseTool
{
    /**
     * @param {string} name
     * @constructor
     * @public
     */
    constructor (name)
    {
        super(name);
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // 専用カーソルを登録
        this.setCursor("crosshair");

        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor(this._$cursor);
            this.changeNodeEvent(false);
        });

        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            Util.$setCursor(this._$cursor);
            this.active = !!event.screen;
            if (event.screen) {
                this.mouseDown(event);
            }
        });

        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            Util.$setCursor(this._$cursor);
            if (event.screen && this.active) {

                // 親のイベントを中止する
                event.stopPropagation();

                this.mouseMove(event);
            }
        });

        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            Util.$setCursor(this._$cursor);

            // 親のイベントを中止する
            event.stopPropagation();

            if (event.screen) {

                Util.$timelineLayer.attachLayer();
                this.createCharacter();

                document
                    .getElementById("draw-rect")
                    .style.display = "none";

                Util.$tools.reset();
            }
        });
    }

    /**
     * @description 指定の座標に描画を行う
     *
     * @param  {string} name
     * @return {void}
     * @method
     * @public
     */
    createCharacter (name)
    {
        const element = document.getElementById("draw-rect");

        const { Graphics } =  window.next2d.display;

        const strokeSize = document
            .getElementById("stroke-size")
            .value | 0;

        const width  = (parseFloat(element.style.width)  + strokeSize) / Util.$zoomScale;
        const height = (parseFloat(element.style.height) + strokeSize) / Util.$zoomScale;
        if (width && height) {

            const workSpace = Util.$currentWorkSpace();
            workSpace.temporarilySaved();

            // draw
            const graphics = new Graphics();

            graphics
                .beginFill(document.getElementById("fill-color").value, 1);

            switch (name) {

                case "rectangle":
                    graphics.drawRect(0, 0, width, height);
                    break;

                case "circle":
                    graphics.drawEllipse(0, 0, width, height);
                    break;

                case "round-rect":
                    graphics.drawRoundRect(
                        0, 0, width, height,
                        Math.min(width, height) / 4
                    );
                    break;

            }
            graphics.endFill();

            const x  = (this.offsetX - Util.$offsetLeft) / Util.$zoomScale;
            const y  = (this.offsetY - Util.$offsetTop)  / Util.$zoomScale;
            const id = workSpace.nextLibraryId;

            this.createShape({
                "id": id,
                "type": "shape",
                "name": `Shape_${id}`,
                "symbol": "",
                "recodes": graphics._$recode ? graphics._$recode.slice(0) : [],
                "bounds": {
                    "xMin": 0,
                    "xMax": width,
                    "yMin": 0,
                    "yMax": height
                }
            }, x + strokeSize / 2, y + strokeSize / 2);

            if (strokeSize) {

                const graphics = new Graphics();
                graphics
                    .lineStyle(
                        strokeSize,
                        document.getElementById("stroke-color").value
                    );

                switch (name) {

                    case "rectangle":
                        graphics.drawRect(0, 0, width, height);
                        break;

                    case "circle":
                        graphics.drawEllipse(0, 0, width, height);
                        break;

                    case "round-rect":
                        graphics.drawRoundRect(
                            0, 0, width, height,
                            Math.min(width, height) / 4
                        );
                        break;

                }
                graphics.endLine();

                const offsetX = Math.abs(graphics._$xMax - graphics._$xMin) - width;
                const offsetY = Math.abs(graphics._$yMax - graphics._$yMin) - height;

                const x = this.offsetX - Util.$offsetLeft;
                const y = this.offsetY - Util.$offsetTop;

                const id = workSpace.nextLibraryId;

                this.createShape({
                    "id": id,
                    "type": "shape",
                    "name": `Shape_${id}`,
                    "symbol": "",
                    "recodes": graphics._$recode ? graphics._$recode.slice(0) : [],
                    "bounds": {
                        "xMin": -offsetX / 2,
                        "xMax": width + offsetX / 2,
                        "yMin": -offsetY / 2,
                        "yMax": height + offsetY / 2
                    }
                }, x + offsetX / 2, y + offsetY / 2);

            }

            // 再描画
            this.reloadScreen();
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        this.pageX = event.pageX;
        this.pageY = event.pageY;

        this.offsetX = event.offsetX;
        this.offsetY = event.offsetY;
        if (event.target.id !== "stage-area") {
            this.offsetX += event.target.offsetLeft;
            this.offsetY += event.target.offsetTop;
        }

        const element = document.getElementById("draw-rect");

        element.style.left    = `${event.pageX}px`;
        element.style.top     = `${event.pageY}px`;
        element.style.width   = "0px";
        element.style.height  = "0px";
        element.style.display = "";

        // fill color
        element.style.background = document.getElementById("fill-color").value;

        // stroke reset
        element.style.borderRadius = "";
        element.style.border       = "";

        const strokeSize = document.getElementById("stroke-size").value | 0;
        if (strokeSize) {
            element.style.borderRadius = `${strokeSize}px`;
            element.style.border       = `${strokeSize}px solid ${document.getElementById("stroke-color").value}`;
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        event.preventDefault();

        const x = event.pageX;
        const y = event.pageY;

        const element = document.getElementById("draw-rect");
        if (this.name === "circle") {
            element.style.borderRadius = "50%";
        }

        if (Util.$shiftKey) {

            const max = Math.max(
                Math.abs(x - this.pageX),
                Math.abs(y - this.pageY)
            );

            if (this.pageX < x) {
                element.style.left = `${this.pageX}px`;
            }
            if (this.pageY < y) {
                element.style.top = `${this.pageY}px`;
            }

            if (this.pageX > x) {
                this.offsetX = event.offsetX;
                element.style.left = `${this.pageX - max}px`;
            }
            if (this.pageY > y) {
                this.offsetY = event.offsetY;
                element.style.top = `${this.pageY - max}px`;
            }

            element.style.width  = `${max}px`;
            element.style.height = `${max}px`;

        } else {

            if (this.pageX > x) {
                this.offsetX = event.offsetX;
                element.style.left = `${x}px`;
            }
            if (this.pageY > y) {
                this.offsetY = event.offsetY;
                element.style.top = `${y}px`;
            }

            element.style.width  = `${Math.abs(x - this.pageX)}px`;
            element.style.height = `${Math.abs(y - this.pageY)}px`;
        }

        if (this.name === "round-rect") {
            const min = Math.min(
                parseFloat(element.style.width),
                parseFloat(element.style.height)
            );
            element.style.borderRadius = `${min / 8 | 0}px`;
        }
    }
}

/**
 * @class
 * @extends {BaseTool}
 */
class ArrowTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("arrow");

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$activeElement = "";

        /**
         * @type {array}
         * @private
         */
        this._$activeElements = [];
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        this.addEventListener(EventType.MOUSE_OVER, (event) =>
        {
            const target  = event.currentTarget;
            const layerId = target.dataset.layerId | 0;

            const lockElement = document
                .getElementById(`layer-lock-icon-${layerId}`);

            if (!lockElement
                || lockElement.classList.contains("icon-active")
            ) {
                return ;
            }

            Util.$setCursor("move");
        });

        this.addEventListener(EventType.MOUSE_OUT, () =>
        {
            Util.$setCursor("auto");
        });

        // コントローラーのプルダウンでライブラリの入れ替えを行った際のイベント
        this.addEventListener(EventType.CHANGE, (event) =>
        {
            this.changeCharacter(event);
        });

        // カーソルがスクリーンエリアから外れた時は非アクティブに
        this.addEventListener(EventType.MOUSE_LEAVE, () =>
        {
            this.active = false;
        });

        // 各種シーンによってのマウスダウンイベント
        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            this.active = false;
            switch (true) {

                case event.displayObject:
                    this.active = true;
                    this._$activeElement = ArrowTool.DISPLAY_OBJECT;
                    Util.$endMenu();
                    this.activateElement(event);
                    break;

                case event.screen:
                    this.active = true;
                    this._$activeElement = ArrowTool.SCREEN;
                    Util.$endMenu();
                    this.clear();
                    this.startRect(event);
                    break;

                case event.transform:
                    this.active = true;
                    this._$activeElement = ArrowTool.TRANSFORM;
                    Util.$endMenu();
                    this.startPosition(event);
                    break;

                case event.grid:
                    this.active = true;
                    this._$activeElement = ArrowTool.GRID;
                    Util.$endMenu();
                    this.startPosition(event);
                    break;

                default:
                    this._$activeElement = "";
                    break;

            }
        });

        // アクティブなエレメントに合わせたマウスムーブイベント
        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            if (!this.active) {
                return ;
            }

            // 親のイベントを中止する
            event.stopPropagation();
            event.preventDefault();

            switch (this._$activeElement) {

                case ArrowTool.DISPLAY_OBJECT:
                    this.moveDisplayObject(event);
                    break;

                case ArrowTool.SCREEN:
                    this.moveRect(event);
                    break;

                case ArrowTool.TRANSFORM:
                    this.moveTransform(event);
                    break;

                case ArrowTool.GRID:
                    this.moveGrid(event);
                    break;

                default:
                    break;

            }

        });

        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            if (!this._$activeElement) {
                return ;
            }

            switch (this._$activeElement) {

                case ArrowTool.SCREEN:
                    // 親のイベントを中止する
                    event.stopPropagation();
                    this.endRect();
                    break;

                case ArrowTool.DISPLAY_OBJECT:
                case ArrowTool.TRANSFORM:
                case ArrowTool.GRID:
                    break;

                default:
                    break;

            }

            // アクティブ判定を初期化
            this._$activeElement = "";

            // 連続セーブ防止フラグを初期化
            this._$saved = false;
        });

        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor(this._$cursor);
            this.changeNodeEvent();
        });

        // ツール終了時に初期化
        this.addEventListener(EventType.END, () =>
        {
            // 配列を初期化
            this.clearActiveElement();

            // スクリーンエリアの変形Elementを非表示に
            Util.$transformController.hide();
            Util.$gridController.hide();
            Util.$tweenController.clearPointer();

            // コントローラーエリアを初期化
            Util.$controller.default();
        });

        // シーン移動
        this.addEventListener(EventType.DBL_CLICK, (event) =>
        {
            if (event.screen && !this._$activeElements.length) {
                this.moveScene();
            }
        });

        // アクティブツールとして登録
        this.dispatchEvent(EventType.START);
        Util.$tools.activeTool = this;
    }

    /**
     * @description スクリーンで選択したElementの配列
     *
     * @return {array}
     * @readonly
     * @public
     */
    get activeElements ()
    {
        return this._$activeElements;
    }

    /**
     * @return {string}
     * @const
     * @static
     */
    static get SCREEN ()
    {
        return "screen";
    }

    /**
     * @return {string}
     * @const
     * @static
     */
    static get TRANSFORM ()
    {
        return "transform";
    }

    /**
     * @return {string}
     * @const
     * @static
     */
    static get DISPLAY_OBJECT ()
    {
        return "displayObject";
    }

    /**
     * @return {string}
     * @const
     * @static
     */
    static get GRID ()
    {
        return "grid";
    }

    /**
     * @description スクリーン、タイムライン、コントローラー全ての値を初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clear ()
    {
        // 配列を初期化
        this.clearActiveElement();

        // Shapeのポインターを初期化
        Util.$clearShapePointer();

        // スクリーンエリアの変形Elementを非表示に
        Util.$transformController.hide();
        Util.$gridController.hide();
        Util.$tweenController.clearPointer();

        // コントローラーエリアを初期化
        Util.$controller.default();

        // タイムラインエリアを初期化
        Util.$timelineLayer.clear();

        // 中心点を初期化
        Util.$referenceController.resetPointer();
    }

    /**
     * @description プロパティーの更新がある時はundo用にデータを内部保管する
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }

    /**
     * @description 選択中のDisplayObjectを非アクティブ化
     *
     * @return {void}
     * @method
     * @public
     */
    clearActiveElement ()
    {
        this._$activeElements.length = 0;
    }

    /**
     * @description 選択してるDisplayObjectをスクリーンから削除
     *
     * @return {void}
     * @method
     * @public
     */
    deleteDisplayObject ()
    {
        // 選択してるDisplayObjectがなければ終了
        const activeElements = this.activeElements;
        if (!activeElements.length) {
            return ;
        }

        this.save();

        const frame  = Util.$timelineFrame.currentFrame;
        const layers = new Map();
        const scene  = Util.$currentWorkSpace().scene;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];

            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            if (!layer) {
                continue;
            }

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            if (!character) {
                continue;
            }

            if (!layers.has(layer.id)) {
                layers.set(layer.id, {
                    "layer": layer,
                    "range": character.getRange(frame)
                });
            }

            character.remove(layer);
        }

        // 選択していたDisplayObjectをリセット
        this.clearActiveElement();

        // タイムラインを再構成
        for (const object of layers.values()) {

            const layer = object.layer;
            const range = object.range;

            const characters = layer.getActiveCharacter(range.startFrame);
            if (characters.length) {

                // 深度順に並び替え
                layer.sort(characters, frame);

                for (let idx = 0; idx < characters.length; ++idx) {
                    characters[idx].getPlace(frame).depth = idx;
                }

            } else {

                layer.addEmptyCharacter(
                    new EmptyCharacter({
                        "startFrame": range.startFrame,
                        "endFrame": range.endFrame
                    })
                );

            }

            layer.reloadStyle();
        }

        // 再描画
        this.reloadScreen();

        // 初期化
        this._$saved = false;
    }

    /**
     * @description 選択したDisplayObjectを配列に格納
     *              もし配列内に指定済みのDisplayObjectがあれば何もしない
     *
     * @param  {HTMLDivElement} element
     * @param  {boolean} [hit=false]
     * @return {boolean}
     * @method
     * @public
     */
    addElement (element, hit = false)
    {
        for (let idx = 0; idx < this._$activeElements.length; ++idx) {

            const target = this._$activeElements[idx];
            if (target.dataset.characterId === element.dataset.characterId) {

                if (Util.$shiftKey) {

                    Util
                        .$tweenController
                        .clearPointer();

                    // 服選択時は二度目の押下は対象外にする
                    this._$activeElements.splice(idx, 1);

                } else {

                    this._$activeElements.splice(idx, 1, element);

                }

                return false;
            }
        }

        // 複数選択でなければ配列は初期化する
        if (!hit && !Util.$shiftKey) {
            // 配列を初期化
            this.clearActiveElement();
        }

        this._$activeElements.push(element);

        // tweenの設定があればポインターを配置
        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );

        if (character.hasTween(range.startFrame)) {
            Util
                .$tweenController
                .clearPointer()
                .relocationPointer();
        }

        return true;
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    activateElement (event)
    {
        let target = this.target;

        const layerId = target.dataset.layerId | 0;

        const workSpace = Util.$currentWorkSpace();

        const scene = workSpace.scene;
        const layer = scene.getLayer(layerId);

        // タイムラインでロック中のDisplayObjectは何もしない
        if (layer.lock) {
            return ;
        }

        // 現在の座標をセット
        this.pageX = event.pageX;
        this.pageY = event.pageY;

        // タイムラインのアクティブなElementを初期化
        Util.$timelineLayer.clear();

        const character = layer.getCharacter(
            target.dataset.characterId | 0
        );

        // 指定のDisplayObjectをクローンしてスクリーンに配置
        if (Util.$altKey) {

            const clone = character.clone();

            // クローンしたDisplayObjectを最前面にセット
            for (const [keyFrame, place] of clone._$places) {

                let depth = 0;
                const characters = layer.getActiveCharacter(keyFrame);
                for (let idx = 0; idx < characters.length; ++idx) {
                    depth = Math.max(characters[idx].getPlace(keyFrame).depth, depth);
                }

                place.depth = depth + 1;
            }

            // レイヤーにセット
            layer.addCharacter(clone);

            const frame = Util.$timelineFrame.currentFrame;

            // スクリーンに配置
            Util
                .$screen
                .appendCharacter(clone, frame, layer.id);

            target = document
                .getElementById(`character-${clone.id}`);

        }

        // アクティブ登録
        this.addElement(target);

        // コントローラーエリアの情報を更新
        this.updateControllerProperty();

        // Shapeは描画反映の判定で毎回ヒット判定を行う
        if (this._$activeElements.length === 1) {
            character.showShapeColor(event);
        }

        // 拡大縮小回転のElementのポイントを表示して再計算
        Util
            .$transformController
            .show()
            .relocation();

        // 9sliceのElementのポイントを表示して再計算
        Util
            .$gridController
            .show()
            .relocation();

        // 選択されたDisplayObjectが配置されてるタイムラインをアクティブに
        this.activeTimeline();
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    activeTimeline ()
    {
        // 初期化
        Util.$timelineLayer.clear();

        const frame = Util.$timelineFrame.currentFrame;

        // 複数選択可能にするため、擬似的にctrlキーをOnにする
        const cacheValue = Util.$ctrlKey;
        Util.$ctrlKey = this._$activeElements.length > 1;

        for (let idx = 0; idx < this._$activeElements.length; ++idx) {

            const element = this._$activeElements[idx];

            const layerId = element.dataset.layerId | 0;

            const layerElement = document
                .getElementById(`layer-id-${layerId}`);

            if (!Util.$timelineLayer.targetLayers.has(layerElement.id)) {
                Util.$timelineLayer.targetLayer = layerElement;
            }

            Util
                .$timelineLayer
                .addTargetFrame(
                    layerId,
                    document.getElementById(`${layerId}-${frame}`)
                );
        }
        Util.$ctrlKey = cacheValue;
    }

    /**
     * @description コントローラーのプルダウン変更時のイベント関数
     *              指定されたライブラリ内のオブジェクトと切り替える
     *
     * @return {void}
     * @method
     * @public
     */
    changeCharacter (event)
    {
        if (this._$activeElements.length !== 1) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const target = this._$activeElements[0];

        const layerId = target.dataset.layerId | 0;
        const layer   = scene.getLayer(layerId);

        const characterId = target.dataset.characterId | 0;
        const character   = layer.getCharacter(characterId);

        // update
        character._$libraryId = event.target.value | 0;
        character._$image     = null;

        const instance = workSpace
            .getLibrary(character._$libraryId);

        if (instance.type === "container") {
            for (const place of character._$places.values()) {
                place.loop = Util.$getDefaultLoopConfig();
            }
        }

        const range = character.getRange(Util.$timelineFrame.currentFrame);
        if (character.hasTween(range.startFrame)) {
            Util
                .$tweenController
                .clearPointer()
                .relocationPointer();
        }

        const icon = document
            .getElementById("instance-type-name")
            .getElementsByTagName("i")[0];

        icon.setAttribute("class", `library-type-${instance.type}`);

        // スクリーンエリアのDisplayObjectを再描画
        this.reloadScreen();

        // アクティブなDisplayObjectの変形Elementを再計算
        Util
            .$transformController
            .show()
            .relocation();
    }

    /**
     * @description スクリーン上でマウスで選択した範囲のDisplayObjectを選択する起動関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    startRect (event)
    {
        this.pageX = event.pageX;
        this.pageY = event.pageY;

        const element = document.getElementById("stage-rect");
        element.style.left    = `${event.pageX}px`;
        element.style.top     = `${event.pageY}px`;
        element.style.width   = "0px";
        element.style.height  = "0px";
        element.style.display = "";
    }

    /**
     * @description スクリーン上でマウスで選択する範囲調整関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveRect (event)
    {
        const x = event.pageX;
        const y = event.pageY;

        const element = document.getElementById("stage-rect");

        if (this.pageX > x) {
            element.style.left = `${x}px`;
        }

        if (this.pageY > y) {
            element.style.top = `${y}px`;
        }

        element.style.width  = `${Math.abs(x - this.pageX)}px`;
        element.style.height = `${Math.abs(y - this.pageY)}px`;
    }

    /**
     * @description スクリーン上でマウスで選択する範囲の最終位置
     *
     * @return {void}
     * @method
     * @public
     */
    endRect ()
    {
        const element = document.getElementById("stage-rect");
        element.style.display = "none";

        const width   = parseFloat(element.style.width);
        const height  = parseFloat(element.style.height);
        if (!width || !height) {
            return ;
        }

        const left    = parseFloat(element.style.left);
        const top     = parseFloat(element.style.top);
        const right   = left + width;
        const bottom  = top  + height;

        const children = document
            .getElementById("stage-area")
            .children;

        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];
            switch (true) {

                case !node.dataset.child:
                case node.dataset.child === "tween":
                case node.dataset.preview === "true":
                    continue;

                default:
                    break;

            }

            const rect = node.getBoundingClientRect();
            switch (true) {

                case rect.bottom < top:
                case rect.top    > bottom:
                case rect.right  < left:
                case rect.left   > right:
                    continue;

                default:
                    break;

            }

            const layerId = node.dataset.layerId | 0;

            const lockElement = document
                .getElementById(`layer-lock-icon-${layerId}`);

            if (lockElement.classList.contains("icon-active")) {
                continue;
            }

            this.addElement(node, true);
        }

        if (this._$activeElements.length) {
            this.updateControllerProperty();

            Util
                .$transformController
                .show()
                .relocation();

            this.activeTimeline();
        }
    }

    /**
     * @description マウスダウンした時の座標を保存
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    startPosition (event)
    {
        this.pageX = event.pageX;
        this.pageY = event.pageY;
    }

    /**
     * @description スクリーンエリアでの拡大縮小回転の分岐処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveGrid (event)
    {
        Util.$setCursor("move");

        event.preventDefault();

        const dx = (event.pageX - this.pageX) / Util.$zoomScale;
        const dy = (event.pageY - this.pageY) / Util.$zoomScale;

        let x = +document
            .getElementById("nine-slice-setting-x")
            .value;

        let y = +document
            .getElementById("nine-slice-setting-y")
            .value;

        let w = +document
            .getElementById("nine-slice-setting-w")
            .value;

        let h = +document
            .getElementById("nine-slice-setting-h")
            .value;

        switch (this.target.id) {

            case "grid-top-left":
                x += dx;
                w -= dx;
                y += dy;
                h -= dy;
                break;

            case "grid-top-right":
                w += dx;
                y += dy;
                break;

            case "grid-bottom-left":
                x += dx;
                w -= dx;
                h += dy;
                break;

            case "grid-bottom-right":
                w += dx;
                h += dy;
                break;

        }

        document
            .getElementById("nine-slice-setting-x")
            .value = `${x}`;

        document
            .getElementById("nine-slice-setting-y")
            .value = `${y}`;

        document
            .getElementById("nine-slice-setting-w")
            .value = `${w}`;

        document
            .getElementById("nine-slice-setting-h")
            .value = `${h}`;

        this.startPosition(event);

        Util
            .$gridController
            .updateShapeGrid(x, y, w, h);

        this.reloadScreen();
    }

    /**
     * @description スクリーンエリアでの拡大縮小回転の分岐処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveTransform (event)
    {
        Util.$setCursor("move");

        event.preventDefault();

        this.save();

        let reload = false;
        switch (this.target.id) {

            case "scale-top-left": // 左上
                {
                    const resultX = this.updateLeftScaleX(event);
                    const resultY = this.updateTopScaleY(event);
                    if (resultX || resultY) {
                        reload = true;
                        if (Util.$shiftKey) {
                            this.adjustmentScale(resultX, resultY);
                        }
                    }
                }
                break;

            case "scale-center-left": // 左中央
                if (this.updateLeftScaleX(event)) {
                    reload = true;
                }
                break;

            case "scale-bottom-left": // 左下
                {
                    const resultX = this.updateLeftScaleX(event);
                    const resultY = this.updateBottomScaleY(event);
                    if (resultX || resultY) {
                        reload = true;
                        if (Util.$shiftKey) {
                            this.adjustmentScale(resultX, resultY);
                        }
                    }
                }
                break;

            case "scale-center-bottom": // 中央下
                if (this.updateBottomScaleY(event)) {
                    reload = true;
                }
                break;

            case "scale-bottom-right": // 右下
                {
                    const resultX = this.updateRightScaleX(event);
                    const resultY = this.updateBottomScaleY(event);
                    if (resultX || resultY) {
                        reload = true;
                        if (Util.$shiftKey) {
                            this.adjustmentScale(resultX, resultY);
                        }
                    }
                }
                break;

            case "scale-center-right": // 中央右
                if (this.updateRightScaleX(event)) {
                    reload = true;
                }
                break;

            case "scale-top-right": // 右上
                {
                    const resultX = this.updateRightScaleX(event);
                    const resultY = this.updateTopScaleY(event);
                    if (resultX || resultY) {
                        reload = true;
                        if (Util.$shiftKey) {
                            this.adjustmentScale(resultX, resultY);
                        }
                    }
                }
                break;

            case "scale-center-top": // 中央上
                if (this.updateTopScaleY(event)) {
                    reload = true;
                }
                break;

            case "target-rotation": // 回転
                if (this.updateRotate(event)) {
                    reload = true;
                }
                break;

            case "reference-point": // 中心点
                this.updateReferencePoint(event);
                break;

            default:
                return ;

        }

        this.startPosition(event);
        if (reload) {
            this.reloadScreen();
        }

    }

    /**
     * @description マウスでの拡大縮小回転の時にShiftを押下してる時はロック時と同じく対比を固定
     *
     * @param  {number} x
     * @param  {number} y
     * @return {void}
     * @method
     * @public
     */
    adjustmentScale (x = 0, y = 0)
    {
        if (x !== y) {

            if (x) {

                const yScale = +document
                    .getElementById("transform-scale-y")
                    .value;

                Util
                    .$transformController
                    .updateScaleY((yScale + x) / 100);

            }

            if (y) {

                const xScale = +document
                    .getElementById("transform-scale-x")
                    .value;

                Util
                    .$transformController
                    .updateScaleX((xScale + y) / 100);

            }

        }
    }

    /**
     * @description マウスでの拡大縮小時の上部のx座標計算
     *              マウスが下に移動したら縮小、上に移動したら拡大
     *
     * @param  {MouseEvent} event
     * @return {number}
     * @method
     * @public
     */
    updateTopScaleY (event)
    {
        const updateScaleY = this.pageY - event.pageY;
        if (!updateScaleY) {
            return 0;
        }

        const yScale = +document
            .getElementById("transform-scale-y")
            .value;

        Util
            .$transformController
            .updateScaleY((yScale + updateScaleY) / 100);

        return updateScaleY;
    }

    /**
     * @description 回転処理、右に移動したら右回転、左に移動したら左回転
     *
     * @param  {MouseEvent} event
     * @return {number}
     * @method
     * @public
     */
    updateRotate (event)
    {
        const updateRotate = event.pageX - this.pageX;
        if (!updateRotate) {
            return 0;
        }

        const rotate = +document
            .getElementById("transform-rotate")
            .value;

        let value = rotate + updateRotate;
        value = Util.$clamp(
            (value | 0) % 360,
            TransformController.MIN_ROTATE,
            TransformController.MAX_ROTATE
        );
        if (0 > value) {
            value += 360;
        }

        Util
            .$transformController
            .updateRotate(value);

        return 1;
    }

    /**
     * @description 中心点を移動
     *
     * @param  {MouseEvent} event
     * @return {number}
     * @method
     * @public
     */
    updateReferencePoint (event)
    {
        const mouseX = (event.pageX - this.pageX) / Util.$zoomScale;
        const mouseY = (event.pageY - this.pageY) / Util.$zoomScale;

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;

        const element = document.getElementById("reference-point");
        if (activeElements.length > 1) {

            const point = Util
                .$referenceController
                .pointer;

            point.x += mouseX;
            point.y += mouseY;

            Util
                .$referenceController
                .setInputValue(point.x, point.y);

            element.style.left = `${element.offsetLeft + mouseX}px`;
            element.style.top  = `${element.offsetTop  + mouseY}px`;

        } else {

            const target  = activeElements[0];
            const layerId = target.dataset.layerId | 0;
            const scene   = Util.$currentWorkSpace().scene;
            const layer   = scene.getLayer(layerId);

            // 座標を更新
            const character = layer
                .getCharacter(target.dataset.characterId | 0);

            character._$referencePoint.x += mouseX;
            character._$referencePoint.y += mouseY;

            const point = character.referencePoint;

            Util
                .$referenceController
                .setInputValue(point.x, point.y);

            // 画面の拡大縮小対応
            const pointX = point.x * Util.$zoomScale;
            const pointY = point.y * Util.$zoomScale;

            const characterElement = document
                .getElementById(`character-${character.id}`);

            const xMin   = characterElement.offsetLeft;
            const yMin   = characterElement.offsetTop;
            const width  = characterElement.offsetWidth;
            const height = characterElement.offsetHeight;

            element.style.left = `${pointX + xMin + width  / 2 - 8}px`;
            element.style.top  = `${pointY + yMin + height / 2 - 8}px`;
        }
    }

    /**
     * @description マウスでの拡大縮小時の上部のy座標計算
     *              マウスが右に移動したら縮小、左に移動したら拡大
     *
     * @param  {MouseEvent} event
     * @return {number}
     * @method
     * @public
     */
    updateLeftScaleX (event)
    {
        const updateScaleX = this.pageX - event.pageX;
        if (!updateScaleX) {
            return 0;
        }

        const xScale = +document
            .getElementById("transform-scale-x")
            .value;

        Util
            .$transformController
            .updateScaleX((xScale + updateScaleX) / 100);

        return updateScaleX;
    }

    /**
     * @description マウスでの拡大縮小時の下部のy座標計算
     *              マウスが下に移動したら拡大、上に移動したら縮小なので、反転して計算する
     *
     * @param  {MouseEvent} event
     * @return {number}
     * @method
     * @public
     */
    updateBottomScaleY (event)
    {
        const updateScaleY = event.pageY - this.pageY;
        if (!updateScaleY) {
            return 0;
        }

        const yScale = +document
            .getElementById("transform-scale-y")
            .value;

        Util
            .$transformController
            .updateScaleY((yScale + updateScaleY) / 100);

        return updateScaleY;
    }

    /**
     * @description マウスでの拡大縮小時の下部のx座標計算
     *              マウスが右に移動したら拡大、左に移動したら縮小なので、反転して計算する
     *
     * @param  {MouseEvent} event
     * @return {number}
     * @method
     * @public
     */
    updateRightScaleX (event)
    {
        const updateScaleX = event.pageX - this.pageX;
        if (!updateScaleX) {
            return 0;
        }

        const xScale = +document
            .getElementById("transform-scale-x")
            .value;

        Util
            .$transformController
            .updateScaleX((xScale + updateScaleX) / 100);

        return updateScaleX;
    }

    /**
     * @description DisplayObjectのマウス移動処理関数
     *
     * @param  {MouseEvent} [event=null]
     * @return {void}
     * @method
     * @public
     */
    moveDisplayObject (event = null)
    {
        this.save();

        const scene = Util.$currentWorkSpace().scene;
        const frame = Util.$timelineFrame.currentFrame;

        const dx = event ? event.pageX - this.pageX : this.pageX;
        const dy = event ? event.pageY - this.pageY : this.pageY;

        let xMin = Number.MAX_VALUE;
        let yMin = Number.MAX_VALUE;
        for (let idx = 0; idx < this._$activeElements.length; ++idx) {

            const object  = this._$activeElements[idx];
            const element = document.getElementById(object.id);

            // ロックしている場合など、スクリーンにElementが存在しない場合はスキップ
            if (!element) {
                continue;
            }

            const layerId = element.dataset.layerId | 0;

            const layer = scene.getLayer(layerId);

            const character = layer
                .getCharacter(element.dataset.characterId | 0);

            // fixed logic
            this.initPlace(character, layerId, frame);

            const place  = character.getPlace(frame);
            const matrix = place.matrix;
            matrix[4] += dx / Util.$zoomScale;
            matrix[5] += dy / Util.$zoomScale;

            const range  = character.getRange(frame);
            const bounds = character.getBounds(place.matrix, place, range);
            character.screenX = bounds.xMin;
            character.screenY = bounds.yMin;

            let divStyle = "";
            divStyle += `pointer-events: ${element.dataset.pointer};`;

            if (layer.maskId !== null) {
                const maskLayer = scene.getLayer(layer.maskId);
                if (maskLayer.lock && maskLayer._$characters.length) {

                    const maskCharacter = maskLayer._$characters[0];
                    const maskImage     = maskCharacter.getImage();

                    const maskSrc    = maskImage.src;
                    const maskWidth  = maskImage.width;
                    const maskHeight = maskImage.height;

                    const x = maskCharacter.screenX - character.screenX;
                    const y = maskCharacter.screenY - character.screenY;

                    divStyle += `mask: url(${maskSrc}), none;`;
                    divStyle += `-webkit-mask: url(${maskSrc}), none;`;
                    divStyle += `mask-size: ${maskWidth}px ${maskHeight}px;`;
                    divStyle += `-webkit-mask-size: ${maskWidth}px ${maskHeight}px;`;
                    divStyle += "mask-repeat: no-repeat;";
                    divStyle += "-webkit-mask-repeat: no-repeat;";
                    divStyle += `mask-position: ${x}px ${y}px;`;
                    divStyle += `-webkit-mask-position: ${x}px ${y}px;`;

                    const image = character.getImage();
                    divStyle += `mix-blend-mode: ${image.style.mixBlendMode};`;
                    divStyle += `filter: ${image.style.filter};`;

                }
            }

            const left = Util.$offsetLeft + bounds.xMin * Util.$zoomScale;
            const top  = Util.$offsetTop  + bounds.yMin * Util.$zoomScale;

            divStyle += `left: ${left}px;`;
            divStyle += `top: ${top}px;`;
            element.setAttribute("style", divStyle);

            // move resize rect
            xMin = Math.min(xMin, character.x);
            yMin = Math.min(yMin, character.y);

            // tweenの座標を再計算してポインターを再配置
            character.relocationTween(frame);
        }

        // 移動位置を更新
        if (event) {
            this.pageX = event.pageX;
            this.pageY = event.pageY;
        }

        document.getElementById("object-x").value = xMin;
        document.getElementById("object-y").value = yMin;

        Util
            .$transformController
            .show()
            .relocation();

        Util
            .$gridController
            .show()
            .relocation();

        const element = document
            .getElementById("timeline-onion-skin");

        if (element && element.classList.contains("onion-skin-active")) {
            this.reloadScreen();
        }
    }

    /**
     * @description DisplayObjectのPlaceObjectがない時の処理関数
     *
     * @param  {Character} character
     * @param  {number} layer_id
     * @param  {number} frame
     * @return {void}
     * @public
     */
    initPlace (character, layer_id, frame)
    {
        let prevFrame = frame;
        while (prevFrame > 0) {

            const frameElement = document
                .getElementById(`${layer_id}-${prevFrame}`);

            if (frameElement.dataset.frameState === "key-frame") {

                if (!character._$places.has(prevFrame)) {
                    character.setPlace(prevFrame,
                        character.getClonePlace(prevFrame)
                    );
                }

                break;
            }

            prevFrame--;
        }
    }

    /**
     * @description コントローラーの変形にあるInputの値を再計算して更新
     * @return {void}
     * @method
     * @public
     */
    updateControllerProperty ()
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        let character   = null;

        // 拡大縮小回転の範囲とポインターの情報を再取得
        let tx   = Number.MAX_VALUE;
        let ty   = Number.MAX_VALUE;
        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;
        for (let idx = 0; idx < this._$activeElements.length; ++idx) {

            const moveTarget = this._$activeElements[idx];

            const layerId = moveTarget.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            character = layer.getCharacter(
                moveTarget.dataset.characterId | 0
            );

            tx = Math.min(tx, character.x);
            ty = Math.min(ty, character.y);

            const bounds = character.getBounds();
            xMin = Math.min(xMin, bounds.xMin);
            xMax = Math.max(xMax, bounds.xMax);
            yMin = Math.min(yMin, bounds.yMin);
            yMax = Math.max(yMax, bounds.yMax);
        }

        document.getElementById("object-width").value  = Math.abs(xMax - xMin);
        document.getElementById("object-height").value = Math.abs(yMax - yMin);
        document.getElementById("object-x").value = tx;
        document.getElementById("object-y").value = ty;

        // オブジェクト設定を表示して、Stage情報は非表示にする
        Util.$controller.showObjectSetting([
            "object-area"
        ]);
        Util.$controller.hideObjectSetting([
            "stage-setting",
            "fill-color-setting"
        ]);

        if (this._$activeElements.length > 1) {

            // 複数選択時は変形以外のコントローラーを非表示にする
            Util.$controller.hideObjectSetting([
                "object-setting",
                "color-setting",
                "blend-setting",
                "loop-setting",
                "filter-setting",
                "video-setting",
                "instance-setting",
                "text-setting",
                "nine-slice-setting",
                "sound-setting",
                "ease-setting"
            ]);

            document
                .getElementById("transform-scale-x")
                .value = 100;

            document
                .getElementById("transform-scale-y")
                .value = 100;

            document
                .getElementById("transform-rotate")
                .value = 0;

        } else {
            character.showController();
        }
    }

    /**
     * @description 親のMovieClipへシーン移動
     *
     * @return {void}
     * @method
     * @public
     */
    moveScene ()
    {
        const node = document
            .getElementById("scene-name-menu-list")
            .lastElementChild;

        if (node) {

            // シーン移動
            Util.$sceneChange.execute(
                node.dataset.libraryId | 0
            );

            // リストから削除
            node.remove();
        }
    }
}

/**
 * @class
 * @extends {BaseTool}
 */
class BucketTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("bucket");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            this.setCursor();
            this.changeNodeEvent();
        });

        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            this.setCursor();

            // 親のイベントを中止する
            event.stopPropagation();

            if (event.displayObject) {
                this.mouseDown(event);
            }
        });

        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            this.setCursor();

            // 親のイベントを中止する
            event.stopPropagation();
        });

        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            this.setCursor();

            // 親のイベントを中止する
            event.stopPropagation();

            Util.$tools.reset();
        });
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    setCursor ()
    {
        const color = Util.$intToRGB(
            `0x${document.getElementById("fill-color").value.slice(1)}` | 0
        );
        Util.$setCursor(`url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="rgb(${color.R},${color.G},${color.B})" d="M24 19.007c0-3.167-1.409-6.771-2.835-9.301l-.006-.01-.014-.026c-.732-1.392-1.914-3.052-3.619-4.757-2.976-2.976-5.476-3.912-6.785-3.913-.413 0-.708.094-.859.245l-.654.654c-1.898-.236-3.42.105-4.294.982-.876.875-1.164 2.159-.792 3.524.242.893.807 1.891 1.752 2.836.867.867 2.062 1.684 3.615 2.327.488-.839 1.654-1.019 2.359-.315.586.586.584 1.533-.002 2.119s-1.533.589-2.121 0c-.229-.229-.366-.515-.416-.812-1.646-.657-3.066-1.534-4.144-2.612-.728-.728-1.289-1.528-1.664-2.349l-2.835 2.832c-.445.447-.685 1.064-.686 1.82.001 1.635 1.122 3.915 3.714 6.506 2.764 2.764 5.58 4.243 7.431 4.243.649 0 1.181-.195 1.548-.562l8.086-8.079c.911.875-.777 3.541-.777 4.65 0 1.104.896 1.999 2 1.998 1.104 0 1.998-.895 1.998-2zm-18.912-12.974c-.236-.978-.05-1.845.554-2.444.526-.53 1.471-.791 2.656-.761l-3.21 3.205zm9.138 2.341l-.03-.029c-1.29-1.291-3.802-4.354-3.095-5.062.715-.715 3.488 1.521 5.062 3.095.862.863 2.088 2.248 2.938 3.459-1.718-1.073-3.493-1.469-4.875-1.463zm-3.875 12.348c-.547-.082-1.5-.547-1.9-.928l7.086-7.086c.351.37 1.264.931 1.753 1.075l-6.939 6.939z"/></svg>'),auto`);
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        const element = event.target;
        if (element.dataset.instanceType === "shape") {

            const { Graphics } = window.next2d.display;

            const workSpace = Util.$currentWorkSpace();
            workSpace.temporarilySaved();

            const instance = workSpace.getLibrary(
                element.dataset.libraryId | 0
            );

            const color = Util.$intToRGB(
                `0x${document.getElementById("fill-color").value.slice(1)}` | 0
            );

            switch (instance._$recodes[instance._$recodes.length - 1]) {

                case Graphics.END_FILL:
                    instance._$recodes.splice(
                        instance._$recodes.length - 6,
                        6,
                        Graphics.FILL_STYLE,
                        color.R,
                        color.G,
                        color.B,
                        255,
                        Graphics.END_FILL
                    );
                    break;

                case Graphics.END_STROKE:
                    instance._$recodes.push(
                        Graphics.FILL_STYLE,
                        color.R,
                        color.G,
                        color.B,
                        255,
                        Graphics.END_FILL
                    );
                    break;

                default:
                    break;

            }

            instance.cacheClear();

            // 再描画
            this.reloadScreen();
        }
    }
}

/**
 * @class
 * @extends {DrawTool}
 */
class CircleTool extends DrawTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("circle");
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    createCharacter ()
    {
        super.createCharacter("circle");
    }
}

/**
 * @class
 * @extends {BaseTool}
 */
class HandTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("hand");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        this.setCursor("grab");

        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor(this._$cursor);
            this.changeNodeEvent(false);
        });

        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            Util.$setCursor(this._$cursor);

            if (!this.active) {
                return ;
            }

            // 画面をスクロール
            const element = document.getElementById("screen");
            element.scrollLeft += this.pageX - event.pageX;
            element.scrollTop  += this.pageY - event.pageY;

            // 値を更新
            this.pageX = event.pageX;
            this.pageY = event.pageY;
        });

        this.addEventListener(EventType.MOUSE_UP, () =>
        {
            this.active = false;
            this.setCursor("grab");
            Util.$setCursor(this._$cursor);
        });

        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            this.active = true;

            this.setCursor("grabbing");
            Util.$setCursor(this._$cursor);

            this.pageX = event.pageX;
            this.pageY = event.pageY;
        });
    }
}

/**
 * @class
 * @extends {BaseTool}
 */
class PenTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("pen");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            this.setCursor();
            this.changeNodeEvent(false);
        });

        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            this.setCursor();

            // 親のイベントを中止する
            event.stopPropagation();

            // ペンで追加したElementを削除
            this.clearPenPointer();

            // 初期座標をセット
            let offsetX = event.offsetX;
            let offsetY = event.offsetY;
            if (event.target.id !== "stage-area") {
                offsetX += event.target.offsetLeft;
                offsetY += event.target.offsetTop;
            }

            this.offsetX = offsetX;
            this.offsetY = offsetY;
        });

        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            this.setCursor();

            // 親のイベントを中止する
            event.stopPropagation();

            if (event.screen && this.active) {
                this.mouseMove(event);
            }
        });

        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            this.setCursor();

            // 親のイベントを中止する
            event.stopPropagation();

            this.mouseUp();
        });
    }

    /**
     * @description ペンで使用してるポインターelementを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clearPenPointer ()
    {
        const element  = document
            .getElementById("stage-area");

        for (let idx = 0; element.children.length > idx; ++idx) {

            const node = element.children[idx];
            if (!node.dataset.penPointer) {
                continue;
            }

            node.remove();
            --idx;
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    setCursor ()
    {
        const color = Util.$intToRGB(
            `0x${document.getElementById("stroke-color").value.slice(1)}` | 0
        );
        Util.$setCursor(`url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 24 24"><path fill="rgb(${color.R},${color.G},${color.B})" d="M1.438 16.875l5.688 5.689-7.126 1.436 1.438-7.125zm22.562-11.186l-15.46 15.46-5.688-5.689 15.459-15.46 5.689 5.689zm-4.839-2.017l-.849-.849-12.614 12.599.85.849 12.613-12.599z"/></svg>') 0 12, auto`);
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        const width = document.getElementById("stroke-size").value | 0;
        if (width) {

            event.preventDefault();

            let x = event.offsetX;
            let y = event.offsetY;
            if (event.target.id !== "stage-area") {
                x += event.target.offsetLeft;
                y += event.target.offsetTop;
            }

            const element = document.getElementById("stage-area");

            const div = document.createElement("div");
            div.dataset.penPointer = "true";
            div.classList.add("pen-pointer");

            div.style.width           = `${width}px`;
            div.style.height          = `${width}px`;
            div.style.left            = `${x}px`;
            div.style.top             = `${y}px`;
            div.style.backgroundColor = document.getElementById("stroke-color").value;
            div.style.borderRadius    = `${width / 2}px`;

            element.appendChild(div);
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        Util.$timelineLayer.attachLayer();
        const { Shape } = window.next2d.display;

        const thickness = document
            .getElementById("stroke-size").value | 0;

        const shape = new Shape();
        shape.graphics.lineStyle(
            thickness,
            document.getElementById("stroke-color").value
        );

        const x = this.offsetX - Util.$offsetLeft;
        const y = this.offsetY - Util.$offsetTop;
        shape.graphics.moveTo(0, 0);

        const element  = document.getElementById("stage-area");
        const children = element.children;
        for (let idx = 0; children.length > idx; ++idx) {

            const node = children[idx];
            if (!node.dataset.penPointer) {
                continue;
            }

            shape.graphics.lineTo(
                (node.offsetLeft - Util.$offsetLeft - x) / Util.$zoomScale,
                (node.offsetTop  - Util.$offsetTop  - y) / Util.$zoomScale
            );

            node.remove();
            --idx;
        }
        shape.graphics.endLine();

        const id = Util.$currentWorkSpace().nextLibraryId;
        const dx = (x + thickness) / 2 / Util.$zoomScale;
        const dy = (y + thickness) / 2 / Util.$zoomScale;
        this.createShape({
            "id": id,
            "type": "shape",
            "name": `Shape_${id}`,
            "symbol": "",
            "recodes": shape.graphics._$recode.slice(0),
            "bounds": {
                "xMin": shape.graphics._$xMin,
                "xMax": shape.graphics._$xMax,
                "yMin": shape.graphics._$yMin,
                "yMax": shape.graphics._$yMax
            }
        }, dx, dy);

        // 再描画
        this.reloadScreen();

        Util.$tools.reset();
    }
}

/**
 * @class
 * @extends {DrawTool}
 */
class RectangleTool extends DrawTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("rectangle");
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    createCharacter ()
    {
        super.createCharacter("rectangle");
    }
}

/**
 * @class
 * @extends {DrawTool}
 */
class RoundRectTool extends DrawTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("round-rect");
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    createCharacter ()
    {
        super.createCharacter("round-rect");
    }
}

/**
 * @class
 * @extends {BaseTool}
 */
class TextTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("text");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor("text");
            this.changeNodeEvent(false);
        });

        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            Util.$setCursor("text");

            // 親のイベントを中止する
            event.stopPropagation();

            if (event.screen) {
                this.mouseDown(event);
            }
        });

        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            Util.$setCursor("text");

            // 親のイベントを中止する
            event.stopPropagation();

            if (event.screen) {
                this.mouseMove(event);
            }
        });

        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            Util.$setCursor("text");

            if (event.screen) {
                // 親のイベントを中止する
                event.stopPropagation();

                // マウスアップ処理
                this.mouseUp();

                // 選択ツールに戻す
                Util.$tools.reset();
            }
        });
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        // オフセット値を調整
        let offsetX = event.offsetX;
        let offsetY = event.offsetY;
        if (event.target.id !== "stage-area") {
            offsetX += event.target.offsetLeft;
            offsetY += event.target.offsetTop;
        }

        // 初期座標をセット
        this.pageX   = event.pageX;
        this.pageY   = event.pageY;
        this.offsetX = offsetX;
        this.offsetY = offsetY;

        const element = document.getElementById("draw-text");
        element.style.left    = `${event.pageX}px`;
        element.style.top     = `${event.pageY}px`;
        element.style.width   = "0px";
        element.style.height  = "0px";
        element.style.display = "";
        element.style.border = "1px dashed gray";
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        event.preventDefault();

        const x = event.pageX;
        const y = event.pageY;

        const element = document.getElementById("draw-text");

        if (this.pageX > x) {
            this.offsetX = event.offsetX;
            element.style.left = `${x}px`;
        }
        if (this.pageY > y) {
            this.offsetY = event.offsetY;
            element.style.top = `${y}px`;
        }

        element.style.width  = `${Math.abs(x - this.pageX)}px`;
        element.style.height = `${Math.abs(y - this.pageY)}px`;
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        Util.$timelineLayer.attachLayer();

        const element = document.getElementById("draw-text");
        const workSpace = Util.$currentWorkSpace();
        workSpace.temporarilySaved();

        const x      = (this.offsetX - Util.$offsetLeft) / Util.$zoomScale;
        const y      = (this.offsetY - Util.$offsetTop)  / Util.$zoomScale;
        const width  = parseFloat(element.style.width)  / Util.$zoomScale;
        const height = parseFloat(element.style.height) / Util.$zoomScale;

        const id = workSpace.nextLibraryId;
        this.createTextField({
            "id": id,
            "type": "text",
            "name": `Text_${id}`,
            "symbol": "",
            "bounds": {
                "xMin": 0,
                "xMax": width,
                "yMin": 0,
                "yMax": height
            },
            "originBounds": {
                "xMin": 0,
                "xMax": width,
                "yMin": 0,
                "yMax": height
            }
        }, x, y);

        // 再描画
        this.reloadScreen();

        element.style.display = "none";
    }
}

/**
 * @class
 * @extends {BaseTool}
 */
class TransformTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("transform");

        /**
         * @type {HTMLDivElement}
         * @private
         */
        this._$element = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$deletePointer = null;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // 専用カーソルを登録
        this.setCursor(
            "url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"25\" height=\"25\" viewBox=\"0 0 48 48\"><path fill=\"white\" d=\"M27.8,39.7c-0.1,0-0.2,0-0.4-0.1c-0.2-0.1-0.4-0.3-0.6-0.5l-3.7-8.6l-4.5,4.2C18.5,34.9,18.3,35,18,35c-0.1,0-0.3,0-0.4-0.1C17.3,34.8,17,34.4,17,34l0-22c0-0.4,0.2-0.8,0.6-0.9C17.7,11,17.9,11,18,11c0.2,0,0.5,0.1,0.7,0.3l16,15c0.3,0.3,0.4,0.7,0.3,1.1c-0.1,0.4-0.5,0.6-0.9,0.7l-6.3,0.6l3.9,8.5c0.1,0.2,0.1,0.5,0,0.8c-0.1,0.2-0.3,0.5-0.5,0.6l-2.9,1.3C28.1,39.7,27.9,39.7,27.8,39.7z\"/><path fill=\"black\" d=\"M18,12l16,15l-7.7,0.7l4.5,9.8l-2.9,1.3l-4.3-9.9L18,34L18,12 M18,10c-0.3,0-0.5,0.1-0.8,0.2c-0.7,0.3-1.2,1-1.2,1.8l0,22c0,0.8,0.5,1.5,1.2,1.8C17.5,36,17.8,36,18,36c0.5,0,1-0.2,1.4-0.5l3.4-3.2l3.1,7.3c0.2,0.5,0.6,0.9,1.1,1.1c0.2,0.1,0.5,0.1,0.7,0.1c0.3,0,0.5-0.1,0.8-0.2l2.9-1.3c0.5-0.2,0.9-0.6,1.1-1.1c0.2-0.5,0.2-1.1,0-1.5l-3.3-7.2l4.9-0.4c0.8-0.1,1.5-0.6,1.7-1.3c0.3-0.7,0.1-1.6-0.5-2.1l-16-15C19,10.2,18.5,10,18,10L18,10z\"/></svg>') 6 6,auto"
        );

        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor(this._$cursor);
            this.changeNodeEvent();

            this._$deletePointer = this.deletePointer.bind(this);
            window.addEventListener("keydown", this._$deletePointer);
        });

        // 終了イベント
        this.addEventListener(EventType.END, () =>
        {
            window.removeEventListener("keydown", this._$deletePointer);
        });

        // スクリーン上でのマウスダウンイベント
        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            Util.$setCursor(this._$cursor);
            switch (true) {

                case event.displayObject:
                    this._$element = null;
                    this.mouseDownForDisplayObject(event);
                    break;

                case event.shapePointer:
                    this.mouseDownForPointer(event);
                    break;

                default:
                    this._$element = null;
                    break;

            }
        });

        // スクリーン上でのダブルクリックイベント
        this.addEventListener(EventType.DBL_CLICK, (event) =>
        {
            Util.$setCursor(this._$cursor);

            // 親のイベントを中止する
            event.stopPropagation();

            switch (true) {

                case event.shapePointer:
                    this.addCurvePointer(event);
                    break;

                case event.screen:
                    this.addPointer(event);
                    break;

                default:
                    break;

            }
        });

        // スクリーン上でのマウスアップイベント
        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            Util.$setCursor(this._$cursor);

            // 親のイベントを中止する
            event.stopPropagation();
        });

        // スクリーン上でのマウスムーブイベント
        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            Util.$setCursor(this._$cursor);
            if (this.active) {

                // 親のイベントを中止する
                event.stopPropagation();

                this.movePointer(event);
            }
        });
    }

    /**
     * @description Shapeの新しいポインター追加関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    addPointer (event)
    {
        // アクティブなポインターがあれば初期化
        this.clearActivePointer();

        const frame = Util.$timelineFrame.currentFrame;

        let target = null;
        let minDistance = Number.MAX_VALUE;

        const children = document
            .getElementById("stage-area")
            .children;

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        let px = event.offsetX;
        let py = event.offsetY;
        if (event.target.id !== "stage-area") {

            const layerId     = event.target.dataset.layerId | 0;
            const characterId = event.target.dataset.characterId | 0;
            const layer       = scene.getLayer(layerId);
            const character   = layer.getCharacter(characterId);

            px = character.screenX + Util.$offsetLeft + event.offsetX;
            py = character.screenY + Util.$offsetTop  + event.offsetY;
        }

        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];
            if (!node.dataset.shapePointer) {
                continue;
            }

            if (node.dataset.curve === "true") {
                continue;
            }

            const distance = Math.sqrt(
                Math.pow(node.offsetLeft - px, 2)
                + Math.pow(node.offsetTop - py, 2)
            );

            if (minDistance > distance) {
                target = node;
            }
            minDistance = Math.min(minDistance, distance);
        }

        if (!target) {
            return ;
        }

        const instance = workSpace.getLibrary(
            target.dataset.libraryId | 0
        );
        if (!instance) {
            return ;
        }

        const targets  = [];
        const position = target.dataset.position | 0;

        for (let idx = position + 1; idx < children.length; ++idx) {

            const node = children[idx];
            if (node.dataset.curve === "true") {
                continue;
            }

            targets.push(node);
            break;
        }

        if (!targets.length) {

            for (let idx = 0; idx < children.length; ++idx) {

                const node = children[idx];
                if (!node.dataset.shapePointer) {
                    continue;
                }

                if (node.dataset.curve === "true") {
                    continue;
                }

                targets.push(node);
                break;
            }

        }

        for (let idx = position - 1; ; --idx) {

            const node = children[idx];
            if (!node.dataset.shapePointer) {
                break;
            }

            if (node.dataset.curve === "true") {
                continue;
            }

            targets.push(node);
            break;
        }

        if (targets.length === 1) {
            for (let idx = children.length - 1; ; --idx) {

                const node = children[idx];
                if (!node.dataset.shapePointer) {
                    break;
                }

                if (node.dataset.curve === "true") {
                    continue;
                }

                targets.push(node);
                break;
            }
        }

        let nextTarget = null;
        minDistance = Number.MAX_VALUE;
        for (let idx = 0; idx < targets.length; ++idx) {

            const node = targets[idx];

            const distance = Math.sqrt(
                Math.pow(node.offsetLeft - px, 2)
                + Math.pow(node.offsetTop - py, 2)
            );

            if (minDistance > distance) {
                nextTarget = node;
            }
            minDistance = Math.min(minDistance, distance);
        }

        const { Graphics } = window.next2d.display;
        const layerId      = target.dataset.layerId | 0;
        const characterId  = target.dataset.characterId | 0;
        const layer        = scene.getLayer(layerId);
        const character    = layer.getCharacter(characterId);
        const matrix       = character.getPlace(frame).matrix;

        const xScale = Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale = Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        const index     = target.dataset.index | 0;
        const nextIndex = nextTarget.dataset.index | 0;
        if (nextIndex > index) {

            instance._$recodes.splice(index + 2, 0,
                Graphics.LINE_TO,
                (px - Util.$offsetLeft - character.screenX + instance._$bounds.xMin) / xScale,
                (py - Util.$offsetTop  - character.screenY + instance._$bounds.yMin) / yScale
            );

        } else {

            instance._$recodes.splice(nextIndex + 2, 0,
                Graphics.LINE_TO,
                (px - Util.$offsetLeft - character.screenX + instance._$bounds.xMin) / xScale,
                (py - Util.$offsetTop  - character.screenY + instance._$bounds.yMin) / yScale
            );

        }

        // pointer remove
        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];
            if (!node.dataset.shapePointer) {
                continue;
            }

            if (node.dataset.curve === "true") {
                continue;
            }

            node.remove();
            --idx;
        }

        const bounds = instance.reloadBounds(
            Util.$hitColor ? Util.$hitColor.width | 0 : 0
        );
        instance._$bounds.xMin = bounds.xMin;
        instance._$bounds.xMax = bounds.xMax;
        instance._$bounds.yMin = bounds.yMin;
        instance._$bounds.yMax = bounds.yMax;
        instance.cacheClear();

        scene.changeFrame(frame);

        if (character) {
            const matrix = character.getPlace(frame).matrix;
            instance.createPointer(matrix, layerId, characterId);
        }
    }

    /**
     * @description 指定したポインターのカーブポインター追加関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    addCurvePointer (event)
    {
        // アクティブなポインターがあれば初期化
        this.clearActivePointer();

        const { Graphics } = window.next2d.display;

        const workSpace = Util.$currentWorkSpace();

        const element = event.target;
        const curve   = element.dataset.curve === "true";
        if (!curve) {

            const type        = element.dataset.type | 0;
            const index       = element.dataset.index | 0;
            const layerId     = element.dataset.layerId | 0;
            const characterId = element.dataset.characterId | 0;

            const instance = workSpace.getLibrary(
                element.dataset.libraryId | 0
            );

            switch (type) {

                case Graphics.LINE_TO:
                    {
                        workSpace
                            .temporarilySaved();

                        instance._$recodes[index - 1] = Graphics.CURVE_TO;

                        const tx = instance._$recodes[index    ];
                        const ty = instance._$recodes[index + 1];
                        instance._$recodes.splice(index + 2, 0, tx, ty);

                        instance._$recodes[index    ] += 20;
                        instance._$recodes[index + 1] += 20;

                        instance.cacheClear();

                        const frame = Util.$timelineFrame.currentFrame;

                        workSpace
                            .scene
                            .changeFrame(frame);

                        instance.createPointer(event.matrix, layerId, characterId);
                    }
                    break;

                case Graphics.CURVE_TO:
                    {
                        workSpace
                            .temporarilySaved();

                        instance._$recodes[index - 3] = Graphics.CUBIC;

                        const tx = instance._$recodes[index    ];
                        const ty = instance._$recodes[index + 1];
                        instance._$recodes.splice(index + 2, 0, tx, ty);

                        instance._$recodes[index    ] += 20;
                        instance._$recodes[index + 1] += 20;

                        instance.cacheClear();

                        const frame = Util.$timelineFrame.currentFrame;
                        Util.$currentWorkSpace().scene.changeFrame(frame);

                        instance.createPointer(event.matrix, layerId, characterId);
                    }
                    break;

            }
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    clearActivePointer ()
    {
        const { Graphics } = window.next2d.display;

        const stageArea = document
            .getElementById("stage-area");

        // アクティブなポインターがあれば初期化
        const element = this._$element;
        if (element) {

            element.style.backgroundColor = "";

            const position = element.dataset.position | 0;
            const type     = element.dataset.type | 0;
            const curve    = element.dataset.curve === "true";
            switch (type) {

                case Graphics.CURVE_TO:
                    if (curve) {
                        stageArea.children[position + 1].style.backgroundColor = "";
                    } else {
                        stageArea.children[position - 1].style.backgroundColor = "";
                    }
                    break;

                case Graphics.CUBIC:
                    if (curve) {
                        for (let idx = 1; idx < 3; ++idx) {
                            const element = stageArea.children[position + idx];
                            element.style.backgroundColor = "";
                            if (element.dataset.curve !== "true") {
                                if (idx === 1) {
                                    stageArea.children[position - 1].style.backgroundColor = "";
                                }
                                break;
                            }
                        }
                    } else {
                        stageArea.children[position - 1].style.backgroundColor = "";
                        stageArea.children[position - 2].style.backgroundColor = "";
                    }
                    break;

            }
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDownForPointer (event)
    {
        Util
            .$currentWorkSpace()
            .temporarilySaved();

        const { Graphics } = window.next2d.display;

        const stageArea = document
            .getElementById("stage-area");

        // アクティブなポインターがあれば初期化
        this.clearActivePointer();

        const target   = this.target;
        this._$element = target;

        // ターゲットなるポインターの現在のxy座標をセット
        this.pageX = event.pageX - target.offsetLeft;
        this.pageY = event.pageY - target.offsetTop;

        const element = this.target;
        element.style.backgroundColor = Util.$shapePointerColor;

        const position = element.dataset.position | 0;
        const type     = element.dataset.type | 0;
        const curve    = element.dataset.curve === "true";

        switch (type) {

            case Graphics.CURVE_TO:
                if (curve) {
                    stageArea
                        .children[position + 1]
                        .style
                        .backgroundColor = Util.$shapeLinkedPointerColor;
                } else {
                    stageArea
                        .children[position - 1]
                        .style
                        .backgroundColor = Util.$shapeLinkedPointerColor;
                }
                break;

            case Graphics.CUBIC:
                if (curve) {
                    for (let idx = 1; idx < 3; ++idx) {

                        const element = stageArea.children[position + idx];
                        element
                            .style
                            .backgroundColor = Util.$shapeLinkedPointerColor;

                        if (element.dataset.curve !== "true") {
                            if (idx === 1) {
                                stageArea
                                    .children[position - 1]
                                    .style
                                    .backgroundColor = Util.$shapeLinkedPointerColor;
                            }
                            break;
                        }
                    }
                } else {
                    stageArea
                        .children[position - 1]
                        .style
                        .backgroundColor = Util.$shapeLinkedPointerColor;

                    stageArea
                        .children[position - 2]
                        .style
                        .backgroundColor = Util.$shapeLinkedPointerColor;
                }
                break;

        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDownForDisplayObject (event)
    {
        const target = this.target;
        if (target.dataset.instanceType !== "shape") {
            return ;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        // スクリーンを初期化
        tool.clear();

        const frame = Util.$timelineFrame.currentFrame;

        const workSpace   = Util.$currentWorkSpace();
        const layerId     = target.dataset.layerId | 0;
        const characterId = target.dataset.characterId | 0;

        const layer     = workSpace.scene.getLayer(layerId);
        const character = layer.getCharacter(characterId);
        const instance  = workSpace.getLibrary(target.dataset.libraryId | 0);
        const matrix    = character.getPlace(frame).matrix;

        const cacheColor = Util.$hitColor;
        instance.setHitColor(event.offsetX, event.offsetY, matrix);
        if (Util.$hitColor) {
            instance.createPointer(matrix, layerId, characterId);
        } else {
            Util.$hitColor = cacheColor;
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    movePointer (event)
    {
        const element = this.target;
        if (element.dataset.shapePointer !== "true") {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace.getLibrary(
            element.dataset.libraryId | 0
        );
        if (!instance) {
            Util.$clearShapePointer();
            return ;
        }

        event.preventDefault();

        const frame = Util.$timelineFrame.currentFrame;

        const layerId     = element.dataset.layerId | 0;
        const characterId = element.dataset.characterId | 0;

        const scene       = workSpace.scene;
        const layer       = scene.getLayer(layerId);
        const character   = layer.getCharacter(characterId);
        const matrix      = character.getPlace(frame).matrix;

        const x = event.pageX - this.pageX;
        const y = event.pageY - this.pageY;

        const angle  = Math.atan2(matrix[1], matrix[0]) * Util.$Rad2Deg;
        const scaleX = Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const scaleY = Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        let tx = (x - element.offsetLeft) / scaleX;
        let ty = (y - element.offsetTop)  / scaleY;
        if (angle) {
            const rad = (360 - angle) * (Math.PI / 180);
            tx *= Math.cos(rad);
            ty *= Math.sin(rad);
        }

        const index = element.dataset.index | 0;
        instance._$recodes[index    ] += tx / Util.$zoomScale;
        instance._$recodes[index + 1] += ty / Util.$zoomScale;

        const syncId = element.dataset.syncId | 0;
        if (syncId) {
            instance._$recodes[syncId    ] += tx / Util.$zoomScale;
            instance._$recodes[syncId + 1] += ty / Util.$zoomScale;
        }

        element.style.left = `${x}px`;
        element.style.top  = `${y}px`;

        const bounds = instance.reloadBounds(
            Util.$hitColor ? Util.$hitColor.width | 0 : 0
        );
        instance._$bounds.xMin = bounds.xMin;
        instance._$bounds.xMax = bounds.xMax;
        instance._$bounds.yMin = bounds.yMin;
        instance._$bounds.yMax = bounds.yMax;
        instance.cacheClear();

        scene.changeFrame(frame);
    }

    /**
     * @description ポインターを削除
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    deletePointer (event)
    {
        Util.$setCursor(this._$cursor);

        if (Util.$keyLock || event.key !== "Backspace") {
            return ;
        }

        // 親のイベントを中止する
        event.stopPropagation();

        const stageArea = document.getElementById("stage-area");

        let count = 0;
        const children = stageArea.children;
        for (let idx = 0; children.length > idx; ++idx) {

            const node = children[idx];
            if (!node.dataset.shapePointer) {
                continue;
            }

            if (node.dataset.curve === "false") {
                count++;
            }
        }

        const element = this._$element;
        if (!element) {
            return ;
        }

        const curve = element.dataset.curve === "true";
        if (!element.dataset.syncId && (count > 2 || curve)) {

            const workSpace = Util.$currentWorkSpace();
            workSpace.temporarilySaved();

            const { Graphics } = window.next2d.display;

            const instance  = workSpace.getLibrary(
                element.dataset.libraryId | 0
            );

            const index = element.dataset.index | 0;
            const type  = element.dataset.type | 0;
            switch (type) {

                case Graphics.MOVE_TO:
                    break;

                case Graphics.LINE_TO:
                    instance._$recodes.splice(index - 1, 3);
                    break;

                case Graphics.CUBIC:
                    {
                        let deletePos = index;
                        for (;;) {
                            if (instance._$recodes[--deletePos] === Graphics.CUBIC) {
                                break;
                            }
                        }

                        if (curve) {

                            instance._$recodes[deletePos] = Graphics.CURVE_TO;
                            instance._$recodes.splice(index, 2);

                        } else {

                            instance._$recodes.splice(deletePos, 7);

                        }
                    }
                    break;

                case Graphics.CURVE_TO:
                    {
                        let deletePos = index;
                        for (;;) {
                            if (instance._$recodes[--deletePos] === Graphics.CURVE_TO) {
                                break;
                            }
                        }

                        if (curve) {

                            instance._$recodes[deletePos] = Graphics.LINE_TO;
                            instance._$recodes.splice(index, 2);

                        } else {

                            instance._$recodes.splice(deletePos, 5);

                        }
                    }
                    break;

            }

            const bounds = instance.reloadBounds(
                Util.$hitColor ? Util.$hitColor.width | 0 : 0
            );
            instance._$bounds.xMin = bounds.xMin;
            instance._$bounds.xMax = bounds.xMax;
            instance._$bounds.yMin = bounds.yMin;
            instance._$bounds.yMax = bounds.yMax;
            instance.cacheClear();

            // reload
            const frame = Util.$timelineFrame.currentFrame;

            const scene = workSpace.scene;
            scene.changeFrame(frame);

            const layerId     = element.dataset.layerId | 0;
            const characterId = element.dataset.characterId | 0;
            const layer       = scene.getLayer(layerId);
            const character   = layer.getCharacter(characterId);
            if (character) {
                const matrix = character.getPlace(frame).matrix;
                instance.createPointer(matrix, layerId, characterId);
            }
        }
    }
}

/**
 * @class
 * @extends {BaseTool}
 */
class ZoomTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("zoom");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // 専用カーソルを登録
        this.setCursor(
            "url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"17\" height=\"17\" viewBox=\"0 0 24 24\"><path d=\"M13 10h-3v3h-2v-3h-3v-2h3v-3h2v3h3v2zm8.172 14l-7.387-7.387c-1.388.874-3.024 1.387-4.785 1.387-4.971 0-9-4.029-9-9s4.029-9 9-9 9 4.029 9 9c0 1.761-.514 3.398-1.387 4.785l7.387 7.387-2.828 2.828zm-12.172-8c3.859 0 7-3.14 7-7s-3.141-7-7-7-7 3.14-7 7 3.141 7 7 7z\"/></svg>') 6 6,auto"
        );

        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor(this._$cursor);
            this.changeNodeEvent(false);
        });

        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            this.startRect(event);
        });

        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            this.moveRect(event);
        });

        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            this.execute(event);
        });
    }

    /**
     * @description ズーム範囲設定を起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    startRect (event)
    {
        this.active = true;
        Util.$setCursor(this._$cursor);

        this.pageX = event.pageX;
        this.pageY = event.pageY;

        const element = document.getElementById("stage-rect");
        element.style.left    = `${event.pageX}px`;
        element.style.top     = `${event.pageY}px`;
        element.style.width   = "0px";
        element.style.height  = "0px";
        element.style.display = "";
    }

    /**
     * @description ズーム範囲設定の矩形を描画
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveRect (event)
    {
        Util.$setCursor(this._$cursor);
        if (!this.active) {
            return ;
        }

        const x = event.pageX;
        const y = event.pageY;

        const element = document.getElementById("stage-rect");

        if (this.pageX > x) {
            element.style.left = `${x}px`;
        }

        if (this.pageY > y) {
            element.style.top = `${y}px`;
        }

        element.style.width  = `${Math.abs(x - this.pageX)}px`;
        element.style.height = `${Math.abs(y - this.pageY)}px`;
    }

    /**
     * @description ズーム範囲でズームを実行
     *
     * @return {void}
     * @method
     * @public
     */
    execute ()
    {
        this.active = false;
        Util.$setCursor(this._$cursor);

        const element = document.getElementById("stage-rect");
        element.style.display = "none";

        const width   = parseFloat(element.style.width);
        const height  = parseFloat(element.style.height);
        if (!width || !height) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();

        const scale = Math.max(
            workSpace.stage.width / width,
            workSpace.stage.height / height,
            Util.$zoomScale
        );

        Util.$zoomScale = 0;
        Util.$screenZoom.execute(scale);

        // アクティブなツールがあれば終了
        if (Util.$tools.activeTool) {
            Util
                .$tools
                .activeTool
                .dispatchEvent(EventType.END);
        }

        const tool = Util.$tools.getDefaultTool("zoom");
        tool.dispatchEvent(EventType.START);
        Util.$tools.activeTool = tool;
    }
}

/**
 * @class
 */
class BaseController
{
    /**
     * @param {string} [name=""]
     * @constructor
     * @public
     */
    constructor (name = "")
    {
        /**
         * @type {string}
         * @private
         */
        this._$name = name;

        /**
         * @description 自動セーブの判定フラグ
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pointX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pointY = 0;

        /**
         * @description フォーカスされたかの判定変数
         * @type {boolean}
         * @default false
         * @private
         */
        this._$focus = false;

        /**
         * @description ロック時のInputの値を管理する変数
         *
         * @type {number}
         * @default null
         * @private
         */
        this._$currentValue = null;

        /**
         * @description 指定されたInputElement
         *
         * @type {HTMLInputElement}
         * @default null
         * @private
         */
        this._$currentTarget = null;

        /**
         * @description ロックがOnの時の対象InputElement
         *
         * @type {HTMLInputElement}
         * @default null
         * @private
         */
        this._$lockTarget = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description コントローラーの共通初期イベント登録関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        // コントローラー部分の表示非表示イベントを登録
        if (this.name) {
            const element = document
                .getElementById(`${this.name}-setting-title`);

            if (element) {
                element
                    .addEventListener("mousedown", () =>
                    {
                        this.clickTitle();
                    });
            }
        }

        Util.$initializeEnd();
    }

    /**
     * @description Inputにフォーカスされた時に変数を初期化する
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    focusIn (event)
    {
        this._$focus        = true;
        this._$currentValue = +event.target.value;
        Util.$keyLock       = true;
    }

    /**
     * @description Inputにフォーカス終了した時にロックを解放する
     *
     * @return {void}
     * @method
     * @public
     */
    focusOut ()
    {
        this._$focus         = false;
        this._$currentValue  = null;
        this._$currentTarget = null;
        this._$lockTarget    = null;
        Util.$keyLock        = false;
    }

    /**
     * @description Inputが数値の場合マウス動作終了関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseOut (event)
    {
        event.stopPropagation();

        if (this._$focus || !this._$currentTarget) {
            Util.$setCursor("auto");
            event.target.style.cursor = "";
        }
    }

    /**
     * @description 数値のInputElementの場合はマウスで値を変更可能
     *              状態に合わせてカーソルや変数を初期化する
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseDown (event)
    {
        // Inputモードなら何もしない
        if (this._$focus) {
            return ;
        }

        event.preventDefault();

        // 初期化
        this._$saved         = false;
        this._$pointX        = event.screenX;
        this._$currentTarget = event.target;
        this._$currentValue  = +event.target.value;

        Util.$setCursor("ew-resize");

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        Util.$setCursor("auto");

        if (this._$currentTarget) {
            this._$currentTarget.style.cursor = "";
            this._$currentTarget.focus();
        }
    }

    /**
     * @description マウスで数値の加算減算を行う
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseMove (event)
    {
        if (this._$focus || !this._$currentTarget) {
            return ;
        }

        window.requestAnimationFrame(() =>
        {
            if (this._$focus || !this._$currentTarget) {
                return ;
            }

            event.preventDefault();

            Util.$setCursor("ew-resize");

            const diff = event.screenX - this._$pointX;

            let currentValue = +this._$currentTarget.value;
            if (isNaN(currentValue)) {
                currentValue = 0;
            }

            // clampで補正された値をセット
            this._$currentTarget.value = this.executeFunction(
                this._$currentTarget.id,
                currentValue + diff
            );

            this._$currentValue = +this._$currentTarget.value;
            if (this._$lockTarget) {
                // clampで補正された値をセット
                this._$lockTarget.value = this.executeFunction(
                    this._$lockTarget.id,
                    +this._$lockTarget.value + diff
                );
            }

            this._$pointX = event.screenX;

            this.reloadScreen();
        });
    }

    /**
     * @description スクリーンエリアで変更があったElementを再描画
     *
     * @return {void}
     * @method
     * @public
     */
    reloadScreen ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        Util
            .$currentWorkSpace()
            .scene
            .changeFrame(frame);
    }

    /**
     * @description Inputが数値の場合マウス動作で加算減算できればカーソルを変化させる
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseOver (event)
    {
        event.stopPropagation();

        switch (true) {

            case this._$focus:
            case this._$currentTarget !== null:
            case this._$currentValue !== null:
                return ;

            default:
                Util.$setCursor("ew-resize");
                event.target.style.cursor = "ew-resize";
                break;

        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    clickTitle ()
    {
        const element = document
            .getElementById(`${this.name}-setting-view-area`);

        const icon = document
            .getElementById(`${this.name}-setting-title`)
            .getElementsByTagName("i")[0];

        if (element.style.display === "none") {
            element.style.display = "";
            icon.setAttribute("class", "active");
        } else {
            element.style.display = "none";
            icon.setAttribute("class", "disable");
        }
    }

    /**
     * @description Elementのid名をキャメルケースに変換して関数を実行
     *              例) font-select => changeFontSelectがコールされる
     *              valueはstringで渡すので、コール先の関数内で変換とバリデーションを行う必要がある
     *
     *              DOMの場合は最後の文字列にIDが付与されるので、関数が存在しない時は最後の文字列を外す
     *              例) sound-volume-1 => changeSoundVolumeがコールされる
     *
     * @param  {string} name
     * @param  {string|number|Event} value
     * @return {*}
     * @method
     * @public
     */
    executeFunction (name, value)
    {
        this.save();

        const names = name.split("-");

        let functionName = names
            .map((value) =>
            {
                return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
            })
            .join("");

        if (!(`change${functionName}` in this)) {

            // 最後の文字を削除
            names.pop();

            functionName = names
                .map((value) => {
                    return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
                })
                .join("");
        }

        return this[`change${functionName}`](value);
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    finishInput (event, reload = true)
    {
        // Enterを押下したら、focusoutイベントを発火させる
        if (event.key === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        // focusoutなら更新関数を実行
        if (event.type === "focusout") {

            this._$currentTarget = event.target;

            // Inputの値を更新
            const value = this.executeFunction(
                event.target.id,
                event.target.value
            );

            // ロックしたInputの値を更新
            if (this._$lockTarget) {
                this._$lockTarget.value = this.executeFunction(
                    this._$lockTarget.id,
                    +this._$lockTarget.value + value - this._$currentValue
                );
            }

            event.target.value  = value;
            this._$currentValue = value;

            this.focusOut();

            // スクリーンを再描画
            if (reload) {
                this.reloadScreen();
            }
        }
    }

    /**
     * @description プロパティーの更新がある時はundo用にデータを内部保管する
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }

    /**
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setChangeEvent (element)
    {
        if (!element) {
            return ;
        }

        element
            .addEventListener("change", (event) =>
            {
                this._$currentTarget = event.target;

                this.executeFunction(
                    event.target.id,
                    event.target.value
                );

                this._$currentTarget = null;

                // スクリーンを再描画
                this.reloadScreen();
            });
    }

    /**
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setInputEvent (element)
    {
        if (!element) {
            return ;
        }

        element.addEventListener("mouseover", (event) =>
        {
            this.mouseOver(event);
        });
        element.addEventListener("mouseout", (event) =>
        {
            this.mouseOut(event);
        });
        element.addEventListener("mousedown", (event) =>
        {
            this.mouseDown(event);
        });
        element.addEventListener("focusin", (event) =>
        {
            this.focusIn(event);
        });
        element.addEventListener("focusout",  (event) =>
        {
            this.finishInput(event);
        });
        element.addEventListener("keypress",  (event) =>
        {
            this.finishInput(event);
        });
    }

    /**
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setClickEvent (element)
    {
        if (!element) {
            return ;
        }

        element
            .addEventListener("click", (event) =>
            {
                this._$currentTarget = event.target;

                this.executeFunction(
                    event.target.id,
                    event.target.value
                );

                this._$currentTarget = null;

                // スクリーンを再描画
                this.reloadScreen();
            });
    }

    /**
     * @return {string}
     * @readonly
     * @public
     */
    get name ()
    {
        return this._$name;
    }
}

/**
 * @class
 * @extends {BaseController}
 */
class GradientFilterController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor (name)
    {
        super(name);

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$currentPointer = null;

        /**
         * @type {CanvasRenderingContext2D}
         * @default null
         * @private
         */
        this._$drawGradientContext = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMoveGradientColorPointer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUpGradientColorPointer = null;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get GRADIENT_CANVAS_WIDTH ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get GRADIENT_CANVAS_HEIGHT ()
    {
        return 30;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_GRADIENT_POINTER ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_GRADIENT_POINTER ()
    {
        return 255;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        // 内部描画用のcontext
        const canvas  = document.createElement("canvas");
        canvas.width  = GradientFilterController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio;
        canvas.height = GradientFilterController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio;
        this._$drawGradientContext = canvas.getContext("2d");
    }

    /**
     * @description filterの指定グラデーションカラーの値を更新
     *
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    changeGradientColor (value)
    {
        const filterId = this._$currentTarget.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return ;
        }

        if (this._$currentPointer) {
            const filter = this._$filters.get(filterId).filter;
            const index  = this._$currentPointer.dataset.index | 0;
            filter._$colors[index] = `0x${value.slice(1)}` | 0;

            this._$currentPointer.dataset.color = value;
            this
                ._$currentPointer
                .getElementsByTagName("i")[0]
                .style.backgroundColor = value;

            this.updateFilterGradientCanvas(filter);

            this.disposeCharacterImage();

            this.reloadScreen();
        }

        return value;
    }

    /**
     * @description filterのグラデーション透明度を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeGradientAlpha (value)
    {
        const filterId = this._$currentTarget.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return ;
        }

        value = Util.$clamp(
            +value,
            FilterController.MIN_ALPHA,
            FilterController.MAX_ALPHA
        );

        if (this._$currentPointer) {
            const filter = this._$filters.get(filterId).filter;
            const index  = this._$currentPointer.dataset.index | 0;
            filter._$alphas[index] = value;

            this._$currentPointer.dataset.alpha = value;

            this.updateFilterGradientCanvas(filter);

            this.disposeCharacterImage();

            this.reloadScreen();
        }

        return value;
    }

    /**
     * @param  {HTMLDivElement} element
     * @param  {GradientBevelFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    addGradientBevelFilter (element, filter = null, reload = true)
    {

        const id = this.createFilter(GradientBevelFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = this.getFilterHeaderHTML(id, "GradientBevel") + `

        <div class="filter-view-area-right">

            <div class="filter-container">
                <div class="filter-text">BlurX</div>
                <div><input type="text" id="blurX-${id}" value="${filter.blurX}" data-name="blurX" data-filter-id="${id}" data-detail="水平方向にぼかす"></div>
                                
                <div class="filter-text">Strength</div>
                <div><input type="text" id="strength-${id}" value="${filter.strength}" data-filter-id="${id}" data-name="strength" data-detail="フィルター強度"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">BlurY</div>
                <div><input type="text" id="blurY-${id}" value="${filter.blurY}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
                
                <div class="filter-text">Angle</div>
                <div><input type="text" id="angle-${id}" value="${filter.angle}" data-filter-id="${id}" data-name="angle" data-detail="{{フィルター角度}}"></div>
            </div>
            
            <div class="filter-container">
                <div class="filter-text">Distance</div>
                <div><input type="text" id="distance-${id}" value="${filter.distance}" data-filter-id="${id}" data-name="distance" data-detail="{{フィルター距離}}"></div>
            </div>
            
            <div class="filter-container">
                <div id="gradient-color-palette-${id}" class="gradient-color-palette">
                    <div id="color-palette-${id}" class="color-palette">
                        <canvas id="gradient-canvas-${id}"></canvas>
                    </div>
                    <div id="color-pointer-list-${id}" data-filter-id="${id}" class="color-pointer-list" data-detail="{{カラーポインターを追加}}"></div>
                </div>
            </div>
            
            <div class="filter-container">
                <div class="filter-text">Color</div>
                <div><input type="color" id="gradientColor-${id}" value="#000000" data-detail="{{グラデーションカラー}}"></div>
                
                <div class="filter-text">Alpha</div>
                <div><input type="text" id="gradientAlpha-${id}" value="100" data-name="gradientAlpha" data-detail="{{グラデーションのアルファ}}"></div>
            </div>
            
            <div class="filter-container">
                <div><input type="checkbox" id="knockout-${id}" data-name="knockout" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="knockout-${id}">Knockout</label>
                </div>
            </div>

            <div class="filter-container">
                <div class="filter-text-long">Type</div>
                <div>
                    <select id="type-${id}" data-name="type" data-filter-id="${id}">
                        <option value="inner">Inner</option>
                        <option value="outer">Outer</option>
                        <option value="full">Full</option>
                    </select>
                </div>
    
                <div class="filter-text-long">Quality</div>
                <div>
                    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
                        <option value="1">Low</option>
                        <option value="2">Middel</option>
                        <option value="3">High</option>
                    </select>
                </div>
            </div>
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        const canvas  = document.getElementById(`gradient-canvas-${id}`);
        canvas.width  = GradientFilterController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio;
        canvas.height = GradientFilterController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio;

        canvas.style.transform          = `scale(${1 / window.devicePixelRatio}, ${1 / window.devicePixelRatio})`;
        canvas.style.backfaceVisibility = "hidden";
        canvas.style.transformOrigin    = "0 0";

        filter.context = canvas.getContext("2d");

        // 共有イベント処理
        this.setCommonEvent(id);

        // 保存データの場合はcheckboxの値を更新
        if (filter.knockout) {
            document
                .getElementById(`knockout-${id}`)
                .checked = true;
        }

        const inputIds = [
            `blurX-${id}`,
            `blurY-${id}`,
            `strength-${id}`,
            `angle-${id}`,
            `gradientAlpha-${id}`,
            `distance-${id}`
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const clickIds = [
            `knockout-${id}`
        ];

        for (let idx = 0; idx < clickIds.length; ++idx) {
            this.setClickEvent(
                document.getElementById(clickIds[idx])
            );
        }

        const changeIds = [
            `gradientColor-${id}`,
            `type-${id}`,
            `quality-${id}`
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(changeIds[idx])
            );
        }

        // ポインターを追加
        for (let idx = 0; idx < filter.ratios.length; ++idx) {

            const ratio = filter.ratios[idx];
            const color = `#${filter.colors[idx].toString(16).padStart(6, "0")}`;
            const alpha = filter.alphas[idx];

            this.addFilterGradientColorPointer(id, idx, ratio, color, alpha);

        }

        // ポインター追加イベント
        this.setCreateGradientColorPointerEvent(id);

        // canvasを更新
        this.updateFilterGradientCanvas(filter);

        // 内部キャッシュを削除
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(
            document.getElementById(`filter-id-${id}`)
        );
    }

    /**
     * @description グラデーションのポインターを追加
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    addGradientColorPointer (event)
    {
        const filterId = event.target.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return ;
        }

        const filter = this._$filters.get(filterId).filter;

        const index = filter.ratios.length;
        const ratio = event.offsetX;
        const color = document.getElementById(`gradientColor-${filterId}`).value;
        const alpha = document.getElementById(`gradientAlpha-${filterId}`).value | 0;

        filter.ratios.push(ratio);
        filter.colors.push(`0x${color.slice(1)}` | 0);
        filter.alphas.push(alpha);

        this.addFilterGradientColorPointer(
            filterId, index, ratio, color, alpha
        );

        // グラデーションレビューの更新
        this.updateFilterGradientCanvas(filter);

        // 再描画用に画像のキャッシュを削除
        this.disposeCharacterImage();

        // 再描画
        this.reloadScreen();
    }

    /**
     * @description グラデーションのポインター追加イベンち
     *
     * @param  {number} id
     * @return {void}
     * @method
     * @public
     */
    setCreateGradientColorPointerEvent (id)
    {
        const element = document
            .getElementById(`color-pointer-list-${id}`);

        if (!element) {
            return ;
        }

        element.addEventListener("mousedown", (event) =>
        {
            this.addGradientColorPointer(event);
        });
    }

    /**
     * @description グラデーションのcanvasを更新
     *
     * @param  {GradientBevelFilter|GradientGlowFilter} filter
     * @return {void}
     * @method
     * @public
     */
    updateFilterGradientCanvas (filter)
    {
        const context = this._$drawGradientContext;

        // clear
        context.clearRect(0, 0,
            GradientFilterController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            GradientFilterController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );

        const object = filter.adjustment();

        context.beginPath();

        const length = object.ratios.length;
        const x1 = Math.ceil(object.ratios[length - 1] * 255 * window.devicePixelRatio);
        const gradient = context.createLinearGradient(0, 0, x1, 0);

        for (let idx = 0; idx < length; ++idx) {
            const obj = Util.$intToRGB(object.colors[idx]);
            gradient.addColorStop(
                object.ratios[idx],
                `rgba(${obj.R}, ${obj.G}, ${obj.B}, ${object.alphas[idx]})`
            );
        }

        context.fillStyle = gradient;
        context.rect(0, 0,
            GradientFilterController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            GradientFilterController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );

        context.fill();

        filter.context.clearRect(0, 0,
            GradientFilterController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            GradientFilterController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );
        filter.context.drawImage(context.canvas, 0, 0);
    }

    /**
     * @description グラデーションのポインターを追加
     *
     * @param  {number} id
     * @param  {number} index
     * @param  {number} ratio
     * @param  {string} color
     * @param  {number} alpha
     * @return {void}
     * @method
     * @public
     */
    addFilterGradientColorPointer (id, index, ratio, color, alpha)
    {
        const element = document
            .getElementById(`color-pointer-list-${id}`);

        const htmlTag = `
<div class="color-pointer" style="left: ${ratio - 4}px;" data-filter-id="${id}" data-index="${index}" data-color="${color}" data-alpha="${alpha}">
    <div class="color-pointer-triangle"></div>
    <div class="color-pointer-rect">
        <i class="pointer-color" style="background-color: ${color}"></i>
    </div>
</div>
`;

        element.insertAdjacentHTML("beforeend", htmlTag);

        const pointer = element.lastElementChild;

        pointer.addEventListener("mousedown", (event) =>
        {
            this.mouseDownGradientColorPointer(event);
        });

        if (index) {
            pointer.addEventListener("dblclick", (event) =>
            {
                this.removeGradientColorPointer(event);
            });
        }

        // 初期値は最後に生成されたポインターのElement
        this._$currentPointer = pointer;
    }

    /**
     * @description グラデーションのカラーポインターを削除
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    removeGradientColorPointer (event)
    {
        const filterId = event.target.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return ;
        }

        const element = document
            .getElementById(`color-pointer-list-${filterId}`);

        if (2 >= element.children.length ) {
            return ;
        }

        const index  = event.target.dataset.index | 0;
        const filter = this._$filters.get(filterId).filter;

        filter.ratios.splice(index, 1);
        filter.colors.splice(index, 1);
        filter.alphas.splice(index, 1);

        // remove
        event.target.remove();

        // 削除したindexの差分の補完
        for (let idx = index; idx < element.children.length; ++idx) {

            const child = element.children[idx];
            const index = (child.dataset.index | 0) - 1;

            child.dataset.index = `${index}`;
        }

        super.focusOut();

        // グラデーションプレビューを更新
        this.updateFilterGradientCanvas(filter);

        // 再描画用に画像のキャッシュを削除
        this.disposeCharacterImage();

        // 再描画
        this.reloadScreen();
    }

    /**
     * @description グラデーションのカラーポインターを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDownGradientColorPointer (event)
    {
        // 親のイベントを中止
        event.stopPropagation();

        // 初期化
        this._$saved          = false;
        this._$pointX         = event.screenX;
        this._$currentTarget  = event.target;
        this._$currentPointer = event.target;

        const filterId = event.target.dataset.filterId;

        document
            .getElementById(`gradientColor-${filterId}`)
            .value = event.target.dataset.color;

        document
            .getElementById(`gradientAlpha-${filterId}`)
            .value = event.target.dataset.alpha;

        if (!this._$mouseMoveGradientColorPointer) {
            this._$mouseMoveGradientColorPointer =
                this.mouseMoveGradientColorPointer.bind(this);
        }

        if (!this._$mouseUpGradientColorPointer) {
            this._$mouseUpGradientColorPointer =
                this.mouseUpGradientColorPointer.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMoveGradientColorPointer);
        window.addEventListener("mouseup", this._$mouseUpGradientColorPointer);
    }

    /**
     * @description グラデーションのカラーポインターの移動処理
     *
     * @return {void}
     * @method
     * @public
     */
    mouseMoveGradientColorPointer (event)
    {
        const element = this._$currentTarget;
        if (!element) {
            return ;
        }

        const index = element.dataset.index | 0;
        if (index) {
            window.requestAnimationFrame(() =>
            {
                event.preventDefault();

                const filterId = element.dataset.filterId | 0;
                if (!this._$filters.has(filterId)) {
                    return ;
                }

                const currentPoint = parseFloat(
                    element.style.left
                );

                const value = Util.$clamp(
                    currentPoint + (event.screenX - this._$pointX) + 4,
                    GradientFilterController.MIN_GRADIENT_POINTER,
                    GradientFilterController.MAX_GRADIENT_POINTER
                );

                element.style.left = `${value - 4}px`;

                const filter = this._$filters.get(filterId).filter;
                filter._$ratios[index] = value;

                if (this._$pointX) {
                    this._$pointX = event.screenX;
                }

                // グラデーションプレビューを更新
                this.updateFilterGradientCanvas(filter);

                // 再描画用にキャッシュをクリア
                this.disposeCharacterImage();

                // 再描画
                this.reloadScreen();
            });
        }
    }

    /**
     * @description グラデーションのカラーポインターの移動を終了、イベントも削除
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUpGradientColorPointer ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMoveGradientColorPointer);
        window.removeEventListener("mouseup", this._$mouseUpGradientColorPointer);
        Util.$setCursor("auto");

        // 設定を初期化
        super.focusOut();
    }
}

/**
 * @class
 */
class View
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const element = document.getElementById("view");
        if (element) {
            element.addEventListener("mousedown", (event) =>
            {
                if (event.button) {
                    return ;
                }

                Util.$endMenu();
            });
        }

        Util.$initializeEnd();
    }
}

Util.$view = new View();

/**
 * @class
 * @extends {InputEvent}
 */
class BaseTimeline extends InputEvent
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 共通初期イベント登録関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        Util.$initializeEnd();
    }

    /**
     * @description スクリーンエリアで変更があったElementを再描画
     *
     * @return {void}
     * @method
     * @public
     */
    reloadScreen ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        Util
            .$currentWorkSpace()
            .scene
            .changeFrame(frame);
    }

    /**
     * @description Elementのid名をキャメルケースに変換して関数を実行
     *              例) font-select => executeFontSelectがコールされる
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    executeFunction (event)
    {
        const names = event.target.id.split("-");

        let functionName = names
            .map((value) =>
            {
                return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
            })
            .join("");

        this[`execute${functionName}`](event);
    }
}

/**
 * @class
 * @extends {BaseTimeline}
 */
class JavaScriptEditor extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {Editor}
         * @default null
         * @private
         */
        this._$editor = null;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$active = false;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$frame = -1;

        /**
         * @type {MovieClip}
         * @default null
         * @private
         */
        this._$scene = null;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$screenX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$screenY = 0;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get SCRIPT_MODAL_WIDTH ()
    {
        return 620;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get SCRIPT_MODAL_HEIGHT ()
    {
        return 450;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get SCRIPT_MODAL_BAR_HEIGHT ()
    {
        return 25;
    }

    /**
     * @description モーダルがアクティブかを返します。
     *
     * @return {boolean}
     * @readonly
     * @public
     */
    get active ()
    {
        return this._$active;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        // JavaScriptの編集エディターを起動
        this.createEditor();

        const elementIds = [
            "editor-hide-icon",
            "editor-bar"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document
                .getElementById(elementIds[idx]);

            if (!element) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // メニューを終了
                Util.$endMenu("editor-modal");

                // id名で関数を実行
                this.executeFunction(event);
            });
        }

        document
            .documentElement
            .style
            .setProperty("--script-modal-width", `${JavaScriptEditor.SCRIPT_MODAL_WIDTH}px`);

        document
            .documentElement
            .style
            .setProperty("--script-modal-height", `${JavaScriptEditor.SCRIPT_MODAL_HEIGHT}px`);

        document
            .documentElement
            .style
            .setProperty("--script-modal-bar-height", `${JavaScriptEditor.SCRIPT_MODAL_BAR_HEIGHT}px`);

    }

    /**
     * @description JavaScriptの編集エディターを起動
     *
     * @return {void}
     * @method
     * @public
     */
    createEditor ()
    {
        if (!("ace" in window)) {
            return ;
        }

        this._$editor = ace.edit("editor");
        this._$editor.setOptions({
            "enableBasicAutocompletion": true,
            "enableSnippets": true,
            "enableLiveAutocompletion": true
        });
        this._$editor.setTheme("ace/theme/monokai");
        this._$editor.session.setMode("ace/mode/javascript");

        const words = [
            { "word": "next2d", "meta": "window.next2d" },
            { "word": "toString",  "value": "toString()",  "meta": "common method" },
            { "word": "namespace", "meta": "common property" }
        ];

        const level1 = Object.keys(window.next2d);
        for (let idx = 1; idx < level1.length; ++idx) {

            const name = level1[idx];
            words.push({
                "word": `next2d.${name}`,
                "meta": `next2d.${name}`
            });

            const level2 = Object.keys(window.next2d[name]);
            for (let idx = 0; idx < level2.length; ++idx) {

                const className = level2[idx];
                words.push(
                    {
                        "word": className,
                        "meta": `next2d.${name}.${className}`
                    }
                );

                const Class = window.next2d[name][className];

                const staticMethods = Object.getOwnPropertyDescriptors(Class);
                const staticNames   = Object.getOwnPropertyNames(Class);
                for (let idx = 0; idx < staticNames.length; ++idx) {

                    const name = staticNames[idx];
                    switch (name) {

                        case "length":
                        case "prototype":
                        case "toString":
                        case "namespace":
                        case "name":
                            continue;

                        default:
                            break;

                    }

                    const object = staticMethods[name];
                    if ("value" in object) {

                        const args = object
                            .value
                            .toString()
                            .replace(/ |\n/g, "")
                            .split("{")[0]
                            .split("(")[1];

                        words.push({
                            "word": name,
                            "value": `${name}()`,
                            "meta": `${className}.${name}(${args}`
                        });

                    } else {

                        words.push({
                            "word": name,
                            "meta": `${className}.${name}`
                        });

                    }

                }

                const publicMethods = Object.getOwnPropertyDescriptors(Class.prototype);
                const publicNames   = Object.getOwnPropertyNames(Class.prototype);
                for (let idx = 0; idx < publicNames.length; ++idx) {

                    const name = publicNames[idx];
                    switch (name) {

                        case "constructor":
                        case "toString":
                        case "namespace":
                        case "name":
                            continue;

                        default:
                            break;

                    }

                    if (name.indexOf("_$") > -1) {
                        continue;
                    }

                    const object = publicMethods[name];
                    if ("value" in object) {

                        const args = object
                            .value
                            .toString()
                            .replace(/ |\n/g, "")
                            .split("{")[0]
                            .split("(")[1];

                        words.push({
                            "word": name,
                            "value": `${name}()`,
                            "meta": `${className}.${name}(${args}`
                        });

                    } else {

                        words.push({
                            "word": name,
                            "meta": `${className}.${name}`
                        });

                    }
                }
            }
        }

        ace
            .require("ace/ext/language_tools")
            .addCompleter({
                // eslint-disable-next-line no-unused-vars
                "getCompletions": (editor, session, pos, prefix, callback) =>
                {
                    callback(null, words.map((object) =>
                    {
                        return {
                            "caption": object.word,
                            "value":   object.value || object.word,
                            "meta":    object.meta,
                            "score":   0
                        };
                    }));
                }
            });

        //要素のリサイズイベント取得
        const resizeObserver = new ResizeObserver((entries) =>
        {
            entries.forEach((entry) =>
            {
                const element = entry.target;

                const modalWidth = parseFloat(document
                    .documentElement
                    .style
                    .getPropertyValue("--script-modal-width"));

                const modalHeight = parseFloat(document
                    .documentElement
                    .style
                    .getPropertyValue("--script-modal-height"));

                if (modalWidth !== element.clientWidth) {
                    document
                        .documentElement
                        .style
                        .setProperty("--script-modal-width", `${element.clientWidth}px`);
                }

                if (modalHeight !== element.clientHeight) {
                    document
                        .documentElement
                        .style
                        .setProperty("--script-modal-height",
                            `${element.clientHeight + JavaScriptEditor.SCRIPT_MODAL_BAR_HEIGHT}px`);
                }
            });

            this._$editor.resize();

        });

        const element = document.getElementById("editor-modal");
        if (element) {
            resizeObserver.observe(element);
        }
    }

    /**
     * @description JavaScriptの編集エディターを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeTimelineScriptAdd (event)
    {
        this.show(event);
    }

    /**
     * @description JavaScriptの編集エディターを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuScriptAdd (event)
    {
        this.show(event);
    }

    /**
     * @description JavaScriptの編集エディターを起動
     *
     * @return {void}
     * @method
     * @public
     */
    executeEditorHideIcon ()
    {
        this.hide();
    }

    /**
     * @description JavaScriptの編集エディターを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeEditorBar (event)
    {
        // 現在の座標位置をセット
        this._$screenX = event.screenX;
        this._$screenY = event.screenY;

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description エディターを移動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        window.requestAnimationFrame(() =>
        {
            const element = document
                .getElementById("editor-modal");

            element.style.left = `${parseFloat(element.style.left) + (event.screenX - this._$screenX)}px`;
            element.style.top  = `${parseFloat(element.style.top)  + (event.screenY - this._$screenY)}px`;

            this._$screenX = event.screenX;
            this._$screenY = event.screenY;
        });
    }

    /**
     * @description マウスアップイベント。登録してるイベントを削除
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);
        Util.$setCursor("auto");
    }

    /**
     * @description JavaScriptの編集エディターを起動表示
     *
     * @param  {MouseEvent} [event=null]
     * @param  {number} [frame=0]
     * @param  {MovieClip} [scene=null]
     * @return {void}
     * @method
     * @public
     */
    show (event = null, frame = 0, scene = null)
    {
        Util.$keyLock = true;
        this._$active = true;

        // 追加対象のフレーム番号をセット
        this._$frame = frame || Util.$timelineFrame.currentFrame;

        // reset
        this._$editor.setValue("", -1);

        scene = scene || Util.$currentWorkSpace().scene;
        if (scene.hasAction(this._$frame)) {
            this._$editor.setValue(scene.getAction(this._$frame), -1);
        }

        document
            .getElementById("editor-title")
            .textContent = `${scene.name} / frame[${this._$frame}]`;

        const element = document.getElementById("editor-modal");
        if (event) {
            element.style.display = "";
            element.style.left = `${event.pageX + 5}px`;
            element.style.top  = `${event.pageY - element.clientHeight / 2}px`;
        }

        if (isNaN(parseFloat(element.style.left))) {
            element.style.left = "200px";
            element.style.top  = `${300 - element.clientHeight / 2}px`;
        }

        element.setAttribute("class", "fadeIn");
        Util.$endMenu("editor-modal");

        this._$editor.focus();
    }

    /**
     * @description JavaScriptの編集エディターの編集内容を保存して非表示
     *
     * @return {void}
     * @method
     * @public
     */
    hide ()
    {
        this.save();

        // 初期化
        this._$editor.setValue("", 0);
        this._$frame  = -1;
        this._$scene  = null;
        this._$active = false;
        Util.$keyLock = false;
        Util.$endMenu();
    }

    /**
     * @description 編集したjavaScriptの内容を保存
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (this._$frame === -1) {
            return ;
        }

        const script = this._$editor.getValue(0);

        const element = document
            .getElementById(`frame-label-action-${this._$frame}`);

        const scene = this._$scene || Util.$currentWorkSpace().scene;
        if (script) {
            scene.setAction(this._$frame, script.trim());
            if (!this._$scene
                && !element.classList.contains("frame-border-box-action")
            ) {
                element.setAttribute("class", "frame-border-box-action");
            }
        } else {
            scene.deleteAction(this._$frame);
            if (!this._$scene) {
                element.setAttribute("class", "frame-border-box");
            }
        }
    }
}

Util.$javaScriptEditor = new JavaScriptEditor();

/**
 * @class
 */
class TimelineAdjustment extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pointY = 0;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get TIMELINE_DEFAULT_SIZE ()
    {
        return 280;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get TIMELINE_MIN_SIZE ()
    {
        return 150;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        document
            .documentElement
            .style
            .setProperty(
                "--timeline-height",
                `${TimelineAdjustment.TIMELINE_DEFAULT_SIZE}px`
            );

        const element = document.getElementById("timeline-adjustment");
        if (element) {
            element.addEventListener("mousedown", (event) =>
            {
                this.mouseDown(event);
            });
        }
    }

    /**
     * @description コントローラーのサイズ変更イベントを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        event.preventDefault();

        this._$pointY = event.screenY;

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description コントローラーのサイズ変更処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        Util.$setCursor("row-resize");

        window.requestAnimationFrame(() =>
        {
            const diff = this._$pointY - event.screenY;

            const value = document
                .documentElement
                .style
                .getPropertyValue("--timeline-height")
                .split("px")[0] | 0;

            const height = Math.max(
                TimelineAdjustment.TIMELINE_MIN_SIZE,
                value + diff
            );

            document
                .documentElement
                .style
                .setProperty(
                    "--timeline-height",
                    `${height}px`
                );

            Util.$currentWorkSpace()._$timelineHeight = height;

            this._$pointY = event.screenY;
        });
    }

    /**
     * @description コントローラーのサイズ変更イベントを終了
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        Util.$setCursor("auto");
    }
}

Util.$timelineAdjustment = new TimelineAdjustment();

/**
 * @class
 * @extends {BaseTimeline}
 */
class TimelineFrame extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pointX = 0;

        /**
         * @description ロック時のInputの値を管理する変数
         *
         * @type {number}
         * @default null
         * @private
         */
        this._$currentValue = null;

        /**
         * @description 指定されたInputElement
         *
         * @type {HTMLInputElement}
         * @default null
         * @private
         */
        this._$currentTarget = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;
    }

    /**
     * @description 現在のフレーム番号を返却する
     *
     * @return {number}
     * @public
     */
    get currentFrame ()
    {
        return document.getElementById("current-frame").value | 0;
    }

    /**
     * @description 指定フレームをセット
     *
     * @param  {number} frame
     * @return {void}
     * @public
     */
    set currentFrame (frame)
    {
        document.getElementById("current-frame").value = `${frame | 0}`;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document.getElementById("current-frame");

        if (element) {

            element.addEventListener("mouseover", (event) =>
            {
                this.mouseOver(event);
            });
            element.addEventListener("mouseout", (event) =>
            {
                this.mouseOut(event);
            });
            element.addEventListener("mousedown", (event) =>
            {
                this.mouseDown(event);
            });
            element.addEventListener("focusin", (event) =>
            {
                this.focusIn(event);
            });
            element.addEventListener("focusout",  (event) =>
            {
                this.finishInput(event);
            });
            element.addEventListener("keypress",  (event) =>
            {
                this.finishInput(event);
            });
        }
    }

    /**
     * @description Inputにフォーカスされた時に変数を初期化する
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    focusIn (event)
    {
        super.focusIn();
        this._$currentValue  = +event.target.value;
        this._$currentTarget = event.target;
    }

    /**
     * @description Inputにフォーカス終了した時にロックを解放する
     *
     * @return {void}
     * @method
     * @public
     */
    focusOut ()
    {
        super.focusOut();
        this._$currentValue  = null;
        this._$currentTarget = null;
    }

    /**
     * @description Inputが数値の場合マウス動作で加算減算できればカーソルを変化させる
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseOver (event)
    {
        event.stopPropagation();

        switch (true) {

            case this._$focus:
            case this._$currentTarget !== null:
            case this._$currentValue !== null:
                return ;

            default:
                Util.$setCursor("ew-resize");
                event.target.style.cursor = "ew-resize";
                break;

        }
    }

    /**
     * @description Inputが数値の場合マウス動作終了関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseOut (event)
    {
        event.stopPropagation();

        if (this._$focus || !this._$currentTarget) {
            Util.$setCursor("auto");
            event.target.style.cursor = "";
        }
    }

    /**
     * @description 数値のInputElementの場合はマウスで値を変更可能
     *              状態に合わせてカーソルや変数を初期化する
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseDown (event)
    {
        // Inputモードなら何もしない
        if (this._$focus) {
            return ;
        }

        event.preventDefault();

        // 初期化
        this._$pointX        = event.screenX;
        this._$currentTarget = event.target;
        this._$currentValue  = +event.target.value;

        Util.$setCursor("ew-resize");

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // 選択中のレイヤーを初期化
        Util.$timelineLayer.clear();

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        Util.$setCursor("auto");

        if (this._$currentTarget) {
            this._$currentTarget.style.cursor = "";
            this._$currentTarget.focus();
        }
    }

    /**
     * @description マウスで数値の加算減算を行う
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseMove (event)
    {
        if (this._$focus || !this._$currentTarget) {
            return ;
        }

        window.requestAnimationFrame(() =>
        {
            if (this._$focus || !this._$currentTarget) {
                return ;
            }

            event.preventDefault();

            Util.$setCursor("ew-resize");

            const diff = event.screenX - this._$pointX;

            let currentValue = +this._$currentTarget.value;
            if (isNaN(currentValue)) {
                currentValue = 1;
            }

            // clampで補正された値をセット
            const frame = Util.$clamp(
                currentValue + diff,
                1, Util.$timelineHeader.lastFrame
            );

            this._$currentTarget.value = `${frame}`;
            this._$currentValue        = frame;
            this._$pointX              = event.screenX;

            // タイムラインの座標の補正
            this.moveTimeline();

            //

            // 再描画
            this.reloadScreen();
        });
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    finishInput (event)
    {
        // Enterを押下したら、focusoutイベントを発火させる
        if (event.key === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        // focusoutなら更新関数を実行
        if (event.type === "focusout") {

            // Inputの値を更新
            const frame = Util.$clamp(
                event.target.value | 0,
                1, Util.$timelineHeader.lastFrame
            );

            event.target.value = `${frame}`;

            // タイムラインの座標の補正
            this.moveTimeline();

            // 初期化
            this.focusOut();

            // 再描画
            this.reloadScreen();
        }
    }

    /**
     * @description フレームに合わせてタイムラインの座標を移動させる
     *
     * @return {void}
     * @method
     * @public
     */
    moveTimeline ()
    {
        // マーカーを移動
        Util.$timelineMarker.move();

        // タイムラインの座標修正
        const deltaX =
            Util.$timelineFrame.currentFrame
                * (Util.$timelineTool.timelineWidth + 1);

        const element = document
            .getElementById("timeline-controller-base");

        switch (true) {

            case deltaX > element.scrollLeft + element.offsetWidth:
                Util
                    .$timelineLayer
                    .moveTimeLine(
                        deltaX - (Util.$timelineTool.timelineWidth + 1)
                    );
                break;

            case element.scrollLeft >= deltaX:
                {
                    const frame = element.offsetWidth
                        / (Util.$timelineTool.timelineWidth + 1) | 0;

                    Util
                        .$timelineLayer
                        .moveTimeLine(
                            deltaX - frame
                                * (Util.$timelineTool.timelineWidth + 1)
                        );
                }
                break;

            default:
                break;

        }
    }
}

Util.$timelineFrame = new TimelineFrame();

/**
 * @class
 * @extends {BaseTimeline}
 */
class TimelineHeader extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @description 1
         * @private
         */
        this._$lastFrame = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$scrollX = 0;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$targetElement = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$deleteIcon = null;
    }

    /**
     * @description ヘッダータイムラインのスクロールx座標
     *
     * @return {number}
     * @public
     */
    get scrollX ()
    {
        return this._$scrollX;
    }

    /**
     * @description ヘッダータイムラインのスクロールx座標
     *
     * @param  {number} scroll_x
     * @return {void}
     * @public
     */
    set scrollX (scroll_x)
    {
        this._$scrollX = scroll_x | 0;
    }

    /**
     * @description 現在のタイムラインの最後のフレーム番号を返す
     *
     * @return {number}
     * @public
     */
    get lastFrame ()
    {
        return this._$lastFrame;
    }

    /**
     * @description 現在のタイムラインの最後のフレーム番号を返す
     *
     * @param  {number} last_frame
     * @return {void}
     * @public
     */
    set lastFrame (last_frame)
    {
        this._$lastFrame = last_frame | 0;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        if (!this._$deleteIcon) {
            this._$deleteIcon = this.deleteIcon.bind(this);
        }

        // 上部のタイムラインの動作イベント
        const element = document
            .getElementById("timeline-controller-base");

        if (element) {
            element.addEventListener("wheel", (event) =>
            {
                // 全てのイベントを停止
                event.stopPropagation();
                event.preventDefault();

                if (Util.$altKey) {

                    const deltaY = event.deltaY | 0;
                    if (!deltaY) {
                        return false;
                    }

                    // タイムラインの幅をスケール
                    window.requestAnimationFrame(() =>
                    {
                        Util.$timelineTool.timelineWidth = Util.$clamp(
                            Util.$timelineTool.timelineWidth + deltaY,
                            5,
                            240
                        );
                    });

                } else {

                    const delta = (event.deltaX || event.deltaY) | 0;
                    if (!delta) {
                        return false;
                    }

                    const target = event.currentTarget;

                    window.requestAnimationFrame(() =>
                    {
                        const maxDeltaX = target.scrollWidth - target.offsetWidth;

                        this._$scrollX = Util.$clamp(
                            this._$scrollX + delta, 0, maxDeltaX
                        );

                        Util
                            .$timelineLayer
                            .moveTimeLine(this._$scrollX);
                    });
                }

            }, { "passive" : false });

            element
                .addEventListener("mouseleave", () =>
                {
                    this.clearParams();
                    window.removeEventListener("keydown", this._$deleteIcon);
                });

            element
                .addEventListener("mouseover", () =>
                {
                    window.addEventListener("keydown", this._$deleteIcon);
                });
        }
    }

    /**
     * @description クラスで利用する変数を初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clearParams ()
    {
        this._$targetElement = null;
    }

    /**
     * @description タイムラインのヘッダーを生成
     *
     * @param  {boolean} [build=true]
     * @return {void}
     * @method
     * @public
     */
    create (build = false)
    {
        // 描画エリアのサイズをセット
        const element = document
            .getElementById("timeline-header");

        if (!element) {
            return ;
        }

        // シーン移動や初回起動の時は初期化
        if (build) {

            // 変数を初期化
            this.lastFrame = 0;
            this._$scrollX = 0;
            this.clearParams();

            // スクロール位置を初期化
            Util.$timelineMarker.move();
            Util.$timelineLayer.moveTimeLine(0);

            // remove all
            while (element.children.length) {
                element.children[0].remove();
            }
        }

        // 生成する範囲の補正幅
        const adjustmentWidth = build ? 0 : element.scrollWidth;

        const fps = document
            .getElementById("stage-fps")
            .value | 0;

        let frame = this.lastFrame + 1;
        let sec   = Math.max(1, (frame / 24 | 0) + 1);
        let limit = Math.ceil(window.parent.screen.width * 2.5
            + Util.$currentWorkSpace().scene.totalFrame
            * (TimelineTool.DEFAULT_TIMELINE_WIDTH + 1)// +1はborder solidの1px
        ) - adjustmentWidth;

        for (;;) {

            const htmlTag = `
<div class="frame-header-parent" data-frame="${frame}">
    <div class="frame-sec ${frame % 5 === 0 ? "frame-border-end" : "frame-border"}" data-frame="${frame}">${frame % fps === 0 && fps > 4 ? sec++ + "s" : ""}</div>
    <div id="frame-label-marker-${frame}" class="frame-border-box" data-type="marker" data-frame="${frame}"></div>
    <div id="frame-label-action-${frame}" class="frame-border-box" data-type="action" data-frame="${frame}"></div>
    <div id="frame-label-sound-${frame}" class="frame-border-box" data-type="sound" data-frame="${frame}"></div>
    <div class="frame-number" data-frame="${frame}">${frame % 5 === 0 ? frame : ""}</div>
</div>
`;
            // add child
            element.insertAdjacentHTML("beforeend", htmlTag);

            element
                .lastElementChild
                .addEventListener("mousedown", (event) =>
                {
                    this.moveMarker(event);
                });

            // アイコンにdrag/dropイベントを登録
            const icons = [
                "marker",
                "action",
                "sound"
            ];

            for (let idx = 0; idx < icons.length; ++idx) {

                const element = document
                    .getElementById(`frame-label-${icons[idx]}-${frame}`);

                if (!element) {
                    continue;
                }

                element.addEventListener("mousedown", (event) =>
                {
                    this.dragIcon(event);
                });

                element.addEventListener("dragover", (event) =>
                {
                    event.preventDefault();
                });

                element.addEventListener("drop", (event) =>
                {
                    this.dropIcon(event);
                });
            }

            // +1はborder solidの1px
            limit -= TimelineTool.DEFAULT_TIMELINE_WIDTH + 1;
            if (0 >= limit) {
                break;
            }

            if (limit > 0) {
                frame++;
            }
        }

        this.lastFrame = frame;
    }

    /**
     * @description ラベル・スクリプト・サウンドのアイコンを移動開始関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    dragIcon (event)
    {
        const target = event.target;
        if (target.classList.contains("frame-border-box")) {
            return ;
        }

        // 全てのイベントを中止
        event.stopPropagation();

        // setup
        target.draggable     = true;
        this._$targetElement = target;
    }

    /**
     * @description 指定したアイコンを削除する
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     */
    deleteIcon (event)
    {
        if (Util.$keyLock) {
            return ;
        }

        if (event.key !== "Backspace") {
            return ;
        }

        if (!this._$targetElement) {
            return ;
        }

        this.save();

        const frame = this._$targetElement.dataset.frame | 0;
        const scene = Util.$currentWorkSpace().scene;
        const type  = this._$targetElement.dataset.type;
        switch (type) {

            case "marker":
                scene.deleteLabel(frame);
                break;

            case "action":
                scene.deleteAction(frame);
                break;

            case "sound":
                scene.deleteSound(frame);
                break;

            default:
                break;

        }

        // スタイルの変更して初期化
        this
            ._$targetElement
            .setAttribute("class", "frame-border-box");

        this._$targetElement = null;

        // 初期化
        super.focusOut();
    }

    /**
     * @description ラベル・スクリプト・サウンドのアイコンを移動処理関数
     *
     * @param  {DragEvent} event
     * @return {void}
     * @method
     * @public
     */
    dropIcon (event)
    {
        if (!this._$targetElement) {
            return ;
        }

        event.preventDefault();
        this._$targetElement.draggable = false;

        const target = event.target;

        const dragFrame = this._$targetElement.dataset.frame | 0;
        const dropFrame = target.dataset.frame | 0;

        // フレームが異なれば処理を行う
        if (dragFrame !== dropFrame) {

            this.save();

            const scene = Util.$currentWorkSpace().scene;
            const type  = this._$targetElement.dataset.type;

            // 表示を追加
            const element = document
                .getElementById(`frame-label-${type}-${dropFrame}`);

            element
                .setAttribute("class", `frame-border-box-${type}`);

            switch (type) {

                case "marker":
                    scene.setLabel(dropFrame, scene.gerLabel(dragFrame));
                    break;

                case "action":
                    scene.setAction(dropFrame, scene.getAction(dragFrame));
                    break;

                case "sound":
                    scene.setSound(dropFrame, scene.getSound(dragFrame));
                    break;

                default:
                    break;

            }

            // 複製でない時は削除する
            if (!Util.$altKey) {
                this.deleteIcon({ "key": "Backspace" });
            }

            // 新しいアイコンのelementをセット
            this._$targetElement = element;
        }

        // 初期化
        super.focusOut();
    }

    /**
     * @description ヘッダーのフレーム枠をマウスダウンした時の処置
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    moveMarker (event)
    {
        // 全てのイベント停止
        event.stopPropagation();

        // 変数を初期化
        this.clearParams();

        // フレームを更新
        Util.$timelineFrame.currentFrame = event.target.dataset.frame | 0;

        // マーカーを移動
        Util.$timelineMarker.move();

        // 移動先の音声設定を生成
        Util.$soundController.createSoundElements();

        // マーカーの移動を有効化
        Util.$timelineMarker.startMarker();
    }
}

Util.$timelineHeader = new TimelineHeader();

/**
 * @class
 */
class TimelineHighlight
{
    /**
     * @description ランダムにカラーを返す
     *
     * @return {string}
     * @static
     */
    static get color ()
    {
        const colors = [
            "#ef857d",
            "#ffedab",
            "#a3d6cc",
            "#8d93c8",
            "#e3acae",
            "#ea5550",
            "#00947a",
            "#4d4398",
            "#915da3",
            "#ed6d35",
            "#bd6856",
            "#72640c",
            "#98605e",
            "#6c3524",
            "#f8f4e6",
            "#6a1917",
            "#7f1184",
            "#00afcc",
            "#e3e548",
            "#af0082",
            "#0073a8",
            "#e4007f"
        ];

        const index = Math.random() * colors.length | 0;
        return colors[index];
    }
}

/**
 * @class
 * @extends {KeyboardCommand}
 */
class TimelineKeyboardCommand extends KeyboardCommand
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("timeline");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document
            .getElementById("timeline");

        if (element) {

            element.addEventListener("mouseleave", () =>
            {
                this.active = false;
            });

            element.addEventListener("mouseover", () =>
            {
                if (!this.active) {
                    this.active = true;
                }
            });
        }

        // レイヤー追加コマンド
        this.add(
            Util.$generateShortcutKey("+", { "ctrl": true }),
            this.addLayer
        );
        this.add(
            Util.$generateShortcutKey(";", { "ctrl": true }),
            this.addLayer
        );

        // レイヤの削除コマンド
        this.add(
            Util.$generateShortcutKey("Backspace", { "ctrl": true }),
            this.deleteLayer
        );

        // フレームに設定されてるDisplayObjectを削除
        this.add("Backspace", this.removeFrameCharacter);

        // レイヤーの上下移動
        this.add("ArrowDown", this.selectLayer);
        this.add("ArrowUp", this.selectLayer);

        // タイムラインの左右移動
        this.add("ArrowLeft", this.moveFrame);
        this.add("ArrowRight", this.moveFrame);

        // フレーム追加コマンド
        this.add("f", this.addFrame);
        this.add(
            Util.$generateShortcutKey("f", { "ctrl": true }),
            this.deleteFrame
        );

        // キーフレーム追加コマンド
        this.add("k", this.addKeyFrame);
        this.add(
            Util.$generateShortcutKey("k", { "ctrl": true }),
            this.deleteKeyFrame
        );

        // ラベルへのフォーカス
        this.add("l", this.focusLabel);

        // 空のキーフレームを追加
        this.add("e", this.addEmptyKey);

        // JavaScriptのモーダルを起動
        this.add("s", this.openScriptModal);

        // 選択肢たフレームのDisplayObjectのプロパティーに切り替え
        this.add("v", this.activePropertyTab);

        // ズームへのフォーカス
        this.add("z", this.focusZoom);

        // プレビュー機能のOn/Off
        this.add("p", Util.$timelineTool.executeTimelinePreview);

        // オニオンスキンを起動
        this.add("o", () => {
            Util
                .$timelineTool
                .executeTimelineOnionSkin();
        });

        // tweenを起動
        this.add("m", () =>
        {
            Util
                .$timelineMenu
                .executeContextMenuTweenAdd();
        });

        // tweenを削除
        this.add(Util.$generateShortcutKey("m", { "ctrl": true }), () =>
        {
            Util
                .$timelineMenu
                .executeContextMenuTweenDelete();
        });

        // レイヤの削除コマンド
        this.add(Util.$generateShortcutKey("h", { "shift": true }), () =>
        {
            Util
                .$timelineTool
                .executeTimelineLayerLightAll();
        });

        this.add(Util.$generateShortcutKey("l", { "shift": true }), () =>
        {
            Util
                .$timelineTool
                .executeTimelineLayerLockAll();
        });

        this.add(Util.$generateShortcutKey("d", { "shift": true }), () =>
        {
            Util
                .$timelineTool
                .executeTimelineLayerDisableAll();
        });

        this.add(Util.$generateShortcutKey("n", { "shift": true }), () =>
        {
            Util
                .$timelineLayerMenu
                .executeTimelineLayerNormal();
        });

        this.add(Util.$generateShortcutKey("m", { "shift": true }), () =>
        {
            Util
                .$timelineLayerMenu
                .executeTimelineLayerMask();
        });

        this.add(Util.$generateShortcutKey("g", { "shift": true }), () =>
        {
            Util
                .$timelineLayerMenu
                .executeTimelineLayerGuide();
        });
    }

    /**
     * @description 選択肢たフレームのDisplayObjectのプロパティーに切り替え
     *
     * @return {void}
     * @method
     * @public
     */
    activePropertyTab ()
    {
        // タブの切り替え
        document
            .getElementById("controller-tab-area")
            .children[0].click();
    }

    /**
     * @description JavaScriptのモーダルの起動
     *
     * @return {void}
     * @method
     * @public
     */
    openScriptModal ()
    {
        Util.$javaScriptEditor.show();
    }

    /**
     * @description ズームへフォーカス
     *
     * @return {void}
     * @method
     * @public
     */
    focusZoom ()
    {
        document.getElementById("timeline-scale").focus();
    }

    /**
     * @description ラベルへフォーカス
     *
     * @return {void}
     * @method
     * @public
     */
    focusLabel ()
    {
        document.getElementById("label-name").focus();
    }

    /**
     * @description 指定フレームにフレームを削除
     *
     * @return {void}
     * @method
     * @public
     */
    deleteFrame ()
    {
        Util.$timelineTool.executeTimelineFrameDelete();
    }

    /**
     * @description 指定フレームにフレームを追加
     *
     * @return {void}
     * @method
     * @public
     */
    addFrame ()
    {
        Util.$timelineTool.executeTimelineFrameAdd();
    }

    /**
     * @description 左右キーでフレームを移動
     *
     * @param  {string} code
     * @return {void}
     * @method
     * @public
     */
    moveFrame (code)
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const index = code
            ? code === "ArrowRight" ? 1 : -1
            : 0;

        const frame = Math.max(1, Math.min(
            Util.$timelineFrame.currentFrame + index,
            Util.$timelineHeader.lastFrame
        ));

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();

        // フレーム移動前にラベルの情報を更新する
        Util.$timelineLayer.changeLabel(frame); // fixed logic

        // フレーム移動
        Util.$timelineLayer.moveFrame(frame);
        Util.$timelineLayer.activeLayer(targetLayer);
        Util.$timelineMarker.moveVisibleLocation();
    }

    /**
     * @description 上下キーで選択レイヤーを操作
     *
     * @param  {string} code
     * @return {void}
     * @method
     * @public
     */
    selectLayer (code)
    {
        let element = null;

        const parent = document
            .getElementById("timeline-content");

        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {

            if (code === "ArrowDown") {

                element = parent.firstElementChild;
                parent.scrollTop = 0;

            } else {

                element = parent.lastElementChild;
                parent.scrollTop = parent.scrollHeight;

            }

        } else {

            if (code === "ArrowDown") {

                element = targetLayer.nextElementSibling;
                if (!element) {
                    return ;
                }

                if (element.offsetTop + element.offsetHeight
                    > window.innerHeight
                ) {
                    parent.scrollTop += element.offsetHeight;
                }

            } else {

                element = targetLayer.previousElementSibling;
                if (!element) {
                    return ;
                }

                if (parent.offsetTop + parent.scrollTop >= element.offsetTop) {
                    parent.scrollTop -= element.offsetHeight;
                }

            }

        }

        Util
            .$timelineLayer
            .activeLayer(element);
    }

    /**
     * @description 選択中のレイヤーを削除
     *
     * @return {void}
     * @method
     * @public
     */
    deleteLayer ()
    {
        Util.$timelineTool.executeTimelineLayerTrash();
    }

    /**
     * @description 選択中のフレームに設定されてるDisplayObjectを削除
     *
     * @method
     * @public
     */
    removeFrameCharacter ()
    {
        Util.$timelineLayer.removeFrame();
    }

    /**
     * @description 新規レイヤーを追加
     *
     * @method
     * @public
     */
    addLayer ()
    {
        Util.$timelineTool.executeTimelineLayerAdd();
    }

    /**
     * @description 空のキーフレームを追加
     *
     * @method
     * @public
     */
    addEmptyKey ()
    {
        Util.$timelineTool.executeTimelineEmptyAdd();
    }

    /**
     * @description キーフレームを追加
     *
     * @return {void}
     * @method
     * @public
     */
    addKeyFrame ()
    {
        Util.$timelineTool.executeTimelineKeyAdd();
    }

    /**
     * @description キーフレームを削除
     *
     * @return {void}
     * @method
     * @public
     */
    deleteKeyFrame ()
    {
        Util.$timelineTool.executeTimelineKeyDelete();
    }
}

Util.$timelineKeyboardCommand = new TimelineKeyboardCommand();

/**
 * @class
 * @extends {BaseTimeline}
 */
class TimelineLayer extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {Map}
         * @private
         */
        this._$targetFrames = new Map();

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$activeKeyEvent = false;

        /**
         * @type {Map}
         * @private
         */
        this._$targetLayers = new Map();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$scrollX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$clientX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$clientY = 0;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$moveLayerId = -1;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$selectLayerId = -1;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$destLayer = null;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$timerId = -1;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$exitLayer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$executeMoveLayer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$moveLayer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endInput = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$moveTargetGroup = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endTargetGroup = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$multiSelect = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endMultiSelect = null;
    }

    /**
     * @description 選択中の全てのフレームElementを返す
     *
     * @return {Map}
     * @public
     */
    get targetFrames ()
    {
        return this._$targetFrames;
    }

    /**
     * @description 選択中のフレームElementを返す
     *
     * @return {HTMLDivElement|null}
     * @public
     */
    get targetFrame ()
    {
        return this.targetFrames.size
            ? this.targetFrames.values().next().value[0]
            : null;
    }

    /**
     * @description 選択中の全てのレイヤーElementを返す
     *
     * @return {Map}
     * @public
     */
    get targetLayers ()
    {
        return this._$targetLayers;
    }

    /**
     * @description 選択中のレイヤーElementを返す
     *
     * @return {HTMLDivElement|null}
     * @public
     */
    get targetLayer ()
    {
        return this.targetLayers.size
            ? this.targetLayers.values().next().value
            : null;
    }

    /**
     * @description 選択したレイヤーのElementをセット
     *
     * @param  {HTMLDivElement} layer
     * @return {void}
     * @public
     */
    set targetLayer (layer)
    {
        switch (true) {

            case Util.$ctrlKey:
                if (layer) {
                    if (this.targetLayers.has(layer.id)) {

                        // アクティブな時は非アクティブにして選択リストから削除
                        layer
                            .classList
                            .remove("active");

                        this.targetLayers.delete(layer.id);
                    } else {

                        // アクティブ表示
                        layer
                            .classList
                            .add("active");

                        this.targetLayers.set(layer.id, layer);
                    }

                }
                break;

            case Util.$shiftKey:
                if (layer) {
                    const baseLayer = this.targetLayer;
                    if (!baseLayer || baseLayer.id === layer.id) {
                        return ;
                    }

                    this.clearActiveLayers();
                    this.clearActiveFrames();

                    const children = Array.from(
                        document.getElementById("timeline-content").children
                    );

                    const baseIndex   = children.indexOf(baseLayer);
                    const targetIndex = children.indexOf(layer);

                    const min = Math.min(baseIndex, targetIndex);
                    const max = Math.max(baseIndex, targetIndex);

                    this.targetLayers.set(
                        baseLayer.id,
                        baseLayer
                    );

                    for (let idx = min; idx <= max; ++idx) {

                        const targetLayer = children[idx];

                        // アクティブな時は非アクティブにして選択リストから削除
                        targetLayer
                            .classList
                            .add("active");

                        if (this.targetLayers.has(targetLayer.id)) {
                            continue;
                        }

                        this.targetLayers.set(targetLayer.id, targetLayer);

                    }
                }
                break;

            default:
                // 選択中の全てのElementを非アクティブに
                this.clearActiveLayers();
                this.clearActiveFrames();

                if (layer) {

                    // アクティブ表示
                    layer
                        .classList
                        .add("active");

                    this.targetLayers.set(layer.id, layer);
                }

                break;

        }
    }

    /**
     * @description 指定したレイヤーのフレームElementをアクティブ化
     *
     * @param  {number} layer_id
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    addTargetFrame (layer_id, element)
    {
        layer_id |= 0;

        if (!this.targetFrames.has(layer_id)) {
            this.targetFrames.set(layer_id, []);
        }

        const frames = this.targetFrames.get(layer_id);

        // 重複チェック
        if (frames.indexOf(element) > -1) {
            return ;
        }

        frames.push(element);

        element
            .classList
            .add("frame-active");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const timeline = document
            .getElementById("timeline");

        if (timeline) {
            timeline.addEventListener("mouseover", () =>
            {
                Util.$setCursor("auto");
            });
        }

        const element = document
            .getElementById("timeline-content");

        if (element) {
            element.addEventListener("wheel", (event) =>
            {
                if (!Util.$altKey) {
                    return ;
                }

                const deltaY = event.deltaY | 0;
                if (!deltaY) {
                    return false;
                }

                event.preventDefault();

                window.requestAnimationFrame(() =>
                {
                    Util.$timelineTool.timelineWidth = Util.$clamp(
                        Util.$timelineTool.timelineWidth + deltaY,
                        5,
                        240
                    );
                });
            });
        }

        // フレーム移動のElementを非表示
        this.hideTargetGroup();
    }

    /**
     * @description タイムラインで選択したレイヤに設置されたDisplayObjectをアクティブ化する
     *
     * @return {void}
     * @method
     * @public
     */
    activeCharacter ()
    {
        if (!this.targetLayers.size) {
            return ;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        // 選択中のDisplayObjectを初期化
        tool.clearActiveElement();

        Util
            .$transformController
            .hide();

        Util
            .$gridController
            .hide();

        const frame = Util.$timelineFrame.currentFrame;
        const scene = Util.$currentWorkSpace().scene;

        // 複数選択ようにshiftキーをonにする
        const cacheValue = Util.$shiftKey;
        Util.$shiftKey   = true;

        // アクティブ判定
        for (const layerId of this.targetFrames.keys()) {

            const layer = scene.getLayer(layerId);
            const characters = layer.getActiveCharacter(frame);
            for (let idx = 0; idx < characters.length; ++idx) {

                const character = characters[idx];

                const characterElement = document
                    .getElementById(`character-${character.id}`);

                if (!characterElement) {
                    continue;
                }

                tool.addElement(characterElement, true);
            }
        }

        // shiftキーを元の値に戻す
        Util.$shiftKey = cacheValue;

        // コントローラーエリアを初期化
        Util.$controller.default();
        if (tool.activeElements.length) {

            // コントローラーエリアの表示を更新
            tool.updateControllerProperty();

            // 拡大縮小回転のElementのポイントを表示して再計算
            Util
                .$transformController
                .show()
                .relocation();

            // 9sliceのElementのポイントを表示して再計算
            Util
                .$gridController
                .show()
                .relocation();

        } else {

            Util
                .$tweenController
                .clearPointer();

        }

    }

    /**
     * @description タイムラインの全てのアクティブElementを非アクティブ化
     *              外部クラスからコールされる想定
     *
     * @return {void}
     * @method
     * @public
     */
    clear ()
    {
        this.clearActiveLayers();
        this.clearActiveFrames();
    }

    /**
     * @description タイムラインの全てのElementを削除
     *
     * @return {void}
     * @method
     * @public
     */
    removeAll ()
    {
        const element = document
            .getElementById("timeline-content");

        while (element.firstChild) {
            element.firstChild.remove();
        }
    }

    /**
     * @description タイムラインにレイヤーを追加する
     *
     * @param  {number} [current_frame=1]
     * @param  {number} [layer_id=-1]
     * @return {void}
     * @method
     * @public
     */
    create (current_frame = 0, layer_id = -1)
    {
        let frame = current_frame + 1;

        const scene   = Util.$currentWorkSpace().scene;
        const layerId = layer_id === -1 ? scene._$layerId : layer_id;

        const element = document
            .getElementById("timeline-content");

        const lastFrame = Util.$timelineHeader.lastFrame;

        let parent = document
            .getElementById(`frame-scroll-id-${layerId}`);

        // イベント登録は初回だけ
        if (!parent) {

            element.insertAdjacentHTML("beforeend", `
<div class="timeline-content-child" id="layer-id-${layerId}" data-layer-id="${layerId}">

    <div class="timeline-layer-controller">
        <i class="timeline-exit-icon" id="timeline-exit-icon-${layerId}" data-layer-id="${layerId}"></i>
        <i class="timeline-exit-in-icon" id="timeline-exit-in-icon-${layerId}" data-layer-id="${layerId}"></i>
        <i class="timeline-layer-icon" id="layer-icon-${layerId}" data-layer-id="${layerId}" data-detail="{{レイヤー変更(ダブルクリック)}}"></i>
        <i class="timeline-mask-icon" id="layer-mask-icon-${layerId}" data-layer-id="${layerId}" data-detail="{{レイヤー変更(ダブルクリック)}}"></i>
        <i class="timeline-mask-in-icon" id="layer-mask-in-icon-${layerId}" data-layer-id="${layerId}"></i>
        <i class="timeline-guide-icon" id="layer-guide-icon-${layerId}" data-layer-id="${layerId}" data-detail="{{レイヤー変更(ダブルクリック)}}"></i>
        <i class="timeline-guide-in-icon" id="layer-guide-in-icon-${layerId}" data-layer-id="${layerId}" data-detail="{{レイヤー変更(ダブルクリック)}}"></i>
        <div class="view-text" id="layer-name-${layerId}" data-layer-id="${layerId}">layer_${layerId}</div>
        <input type="text" class="view-text-input" id="layer-name-input-${layerId}" data-layer-id="${layerId}" value="layer_${layerId}" style="display: none;">
        <i class="timeline-layer-light-one icon-disable" id="layer-light-icon-${layerId}" data-click-type="light" data-layer-id="${layerId}" data-detail="{{レイヤーをハイライト}}"></i>
        <i class="timeline-layer-disable-one icon-disable" id="layer-disable-icon-${layerId}" data-click-type="disable" data-layer-id="${layerId}" data-detail="{{レイヤーを非表示}}"></i>
        <i class="timeline-layer-lock-one icon-disable" id="layer-lock-icon-${layerId}" data-click-type="lock" data-layer-id="${layerId}" data-detail="{{レイヤーをロック}}"></i>
    </div>

    <div class="timeline-frame-controller" id="frame-scroll-id-${layerId}">
        <div class="timeline-frame">
        </div>
    </div>
</div>
`);

            parent = document
                .getElementById(`frame-scroll-id-${layerId}`);

            // レイヤー名の変更イベントを登録
            document
                .getElementById(`layer-name-${layerId}`)
                .addEventListener("dblclick", (event) =>
                {
                    this.showInput(event);
                });

            // レイヤー切り替えイベントを登録
            document
                .getElementById(`layer-icon-${layerId}`)
                .addEventListener("dblclick", (event) =>
                {
                    this.showLayerMenu(event);
                });

            // ガイドアイコン
            const guideIcon = document
                .getElementById(`layer-guide-icon-${layerId}`);

            guideIcon.addEventListener("dblclick", (event) =>
            {
                this.showLayerMenu(event);
            });
            guideIcon.addEventListener("mouseover", (event) =>
            {
                this.exitLayer(event);
            });
            guideIcon.addEventListener("mouseout", (event) =>
            {
                this.endExitLayer(event);
            });

            // マスクアイコン
            const maskIcon = document
                .getElementById(`layer-mask-icon-${layerId}`);

            maskIcon.addEventListener("dblclick", (event) =>
            {
                this.showLayerMenu(event);
            });
            maskIcon.addEventListener("mouseover", (event) =>
            {
                this.exitLayer(event);
            });
            maskIcon.addEventListener("mouseout", (event) =>
            {
                this.endExitLayer(event);
            });

            // グループから外すexitアイコン
            const exitIcon = document
                .getElementById(`timeline-exit-icon-${layerId}`);

            exitIcon.addEventListener("mouseover", (event) =>
            {
                this.exitLayer(event);
            });
            exitIcon.addEventListener("mouseout", (event) =>
            {
                this.endExitLayer(event);
            });

            const exitInIcon = document
                .getElementById(`timeline-exit-in-icon-${layerId}`);

            exitInIcon.addEventListener("mouseover", (event) =>
            {
                this.exitLayer(event);
            });
            exitInIcon.addEventListener("mouseout", (event) =>
            {
                this.endExitLayer(event);
            });

            // レイヤーの説明モーダルを登録
            const layer = document.getElementById(`layer-id-${layerId}`);
            Util.$addModalEvent(layer);

            // レイヤー全体のイベント
            layer.addEventListener("mousedown", (event) =>
            {
                this.selectLayer(event);
            });

            const layerController = layer
                .getElementsByClassName("timeline-layer-controller")[0];

            // レイヤーのコントロール部分へ、レイヤー移動イベントを登録する
            layerController.addEventListener("mouseover", (event) =>
            {
                this.activeMoveLayer(event);
            });
            layerController.addEventListener("mouseout", (event) =>
            {
                this.inactiveMoveLayer(event);
            });
            layerController.addEventListener("contextmenu", (event) =>
            {
                this.showLayerMenu(event);
            });

            // レイヤーの横移動イベント
            const frameController = layer
                .getElementsByClassName("timeline-frame-controller")[0];

            frameController.addEventListener("wheel", (event) =>
            {
                const deltaX = event.deltaX | 0;
                if (!deltaX) {
                    return false;
                }

                event.preventDefault();

                const target = event.currentTarget;

                window.requestAnimationFrame(() =>
                {
                    const maxDeltaX = target.scrollWidth - target.offsetWidth;

                    this._$scrollX = Util.$clamp(
                        this._$scrollX + deltaX, 0, maxDeltaX
                    );

                    this.moveTimeLine(this._$scrollX);
                });

            }, { "passive" : false });

            // タイムラインプレビュー機能
            frameController.addEventListener("mouseover", (event) =>
            {
                this.showLayerPreview(event);
            });
            frameController.addEventListener("mouseout", () =>
            {
                this.hideLayerPreview();
            });

            frameController.addEventListener("mousedown", (event) =>
            {
                this.selectFrame(event);
            });

            // ハイライトアイコン
            document
                .getElementById(`layer-light-icon-${layerId}`)
                .addEventListener("mousedown", (event) =>
                {
                    this.clickLight(event);
                });

            // 表示・非表示アイコン
            document
                .getElementById(`layer-disable-icon-${layerId}`)
                .addEventListener("mousedown", (event) =>
                {
                    this.clickDisable(event);
                });

            // ロックアイコン
            document
                .getElementById(`layer-lock-icon-${layerId}`)
                .addEventListener("mousedown", (event) =>
                {
                    this.clickLock(event);
                });

            // スクロールエリア
            const frameElement = document
                .getElementById(`frame-scroll-id-${layerId}`);

            frameElement.addEventListener("contextmenu", (event) =>
            {
                Util.$timelineMenu.show(event);
            });

            frameElement.scrollLeft = this._$scrollX;

            // end
            scene._$layerId++;
        }

        let htmlTag = "";
        while (lastFrame >= frame) {
            htmlTag += `<div class="${frame % 5 !== 0 ? "frame" : "frame frame-pointer"}" data-type="${frame % 5 !== 0 ? "frame" : "frame-pointer"}" data-frame-state="empty" data-layer-id="${layerId}" id="${layerId}-${frame}" data-frame="${frame++}"></div>`;
        }

        if (htmlTag) {
            parent
                .firstElementChild
                .insertAdjacentHTML("beforeend", htmlTag);
        }
    }

    /**
     * @description 指定しているフレームのDisplayObjectを削除
     *
     * @return {void}
     * @method
     * @public
     */
    removeFrame ()
    {
        const targetLayer = this.targetLayer;
        if (!targetLayer) {
            return ;
        }

        this.save();

        let reload = false;
        const frame = Util.$timelineFrame.currentFrame;
        const scene = Util.$currentWorkSpace().scene;
        const targetFrames = this.targetFrames;
        for (const layerId of targetFrames.keys()) {

            const layer = scene.getLayer(layerId);

            const characters = layer.getActiveCharacter(frame);
            if (!characters.length) {
                continue;
            }

            reload = true;
            let range = null;
            for (let idx = 0; idx < characters.length; ++idx) {

                const character = characters[idx];

                if (!range) {
                    range = character.getRange(frame);
                }

                character.remove(layer);
            }

            layer.addEmptyCharacter(
                new EmptyCharacter({
                    "startFrame": range.startFrame,
                    "endFrame": range.endFrame
                })
            );

            layer.reloadStyle();
        }

        // 選択中にフレームを解放
        this.clearActiveFrames();

        // スクリーンのDisplayObjectをアクティブ化
        this.activeCharacter();

        if (reload) {
            this.reloadScreen();
        }

        // 初期化
        super.focusOut();
    }

    /**
     * @description レイヤー指定がない場合は一番上のレイヤーを強制的に選択
     *              レイヤーが0の時はレイヤーを強制的に追加する
     *
     * @return {void}
     * @method
     * @public
     */
    attachLayer ()
    {
        if (!this.targetLayer) {

            let targetLayer = document
                .getElementById("timeline-content")
                .children[0];

            // レイヤーがない時は強制的に追加
            if (!targetLayer) {

                Util
                    .$currentWorkSpace()
                    .scene
                    .addLayer();

                targetLayer = document
                    .getElementById("timeline-content")
                    .children[0];
            }

            const shift = Util.$shiftKey;
            const ctrl  = Util.$ctrlKey;

            Util.$shiftKey = false;
            Util.$ctrlKey  = false;

            // セット
            this.targetLayer = targetLayer;

            Util.$shiftKey = shift;
            Util.$ctrlKey  = ctrl;
        }
    }

    /**
     * @description マスクやガイドなどのグルーピングされたレイヤーを抜ける処理
     *
     * @return {void}
     * @method
     * @public
     */
    exitLayer (event)
    {
        if (this._$moveLayerId === -1) {
            return ;
        }

        const layerId = event.target.dataset.layerId | 0;

        let element = document
            .getElementById(`layer-id-${layerId}`);

        const children = Array.from(
            document.getElementById("timeline-content").children
        );

        const scene = Util.$currentWorkSpace().scene;
        const index = children.indexOf(element);
        const node  = children[index + 1];
        if (node) {
            const layer = scene
                .getLayer(node.dataset.layerId | 0);

            switch (layer.mode) {

                // 最終行じゃない時は何もしない
                case Util.LAYER_MODE_MASK_IN:
                case Util.LAYER_MODE_GUIDE_IN:
                    return ;

                default:
                    break;

            }
        }

        // 最終行の場合はフラグをOnにする
        this._$exitLayer = element;

        document
            .getElementById(`timeline-exit-icon-${layerId}`)
            .style.opacity = "1";
        document
            .getElementById(`timeline-exit-in-icon-${layerId}`)
            .style.opacity = "1";
    }

    /**
     * @description グルーピングされたレイヤーを抜ける処理を解除
     *
     * @return {void}
     * @method
     * @public
     */
    endExitLayer (event)
    {
        if (this._$moveLayerId === -1) {
            return ;
        }

        this._$exitLayer = null;

        const layerId = event.target.dataset.layerId | 0;
        document
            .getElementById(`timeline-exit-icon-${layerId}`)
            .style.opacity = "0";
        document
            .getElementById(`timeline-exit-in-icon-${layerId}`)
            .style.opacity = "0";
    }

    /**
     * @description タイムラインのハイライトのOn/Off
     *
     * @return {void}
     * @method
     * @public
     */
    clickLight (event)
    {
        if (event.button) {
            return ;
        }

        event.stopPropagation();
        this.changeType(event.target, "light");
    }

    /**
     * @description タイムラインのロックのOn/Off
     *
     * @return {void}
     * @method
     * @public
     */
    clickLock (event)
    {
        if (event.button) {
            return ;
        }

        event.stopPropagation();
        this.changeType(event.target, "lock");
        Util
            .$transformController
            .show()
            .relocation();
    }

    /**
     * @description タイムラインの表示・非表示のOn/Off
     *
     * @return {void}
     * @method
     * @public
     */
    clickDisable (event)
    {
        if (event.button) {
            return ;
        }

        event.stopPropagation();
        this.changeType(event.target, "disable");

        // スクリーンエリアの変形Elementを表示
        Util
            .$transformController
            .show();

        // Shapeのポインターを初期化
        Util.$clearShapePointer();

        // 再描画
        this.reloadScreen();
    }

    /**
     * @description タイムラインのアイコン押下処理
     *
     * @param  {HTMLDivElement} element
     * @param  {string} type
     * @return {void}
     * @method
     * @public
     */
    changeType (element, type)
    {
        const layerId = element.dataset.layerId | 0;

        const layerElement = document
            .getElementById(`layer-id-${layerId}`);

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layerId);

        layer[type] = !layer[type];
        if (layer[type]) {

            element
                .classList
                .remove("icon-disable");

            if (type === "light") {

                element
                    .classList
                    .add("light-icon-active");

                layerElement
                    .style
                    .borderBottom = `1px solid ${layer.color}`;

            } else {

                element
                    .classList
                    .add("icon-active");

                layerElement
                    .classList
                    .add(`${type}-active`);

            }

        } else {

            element
                .classList
                .add("icon-disable");

            if (type === "light") {

                element
                    .classList
                    .remove("light-icon-active");

                layerElement.style.borderBottom = "";

            } else {

                element
                    .classList
                    .remove("icon-active");

                layerElement
                    .classList
                    .remove(`${type}-active`);

            }

        }

        if (type === "lock") {
            this.reloadScreen();
        }
    }

    /**
     * @description レイヤー変更メニューモーダルを表示
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    showLayerMenu (event)
    {
        // 他のイベント全て中止
        event.preventDefault();
        event.stopPropagation();

        const layerId = event.target.dataset.layerId | 0;

        this.targetLayer = document
            .getElementById(`layer-id-${layerId}`);

        Util.$timelineLayerMenu.show(event);
    }

    /**
     * @description InputElementを表示
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    showInput (event)
    {
        // 他のイベント全て中止
        event.stopPropagation();

        Util.$keyLock = true;

        const layerId = event.target.dataset.layerId | 0;

        const input = document
            .getElementById(`layer-name-input-${layerId}`);

        // Input Elementに値をセットして表示
        input.value = event.target.textContent;
        input.style.display = "";
        input.focus();

        // 表示Elementは非表示
        event.target.style.display = "none";

        // 関数がなければ変数にセット
        if (!this._$endInput) {
            this._$endInput = this.endInput.bind(this);
        }

        // 入力終了イベントを登録
        input.addEventListener("focusout", this._$endInput);
        input.addEventListener("keypress", this._$endInput);
    }

    /**
     * @description 入力終了処理
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    endInput (event)
    {
        if (event.key === "Enter") {
            event.target.blur();
            return ;
        }

        if (event.type !== "focusout") {
            return ;
        }

        // undo用に保存
        this.save();

        // 他のイベント全て中止
        event.stopPropagation();

        const input = event.target;
        const layerId = input.dataset.layerId | 0;

        // レイヤーデータを更新
        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layerId);

        layer.name = input.value;

        // 表示用のElementを表示
        const viewElement = document
            .getElementById(`layer-name-${layerId}`);
        viewElement.textContent   = input.value;
        viewElement.style.display = "";

        // Input Elementを非表示にしてイベントを削除
        input.style.display = "none";
        input.removeEventListener("focusout", this._$endInput);
        input.removeEventListener("keypress", this._$endInput);

        // 初期化
        super.focusOut();
    }

    /**
     * @description レイヤーの移動処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveLayer (event)
    {
        Util.$setCursor("grabbing");

        window.requestAnimationFrame(() =>
        {
            const parent = document
                .getElementById("timeline-content");

            if (event.pageY + 20 > window.innerHeight) {
                parent.scrollTop += event.pageY + 20 - window.innerHeight;
            }

            if (parent.scrollTop > 0 && parent.offsetTop > event.pageY - 8) {
                parent.scrollTop +=  event.pageY - parent.offsetTop - 8;
            }

        });
    }

    /**
     * @description レイヤーの移動を終了する
     *
     * @return {void}
     * @method
     * @public
     */
    executeMoveLayer ()
    {
        window.removeEventListener("mousemove", this._$moveLayer);
        window.removeEventListener("mouseup", this._$executeMoveLayer);

        let exitLayer = null;
        const scene = Util.$currentWorkSpace().scene;
        if (this._$exitLayer) {

            exitLayer = scene.getLayer(
                this._$exitLayer.dataset.layerId | 0
            );

            // valid
            switch (exitLayer.mode) {

                case Util.LAYER_MODE_MASK_IN:
                    // 選択中のレイヤーに親のマスクがあったら初期化して中止
                    for (const layer of this.targetLayers.values()) {
                        if (layer.id !== exitLayer.maskId) {
                            continue;
                        }

                        // 初期化して処理を中止
                        this._$moveLayerId = -1;
                        this._$destLayer   = null;
                        this._$exitLayer   = null;
                        Util.$setCursor("auto");
                        return ;
                    }
                    break;

                case Util.LAYER_MODE_GUIDE_IN:
                    // 選択中のレイヤーに親のガイドがあったら初期化して中止
                    for (const layer of this.targetLayers.values()) {
                        if (layer.id !== exitLayer.guideId) {
                            continue;
                        }

                        // 初期化して処理を中止
                        this._$moveLayerId = -1;
                        this._$destLayer   = null;
                        this._$exitLayer   = null;
                        Util.$setCursor("auto");
                        return ;
                    }
                    break;

                default:
                    break;

            }

            document
                .getElementById(`timeline-exit-icon-${exitLayer.id}`)
                .style.opacity = "0";
            document
                .getElementById(`timeline-exit-in-icon-${exitLayer.id}`)
                .style.opacity = "0";

            this._$destLayer = this._$exitLayer;
        }

        if (this._$destLayer) {

            // 非アクティブへ
            this._$destLayer.classList.remove("move-target");

            // 移動先
            const destLayer = scene.getLayer(
                this._$destLayer.dataset.layerId | 0
            );

            /**
             * 移動先がマスクかマスク対象かガイドかガイド対象レイヤーで
             * 移動対象にマスクレイヤーが含まれる場合
             * もしくは、ガイドレイヤーが含まれる場合は処理を中止する
             */
            if (exitLayer === null) {
                switch (destLayer.mode) {

                    case Util.LAYER_MODE_MASK:
                    case Util.LAYER_MODE_MASK_IN:
                    case Util.LAYER_MODE_GUIDE:
                    case Util.LAYER_MODE_GUIDE_IN:
                        for (const layer of this.targetLayers.values()) {

                            const moveLayer = scene.getLayer(
                                layer.dataset.layerId | 0
                            );

                            switch (moveLayer.mode) {

                                case Util.LAYER_MODE_MASK:
                                case Util.LAYER_MODE_GUIDE:

                                    // 初期化して処理を中止
                                    this._$moveLayerId = -1;
                                    this._$destLayer   = null;
                                    this._$exitLayer   = null;
                                    Util.$setCursor("auto");
                                    return ;

                                default:
                                    break;

                            }

                        }
                        break;

                    default:
                        break;

                }
            }

            // 移動前の状態を保存
            this.save();

            // 親Element
            const element = document
                .getElementById("timeline-content");

            // 複数レイヤーの時は降順に並び替え
            const selectLayers = Array.from(this.targetLayers.values());
            if (selectLayers.length > 1) {

                // マスク対象かガイド対象が含まれているかチェック
                // 含まれている場合で、親Elementが含まれている場合は移動の対象外にする
                for (let idx = 0; idx < selectLayers.length; ++idx) {

                    const layerElement = selectLayers[idx];
                    const layer = scene.getLayer(
                        layerElement.dataset.layerId | 0
                    );

                    switch (layer.mode) {

                        case Util.LAYER_MODE_MASK_IN:
                            {
                                // 親Element
                                const element = document
                                    .getElementById(`layer-id-${layer.maskId}`);

                                const index = selectLayers.indexOf(element);
                                if (index > -1) {
                                    selectLayers.splice(idx, 1);
                                    --idx;
                                }
                            }
                            break;

                        case Util.LAYER_MODE_GUIDE_IN:
                            {
                                // 親Element
                                const element = document
                                    .getElementById(`layer-id-${layer.guideId}`);

                                const index = selectLayers.indexOf(element);
                                if (index > -1) {
                                    selectLayers.splice(idx, 1);
                                    --idx;
                                }
                            }
                            break;

                        default:
                            break;

                    }

                }

                // 降順に並び替え
                const children = Array.from(element.children);
                selectLayers.sort((a, b) =>
                {
                    const aIndex = children.indexOf(a);
                    const bIndex = children.indexOf(b);

                    switch (true) {

                        case aIndex > bIndex:
                            return -1;

                        case aIndex < bIndex:
                            return 1;

                        default:
                            return 0;

                    }
                });
            }

            // 移動開始
            const relationLayers = [];
            for (let idx = 0; idx < selectLayers.length; ++idx) {

                const layer = selectLayers[idx];

                const moveLayer = scene.getLayer(
                    layer.dataset.layerId | 0
                );

                switch (destLayer.mode) {

                    case Util.LAYER_MODE_MASK:
                    case Util.LAYER_MODE_MASK_IN:

                        if (!exitLayer) {

                            // 移動先がマスクか、マスクの対象の時は
                            // マスクIDを紐付けて、アイコンを変更
                            moveLayer.maskId = destLayer.maskId === null
                                ? destLayer.id
                                : destLayer.maskId;

                            moveLayer.mode = Util.LAYER_MODE_MASK_IN;
                            moveLayer.showIcon();

                        } else {

                            if (exitLayer.maskId !== null
                                && exitLayer.maskId === moveLayer.maskId
                            ) {
                                // マスク外に移動するので通常レイヤーに更新
                                moveLayer.maskId = null;
                                moveLayer.mode   = Util.LAYER_MODE_NORMAL;
                                moveLayer.showIcon();
                            }

                        }
                        break;

                    // 移動先がガイドか、ガイドの対象の時
                    case Util.LAYER_MODE_GUIDE:
                    case Util.LAYER_MODE_GUIDE_IN:

                        if (!exitLayer) {

                            // 移動先がガイドか、ガイドの対象の時は
                            // ガイドIDを紐付けて、アイコンを変更
                            moveLayer.guideId = destLayer.guideId === null
                                ? destLayer.id
                                : destLayer.guideId;

                            moveLayer.mode = Util.LAYER_MODE_GUIDE_IN;
                            moveLayer.showIcon();

                        } else {

                            if (exitLayer.guideId !== null
                                && exitLayer.guideId === moveLayer.guideId
                            ) {
                                // マスク外に移動するので通常レイヤーに更新
                                moveLayer.guideId = null;
                                moveLayer.mode    = Util.LAYER_MODE_NORMAL;
                                moveLayer.showIcon();
                            }

                        }

                        break;

                    default:

                        switch (moveLayer.mode) {

                            case Util.LAYER_MODE_MASK_IN:
                                // マスクの外に出る場合はマスク表示を無効化する
                                moveLayer.maskId = null;
                                moveLayer.mode = Util.LAYER_MODE_NORMAL;
                                moveLayer.showIcon();
                                break;

                            case Util.LAYER_MODE_GUIDE_IN:
                                // ガイドの外に出る場合はガイド表示を無効化する
                                moveLayer.guideId = null;
                                moveLayer.mode = Util.LAYER_MODE_NORMAL;
                                moveLayer.showIcon();
                                break;

                            default:
                                break;

                        }

                        break;

                }

                if (relationLayers.length) {
                    relationLayers.length = 0;
                }

                // 移動するレイヤーが親マスクの場合は
                // マスク対象のレイヤーも一緒に移動する
                switch (moveLayer.mode) {

                    case Util.LAYER_MODE_MASK:
                        {

                            const children = Array.from(element.children);
                            let index = children.indexOf(layer);
                            for (;;) {

                                const child = children[++index];
                                if (!child) {
                                    break;
                                }

                                const layer = scene.getLayer(
                                    child.dataset.layerId | 0
                                );

                                // マスク対象がなくなったら終了
                                if (layer.mode !== Util.LAYER_MODE_MASK_IN) {
                                    break;
                                }

                                relationLayers.unshift(child);
                            }
                        }
                        break;

                    case Util.LAYER_MODE_GUIDE:
                        {
                            const children = Array.from(element.children);
                            let index = children.indexOf(layer);
                            for (;;) {

                                const child = children[++index];
                                if (!child) {
                                    break;
                                }

                                const layer = scene.getLayer(
                                    child.dataset.layerId | 0
                                );

                                // マスク対象がなくなったら終了
                                if (layer.mode !== Util.LAYER_MODE_GUIDE_IN) {
                                    break;
                                }

                                relationLayers.unshift(child);
                            }
                        }
                        break;

                    default:
                        break;

                }

                // 指定したレイヤーの下部に移動
                element
                    .insertBefore(layer, this._$destLayer.nextElementSibling);

                // マスク、ガイドに紐ずくElementも一緒に移動する
                if (relationLayers.length) {

                    for (let idx = 0; idx < relationLayers.length; ++idx) {

                        element
                            .insertBefore(
                                relationLayers[idx],
                                layer.nextElementSibling
                            );

                    }

                }

                // スクロール位置を調整
                layer.lastElementChild.scrollLeft
                    = this._$destLayer.lastElementChild.scrollLeft;
            }

            // 並び替えたElementをもとに内部Objectも並び替える
            const layers = [];
            const children = element.children;
            for (let idx = 0; idx < children.length; ++idx) {
                layers.push(
                    scene.getLayer(children[idx].dataset.layerId | 0)
                );
            }

            // レイヤーオブジェクトを初期化
            scene.clearLayer();
            for (let idx = 0; idx < layers.length; ++idx) {
                const layer = layers[idx];
                scene.setLayer(layer.id, layer);
            }

            this.reloadScreen();

        } else {

            // 初回選択出ない時はアクティブ判定を行う
            if (this._$moveLayerId !== this._$selectLayerId) {

                const element = document
                    .getElementById(`layer-id-${this._$moveLayerId}`);

                this.activeLayer(element);

            }

        }

        // 初期化
        super.focusOut();
        this._$selectLayerId = -1;
        this._$moveLayerId   = -1;
        this._$destLayer     = null;
        this._$exitLayer     = null;
        Util.$setCursor("auto");
    }

    /**
     * @description レイヤーの移動先となるレイヤーを変数にセットしてアクティブ表示にする
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    activeMoveLayer (event)
    {
        this._$destLayer = null;
        if (this._$moveLayerId === -1) {
            return ;
        }

        // 他のイベントを中止
        event.stopPropagation();

        // 選択中のレイヤーでなければ移動対象として認識させる
        const element = event.currentTarget.parentNode;
        if (!this.targetLayers.has(element.id)) {

            this._$destLayer = element;
            element.classList.add("move-target");

        }
    }

    /**
     * @description レイヤーの移動先となるレイヤーを変数から削除して非アクティブにする
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    inactiveMoveLayer (event)
    {
        if (this._$moveLayerId === -1 || !this._$destLayer) {
            return ;
        }

        // 他のイベントを中止
        event.stopPropagation();

        // 非アクティブに
        this._$destLayer.classList.remove("move-target");
        this._$destLayer = null;
    }

    /**
     * @description レイヤーのタイムラインの横移動処理
     *
     * @param  {number} [x=0]
     * @return {void}
     * @method
     * @public
     */
    moveTimeLine (x = 0)
    {
        if (0 > x) {
            x = 0;
        }

        const element = document
            .getElementById("timeline-controller-base");

        const limitX = element.scrollWidth - element.offsetWidth;
        if (x > limitX) {
            x = limitX;
        }

        const children = document
            .getElementById("timeline-content")
            .children;

        // 全てのElementの位置を揃える
        const length = children.length;
        for (let idx = 0; idx < length; ++idx) {

            document
                .getElementById(
                    `frame-scroll-id-${children[idx].dataset.layerId}`
                ).scrollLeft = x;

        }

        // タイムラインのscrollXの補正
        element.scrollLeft = x;
        this._$scrollX = Util.$timelineHeader.scrollX = x;
    }

    /**
     * @description タイムラインのフレーム内容をプレビュー表示する
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    showLayerPreview (event)
    {
        if (!document
            .getElementById("timeline-preview")
            .classList
            .contains("timeline-preview-active")
        ) {
            return ;
        }

        const layerId = event.target.dataset.layerId | 0;
        const element = event.target;
        window.requestAnimationFrame(() =>
        {
            const workSpace = Util.$currentWorkSpace();
            const frame = element.dataset.frame | 0;
            const layer = workSpace.scene.getLayer(layerId);

            const currentFrame = Util.$currentFrame;
            Util.$currentFrame = frame;

            const characters = layer.getActiveCharacter(frame);
            if (characters.length) {

                clearTimeout(this._$timerId);

                layer.sort(characters, frame);

                const preview = document
                    .getElementById("timeline-preview-modal");

                const { Sprite, BitmapData } = window.next2d.display;
                const { Matrix, ColorTransform } = window.next2d.geom;

                const sprite = new Sprite();

                let xMin = Number.MAX_VALUE;
                let xMax = -Number.MAX_VALUE;
                let yMin = Number.MAX_VALUE;
                let yMax = -Number.MAX_VALUE;

                // reset
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    const range  = character.getRange(frame);
                    const place  = character.getPlace(frame);

                    const instance = workSpace
                        .getLibrary(character.libraryId)
                        .createInstance(place, range);

                    instance.transform.matrix = new Matrix(
                        place.matrix[0], place.matrix[1],
                        place.matrix[2], place.matrix[3],
                        place.matrix[4], place.matrix[5]
                    );
                    instance.transform.colorTransform = new ColorTransform(
                        place.colorTransform[0], place.colorTransform[1],
                        place.colorTransform[2], place.colorTransform[3],
                        place.colorTransform[4], place.colorTransform[5],
                        place.colorTransform[6], place.colorTransform[7]
                    );

                    const bounds = workSpace
                        .getLibrary(character.libraryId)
                        .getBounds(place.matrix, place, range);

                    xMin = Math.min(xMin, bounds.xMin);
                    xMax = Math.max(xMax, bounds.xMax);
                    yMin = Math.min(yMin, bounds.yMin);
                    yMax = Math.max(yMax, bounds.yMax);

                    sprite.addChild(instance);
                }

                const width  = Math.ceil(Math.abs(xMax - xMin));
                const height = Math.ceil(Math.abs(yMax - yMin));
                const scale  = Math.min(120 / width, 120 / height);
                const ratio  = window.devicePixelRatio;

                const bitmapData = new BitmapData(
                    width  * scale * ratio,
                    height * scale * ratio,
                    true, 0
                );

                const matrix = new Matrix(
                    ratio, 0, 0, ratio,
                    -xMin * ratio,
                    -yMin * ratio
                );

                matrix.scale(scale, scale);
                bitmapData.draw(sprite, matrix);

                while (preview.children.length) {
                    preview.children[0].remove();
                }

                const image = new Image();
                image.onload = () =>
                {
                    preview.appendChild(image);

                    preview.style.display = "";
                    preview.style.left    = `${event.pageX + 10}px`;
                    preview.style.top     = `${event.pageY - preview.offsetHeight - 10}px`;
                    preview.style.backgroundColor = document.getElementById("stage-bgColor").value;

                    if (!preview.classList.contains("fadeIn")) {
                        preview.setAttribute("class", "fadeIn");
                    }
                };

                image.src    = bitmapData.toDataURL();
                image.width  = bitmapData.width  / ratio;
                image.height = bitmapData.height / ratio;

                bitmapData.dispose();
            }

            Util.$currentFrame = currentFrame;
        });
    }

    /**
     * @description タイムラインのフレーム内容をプレビュー表示する
     *
     * @return {void}
     * @method
     * @public
     */
    hideLayerPreview ()
    {
        if (!document
            .getElementById("timeline-preview")
            .classList
            .contains("timeline-preview-active")
        ) {
            return ;
        }

        const preview = document
            .getElementById("timeline-preview-modal");

        if (!preview.classList.contains("fadeOut")) {
            this._$timerId = setTimeout(() =>
            {
                if (!preview.classList.contains("fadeOut")) {
                    preview.setAttribute("class", "fadeOut");
                }
            }, 1000);
        }
    }

    /**
     * @description 選択したレイヤーの操作、アクティブなら移動を可能に
     *              非アクティブならアクティブ化する。
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    selectLayer (event)
    {
        if (event.button) {
            return ;
        }

        // 親のイベントを中止
        event.stopPropagation();

        // メニューモーダルを終了
        Util.$endMenu();

        const element = event.currentTarget;
        if (!element.classList.contains("active")) {
            this.activeLayer(element);
        }

        if (!this._$moveLayer) {
            this._$moveLayer = this.moveLayer.bind(this);
        }

        if (!this._$executeMoveLayer) {
            this._$executeMoveLayer = this.executeMoveLayer.bind(this);
        }

        this._$moveLayerId = element.dataset.layerId | 0;

        window.addEventListener("mousemove", this._$moveLayer);
        window.addEventListener("mouseup", this._$executeMoveLayer);
    }

    /**
     * @description 選択したレイヤーをアクティブにする
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    activeLayer (element)
    {
        // 初期化
        this.clearActiveFrames();

        // 選択したレイヤーをアクティブ化
        this.targetLayer = element;

        // 選択したレイヤーのIDを変数に格納
        this._$selectLayerId = element.dataset.layerId | 0;

        // アクティブ表示
        const frame = Util.$timelineFrame.currentFrame;
        for (const layerElement of this.targetLayers.values()) {

            const layerId = layerElement.dataset.layerId | 0;

            // 編集へセット
            const frameElement = document
                .getElementById(`${layerId}-${frame}`);

            // 選択したレイヤーのフレームを初期化してセット
            this.targetFrames.delete(layerId);
            this.addTargetFrame(layerId, frameElement);

        }

        // マーカーを現在のフレームの位置に移動
        Util.$timelineMarker.move();

        // スクリーンのDisplayObjectをアクティブ化
        this.activeCharacter();
    }

    /**
     * @description タイムラインの選択したフレームをアクティブにする
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    selectFrame (event)
    {
        if (event.button) {
            return ;
        }

        // 親のイベントを中止
        event.stopPropagation();

        // メニューモーダルを終了
        Util.$endMenu();

        const preview = document
            .getElementById("timeline-preview-modal");

        if (!preview.classList.contains("fadeOut")) {
            preview.setAttribute("class", "fadeOut");
        }

        // toolにframeを表示
        const target = event.target;
        const frame  = target.dataset.frame | 0;

        this.changeLabel(frame);

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        if (target.classList.contains("frame-active")) {

            const firstFrames  = this.targetFrames.values().next().value;
            const firstElement = firstFrames[0];
            if (!firstElement) {
                return ;
            }

            // 一番左上のelementを算出
            const children = Array.from(
                document.getElementById("timeline-content").children
            );

            let index = children.indexOf(this.targetLayer);
            if (this.targetFrames.size > 1) {
                index = Number.MAX_VALUE;
                for (const frames of this.targetFrames.values()) {
                    index = Math.min(index,
                        children.indexOf(
                            document.getElementById(
                                `layer-id-${frames[0].dataset.layerId}`
                            )
                        )
                    );
                }
            }

            let frame = Number.MAX_VALUE;
            for (let idx = 0; idx < firstFrames.length; ++idx) {
                frame = Math.min(frame, firstFrames[idx].dataset.frame | 0);
            }

            // 左上のelementを基準に選択範囲を生成
            const layerId = children[index].dataset.layerId | 0;
            const leftElement = document
                .getElementById(`${layerId}-${frame}`);

            const parent = document
                .getElementById("timeline-content");

            const width = firstFrames.length
                * (Util.$timelineTool.timelineWidth + 1) - 5;

            this._$clientX = leftElement.offsetLeft - this._$scrollX;
            this._$clientY = leftElement.offsetTop - parent.scrollTop;

            const element = document
                .getElementById("target-group");

            element.style.display = "";
            element.style.width   = `${width}px`;
            element.style.height  = `${this.targetFrames.size * 31 - 5}px`;
            element.style.left    = `${this._$clientX}px`;
            element.style.top     = `${this._$clientY}px`;

            element.dataset.frame = `${frame}`;
            element.dataset.index = `${index}`;

            const size = Util.$timelineTool.timelineWidth + 1;
            for (;;) {
                if (this._$clientX + size > event.clientX) {
                    break;
                }
                this._$clientX += size;
            }
            for (;;) {
                if (this._$clientY + 30 > event.clientY) {
                    break;
                }
                this._$clientY += 30;
            }

            if (!this._$endTargetGroup) {
                this._$endTargetGroup = this.endTargetGroup.bind(this);
            }

            if (!this._$moveTargetGroup) {
                this._$moveTargetGroup = this.moveTargetGroup.bind(this);
            }

            window.addEventListener("mousemove", this._$moveTargetGroup);
            window.addEventListener("mouseup", this._$endTargetGroup);

        } else {

            // 初期化
            if (!Util.$ctrlKey) {
                tool.clear();
            }

            const layerId = target.dataset.layerId | 0;

            // fixed logic
            this.targetLayer = document
                .getElementById(`layer-id-${layerId}`);

            // 選択したフレームElementをMapに登録
            this.addTargetFrame(layerId, target);

            if (!this._$multiSelect) {
                this._$multiSelect = this.multiSelect.bind(this);
            }

            if (!this._$endMultiSelect) {
                this._$endMultiSelect = this.endMultiSelect.bind(this);
            }

            window.addEventListener("mousemove", this._$multiSelect);
            window.addEventListener("mouseup", this._$endMultiSelect);

            // アクティブ表示
            target
                .classList
                .add("frame-active");

            // フレームを移動
            this.moveFrame(frame);
        }
    }

    /**
     * @description フレームを移動に合わせてラベルの値を表示・更新する
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    changeLabel (frame)
    {
        // ラベル情報更新して初期化
        const labelInput = document.getElementById("label-name");
        labelInput.blur();
        labelInput.value = "";

        // labelがあればセット
        const scene = Util.$currentWorkSpace().scene;
        const label = scene.gerLabel(frame);
        if (label) {
            labelInput.value = label;
        }
    }

    /**
     * @description フレームを移動
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    moveFrame (frame)
    {
        if (Util.$timelineFrame.currentFrame !== frame) {

            // フレームを移動
            Util.$timelineFrame.currentFrame = frame;

            // マーカーを移動
            Util.$timelineMarker.move();

            // 移動先の音声設定を生成
            Util.$soundController.createSoundElements();

            // 再描画
            this.reloadScreen();
        }

        // 再描画後にアクティブ判定を行う
        this.activeCharacter();
    }

    /**
     * @description 選択したフレームの移動表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveTargetGroup (event)
    {
        window.requestAnimationFrame(() =>
        {
            const element = document
                .getElementById("target-group");

            const targetLayer = this.targetLayer;
            if (!targetLayer) {
                return ;
            }

            const scrollElement = document
                .getElementById(`frame-scroll-id-${targetLayer.dataset.layerId}`);

            const size = Util.$timelineTool.timelineWidth + 1;

            const frame = element.dataset.frame | 0;
            const index = element.dataset.index | 0;

            // 右に移動
            if (event.clientX - this._$clientX > size) {

                // 右端まできたらタイムラインを移動
                if (element.offsetLeft + element.offsetWidth + size >
                    scrollElement.offsetLeft + scrollElement.offsetWidth
                ) {

                    const base = document
                        .getElementById("timeline-controller-base");

                    // 移動可能であれば右にタイムラインを移動
                    if (event.pageX > base.offsetLeft + base.offsetWidth
                        && base.scrollWidth - base.offsetWidth > base.scrollLeft
                    ) {
                        this
                            .moveTimeLine(
                                base.scrollLeft
                                + (Util.$timelineTool.timelineWidth + 1)
                            );
                    }

                    return ;
                }

                element.style.left = `${element.offsetLeft + size}px`;

                element.dataset.frame = `${frame + 1}`;

                this._$clientX += size;

                return ;
            }

            // 左に移動
            if (this._$clientX - event.clientX > size) {

                // 左端まできたらタイムラインを移動
                if (scrollElement.offsetLeft > element.offsetLeft - size) {

                    const base = document
                        .getElementById("timeline-controller-base");

                    // 移動可能であれば左にタイムラインを移動
                    if (base.scrollLeft > 0 && base.offsetLeft > event.pageX) {

                        this
                            .moveTimeLine(
                                base.scrollLeft
                                - (Util.$timelineTool.timelineWidth + 1)
                            );

                    }

                    return ;
                }

                element.style.left = `${element.offsetLeft - size}px`;

                element.dataset.frame = `${frame - 1}`;

                this._$clientX -= size;

                return ;
            }

            // 下に移動
            if (event.clientY - this._$clientY > 30) {

                const parent = document
                    .getElementById("timeline-content");

                const height = Math.min(
                    parent.children.length * 31,
                    parent.offsetHeight
                );

                if (element.offsetTop + element.offsetHeight + 31
                    > parent.offsetTop + height
                ) {

                    // 移動可能であれば下にタイムラインを移動
                    const maxScrollTop = parent.scrollHeight - parent.offsetHeight;
                    if (parent.scrollTop + 31 > maxScrollTop) {

                        // 移動先がなければ終了
                        const moveY = maxScrollTop - parent.scrollTop;
                        if (1 > moveY) {
                            return ;
                        }

                        element.style.top = `${element.offsetTop + moveY - 5}px`;
                        parent.scrollTop = maxScrollTop;

                    } else {

                        parent.scrollTop += 31;

                    }

                    return ;
                }

                element.style.top = `${element.offsetTop + 31}px`;

                element.dataset.index = `${index + 1}`;

                this._$clientY += 30;

                return ;
            }

            // 上に移動
            if (this._$clientY - event.clientY > 0) {

                const parent = document
                    .getElementById("timeline-content");

                if (parent.offsetTop > element.offsetTop - 31) {

                    // 移動可能であれば上にタイムラインを移動
                    if (0 > parent.scrollTop - 31) {

                        // 移動先がなければ終了
                        if (!parent.scrollTop) {
                            return ;
                        }

                        element.style.top = `${element.offsetTop - parent.scrollTop + 4}px`;
                        parent.scrollTop = 0;

                    } else {

                        parent.scrollTop -= 31;

                    }

                    return ;
                }

                element.style.top = `${element.offsetTop - 31}px`;

                element.dataset.index = `${index - 1}`;

                this._$clientY -= 30;
            }
        });
    }

    /**
     * @description 選択したフレームの移動処理
     *
     * @return {void}
     * @method
     * @public
     */
    endTargetGroup ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$moveTargetGroup);
        window.removeEventListener("mouseup", this._$endTargetGroup);

        const targetGroup = document
            .getElementById("target-group");

        const distFrame = targetGroup.dataset.frame | 0;
        let index       = targetGroup.dataset.index | 0;

        const children = Array.from(
            document.getElementById("timeline-content").children
        );

        // 選択elementを非表示
        this.hideTargetGroup();

        // 移動をしてなければ中止
        const selectLayerId = children[index].dataset.layerId | 0;
        const targetLayerId = this.targetLayer.dataset.layerId | 0;

        // 選択したフレームで一番若いフレーム番号
        const frame = Util.$timelineTool.getFirstFrame();

        // 移動してなければスキップ
        if (selectLayerId === targetLayerId && frame === distFrame) {
            return ;
        }

        this.save();

        const scene = Util.$currentWorkSpace().scene;
        for (const [layerId, values] of this.targetFrames) {

            // 移動先の終了フレーム
            const endFrame = distFrame + values.length;

            const elements = values.slice();
            if (elements.length > 1) {
                elements.sort((a, b) =>
                {
                    const aFrame = a.dataset.frame | 0;
                    const bFrame = b.dataset.frame | 0;

                    // 昇順
                    switch (true) {

                        case aFrame > bFrame:
                            return 1;

                        case aFrame < bFrame:
                            return -1;

                        default:
                            return 0;

                    }
                });
            }

            // 移動元のレイヤー
            const layer = scene.getLayer(layerId);

            // 移動先のレイヤー
            const targetLayerId = children[index++].dataset.layerId | 0;
            const targetLayer   = scene.getLayer(targetLayerId);

            // 移動先の幅で新規のDisplayObjectを生成、隙間は空のキーフレームを生成
            const characters  = new Map();
            const emptys      = [];
            let currentEmpty  = null;
            let rangeEndFrame = 1;
            for (let idx = 0; idx < elements.length; ++idx) {

                const element = elements[idx];

                const frame = element.dataset.frame | 0;

                if (element.dataset.frameState === "empty") {

                    if (currentEmpty) {
                        currentEmpty.endFrame = frame + 1;
                        continue;
                    }

                    // 最後のフレームにDisplayObjectがあれば拡張
                    if (characters.size) {

                        // 選択幅の最終フレームだけ後続のフレームを拡張
                        for (const character of characters.values()) {

                            // 最終フレームのDisplayObjectでなければスキップ
                            if (character.endFrame !== rangeEndFrame) {
                                continue;
                            }

                            // tweenであれば情報を更新
                            const keyFrame = character.endFrame - 1;
                            if (character.hasPlace(keyFrame)) {

                                const place = character.getPlace(keyFrame);
                                if (place.tweenFrame) {

                                    character.setPlace(
                                        frame,
                                        character.getClonePlace(keyFrame)
                                    );

                                    character
                                        .getTween(place.tweenFrame)
                                        .endFrame = frame + 1;

                                    Util
                                        .$tweenController
                                        .relocationPlace(character, keyFrame);
                                }
                            }

                            character.endFrame = frame + 1;

                            rangeEndFrame = frame + 1;
                        }

                        continue;
                    }

                    // 未定義のフレームであれば空のキーフレームで生成
                    currentEmpty = new EmptyCharacter();
                    currentEmpty.startFrame = frame;
                    currentEmpty.endFrame   = frame + 1;

                } else {

                    // 配置されてるDisplayObject
                    const activeCharacters = layer.getActiveCharacter(frame);
                    if (activeCharacters.length) {

                        if (currentEmpty) {
                            currentEmpty.endFrame = frame;
                            emptys.push(currentEmpty);

                            // 初期化
                            currentEmpty = null;
                        }

                        for (let idx = 0; idx < activeCharacters.length; ++idx) {

                            const character = activeCharacters[idx];

                            if (!characters.has(character.id)) {

                                // 新規のDisplayObjectを生成
                                const newCharacter      = new Character();
                                newCharacter.libraryId  = character.libraryId;
                                newCharacter.startFrame = frame;
                                newCharacter.endFrame   = frame + 1;
                                newCharacter.screenX    = character.screenX;
                                newCharacter.screenY    = character.screenY;

                                // キーフレームをセット
                                const place = character.getClonePlace(frame);
                                newCharacter.setPlace(frame, place);

                                // tweenの設定があれば移動処理を追加
                                if (place.tweenFrame) {

                                    const tweenObject = character
                                        .getCloneTween(place.tweenFrame);

                                    tweenObject.startFrame = frame;
                                    tweenObject.endFrame   = frame + 1;

                                    place.tweenFrame = frame;
                                    newCharacter.setTween(frame, tweenObject);

                                }

                                characters.set(character.id, newCharacter);

                                rangeEndFrame = Math.max(
                                    newCharacter.endFrame, rangeEndFrame
                                );
                                continue;
                            }

                            const newCharacter = characters.get(character.id);
                            if (character.hasPlace(frame)) {

                                const place = character.getClonePlace(frame);
                                newCharacter.setPlace(frame, place);

                                // tweenの設定も移動
                                if (place.tweenFrame) {

                                    place.tweenFrame = newCharacter.startFrame;

                                    newCharacter
                                        .getTween(place.tweenFrame)
                                        .endFrame = frame + 1;

                                }
                            }

                            newCharacter.endFrame = frame + 1;
                            rangeEndFrame = Math.max(
                                newCharacter.endFrame, rangeEndFrame
                            );
                        }

                        continue;
                    }

                    if (!currentEmpty) {
                        currentEmpty = new EmptyCharacter();
                        currentEmpty.startFrame = frame;
                        currentEmpty.endFrame   = frame + 1;

                        rangeEndFrame = Math.max(
                            currentEmpty.endFrame, rangeEndFrame
                        );

                        continue;
                    }

                    currentEmpty.endFrame = frame + 1;

                    rangeEndFrame = Math.max(
                        currentEmpty.endFrame, rangeEndFrame
                    );
                }
            }

            if (currentEmpty) {
                emptys.push(currentEmpty);
            }

            // 移動先のDisplayObjectにキーフレームがあれば削除
            let distLastFrame = endFrame;
            const targetCharacters = targetLayer._$characters.slice();
            for (let idx = 0; idx < targetCharacters.length; ++idx) {

                const character = targetCharacters[idx];

                if (distFrame > character.endFrame - 1) {
                    continue;
                }

                if (character.startFrame >= endFrame) {
                    continue;
                }

                if (character.startFrame >= distFrame
                    && endFrame >= character.endFrame
                ) {

                    targetLayer.deleteCharacter(character.id);

                } else {

                    // 移動先の幅の最大値をセット
                    const range = character.getRange(endFrame);
                    distLastFrame = Math.max(range.endFrame, distLastFrame);

                    console.log("koko: ", range, distLastFrame);

                    // 選択幅のキーフレームを削除
                    for (let frame = distFrame; endFrame > frame; ++frame) {

                        if (!character.hasPlace(frame)) {
                            continue;
                        }

                        // tween補正
                        const place = character.getPlace(frame);
                        if (place.tweenFrame) {

                            const range = character.getRange(frame);
                            if (character.hasTween(frame)) {

                                // tweenの開始位置なら全て削除
                                for (let frame = range.startFrame; range.endFrame > frame; ++frame) {
                                    character.deletePlace(frame);
                                }
                                character.deleteTween(frame);

                            } else {

                                for (let frame = distFrame; range.endFrame > frame; ++frame) {
                                    character.deletePlace(frame);
                                }

                                character
                                    .getTween(place.tweenFrame)
                                    .endFrame = distFrame;

                                // 再計算
                                Util
                                    .$tweenController
                                    .relocationPlace(character, place.tweenFrame);

                            }
                        }

                        character.deletePlace(frame);
                    }

                    if (!character._$places.size) {

                        // 全てのキーフレームが削除された場合はレイヤーからも削除
                        targetLayer.deleteCharacter(character.id);

                    } else {

                        // 後続にキーフレームがあれば分割
                        if (character.hasPlace(range.endFrame)) {

                            // 移動元と移動先が同じレイヤーならチェック
                            if (selectLayerId === targetLayerId
                                && characters.has(character.id)
                            ) {
                                const newCharacter = characters.get(character.id);
                                for (const keyFrame of newCharacter._$places.keys()) {

                                    // 移動元の範囲内にキーフレームがあれば、削除してレンジの最大フレームを更新
                                    if (!character.hasPlace(keyFrame)) {
                                        continue;
                                    }

                                    distLastFrame = Math.max(
                                        character.getRange(keyFrame).endFrame,
                                        distLastFrame
                                    );

                                    character.deletePlace(keyFrame);
                                }
                            }

                            // 複製して分割
                            const cloneCharacter = character.clone();
                            cloneCharacter.startFrame = range.endFrame;

                            // placeオブジェクトを分割
                            const places = new Map();
                            for (const [keyFrame, place] of cloneCharacter._$places) {

                                if (range.endFrame > keyFrame) {
                                    continue;
                                }

                                character.deletePlace(keyFrame);
                                places.set(keyFrame, place);
                            }

                            // キーフレームがあれば分割したDisplayObjectを登録
                            if (places.size) {

                                // tweenを分割
                                const tweenObjects = new Map();
                                for (const [keyFrame, tweenObject] of cloneCharacter._$tween) {

                                    if (range.endFrame > keyFrame) {
                                        continue;
                                    }

                                    character.deleteTween(keyFrame);
                                    tweenObjects.set(keyFrame, tweenObject);
                                }

                                cloneCharacter._$places = places;
                                cloneCharacter._$tween  = tweenObjects;

                                targetLayer.addCharacter(cloneCharacter);
                            }
                        }

                        // 終了位置を補正
                        character.endFrame = distFrame;
                        if (character.hasTween(range.startFrame)) {

                            character
                                .getTween(range.startFrame)
                                .endFrame = distFrame;

                        }

                    }
                }
            }

            // 移動先に空のキーフレームがあれば削除
            const targetEmptys = targetLayer._$emptys.slice();
            for (let idx = 0; idx < targetEmptys.length; ++idx) {

                const emptyCharacter = targetEmptys[idx];

                if (distFrame > emptyCharacter.endFrame - 1) {
                    continue;
                }

                if (emptyCharacter.startFrame >= endFrame) {
                    continue;
                }

                // 終了位置を補正
                if (targetLayer.getActiveCharacter(emptyCharacter.endFrame).length) {
                    distLastFrame = emptyCharacter.endFrame;
                }

                if (distFrame > emptyCharacter.startFrame) {

                    emptyCharacter.endFrame = distFrame;

                } else {

                    targetLayer.deleteEmptyCharacter(emptyCharacter);

                }
            }

            // Altキーが押下されていない時は、選択元を削除
            if (!Util.$altKey) {

                const endFrame = frame + values.length;

                // DisplayObjectを削除
                for (const characterId of characters.keys()) {

                    const character = layer.getCharacter(characterId);
                    if (!character) {
                        continue;
                    }

                    // 同一のレイヤー移動であれば最終フレームを確認
                    if (selectLayerId === targetLayerId
                        && character.hasPlace(frame)
                    ) {
                        const range = character.getRange(frame);
                        if (range.startFrame === character.startFrame
                            && range.startFrame === distLastFrame
                        ) {
                            distLastFrame = Math.max(range.endFrame, distLastFrame);
                        }
                    }

                    // 選択範囲のキーフレームを削除
                    for (let keyFrame = frame; endFrame > keyFrame; ++keyFrame) {

                        if (!character.hasPlace(keyFrame)) {
                            continue;
                        }

                        // キーフレームの反映情報をセット
                        const range = character.getRange(keyFrame);

                        // tweenがあれば範囲内のplaceオブジェクトを削除
                        if (character.hasTween(keyFrame)) {

                            const tweenObject = character.getTween(keyFrame);
                            for (let frame = tweenObject.startFrame; tweenObject.endFrame > frame; ++frame) {
                                character.deletePlace(frame);
                            }

                            character.deleteTween(keyFrame);

                            // 前方にtweenがあれば統合
                            const prevFrame = keyFrame - 1;
                            if (prevFrame > 1 && prevFrame >= character.startFrame) {
                                const place = character.getPlace(prevFrame);
                                if (place.tweenFrame) {

                                    for (let frame = prevFrame + 1; tweenObject.endFrame > frame; ++frame) {
                                        character.setPlace(frame,
                                            character.getClonePlace(prevFrame)
                                        );
                                    }

                                    character
                                        .getTween(place.tweenFrame)
                                        .endFrame = tweenObject.endFrame;

                                    // 再計算
                                    Util
                                        .$tweenController
                                        .relocationPlace(character, prevFrame);
                                }
                            }

                        } else {

                            // tweenの間のフレームなら削除しない
                            const place = character.getPlace(keyFrame);
                            if (place.tweenFrame) {
                                continue;
                            }

                        }

                        // キーフレームを削除
                        character.deletePlace(keyFrame);

                        // キーフレームがなくなったらレイヤーから削除
                        if (!character._$places.size) {

                            layer.deleteCharacter(characterId);

                            if (!layer.getActiveEmptyCharacter(keyFrame)) {

                                const prevEmptyCharacter = layer
                                    .getActiveEmptyCharacter(keyFrame - 1);

                                if (prevEmptyCharacter) {

                                    prevEmptyCharacter.endFrame = range.endFrame;

                                } else {

                                    layer.addEmptyCharacter(new EmptyCharacter({
                                        "startFrame": range.startFrame,
                                        "endFrame": range.endFrame
                                    }));

                                }
                            }

                            // 終了
                            break;
                        }

                        // 削除するキーフレームが開始フレームの場合は、後方に開始位置を補正
                        if (character.startFrame === keyFrame) {

                            // 開始位置を後方に補正
                            character.startFrame = range.endFrame;

                            // フレームが1じゃない場合
                            const prevFrame = keyFrame - 1;
                            if (prevFrame) {

                                const activeCharacters = layer
                                    .getActiveCharacter(prevFrame);

                                if (activeCharacters.length) {

                                    // 前方に配置されてるDisplayObjectがあれば、後方に補正
                                    for (let idx = 0; activeCharacters.length > idx; ++idx) {

                                        const character = activeCharacters[idx];

                                        const keyFrame = character.endFrame - 1;
                                        if (character.hasPlace(keyFrame)) {

                                            // tweenがあれば再計算
                                            const place = character.getPlace(keyFrame);
                                            if (place.tweenFrame) {

                                                const tweenObject = character
                                                    .getTween(place.tweenFrame);

                                                for (let frame = keyFrame + 1; range.endFrame > frame; ++frame) {
                                                    character.setPlace(frame,
                                                        character.getClonePlace(keyFrame)
                                                    );
                                                }

                                                tweenObject.endFrame = range.endFrame;

                                                Util
                                                    .$tweenController
                                                    .relocationPlace(character, keyFrame);
                                            }
                                        }

                                        // 終了位置を補正
                                        character.endFrame = range.endFrame;
                                    }

                                } else {

                                    const emptyCharacter = layer
                                        .getActiveEmptyCharacter(prevFrame);

                                    if (emptyCharacter) {

                                        emptyCharacter.endFrame = range.endFrame;

                                    } else {

                                        layer.addEmptyCharacter(new EmptyCharacter({
                                            "startFrame": range.startFrame,
                                            "endFrame": range.endFrame
                                        }));

                                    }

                                }

                            } else {

                                const emptyCharacter = layer
                                    .getActiveEmptyCharacter(prevFrame);

                                if (!emptyCharacter) {

                                    layer.addEmptyCharacter(new EmptyCharacter({
                                        "startFrame": range.startFrame,
                                        "endFrame": range.endFrame
                                    }));

                                }
                            }
                        }
                    }
                }

                // 空のフレームを削除
                for (let idx = 0; idx < layer._$emptys.length; ++idx) {

                    const emptyCharacter = layer._$emptys[idx];
                    if (emptyCharacter.startFrame > endFrame) {
                        continue;
                    }

                    if (frame >= emptyCharacter.endFrame) {
                        continue;
                    }

                    for (let keyFrame = frame; endFrame > keyFrame; ++keyFrame) {

                        if (emptyCharacter.startFrame !== keyFrame) {
                            continue;
                        }

                        // 前方のフレームと統合か補正
                        const prevFrame = emptyCharacter.startFrame - 1;
                        if (prevFrame) {

                            distLastFrame = Math.max(emptyCharacter.endFrame, distLastFrame);
                            layer.deleteEmptyCharacter(emptyCharacter);

                            const activeCharacters = layer
                                .getActiveCharacter(prevFrame);

                            if (activeCharacters.length) {

                                for (let idx = 0; idx < activeCharacters.length; ++idx) {
                                    const character = activeCharacters[idx];

                                    const keyFrame = character.endFrame - 1;
                                    if (character.hasPlace(keyFrame)) {
                                        const place = character.getPlace(keyFrame);
                                        if (place.tweenFrame) {

                                            for (let frame = keyFrame + 1; emptyCharacter.endFrame > frame; ++frame) {
                                                character.setPlace(frame,
                                                    character.getClonePlace(keyFrame)
                                                );
                                            }

                                            character
                                                .getTween(place.tweenFrame)
                                                .endFrame = emptyCharacter.endFrame;

                                            // 再計算
                                            Util
                                                .$tweenController
                                                .relocationPlace(character, keyFrame);
                                        }
                                    }

                                    character.endFrame = emptyCharacter.endFrame;
                                }

                                break;
                            }

                            const prevEmptyCharacter = layer
                                .getActiveEmptyCharacter(prevFrame);

                            if (prevEmptyCharacter) {

                                prevEmptyCharacter.endFrame = emptyCharacter.endFrame;

                            } else {

                                // 移動元と移動先が異なるレイヤーの時は空のキーフレームを追加
                                if (selectLayerId !== targetLayerId) {
                                    layer.addEmptyCharacter(new EmptyCharacter({
                                        "startFrame": 1,
                                        "endFrame": emptyCharacter.endFrame
                                    }));
                                }

                            }
                        }

                        break;
                    }
                }
            }

            // 移動先に選択したDisplayObjectをセット
            for (const character of characters.values()) {

                // 横移動の補正
                if (distFrame !== frame) {
                    character.move(distFrame - frame);
                }

                // 最終位置の補正
                if (character.endFrame === endFrame
                    && distLastFrame > endFrame
                ) {

                    // tweenがあれば、tweenの最終フレームを補正
                    const keyFrame = character.endFrame - 1;
                    if (character.hasPlace(keyFrame)) {
                        const place = character.getPlace(keyFrame);
                        if (place.tweenFrame) {

                            for (let frame = keyFrame + 1; distLastFrame > frame; ++frame) {
                                character.setPlace(frame,
                                    character.getClonePlace(keyFrame)
                                );
                            }

                            character
                                .getTween(place.tweenFrame)
                                .endFrame = distLastFrame;

                            // 再計算
                            Util
                                .$tweenController
                                .relocationPlace(character, keyFrame);
                        }
                    }

                    character.endFrame = distLastFrame;
                }

                targetLayer.addCharacter(character);

                // 移動先に空のキーフレームがあれば削除
                const emptyCharacter = targetLayer
                    .getActiveEmptyCharacter(character.startFrame);

                if (emptyCharacter) {
                    targetLayer.deleteEmptyCharacter(emptyCharacter);
                }
            }

            // 移動先に選択した空のキーフレームをセット
            for (let idx = 0; idx < emptys.length; ++idx) {

                const emptyCharacter = emptys[idx];

                if (distFrame !== frame) {
                    emptyCharacter.move(distFrame - frame);
                }

                // 最終位置の補正
                if (emptyCharacter.endFrame === endFrame
                    && distLastFrame > endFrame
                ) {
                    emptyCharacter.endFrame = distLastFrame;
                }

                targetLayer.addEmptyCharacter(emptyCharacter);
            }

            // 前方のキーフレームが未設定の場合は空のキーフレームを設定
            if (distFrame > 1) {

                const targetActiveCharacters = targetLayer
                    .getActiveCharacter(distFrame - 1);

                const emptyCharacter = targetLayer
                    .getActiveEmptyCharacter(distFrame - 1);

                if (!targetActiveCharacters.length && !emptyCharacter) {

                    // 結合用の変数
                    let activeCharacters = null;
                    let emptyCharacter   = null;

                    let idx = 1;
                    for ( ; ; ++idx) {

                        activeCharacters = targetLayer
                            .getActiveCharacter(distFrame - idx);

                        if (activeCharacters.length) {
                            break;
                        }

                        emptyCharacter = targetLayer
                            .getActiveEmptyCharacter(distFrame - idx);

                        if (emptyCharacter) {
                            break;
                        }

                        if (0 >= distFrame - idx) {
                            break;
                        }
                    }

                    if (!activeCharacters.length) {
                        activeCharacters = null;
                    }

                    switch (true) {

                        case activeCharacters !== null:
                            for (let idx = 0; idx < activeCharacters.length; ++idx) {

                                const character = activeCharacters[idx];

                                // tweenがあれば補正
                                let endFrame = distFrame;

                                const keyFrame = character.endFrame - 1;
                                if (character.hasPlace(keyFrame)) {

                                    const place = character.getPlace(keyFrame);
                                    if (place.tweenFrame) {

                                        for (let frame = keyFrame + 1; distFrame > frame; ++frame) {
                                            character.setPlace(frame,
                                                character.getClonePlace(keyFrame)
                                            );
                                        }

                                        if (characters.has(character.id)) {

                                            const newCharacter = characters.get(character.id);

                                            for (let frame = newCharacter.startFrame; newCharacter.endFrame > frame; ++frame) {
                                                const clonePlace = newCharacter.getClonePlace(frame);
                                                clonePlace.tweenFrame = place.tweenFrame;
                                                character.setPlace(frame, clonePlace);
                                            }

                                            character
                                                .getTween(place.tweenFrame)
                                                .endFrame = newCharacter.endFrame;

                                            endFrame = newCharacter.endFrame;

                                            characters.delete(character.id);
                                            targetLayer.deleteCharacter(newCharacter.id);

                                        } else {

                                            character
                                                .getTween(place.tweenFrame)
                                                .endFrame = endFrame;

                                        }

                                        // 再計算
                                        Util
                                            .$tweenController
                                            .relocationPlace(character, place.tweenFrame);
                                    }
                                }

                                character.endFrame = endFrame;
                            }
                            break;

                        // 空のキーフレームがあれば統合
                        case emptyCharacter !== null:
                            emptyCharacter.endFrame = distFrame;
                            break;

                        // 前方に何も定義がない時は空のキーフレームを追加
                        default:
                            targetLayer.addEmptyCharacter(new EmptyCharacter({
                                "startFrame": distFrame - idx + 1,
                                "endFrame": distFrame
                            }));
                            break;

                    }
                }
            }

            // 前後の補正、同一のアイテムなら統合
            for (const character of characters.values()) {

                // 結合用の変数に格納
                let unionCharacter = character;

                // 前のフレームを確認
                const prevFrame = character.startFrame - 1;

                if (prevFrame) {

                    const prevActiveCharacters = targetLayer
                        .getActiveCharacter(prevFrame);

                    for (let idx = 0; idx < prevActiveCharacters.length; ++idx) {

                        const prevCharacter = prevActiveCharacters[idx];

                        if (prevCharacter.libraryId !== character.libraryId) {
                            continue;
                        }

                        if (prevCharacter.endFrame !== character.startFrame) {
                            continue;
                        }

                        unionCharacter = prevCharacter;

                        for (const [keyFrame, place] of character._$places) {
                            unionCharacter.setPlace(keyFrame, place);
                        }

                        for (const [keyFrame, tweenObject] of character._$tween) {
                            unionCharacter.setTween(keyFrame, tweenObject);
                        }

                        unionCharacter.endFrame = character.endFrame;

                        // 統合元のDisplayObjectは削除
                        targetLayer.deleteCharacter(character.id);
                        break;
                    }
                }

                // 後続のフレームを確認
                const nextFrame = character.endFrame;

                const nextActiveCharacters = targetLayer
                    .getActiveCharacter(nextFrame);

                for (let idx = 0; idx < nextActiveCharacters.length; ++idx) {

                    const nextCharacter = nextActiveCharacters[idx];

                    if (nextCharacter.libraryId !== unionCharacter.libraryId) {
                        continue;
                    }

                    if (nextCharacter.startFrame !== unionCharacter.endFrame) {
                        continue;
                    }

                    for (const [keyFrame, place] of nextCharacter._$places) {
                        unionCharacter.setPlace(keyFrame, place);
                    }

                    for (const [keyFrame, tweenObject] of nextCharacter._$tween) {
                        unionCharacter.setTween(keyFrame, tweenObject);
                    }

                    unionCharacter.endFrame = nextCharacter.endFrame;

                    // 統合元のDisplayObjectは削除
                    targetLayer.deleteCharacter(nextCharacter.id);
                    break;
                }
            }

            console.log(layer);
            if (targetLayerId === layerId) {

                layer.reloadStyle();

            } else {

                layer.reloadStyle();
                targetLayer.reloadStyle();

            }
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();

        // 再描画
        this.reloadScreen();

        this._$saved = false;
    }

    /**
     * @description 選択中のレイヤーを全て非選択
     *
     * @return {void}
     * @method
     * @public
     */
    clearActiveLayers ()
    {
        for (const element of this.targetLayers.values()) {
            element
                .classList
                .remove("active");
        }
        this.targetLayers.clear();
    }

    /**
     * @description 選択中のフレームを全て非選択
     *
     * @return {void}
     * @method
     * @public
     */
    clearActiveFrames ()
    {
        for (const values of this._$targetFrames.values()) {
            for (let idx = 0; idx < values.length; ++idx) {
                values[idx].classList.remove("frame-active");
            }
        }

        // 変数を初期化
        this.targetFrames.clear();

        // グルーピングElementを非表示にする
        this.hideTargetGroup();
    }

    /**
     * @description 選択したフレームグループElementを非表示
     *
     * @return {void}
     * @method
     * @public
     */
    hideTargetGroup ()
    {
        const element = document.getElementById("target-group");
        if (element) {
            element.style.display = "none";
        }
    }

    /**
     * @description フレームの複数選択
     *
     * @param  {MouseEvent} event
     * @param  {HTMLDivElement} [select_element=null]
     * @return {void}
     * @method
     * @public
     */
    multiSelect (event, select_element = null)
    {
        const target = event
            ? event.target
            : select_element;

        const targetFrame = target.dataset.frame | 0;
        if (!targetFrame) {
            return ;
        }

        // ヘッダー領域の場合は処理をスキップ
        if (!("layerId" in target.dataset)) {
            return ;
        }

        const targetLayer = this.targetLayer;
        if (!targetLayer) {
            return ;
        }

        // 全てのイベント終了
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }

        const selectFrameElement = this.targetFrame;
        const selectFrame        = selectFrameElement.dataset.frame | 0;
        const selectLayerId      = selectFrameElement.dataset.layerId | 0;

        const minFrame = Math.min(targetFrame, selectFrame);
        const maxFrame = Math.max(targetFrame, selectFrame) + 1;

        // 最初に選択したレイヤーと現在選択中のレイヤーの間を補完
        const selectIds = [selectLayerId];

        // 選択範囲が複数行の時は補完
        const targetLayerId = target.dataset.layerId | 0;
        if (selectLayerId !== targetLayerId) {

            const children = Array.from(
                document.getElementById("timeline-content").children
            );

            const startIndex  = children.indexOf(targetLayer);
            const targetIndex = children.indexOf(
                document.getElementById(`layer-id-${targetLayerId}`)
            );

            if (targetIndex > startIndex) {
                const length = targetIndex - startIndex + 1;
                for (let idx = 1; idx < length; ++idx) {
                    selectIds.push(
                        children[startIndex + idx].dataset.layerId | 0
                    );
                }
            } else {
                const length = startIndex - targetIndex + 1;
                for (let idx = 1; idx < length; ++idx) {
                    selectIds.push(
                        children[startIndex - idx].dataset.layerId | 0
                    );
                }
            }
        }

        // フレームのアクティブ表示を初期化
        this.clearActiveFrames();

        // 再度、選択した範囲でアクティブ計算を行う
        for (let idx = 0; idx < selectIds.length; ++idx) {

            const layerId = selectIds[idx];
            for (let frame = minFrame; frame < maxFrame; ++frame) {

                const element = document
                    .getElementById(`${layerId}-${frame}`);

                if (!element) {
                    continue;
                }

                this.addTargetFrame(layerId, element);
            }
        }

        // 最初に選択したフレームの順番を補正
        const frames = this.targetFrames.get(selectLayerId);
        frames.splice(frames.indexOf(selectFrameElement), 1);
        frames.unshift(selectFrameElement);

        // 再描画後にアクティブ判定を行う
        this.activeCharacter();
    }

    /**
     * @description フレームの複数洗濯を終了
     *
     * @return {void}
     * @method
     * @public
     */
    endMultiSelect ()
    {
        Util.$setCursor("auto");
        window.removeEventListener("mousemove", this._$multiSelect);
        window.removeEventListener("mouseup", this._$endMultiSelect);
    }
}

Util.$timelineLayer = new TimelineLayer();

/**
 * @class
 * @extends {BaseTimeline}
 */
class TimelineLayerMenu extends BaseTimeline
{

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "timeline-layer-normal",
            "timeline-layer-mask",
            "timeline-layer-guide"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document
                .getElementById(elementIds[idx]);

            if (!element) {
                continue;
            }

            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event);
            });
        }

        // レイヤーカラー変更のイベント登録
        const element = document.getElementById("timeline-layer-color");
        if (element) {
            element.addEventListener("change", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                this.changeLayerHighlightColor(event);
            });
        }
    }

    /**
     * @description ノーマルレイヤーに変更
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerNormal ()
    {
        // 表示モーダルを全て終了
        Util.$endMenu();

        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const scene   = Util.$currentWorkSpace().scene;
        const layerId = targetLayer.dataset.layerId | 0;

        const layer = scene.getLayer(layerId);
        if (layer.mode === Util.LAYER_MODE_NORMAL) {
            return ;
        }

        // 状態を保存
        this.save();

        const reload = this.resetLayer(targetLayer);

        layer.mode = Util.LAYER_MODE_NORMAL;
        layer.showIcon();

        if (reload) {
            this.reloadScreen();
        }

        // 初期化
        super.focusOut();
    }

    /**
     * @description マスクレイヤーに変更
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerMask ()
    {
        // 表示モーダルを全て終了
        Util.$endMenu();

        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                targetLayer.dataset.layerId | 0
            );

        if (layer.mode === Util.LAYER_MODE_MASK) {
            return ;
        }

        // 状態を保存
        this.save();

        const reload = this.resetLayer(targetLayer);

        layer.mode = Util.LAYER_MODE_MASK;
        layer.showIcon();

        if (reload || layer.lock) {
            this.reloadScreen();
        }

        // 初期化
        super.focusOut();
    }

    /**
     * @description ガイドレイヤーに変更
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerGuide ()
    {
        // 表示モーダルを全て終了
        Util.$endMenu();

        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                targetLayer.dataset.layerId | 0
            );

        if (layer.mode === Util.LAYER_MODE_GUIDE) {
            return ;
        }

        // 状態を保存
        this.save();

        const reload = this.resetLayer(targetLayer);

        layer.mode = Util.LAYER_MODE_GUIDE;
        layer.showIcon();

        if (reload) {
            this.reloadScreen();
        }

        // 初期化
        super.focusOut();
    }

    /**
     * @description レイヤーのハイライトカラーの変更処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    changeLayerHighlightColor (event)
    {
        this.save();

        const layerId = event.target.dataset.layerId | 0;
        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layerId);

        // レイヤーオブジェクトを更新
        layer.color = event.target.value;

        const lightIcon = document
            .getElementById(`layer-light-icon-${layerId}`);

        lightIcon
            .style
            .backgroundImage = `url('${layer.getHighlightURL()}')`;

        if (layer.light) {
            document
                .getElementById(`layer-id-${layerId}`)
                .style
                .borderBottom = `1px solid ${layer.color}`;
        }

        // 初期化
        super.focusOut();

        // モーダルも終了
        Util.$endMenu();
    }

    /**
     * @description レイヤー切り替え時にマスクとガイドの入れ子を初期化する
     *
     * @param  {HTMLDivElement} element
     * @return {boolean}
     * @method
     * @public
     */
    resetLayer (element)
    {
        const scene = Util.$currentWorkSpace().scene;

        const layer = scene.getLayer(element.dataset.layerId | 0);

        const children = Array.from(
            document.getElementById("timeline-content").children
        );

        let reload = false;
        let index  = children.indexOf(element);
        switch (layer.mode) {

            case Util.LAYER_MODE_MASK:
                for (;;) {
                    const node = children[++index];
                    if (!node) {
                        break;
                    }

                    const layer = scene.getLayer(node.dataset.layerId | 0);
                    if (layer.mode !== Util.LAYER_MODE_MASK_IN) {
                        break;
                    }

                    layer.maskId = null;
                    layer.mode   = Util.LAYER_MODE_NORMAL;
                    layer.showIcon();

                    reload = true;
                }
                break;

            case Util.LAYER_MODE_GUIDE:
                for (;;) {
                    const node = children[++index];
                    if (!node) {
                        break;
                    }

                    const layer = scene.getLayer(node.dataset.layerId | 0);
                    if (layer.mode !== Util.LAYER_MODE_GUIDE_IN) {
                        break;
                    }

                    layer.guideId = null;
                    layer.mode    = Util.LAYER_MODE_NORMAL;
                    layer.showIcon();
                }
                break;

            default:
                break;

        }

        return reload;
    }

    /**
     * @description レイヤー切り替えのモーダルを表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    show (event)
    {
        // 全てのイベントを中止
        event.stopPropagation();

        Util.$endMenu("timeline-layer-menu");

        const layerId = event.target.dataset.layerId | 0;
        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layerId);

        const input = document
            .getElementById("timeline-layer-color");

        input.dataset.layerId = `${layerId}`;
        input.value = layer.color;

        const element = document
            .getElementById("timeline-layer-menu");

        element.style.left = `${event.pageX + 5}px`;
        element.style.top  = `${event.pageY - element.clientHeight}px`;
        if (15 > element.offsetTop) {
            element.style.top = "10px";
        }

        if (event.pageY + 15 > window.innerHeight) {
            element.style.top = `${event.pageY - element.clientHeight - 15}px`;
        }

        element.setAttribute("class", "fadeIn");
    }
}

Util.$timelineLayerMenu = new TimelineLayerMenu();

/**
 * @class
 * @extends {BaseTimeline}
 */
class TimelineMarker extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$moveMarker = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endMarker = null;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document.getElementById("timeline-marker");
        if (element) {
            element.addEventListener("mousedown", (event) =>
            {
                this.startMarker(event);
            });
        }
    }

    /**
     * @description マーカーElementの移動準備関数
     *
     * @return {void}
     * @method
     * @public
     */
    startMarker ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        // 全てのアクティブを解除
        tool.clear();

        // マーカーElementをイベント管理外に設定
        document
            .getElementById("timeline-marker")
            .style.pointerEvents = "none";

        if (!this._$moveMarker) {
            this._$moveMarker = this.moveMarker.bind(this);
        }
        if (!this._$endMarker) {
            this._$endMarker = this.endMarker.bind(this);
        }

        window.addEventListener("mousemove", this._$moveMarker);
        window.addEventListener("mouseup", this._$endMarker);

        // ラベル処理を強制的に発火
        document
            .getElementById("label-name")
            .blur();
    }

    /**
     * @description マーカーElementの移動処理関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveMarker (event)
    {
        Util.$setCursor("ew-resize");

        window.requestAnimationFrame(() =>
        {
            const base = document
                .getElementById("timeline-controller-base");

            // タイムラインエリア外(右側)にマウスが出た時の処理
            if (event.pageX > base.offsetLeft + base.offsetWidth
                && base.scrollWidth - base.offsetWidth > base.scrollLeft
            ) {

                const frame =
                    (event.pageX - (base.offsetLeft + base.offsetWidth))
                        / Util.$timelineTool.timelineWidth | 0;

                // フレーム更新してマーカーを移動
                Util.$timelineFrame.currentFrame = Util.$clamp(
                    Util.$timelineFrame.currentFrame + frame,
                    1, Util.$timelineHeader.lastFrame - 1
                );
                this.move();

                // マーカーに合わせてタイムラインを移動
                Util
                    .$timelineLayer
                    .moveTimeLine(
                        base.scrollLeft + frame
                            * (Util.$timelineTool.timelineWidth + 1)
                    );

                // 現在のフレームで再描画
                this.reloadScreen();

                return ;
            }

            // タイムラインエリア外(左側)にマウスが出た時の処理
            if (base.scrollLeft > 0 && base.offsetLeft > event.pageX) {

                const frame =
                    (base.offsetLeft - event.pageX)
                        / Util.$timelineTool.timelineWidth | 0;

                // フレーム更新してマーカーを移動
                Util.$timelineFrame.currentFrame = Util.$clamp(
                    Util.$timelineFrame.currentFrame - frame,
                    1, Util.$timelineHeader.lastFrame - 1
                );
                this.move();

                // マーカーに合わせてタイムラインを移動
                Util
                    .$timelineLayer
                    .moveTimeLine(
                        base.scrollLeft - frame
                            * (Util.$timelineTool.timelineWidth + 1)
                    );

                // 現在のフレームで再描画
                this.reloadScreen();

                return ;
            }

            let frame = event.target.dataset.frame | 0;
            if (!frame) {
                return ;
            }

            const currentFrame = Util.$timelineFrame.currentFrame;
            if (currentFrame === frame) {
                return ;
            }

            // フレームを移動
            Util.$timelineFrame.currentFrame = frame;
            this.move();

            // 見える位置にタイムラインを補正
            this.moveVisibleLocation();

            // 現在のフレームで再描画
            this.reloadScreen();
        });
    }

    /**
     * @description タイムラインを見えるところに移動する
     *
     * @return {void}
     * @method
     * @public
     */
    moveVisibleLocation ()
    {
        const base = document
            .getElementById("timeline-controller-base");

        const marker = document
            .getElementById("timeline-marker");

        // 移動するフレームポイント
        const moveWidth = Util.$timelineTool.timelineWidth * 2;

        // タイムラインの右端になったらタイムラインを右に少しずらす
        if (base.scrollWidth - base.offsetWidth > base.scrollLeft
            && marker.offsetLeft + moveWidth > base.scrollLeft + base.offsetWidth
        ) {

            Util
                .$timelineLayer
                .moveTimeLine(
                    base.scrollLeft + Util.$timelineTool.timelineWidth + 1
                );

        }

        // タイムラインの左端になったらタイムラインを左に少しずらす
        if (base.scrollLeft > 0
            && base.scrollLeft > marker.offsetLeft - moveWidth
        ) {

            Util
                .$timelineLayer
                .moveTimeLine(
                    base.scrollLeft - (Util.$timelineTool.timelineWidth + 1)
                );

        }
    }

    /**
     * @description マーカーElementの移動終了関数
     *
     * @return {void}
     * @method
     * @public
     */
    endMarker ()
    {
        Util.$setCursor("auto");

        // グローバルイベントを削除
        window.removeEventListener("mousemove", this._$moveMarker);
        window.removeEventListener("mouseup", this._$endMarker);

        // マウスダウン用にイベント対象に変更
        document
            .getElementById("timeline-marker")
            .style.pointerEvents = "";

        // ラベルがあればInputElementに挿入
        const label = Util
            .$currentWorkSpace()
            .scene
            .gerLabel(
                Util.$timelineFrame.currentFrame
            );

        document
            .getElementById("label-name")
            .value = label ? label : "";
    }

    /**
     * @description タイムラインのマーカーを指定フレームへ設置
     *
     * @return {void}
     * @method
     * @public
     */
    move ()
    {
        // +1はborder solidの1pxを加算
        const width = Util.$timelineTool.timelineWidth + 1;

        document
            .getElementById("timeline-marker")
            .style
            .left = `${(Util.$timelineFrame.currentFrame - 1) * width}px`;
    }
}

Util.$timelineMarker = new TimelineMarker();

/**
 * @class
 * @extends {BaseTimeline}
 */
class TimelineMenu extends BaseTimeline
{
    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "context-menu-script-add",
            "context-menu-frame-add",
            "context-menu-key-frame-add",
            "context-menu-empty-key-frame-add",
            "context-menu-frame-delete",
            "context-menu-key-frame-delete",
            "context-menu-tween-add",
            "context-menu-tween-delete",
            "context-menu-frame-copy",
            "context-menu-frame-paste"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document
                .getElementById(elementIds[idx]);

            if (!element) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // メニューを非表示
                Util.$endMenu();

                // id名で関数を実行
                this.executeFunction(event);
            });
        }
    }

    /**
     * @description JavaScript編集モーダルを起動
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuScriptAdd ()
    {
        Util.$javaScriptEditor.show();
    }

    /**
     * @description タイムラインにフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuFrameAdd ()
    {
        Util.$timelineTool.executeTimelineFrameAdd();
    }

    /**
     * @description タイムラインにキーフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuKeyFrameAdd ()
    {
        Util.$timelineTool.executeTimelineKeyAdd();
    }

    /**
     * @description タイムラインにキーフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuKeyFrameDelete ()
    {
        Util.$timelineTool.executeTimelineKeyDelete();
    }

    /**
     * @description タイムラインに空のキーフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuEmptyKeyFrameAdd ()
    {
        Util.$timelineTool.executeTimelineEmptyAdd();
    }

    /**
     * @description タイムラインのフレームを削除する
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuFrameDelete ()
    {
        Util.$timelineTool.executeTimelineFrameDelete();
    }

    /**
     * @description 指定のレイヤーにtweenを追加
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuTweenAdd ()
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                targetLayer.dataset.layerId | 0
            );

        const characters = layer.getActiveCharacter(frame);
        if (!characters.length) {
            return ;
        }

        if (characters.length > 1) {
            alert(
                "If you want to add motion tweening to multiple objects, please do so in a single MovieClip."
            );
            return ;
        }

        /**
         * @param {Character}
         */
        const character = characters[0];
        const range = character.getRange(frame);

        // すでに、tweenの設定があればスキップ
        if (character.hasTween(range.startFrame)) {
            return ;
        }

        this.save();

        character.setTween(range.startFrame, {
            "method": "linear",
            "curve": [],
            "custom": Util.$tweenController.createEasingObject(),
            "startFrame": range.startFrame,
            "endFrame": range.endFrame
        });

        character.updateTweenPlace(range.startFrame, range.endFrame);

        //  tweenの座標を再計算してポインターを再配置
        character.relocationTween(range.startFrame);

        // タイムラインを再描画
        layer.reloadStyle();

        // 再描画
        character._$image = null;
        this.reloadScreen();

        this._$saved = false;
    }

    /**
     * @description 指定のレイヤーのtweenを削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuTweenDelete ()
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                targetLayer.dataset.layerId | 0
            );

        const characters = layer.getActiveCharacter(frame);
        if (!characters.length || characters.length > 1) {
            return ;
        }

        /**
         * @param {Character}
         */
        const character = characters[0];
        const range = character.getRange(frame);

        // tweenの設定がなければスキップ
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        this.save();

        // tweenで作成したplace objectを削除
        for (let frame = range.startFrame + 1; range.endFrame > frame; ++frame) {
            if (!character.hasPlace(frame)) {
                continue;
            }
            character.deletePlace(frame);
        }

        // tweenのマスタを削除
        character.deleteTween(range.startFrame);

        const place = character.getPlace(range.startFrame);
        delete place.tweenFrame;

        // tweenのポインターを削除
        Util
            .$tweenController
            .clearPointer();

        // タイムラインを再描画
        layer.reloadStyle();

        // 再描画
        character._$image = null;
        this.reloadScreen();

        this._$saved = false;
    }

    /**
     * @description タイムラインのメニューを表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    show (event)
    {
        Util.$endMenu("timeline-menu");

        const element = document.getElementById("timeline-menu");

        element.style.left = `${event.pageX + 5}px`;
        element.style.top  = `${event.pageY - element.clientHeight}px`;
        if (15 > element.offsetTop) {
            element.style.top = "10px";
        }

        if (event.pageY + 15 > window.innerHeight) {
            element.style.top = `${event.pageY - element.clientHeight - 15}px`;
        }

        element.setAttribute("class", "fadeIn");
    }
}

Util.$timelineMenu = new TimelineMenu();

/**
 * @class
 * @extends {BaseTimeline}
 */
class TimelinePlayer extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$stopFlag = true;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$repeat = false;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$totalFrame = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$startTime = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$fps = 0;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$timerId = -1;

        /**
         * @type {function}
         * @description null
         * @private
         */
        this._$run = null;
    }

    /**
     * @description リピート設定を返す
     *
     * @return {boolean}
     * @readonly
     * @public
     */
    get repeat ()
    {
        return this._$repeat;
    }

    /**
     * @description 再生フラグを返す
     *
     * @return {boolean}
     * @readonly
     * @public
     */
    get stopFlag ()
    {
        return this._$stopFlag;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "timeline-play",
            "timeline-stop",
            "timeline-repeat",
            "timeline-no-repeat"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const id = elementIds[idx];

            const element = document.getElementById(id);
            if (!element) {
                continue;
            }

            // ストップとリピートアイコンは初期は非表示
            switch (id) {

                case "timeline-stop":
                case "timeline-repeat":
                    element.style.display = "none";
                    break;

                default:
                    break;

            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event);

                // 全てのメニューを終了する
                Util.$endMenu();
            });
        }

        // 毎フレームの再生関数を変数にセット
        this._$run = this.run.bind(this);
    }

    /**
     * @description タイムラインのプレイヤーを再生する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelinePlay ()
    {
        if (this._$stopFlag) {

            // アクティブな再生範囲を取得(空のフレームは含めない)
            this._$totalFrame = Util
                .$currentWorkSpace()
                .scene
                .totalFrame;

            // 1フレーム以上あるタイムラインが再生対象
            if (this._$totalFrame > 1) {

                this._$stopFlag = false;

                // 先に起動しているタイマーがあれば停止する
                if (this._$timerId > -1) {
                    window.cancelAnimationFrame(this._$timerId);
                }

                // 再生位置の補正
                let frame = Util.$timelineFrame.currentFrame;
                if (frame >= this._$totalFrame) {

                    Util.$timelineFrame.currentFrame = 1;

                    // マーカーを移動
                    Util.$timelineMarker.move();

                    // スクロールしていれば左端にセット
                    if (document
                        .getElementById("timeline-controller-base")
                        .scrollLeft
                    ) {
                        Util.$timelineLayer.moveTimeLine(0);
                    }

                    // 再描画
                    this.reloadScreen();
                }

                /**
                 * @type {ArrowTool}
                 */
                const tool = Util.$tools.getDefaultTool("arrow");
                tool.clear();

                // 再生ボタンを非表示
                document
                    .getElementById("timeline-play")
                    .style.display = "none";

                // 停止ボタンを表示
                document
                    .getElementById("timeline-stop")
                    .style.display = "";

                this._$startTime = window.performance.now();
                this._$fps       = 1000 / (document.getElementById("stage-fps").value | 0);
                this._$timerId   = window.requestAnimationFrame(this._$run);
            }
        } else {
            this.executeTimelineStop();
        }
    }

    /**
     * @description タイムラインのプレイヤーを停止する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineStop ()
    {
        // タイマーを終了
        window.cancelAnimationFrame(this._$timerId);

        // 変数を初期化
        this._$stopFlag = true;
        this._$timerId  = -1;

        // 再生ボタンを表示
        document
            .getElementById("timeline-play")
            .style.display = "";

        // 停止ボタンを非表示
        document
            .getElementById("timeline-stop")
            .style.display = "none";

        // 再生位置で再描画
        this.reloadScreen();
    }

    /**
     * @description タイムラインのプレイヤーの再生が最終フレームにいくと自動的に終了する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineRepeat ()
    {
        document
            .getElementById("timeline-repeat")
            .style.display = "none";

        document
            .getElementById("timeline-no-repeat")
            .style.display = "";

        this._$repeat = false;
    }

    /**
     * @description タイムラインのプレイヤーの再生をリピートする
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineNoRepeat ()
    {
        document
            .getElementById("timeline-repeat")
            .style.display = "";

        document
            .getElementById("timeline-no-repeat")
            .style.display = "none";

        this._$repeat = true;
    }

    /**
     * @description 毎フレームの再生処理
     * @param  {number} timestamp
     * @return {void}
     * @method
     * @public
     */
    run (timestamp = 0)
    {
        if (this._$stopFlag) {
            return ;
        }

        let delta = timestamp - this._$startTime;
        if (delta > this._$fps) {

            const base = document
                .getElementById("timeline-controller-base");

            let frame = Util.$timelineFrame.currentFrame + 1;
            if (frame > this._$totalFrame) {

                if (!this._$repeat) {
                    return this.executeTimelineStop();
                }

                frame = 1;

                // スクロールしていれば左端にセット
                if (base.scrollLeft) {
                    Util.$timelineLayer.moveTimeLine(0);
                }
            }

            // フレームを移動
            Util.$timelineFrame.currentFrame = frame;

            // マーカーを移動
            Util.$timelineMarker.move();

            const moveX = (frame - 1) * (Util.$timelineTool.timelineWidth + 1);
            if (moveX > base.offsetWidth / 2) {
                Util
                    .$timelineLayer
                    .moveTimeLine(moveX - base.offsetWidth / 2);
            }

            // 描画した時間を更新
            this._$startTime = timestamp - delta % this._$fps;

            // 再描画
            this.reloadScreen();

        }

        // 描画のタイマーをセット
        this._$timerId = window.requestAnimationFrame(this._$run);
    }
}

Util.$timelinePlayer = new TimelinePlayer();


/**
 * @class
 * @extends {BaseTimeline}
 */
class TimelineTool extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$labelFrame = 0;

        /**
         * @type {number}
         * @default
         * @private
         */
        this._$timelineWidth = TimelineTool.DEFAULT_TIMELINE_WIDTH;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$lightAll = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$lockAll = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$disableAll = false;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "timeline-layer-add",
            "timeline-layer-trash",
            "timeline-layer-light-all",
            "timeline-layer-disable-all",
            "timeline-layer-lock-all",
            "timeline-script-add",
            "timeline-frame-add",
            "timeline-key-add",
            "timeline-empty-add",
            "timeline-frame-delete",
            "timeline-onion-skin",
            "timeline-preview",
            "scene-list"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event);
            });
        }

        const inputIds = [
            "label-name"
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {

            const element = document.getElementById(inputIds[idx]);
            if (!element) {
                continue;
            }

            element.addEventListener("focusin", (event) =>
            {
                this.focusIn(event);
            });
            element.addEventListener("keypress", (event) =>
            {
                if (event.key !== "Enter") {
                    return ;
                }
                event.target.blur();
            });
            element.addEventListener("focusout", (event) =>
            {
                this.executeFunction(event);
            });
        }

        const element = document.getElementById("timeline-scale");
        if (element) {
            this.setInputEvent(element);
        }
    }

    /**
     * @description タイムライン幅の初期値
     *
     * @return {number}
     * @const
     * @static
     */
    static get DEFAULT_TIMELINE_WIDTH ()
    {
        return 12;
    }

    /**
     * @description タイムラインの幅を返す
     *
     * @return {number}
     * @public
     */
    get timelineWidth ()
    {
        return this._$timelineWidth;
    }

    /**
     * @description タイムラインの幅を返す
     *
     * @param  {number} timeline_width
     * @return {void}
     * @public
     */
    set timelineWidth (timeline_width)
    {
        this._$timelineWidth = timeline_width;

        // タイムラインの幅を変更
        document
            .documentElement
            .style
            .setProperty("--timeline-frame-width", `${timeline_width}px`);

        // マーカーの幅を変更
        document
            .documentElement
            .style
            .setProperty("--marker-width", `${Util.$clamp(timeline_width, 4, TimelineTool.DEFAULT_TIMELINE_WIDTH)}px`);

        // スケールInputに値を反映
        document
            .getElementById("timeline-scale")
            .value = `${timeline_width / TimelineTool.DEFAULT_TIMELINE_WIDTH * 100 | 0}`;

        // フレーム幅に合わせてマーカーを移動
        Util.$timelineMarker.move();
    }

    /**
     * @description タイムラインツールのInput共通関数
     *
     * @return {void}
     * @method
     * @public
     */
    focusIn ()
    {
        super.focusIn();
        this._$labelFrame = Util.$timelineFrame.currentFrame;
    }

    /**
     * @description ラベル名のInput処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeLabelName (event)
    {
        if (!this._$labelFrame) {
            return ;
        }

        const element = document
            .getElementById(`frame-label-marker-${this._$labelFrame}`);

        const value = event.target.value;
        const scene = Util.$currentWorkSpace().scene;
        if (value) {

            // ラベル名があれば登録
            this.save(); // 事前保存
            scene.setLabel(this._$labelFrame, value);
            element.setAttribute("class", "frame-border-box-marker");

        } else {

            // ラベル名があって、Inputが空ならラベルの削除処理を行う
            const label = scene.gerLabel(this._$labelFrame);
            if (label) {
                this.save(); // 事前保存
                scene.deleteLabel(this._$labelFrame);
                element.setAttribute("class", "frame-border-box");
            }

        }

        // 初期化
        super.focusOut();
        this._$labelFrame = 0;
    }

    /**
     * @description タイムラインのスケールのInput処理
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeTimelineScale (value)
    {
        value = Util.$clamp(value | 0, 41, 2000);

        this.timelineWidth = TimelineTool.DEFAULT_TIMELINE_WIDTH * value / 100;

        return value;
    }

    /**
     * @description 全てのレイヤーロックをOn/Offに変更
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerLockAll ()
    {
        this._$lockAll = !this._$lockAll;

        const content = document
            .getElementById("timeline-content");

        const scene = Util.$currentWorkSpace().scene;

        let useMask = false;
        const length = content.children.length;
        for (let idx = 0; idx < length; ++idx) {

            const child   = content.children[idx];
            const layerId = child.dataset.layerId | 0;

            const element = document
                .getElementById(`layer-lock-icon-${layerId}`);

            const layer = scene.getLayer(layerId);
            if (layer.mode === Util.LAYER_MODE_MASK) {
                useMask = true;
            }

            if (this._$lockAll) {

                element
                    .classList
                    .remove("icon-disable");

                element
                    .classList
                    .add("icon-active");

                layer.lock = true;

            } else {

                element
                    .classList
                    .remove("icon-active");

                element
                    .classList
                    .add("icon-disable");

                layer.lock = false;

            }

            if (useMask) {
                this.reloadScreen();
            }
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();
    }

    /**
     * @description 全てのレイヤーを表示/非表示に変更
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerDisableAll ()
    {
        this._$disableAll = !this._$disableAll;

        const content = document
            .getElementById("timeline-content");

        const scene = Util.$currentWorkSpace().scene;

        const length = content.children.length;
        for (let idx = 0; idx < length; ++idx) {

            const child   = content.children[idx];
            const layerId = child.dataset.layerId | 0;

            const element = document
                .getElementById(`layer-disable-icon-${layerId}`);

            const layer = scene.getLayer(layerId);
            if (this._$disableAll) {

                element
                    .classList
                    .remove("icon-disable");

                element
                    .classList
                    .add("icon-active");

                layer.disable = true;

            } else {

                element
                    .classList
                    .remove("icon-active");

                element
                    .classList
                    .add("icon-disable");

                layer.disable = false;

            }

            /**
             * @type {ArrowTool}
             */
            const tool = Util.$tools.getDefaultTool("arrow");
            tool.clear();

            this.reloadScreen();
        }
    }

    /**
     * @description 全てのハイライトをOn/Offに変更
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerLightAll ()
    {
        this._$lightAll = !this._$lightAll;

        const content = document
            .getElementById("timeline-content");

        const scene = Util.$currentWorkSpace().scene;

        const length = content.children.length;
        for (let idx = 0; idx < length; ++idx) {

            const child   = content.children[idx];
            const layerId = child.dataset.layerId | 0;

            const element = document
                .getElementById(`layer-light-icon-${layerId}`);

            const parent = document
                .getElementById(`layer-id-${layerId}`);

            const layer = scene.getLayer(layerId);
            if (this._$lightAll) {

                element
                    .classList
                    .remove("icon-disable");

                element
                    .classList
                    .add("light-icon-active");

                parent
                    .style
                    .borderBottom = `1px solid ${layer.color}`;

                layer.light = true;

            } else {

                element
                    .classList
                    .remove("light-icon-active");

                element
                    .classList
                    .add("icon-disable");

                parent
                    .style
                    .borderBottom = "";

                layer.light = false;

            }

        }
    }

    /**
     * @description 選択中のレイヤーをタイムラインから削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerTrash ()
    {
        const targetLayers = Util.$timelineLayer.targetLayers;
        if (targetLayers.size) {

            // 変更前の情報を保存
            this.save();

            const scene = Util.$currentWorkSpace().scene;

            // setup
            const parentElement = document
                .getElementById("timeline-content");

            let currentIndex = Array
                .from(parentElement.children)
                .indexOf(Util.$timelineLayer.targetLayer);

            let reload = false;
            const frame = Util.$timelineFrame.currentFrame;
            for (const element of targetLayers.values()) {

                const index = Array
                    .from(parentElement.children)
                    .indexOf(element);

                // マスクの対象となっているレイヤーを元に戻す
                const layerId = element.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const children = parentElement.children;
                switch (layer.mode) {

                    case Util.LAYER_MODE_MASK:
                        for (let idx = index + 1; idx < children.length; ++idx) {

                            const child = children[idx];

                            const layer = scene.getLayer(
                                child.dataset.layerId | 0
                            );

                            if (layer.mode !== Util.LAYER_MODE_MASK_IN) {
                                break;
                            }

                            layer.mode = Util.LAYER_MODE_NORMAL;
                            layer.showIcon();

                        }
                        break;

                    case Util.LAYER_MODE_GUIDE:
                        for (let idx = index + 1; idx < children.length; ++idx) {

                            const child = children[idx];

                            const layer = scene.getLayer(
                                child.dataset.layerId | 0
                            );

                            if (layer.mode !== Util.LAYER_MODE_GUIDE_IN) {
                                break;
                            }

                            layer.mode = Util.LAYER_MODE_NORMAL;
                            layer.showIcon();

                        }
                        break;

                    default:
                        break;

                }

                const characters = layer.getActiveCharacter(frame);
                if (characters.length) {
                    reload = true;
                }

                // 一覧からElementを削除
                element.remove();
                scene.deleteLayer(layerId);
            }

            /**
             * @type {ArrowTool}
             */
            const tool = Util.$tools.getDefaultTool("arrow");
            tool.clear();

            // タイムラインにレイヤーがあれば選択したいた近くのレイヤーをアクティブに
            if (parentElement.children.length) {
                let layerElement = null;
                for (;;) {
                    layerElement = parentElement.children[currentIndex--];
                    if (layerElement) {
                        Util.$timelineLayer.activeLayer(layerElement);
                        break;
                    }
                }
            }

            if (reload) {
                this.reloadScreen();
            }
        }
    }

    /**
     * @description タイムラインに新規レイヤーを追加
     *
     * @param  {MouseEvent} event
     * @param  {Layer} [new_layer=null]
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerAdd (event, new_layer = null)
    {
        this.save();

        const layerElement = Util.$timelineLayer.targetLayer
            || document
                .getElementById("timeline-content")
                .children[0];

        const scene = Util.$currentWorkSpace().scene;

        // 最終行にレイヤーを追加
        scene.addLayer(new_layer);

        // アクティブ中のレイヤーの上部に新規追加したレイヤーを移動
        if (layerElement) {

            const element = document
                .getElementById("timeline-content");

            const targetLayer = scene.getLayer(
                layerElement.dataset.layerId | 0
            );

            const lastElement = element.lastElementChild;
            switch (targetLayer.mode) {

                case Util.LAYER_MODE_MASK_IN:
                    {
                        const newLayer = scene.getLayer(
                            lastElement.dataset.layerId | 0
                        );
                        newLayer.maskId = targetLayer.maskId === null
                            ? targetLayer.id
                            : targetLayer.maskId;
                        newLayer.mode = Util.LAYER_MODE_MASK_IN;
                        newLayer.showIcon();
                    }
                    break;

                case Util.LAYER_MODE_GUIDE_IN:
                    {
                        const newLayer = scene.getLayer(
                            lastElement.dataset.layerId | 0
                        );
                        newLayer.guideId = targetLayer.guideId === null
                            ? targetLayer.id
                            : targetLayer.guideId;
                        newLayer.mode = Util.LAYER_MODE_GUIDE_IN;
                        newLayer.showIcon();
                    }
                    break;

                default:
                    break;

            }

            // 選択中のレイヤーの上部に新規レイヤーを追加
            element
                .insertBefore(lastElement, layerElement);

            // 新規レイヤーのスクロール位置を調整
            lastElement.lastElementChild.scrollLeft
                = layerElement.lastElementChild.scrollLeft;

            // 保存用のObjectの順番も入れ替える
            const layers = [];
            for (let idx = 0; idx < element.children.length; ++idx) {
                layers.push(
                    scene.getLayer(element.children[idx].dataset.layerId | 0)
                );
            }

            scene.clearLayer();
            for (let idx = 0; idx < layers.length; ++idx) {
                const layer = layers[idx];
                scene.setLayer(layer.id, layer);
            }

        }

        // 初期化
        super.focusOut(event);
    }

    /**
     * @description JavaScript編集モーダルを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeTimelineScriptAdd (event)
    {
        Util.$javaScriptEditor.show(event);
    }

    /**
     * @description タイムラインにフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineFrameAdd ()
    {
        const targetFrames = Util.$timelineLayer.targetFrames;
        if (!targetFrames.size) {
            return ;
        }

        this.save();

        const startFrame = this.getFirstFrame();
        const scene = Util.$currentWorkSpace().scene;
        for (const [layerId, values] of targetFrames) {

            const endFrame = startFrame + values.length;

            const element = document
                .getElementById(`${layerId}-${startFrame}`);

            const layer = scene.getLayer(layerId);

            // 未設定フレームに追加
            if (element.dataset.frameState === "empty") {

                let done = false;

                // 前方のフレームを補正
                let idx = 0;
                for ( ; startFrame - idx > 1; ++idx) {

                    const element = document
                        .getElementById(`${layerId}-${startFrame - idx}`);

                    if (element.dataset.frameState !== "empty") {
                        break;
                    }

                }

                const frame = startFrame - idx;

                // DisplayObjectが配置されたレイヤーでれば終了位置を補正
                const characters = layer.getActiveCharacter(frame);
                if (characters.length) {

                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];

                        const range = character.getRange(frame);
                        if (character.hasTween(range.startFrame)) {

                            // tweenの幅情報を更新して各place objectを更新
                            const tweenObject = character
                                .getTween(range.startFrame);

                            tweenObject.endFrame = endFrame;

                            character
                                .updateTweenPlace(
                                    range.startFrame, endFrame
                                );

                            //  tweenの座標を再計算してポインターを再配置
                            character.relocationTween(range.startFrame);
                        }

                        // fixed logic 終了するフレーム番号を更新
                        character.endFrame = endFrame;
                    }

                    done = true;
                }

                // 空フレームでれば終了位置を補正
                const emptyCharacter = layer.getActiveEmptyCharacter(frame);
                if (!done && emptyCharacter) {

                    emptyCharacter.endFrame = endFrame;

                    done = true;
                }

                // レイヤーが空であれば、空フレームを追加
                if (!done) {
                    layer.addEmptyCharacter(
                        new EmptyCharacter({
                            "startFrame": frame,
                            "endFrame": endFrame
                        })
                    );
                }

            } else {

                // 後方補正(DisplayObject)
                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                    const character = layer._$characters[idx];
                    if (startFrame >= character.startFrame) {
                        continue;
                    }

                    character.move(values.length);
                }

                // 後方補正(空のフレーム)
                for (let idx = 0; idx < layer._$emptys.length; ++idx) {

                    const character = layer._$emptys[idx];
                    if (startFrame >= character.startFrame) {
                        continue;
                    }

                    character.move(values.length);

                }

                // 定義済みのフレームの場合
                const characters = layer
                    .getActiveCharacter(startFrame);

                // DisplayObjectが配置されたフレーム
                if (characters.length) {

                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];

                        const range = character.getRange(startFrame);

                        const places = new Map();
                        for (const [keyFrame, place] of character._$places) {

                            // レンジ内か、前方のキーフレームは現状維持
                            if (range.startFrame > keyFrame) {
                                places.set(keyFrame, place);
                                continue;
                            }

                            if (keyFrame >= range.startFrame && range.endFrame > keyFrame) {
                                places.set(keyFrame, place);
                                continue;
                            }

                            place.frame = keyFrame + values.length;
                            if (place.tweenFrame) {
                                place.tweenFrame += values.length;
                            }
                            places.set(place.frame, place);

                        }

                        // キーフレームの情報を上書き
                        character._$places = places;

                        if (character._$tween.size) {

                            // tween情報を更新
                            const tween = new Map();
                            for (const [keyFrame, tweenObject] of character._$tween) {

                                if (range.startFrame >= keyFrame) {
                                    tween.set(keyFrame, tweenObject);
                                    continue;
                                }

                                // 後方のtweenは開始終了位置を追加フレーム分後方に移動
                                // このplace objectを先行処理でキーフレーム情報を更新済み
                                tweenObject.startFrame += values.length;
                                tweenObject.endFrame   += values.length;
                                tween.set(tweenObject.startFrame, tweenObject);
                            }
                            character._$tween = tween;

                            if (character.hasTween(range.startFrame)) {

                                // tweenの幅情報を更新して各place objectを更新
                                const tweenObject = character
                                    .getTween(range.startFrame);

                                tweenObject.endFrame += values.length;

                                character.updateTweenPlace(
                                    range.startFrame,
                                    range.endFrame + values.length
                                );

                                //  tweenの座標を再計算してポインターを再配置
                                character.relocationTween(range.startFrame);
                            }
                        }

                        // fixed logic 終了するフレーム番号を更新
                        character.endFrame += values.length;
                    }

                } else {

                    // 空のフレーム
                    const emptyCharacter = layer
                        .getActiveEmptyCharacter(startFrame);

                    if (emptyCharacter) {
                        emptyCharacter.endFrame += values.length;
                    }

                }

            }

            layer.reloadStyle();
        }

        // アクティブなフレームを再設定
        this.setActiveFrame();

        // 追加した分だけタイムラインを増加させる補正
        this.adjustmentTimeline();

        // 再描画
        this.reloadScreen();

        // 初期化
        super.focusOut();
    }

    /**
     * @description タイムラインにキーフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineKeyAdd ()
    {
        const targetFrames = Util.$timelineLayer.targetFrames;
        if (!targetFrames.size) {
            return ;
        }

        this.save();

        const frame = Util.$timelineFrame.currentFrame;
        const scene = Util.$currentWorkSpace().scene;

        for (const layerId of targetFrames.keys()) {

            const layer = scene.getLayer(layerId);

            const characters = layer.getActiveCharacter(frame);
            if (characters.length) {

                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    // キーフレームがあればスキップ
                    if (character.hasPlace(frame)) {

                        // tweenでキーフレームを追加
                        const place = character.getPlace(frame);
                        if (place.tweenFrame) {

                            const range = character.getRange(frame);

                            const tweenObject    = character.getTween(place.tweenFrame);
                            tweenObject.endFrame = frame;

                            character.setTween(frame, {
                                "method": tweenObject.method,
                                "curve": [],
                                "custom": Util.$tweenController.createEasingObject(),
                                "startFrame": frame,
                                "endFrame": range.endFrame
                            });

                            character
                                .updateTweenPlace(frame, range.endFrame);

                            // 再計算
                            Util
                                .$tweenController
                                .relocationPlace(character, frame);

                            // ポインターを再配置
                            Util
                                .$tweenController
                                .clearPointer()
                                .relocationPointer();
                        }

                        continue;
                    }

                    character.setPlace(frame,
                        character.getClonePlace(frame)
                    );
                }

            } else {

                this.addEmptyCharacter(layer);

            }

            layer.reloadStyle();
        }

        // アクティブなフレームを再設定
        this.setActiveFrame();

        // 追加した分だけタイムラインを増加させる補正
        this.adjustmentTimeline();

        // 再描画(DisplayObjectの再配置で必須)
        this.reloadScreen();

        // 初期化
        super.focusOut();
    }

    /**
     * @description タイムラインのキーフレームを削除する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineKeyDelete ()
    {
        const targetFrames = Util.$timelineLayer.targetFrames;
        if (!targetFrames.size) {
            return ;
        }

        this.save();

        const scene = Util.$currentWorkSpace().scene;

        const startFrame = this.getFirstFrame();
        for (const layerId of targetFrames.keys()) {

            const layer = scene.getLayer(layerId);

            // 何も設定がないのでスキップ
            if (!layer._$characters.length && !layer._$emptys.length) {
                continue;
            }

            const totalFrame = layer.totalFrame;

            const characters = layer
                .getActiveCharacter(startFrame);

            if (characters.length) {

                // キーフレームを削除
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    if (!character.hasPlace(startFrame)) {
                        continue;
                    }

                    // tween内のplace objectであればスキップ
                    const place = character.getPlace(startFrame);
                    if (place.tweenFrame && place.tweenFrame !== startFrame) {
                        continue;
                    }

                    if (character.hasTween(startFrame)) {

                        const tweenObject = character.getTween(startFrame);
                        switch (true) {

                            // tweenのレンジ幅がDisplayObjectのフレーム数であれば全て削除
                            case character.startFrame === tweenObject.startFrame && character.endFrame === tweenObject.endFrame:
                                character._$places.clear();
                                break;

                            // 削除するキーフレームが開始位置ならレンジ幅のplace objectを初期
                            case character.startFrame === tweenObject.startFrame:
                                for (let keyFrame = tweenObject.startFrame; keyFrame < tweenObject.endFrame; ++keyFrame) {
                                    character.deletePlace(keyFrame);
                                }
                                break;

                            default:
                                {
                                    const prevRange = character
                                        .getRange(tweenObject.startFrame - 1);

                                    if (character.hasTween(prevRange.startFrame)) {

                                        // 直前にtweenがあれば結合
                                        for (let keyFrame = tweenObject.startFrame; keyFrame < tweenObject.endFrame; ++keyFrame) {
                                            const place = character.getPlace(keyFrame);
                                            place.tweenFrame = prevRange.startFrame;
                                        }

                                        const prevTweenObject = character.getTween(prevRange.startFrame);
                                        prevTweenObject.endFrame = tweenObject.endFrame;

                                        //  tweenの座標を再計算してポインターを再配置
                                        character.updateTweenFilter(prevRange.startFrame);
                                        character.updateTweenBlend(prevRange.startFrame);
                                        character.relocationTween(prevRange.startFrame);

                                    } else {

                                        // 単独のtweenであればレンジ幅のplace objectを削除
                                        for (let keyFrame = tweenObject.startFrame; keyFrame < tweenObject.endFrame; ++keyFrame) {
                                            character.deletePlace(keyFrame);
                                        }
                                    }
                                }
                                break;

                        }

                        character.deleteTween(startFrame);

                    } else {

                        // キーフレームを削除
                        character.deletePlace(startFrame);

                    }

                    // キーフレームがなければタイムラインから削除
                    if (!character._$places.size) {
                        layer.deleteCharacter(character.id);
                        continue;
                    }

                    // 削除したキーフレームが開始フレームなら開始位置を変更
                    if (startFrame === character.startFrame) {
                        let frame = character.endFrame;
                        for (const keyFrame of character._$places.keys()) {
                            frame = Math.min(frame, keyFrame);
                        }
                        character.startFrame = frame;
                    }
                }

                // 対象フレームが空になった場合はタイムラインの補正
                if (!layer.getActiveCharacter(startFrame).length) {
                    this.adjustmentKeyFrame(layer, startFrame, totalFrame);
                }

                // 再配置
                layer.reloadStyle();

                continue;
            }

            // 空のフレームの場合
            const emptyCharacter = layer
                .getActiveEmptyCharacter(startFrame);

            // キーフレームがなければスキップ
            if (!emptyCharacter || emptyCharacter.startFrame !== startFrame) {
                continue;
            }

            // 空白のフレームを削除
            layer.deleteEmptyCharacter(emptyCharacter);

            // タイムラインの補正
            this.adjustmentKeyFrame(layer, startFrame, totalFrame);

            // 再配置
            layer.reloadStyle();
        }

        // アクティブなフレームを再設定
        this.setActiveFrame();

        // 追加した分だけタイムラインを増加させる補正
        this.adjustmentTimeline();

        // 削除するものがあるので、選択範囲を再計算して再描画
        Util.$timelineLayer.activeCharacter();
        this.reloadScreen();

        // 初期化
        super.focusOut();
    }

    /**
     * @description タイムラインに空のキーフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineEmptyAdd ()
    {
        const targetFrames = Util.$timelineLayer.targetFrames;
        if (!targetFrames.size) {
            return ;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        // スクリーンエリアで選択中のDisplayObjectを未選択に
        tool.clearActiveElement();

        this.save();

        const frame = Util.$timelineFrame.currentFrame;
        const scene = Util.$currentWorkSpace().scene;
        for (const layerId of targetFrames.keys()) {

            const layer = scene.getLayer(layerId);

            const characters = layer.getActiveCharacter(frame);
            if (characters.length) {

                // キーフレームが設定されている場合は何もしない
                const frameElement = document
                    .getElementById(`${layerId}-${frame}`);

                if (frameElement.dataset.frameState === "key-frame") {

                    Util.$fadeIn({
                        "currentTarget": {
                            "dataset": {
                                "detail": "{{キーフレームに空のキーフレームを追加できません}}"
                            }
                        },
                        "pageX": frameElement.offsetLeft,
                        "pageY": frameElement.offsetTop
                    });

                    continue;
                }

                // 分割するフレーム番号を算出
                let splitFrame = Number.MAX_VALUE;
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    splitFrame = Math.min(splitFrame, character.endFrame);
                    for (let keyFrame of character._$places.keys()) {

                        if (frame > keyFrame) {
                            continue;
                        }

                        splitFrame = Math.min(splitFrame, keyFrame);
                    }
                }

                // 分割処理
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    // fixed logic 先に分割
                    character.split(layer, frame, splitFrame);

                    // 終了するフレームが後方にある場合は分割
                    if (character.endFrame > splitFrame) {
                        layer.addCharacter(character.split(layer,
                            splitFrame,
                            character.endFrame
                        ));
                    }
                }

                // 空のフレームを追加
                const emptyCharacter = new EmptyCharacter();
                emptyCharacter.startFrame = frame;
                emptyCharacter.endFrame   = splitFrame;
                layer.addEmptyCharacter(emptyCharacter);

            } else {

                this.addEmptyCharacter(layer);

            }

            layer.reloadStyle();
        }

        // アクティブなフレームを再設定
        this.setActiveFrame();

        // 追加した分だけタイムラインを増加させる補正
        this.adjustmentTimeline();

        // 再描画
        this.reloadScreen();

        // 初期化
        super.focusOut();
    }

    /**
     * @description 空のキーフレームを登録
     *
     * @param  {Layer} layer
     * @return {void}
     * @method
     * @public
     */
    addEmptyCharacter (layer)
    {
        const frame = Util.$timelineFrame.currentFrame;

        // DisplayObjectが何も設置されてないフレームのケース
        const character = layer.getActiveEmptyCharacter(frame);
        if (character) {

            // キーフレームが設定されている場合は何もしない
            const frameElement = document
                .getElementById(`${layer.id}-${frame}`);

            if (frameElement.dataset.frameState === "empty-key-frame") {
                return ;
            }

            // 空のフレームと重なっている
            if (character.startFrame !== frame) {

                // 空のフレームを分割、後半に新しいオブジェクトを設定
                layer.addEmptyCharacter(
                    new EmptyCharacter({
                        "startFrame": frame,
                        "endFrame": character.endFrame
                    })
                );

                // 前半のオブジェクトは再利用
                character.endFrame = frame;

            }

        } else {

            // emptyのフレームの場合

            // 1フレーム目でない時は手前のフレームの確認を行う
            if (frame > 1) {

                // 開始位置を算出
                let idx = 1;
                for (; frame - idx > 1; ++idx) {

                    const element = document
                        .getElementById(`${layer.id}-${frame - idx}`);

                    if (element.dataset.frameState !== "empty") {
                        break;
                    }

                }

                const characters = layer
                    .getActiveCharacter(frame - idx);

                if (characters.length) {

                    // 手前にDisplayObjectを配置したフレームがあった場合は終了位置を補正
                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];
                        character.endFrame = frame;

                    }

                } else {

                    const prevEmptyCharacter = layer
                        .getActiveEmptyCharacter(frame - idx);

                    // 手前のフレームに空フレームがあれば最終位置を伸ばす
                    if (prevEmptyCharacter) {

                        prevEmptyCharacter.endFrame = frame;

                    } else {

                        // なければ新規作成
                        layer.addEmptyCharacter(
                            new EmptyCharacter({
                                "startFrame": frame - idx,
                                "endFrame": frame
                            })
                        );

                    }

                }
            }

            const emptyCharacter = new EmptyCharacter();
            emptyCharacter.startFrame = frame;
            emptyCharacter.endFrame   = frame + 1;
            layer.addEmptyCharacter(emptyCharacter);
        }
    }

    /**
     * @description タイムラインのフレームを削除する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineFrameDelete ()
    {
        const targetFrames = Util.$timelineLayer.targetFrames;
        if (!targetFrames.size) {
            return ;
        }

        this.save();

        const frame = this.getFirstFrame();
        const scene = Util.$currentWorkSpace().scene;
        for (const [layerId, values] of targetFrames) {

            // 未設定のフレームの場合は処理をスキップ
            if (document
                .getElementById(`${layerId}-${frame}`)
                .dataset.frameState === "empty"
            ) {
                continue;
            }

            const layer = scene.getLayer(layerId);

            // 定義済みのフレームの場合
            const characters = layer
                .getActiveCharacter(frame);

            let moveFrame = 0;

            // DisplayObjectが配置されたフレーム
            if (characters.length) {

                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    // 削除対象範囲を計算
                    const range = character.getRange(frame);

                    // 削除開始位置がキーフレームの場合
                    if (character.hasPlace(frame)) {

                        // 削除範囲がキーフレームの幅を超えてる場合はキーフレームを削除
                        if (values.length >= range.endFrame - range.startFrame) {

                            // tweenがあれば情報を削除
                            if (character.hasTween(frame)) {
                                for (let keyFrame = range.startFrame; keyFrame < range.endFrame; ++keyFrame) {
                                    character.deletePlace(keyFrame);
                                }
                                character.deleteTween(frame);

                                // tweenのポインターを削除
                                Util
                                    .$tweenController
                                    .clearPointer();
                            }

                            // キーフレームを削除
                            character.deletePlace(frame);
                        }

                    }

                    // 削除範囲のフレーム数
                    moveFrame = Math.min(
                        range.endFrame, frame + values.length
                    ) - frame;

                    // キーフレームが存在しなけれなDisplayObjectを削除
                    if (!character._$places.size) {

                        layer.deleteCharacter(character.id);

                    } else {

                        const places = new Map();
                        for (const [keyFrame, place] of character._$places) {

                            // レンジ内か、前方のキーフレームは現状維持
                            if (range.startFrame > keyFrame) {
                                places.set(keyFrame, place);
                                continue;
                            }

                            if (keyFrame >= range.startFrame && range.endFrame > keyFrame) {

                                // 削除した範囲外だけ登録
                                if (range.endFrame - moveFrame > keyFrame) {
                                    places.set(keyFrame, place);
                                }

                                // 最後のフレームはキーフレームとしてレンジの最後のフレームに挿入
                                if (range.endFrame - 1 === keyFrame) {
                                    places.set(range.endFrame - moveFrame - 1, place);
                                }

                                continue;
                            }

                            place.frame = keyFrame - moveFrame;
                            if (place.tweenFrame) {
                                place.tweenFrame -= moveFrame;
                            }

                            places.set(place.frame, place);

                        }
                        character._$places = places;

                        // tweenの情報があれば更新して再計算
                        if (character._$tween.size) {

                            const tween = new Map();
                            for (const [keyFrame, tweenObject] of character._$tween) {

                                if (range.startFrame >= keyFrame) {

                                    if (range.startFrame === keyFrame) {
                                        tweenObject.endFrame -= moveFrame;
                                    }

                                    tween.set(keyFrame, tweenObject);

                                } else {

                                    // 削除したフレーム数分、前方へ移動
                                    // レンジ内のplace objectは別処理で移動済み
                                    tweenObject.startFrame -= moveFrame;
                                    tweenObject.endFrame   -= moveFrame;
                                    tween.set(tweenObject.startFrame, tweenObject);

                                }

                            }
                            character._$tween = tween;

                            // tweenの座標を再計算してポインターを再配置
                            character.relocationTween(range.startFrame);
                        }

                        character.endFrame -= moveFrame;
                    }

                }

            } else {

                // 空のフレーム
                const emptyCharacter = layer
                    .getActiveEmptyCharacter(frame);

                if (emptyCharacter) {

                    const totalFrame = emptyCharacter.endFrame
                        - emptyCharacter.startFrame;

                    const endFrame = Math.min(
                        emptyCharacter.endFrame, frame + values.length
                    );

                    moveFrame = endFrame - frame;
                    if (moveFrame >= totalFrame) {

                        // 削除するフレーム数が超えていれば削除
                        layer.deleteEmptyCharacter(emptyCharacter);

                    } else {

                        // フレームを削除
                        emptyCharacter.endFrame -= moveFrame;

                    }

                }
            }

            // 後方補正(DisplayObject)
            for (let idx = 0; idx < layer._$characters.length; ++idx) {

                const character = layer._$characters[idx];
                if (frame >= character.startFrame) {
                    continue;
                }

                character.move(-moveFrame);
            }

            // 後方補正(空のフレーム)
            for (let idx = 0; idx < layer._$emptys.length; ++idx) {

                const character = layer._$emptys[idx];
                if (frame >= character.startFrame) {
                    continue;
                }

                character.move(-moveFrame);

            }

            layer.reloadStyle();
        }

        // アクティブなフレームを再設定
        this.setActiveFrame();

        // 指定フレームの有効なDisplayObjectを確認
        Util.$timelineLayer.activeCharacter();

        // 追加した分だけタイムラインを増加させる補正
        this.adjustmentTimeline();

        // 再描画
        this.reloadScreen();

        // 初期化
        super.focusOut();
    }

    /**
     * @description オニオンスキン機能のon/off
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineOnionSkin ()
    {
        const element = document
            .getElementById("timeline-onion-skin");

        if (element.classList.contains("onion-skin-active")) {

            element
                .classList
                .remove("onion-skin-active");

            // 全てのDisplayObjectのキャッシュを削除
            const layers = Util
                .$currentWorkSpace()
                .scene
                ._$layers;

            for (const layer of layers.values()) {
                for (let idx = 0; idx < layer._$characters.length; ++idx) {
                    layer._$characters[idx]._$image = null;
                }
            }

        } else {

            element
                .classList
                .add("onion-skin-active");

        }

        // 再描画
        this.reloadScreen();
    }

    /**
     * @description タイムラインのマウスオーバーでのプレビュー機能のon/off
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelinePreview ()
    {
        const element = document
            .getElementById("timeline-preview");

        if (element.classList.contains("timeline-preview-active")) {

            element
                .classList
                .remove("timeline-preview-active");

        } else {

            element
                .classList
                .add("timeline-preview-active");

        }
    }

    /**
     * @description 先祖のMovieClipを一覧で表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeSceneList (event)
    {

        // リストがない時は何もしない
        if (!document
            .getElementById("scene-name-menu-list")
            .children.length
        ) {
            return ;
        }

        const element = document
            .getElementById("scene-name-menu");

        // 表示されていれば非表示
        if (element.classList.contains("fadeIn")) {

            element.setAttribute("class", "fadeOut");

        } else {

            const target = event.currentTarget;
            element.style.left = `${target.offsetLeft + target.offsetWidth}px`;
            element.style.top  = `${target.offsetTop + 10}px`;
            element.setAttribute("class", "fadeIn");

            // 一覧以外のメニューを非表示
            Util.$endMenu("scene-name-menu");
        }
    }

    /**
     * @description フレーム追加した場合、アクティブも初期化されるので再度設定が必要
     *
     * @return {void}
     * @method
     * @public
     */
    setActiveFrame ()
    {
        for (const values of Util.$timelineLayer.targetFrames.values()) {
            for (let idx = 0; idx < values.length; ++idx) {
                values[idx]
                    .classList
                    .add("frame-active");
            }
        }
    }

    /**
     * @description タイムラインのフレームに追加時に不足分をタイムラインを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    adjustmentTimeline ()
    {
        const currentLastFrame = Util.$timelineHeader.lastFrame;

        // ヘッダーを追加して、最終フレーム数を増加させる
        Util.$timelineHeader.create();

        // 表示されてるレイヤー全てにタイムラインを追加
        const children = document
            .getElementById("timeline-content").children;

        for (let idx = 0; idx < children.length; ++idx) {

            Util.$timelineLayer.create(
                currentLastFrame,
                children[idx].dataset.layerId | 0
            );

        }
    }

    /**
     * @description キーフレームを削除した時のタイムラインの補正
     *
     * @param  {Layer}  layer
     * @param  {number} key_frame
     * @param  {number} total_frame
     * @return {void}
     * @method
     * @public
     */
    adjustmentKeyFrame (layer, key_frame, total_frame)
    {
        if (key_frame > 1) {

            // 終了位置を計算
            let endFrame = total_frame;
            for (let idx = 1; total_frame > key_frame + idx; ++idx) {

                const frame = key_frame + idx;

                const characters = layer
                    .getActiveCharacter(frame);

                if (characters.length) {
                    endFrame = frame;
                    break;
                }

                const emptyCharacter = layer
                    .getActiveEmptyCharacter(frame);

                if (emptyCharacter) {
                    endFrame = frame;
                    break;
                }
            }

            // フレームが2以上なら前方確認
            for (let idx = 1; key_frame - idx > 0; ++idx) {

                const frame = key_frame - idx;

                const characters = layer
                    .getActiveCharacter(frame);

                if (characters.length) {

                    // 終了位置の補正
                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];

                        // tweenの補正
                        const keyFrame = character.endFrame - 1;
                        if (character.hasPlace(keyFrame)) {
                            const place = character.getPlace(keyFrame);
                            if (place.tweenFrame) {

                                character
                                    .getTween(place.tweenFrame)
                                    .endFrame = endFrame;

                                for (let frame = keyFrame + 1; endFrame > frame; ++frame) {
                                    character.setPlace(frame,
                                        character.getClonePlace(keyFrame)
                                    );
                                }

                                // 再計算
                                Util
                                    .$tweenController
                                    .relocationPlace(character, keyFrame);
                            }
                        }

                        characters[idx].endFrame = endFrame;
                    }

                    break;
                }

                const emptyCharacter = layer
                    .getActiveEmptyCharacter(frame);

                if (emptyCharacter) {
                    emptyCharacter.endFrame = endFrame;
                    break;
                }

            }

        } else {

            // 1フレーム以降に何かの配置があれば実行
            if (layer._$characters.length || layer._$emptys.length) {

                // フレームが1なら後方確認
                for (let idx = 1; ; ++idx) {

                    const frame = 1 + idx;

                    const characters = layer
                        .getActiveCharacter(frame);

                    if (characters.length) {

                        for (let idx = 0; idx < characters.length; ++idx) {

                            const character = characters[idx];

                            let moveFrame = character.endFrame;
                            for (let keyFrame of character._$places.keys()) {
                                moveFrame = Math.min(moveFrame, keyFrame);
                            }

                            // キーフレームを補正
                            const place = character.getPlace(moveFrame);
                            character.deletePlace(moveFrame);
                            character.setPlace(1, place);

                            // 開始位置の補正
                            character.startFrame = 1;
                        }

                        break;
                    }

                    const emptyCharacter = layer
                        .getActiveEmptyCharacter(frame);

                    if (emptyCharacter) {
                        emptyCharacter.startFrame = 1;
                        break;
                    }
                }
            } else {

                layer.addEmptyCharacter(new EmptyCharacter({
                    "startFrame": key_frame,
                    "endFrame": total_frame
                }));

            }
        }
    }

    /**
     * @description 複数のフレームを選択した時の一番若いフレーム番号を返す
     *
     * @return {number}
     * @method
     * @public
     */
    getFirstFrame ()
    {
        if (!Util.$timelineLayer.targetFrame) {
            return 1;
        }

        const frames = Util
            .$timelineLayer
            .targetFrames
            .values()
            .next()
            .value;

        let minFrame = Number.MAX_VALUE;
        for (let idx = 0; idx < frames.length; ++idx) {
            minFrame = Math.min(minFrame, frames[idx].dataset.frame | 0);
        }

        return minFrame;
    }
}

Util.$timelineTool = new TimelineTool();

/**
 * @class
 * @extends {InputEvent}
 */
class BaseScreen extends InputEvent
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super ();

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 共通初期イベント登録関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        Util.$initializeEnd();
    }

    /**
     * @description Elementのid名をキャメルケースに変換して関数を実行
     *              例) font-select => executeFontSelectがコールされる
     *
     * @param  {string} name
     * @return {void}
     * @method
     * @public
     */
    executeFunction (name)
    {
        // メニューを終了
        Util.$endMenu();

        const names = name.split("-");

        let functionName = names
            .map((value) =>
            {
                return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
            })
            .join("");

        this[`execute${functionName}`]();
    }
}

/**
 * @class
 * @extends {BaseScreen}
 */
class SceneChange extends BaseScreen
{
    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();
    }

    /**
     * @description リスト表示の再読み込み
     *
     * @param  {number} library_id
     * @return {void}
     * @method
     * @public
     */
    reload (library_id)
    {
        const scenes = document
            .getElementById("scene-name-menu-list");

        while (scenes.children.length) {
            scenes.children[0].remove();
        }

        // シーン名をリストに追加
        Util.$currentWorkSpace().root.addSceneName();

        // シーン移動
        Util.$sceneChange.execute(library_id);
    }

    /**
     * @description 指定のMovieClipを表示
     *
     * @param  {number} library_id
     * @return {void}
     * @method
     * @public
     */
    execute (library_id)
    {
        // 現在のプロジェクト
        const workSpace = Util.$currentWorkSpace();

        // ライブラリから指定のMovieClipを取得
        const scene = workSpace.getLibrary(library_id);
        const frame = scene.currentFrame;

        // 指定のMovieClipのフレーム
        Util.$timelineFrame.currentFrame = frame;

        // タイムラインのマーカーを移動
        Util.$timelineMarker.move();

        // 上部のタイムラインの位置を補正
        const base = document
            .getElementById("timeline-controller-base");

        // 表示画面の中心
        const moveX = (frame - 1) * (Util.$timelineTool.timelineWidth + 1);
        if (moveX > base.offsetWidth / 2) {
            Util
                .$timelineLayer
                .moveTimeLine(moveX - base.offsetWidth / 2);
        }

        workSpace.scene = scene;
    }
}

Util.$sceneChange = new SceneChange();

/**
 * @class
 */
class Screen extends BaseScreen
{
    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document.getElementById("screen");
        if (element) {

            element.addEventListener("contextmenu", (event) =>
            {
                Util.$screenMenu.show(event);
            });

            element.addEventListener("dragover", (event) =>
            {
                event.preventDefault();
            });

            element.addEventListener("drop", (event) =>
            {
                event.preventDefault();
                this.drop(event);
            });

            element.addEventListener("mousedown", (event) =>
            {
                if (event.button) {
                    return ;
                }

                Util.$canCopyLayer = false;

                Util.$endMenu();

                const activeTool = Util.$tools.activeTool;
                if (activeTool) {
                    event.screen = true;
                    activeTool.dispatchEvent(
                        EventType.MOUSE_DOWN,
                        event
                    );
                }
            });

            element.addEventListener("dblclick", (event) =>
            {
                const activeTool = Util.$tools.activeTool;
                if (activeTool) {
                    event.screen = true;
                    activeTool.dispatchEvent(
                        EventType.DBL_CLICK,
                        event
                    );
                }
            });

            element.addEventListener("mouseleave", (event) =>
            {
                const activeTool = Util.$tools.activeTool;
                if (activeTool) {
                    event.screen = true;
                    activeTool.dispatchEvent(
                        EventType.MOUSE_LEAVE,
                        event
                    );
                }

                document.getElementById("stage-rect").style.display = "none";
                document.getElementById("draw-rect").style.display  = "none";
                Util.$setCursor("auto");
            });

            element.addEventListener("mousewheel", (event) =>
            {
                if (event.ctrlKey && !event.metaKey // windows
                    || !event.ctrlKey && event.metaKey // mac
                ) {

                    const delta = event.deltaX || event.deltaY;
                    if (delta) {

                        event.preventDefault();

                        window.requestAnimationFrame(() => {
                            Util.$screenZoom.execute(delta / 100 * -1);
                        });
                    }

                    return false;

                }

            }, { "passive" : false });

            element.addEventListener("mousemove", (event) =>
            {
                const activeTool = Util.$tools.activeTool;
                if (activeTool) {
                    event.screen = true;
                    window.requestAnimationFrame(() =>
                    {
                        activeTool.dispatchEvent(
                            EventType.MOUSE_MOVE,
                            event
                        );
                    });
                }
            });

            element.addEventListener("mouseup", (event) =>
            {
                const activeTool = Util.$tools.activeTool;
                if (activeTool) {
                    event.screen = true;
                    activeTool.dispatchEvent(
                        EventType.MOUSE_UP,
                        event
                    );
                }
            });
        }
    }

    /**
     * @description ライブラリからのドロップ処理
     *
     * @param  {DragEvent} event
     * @return {void}
     * @method
     * @public
     */
    drop (event)
    {
        const activeInstances = Util
            .$libraryController
            .activeInstances;

        if (!activeInstances.size) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        // レイヤーをアタッチ
        Util.$timelineLayer.attachLayer();
        const targetLayer = Util.$timelineLayer.targetLayer;

        // ロックレイヤーならスキップ
        const layerId = targetLayer.dataset.layerId | 0;
        const layer = scene.getLayer(layerId);
        if (layer.lock) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;

        this.save();

        // 選択したアイテムを指定レイヤーに登録
        const soundIds    = [];
        const instanceIds = [];
        for (const libraryId of activeInstances.keys()) {

            const instance = workSpace.getLibrary(libraryId);
            if (!instance || instance.id === scene.id) {
                continue;
            }

            switch (instance.type) {

                case "sound":
                    soundIds.push(libraryId);
                    break;

                case "folder":
                    instance.getInstanceIds(instanceIds);
                    break;

                default:
                    instanceIds.push(libraryId);
                    break;

            }

        }

        // サウンドを登録
        if (soundIds.length) {

            if (!scene.hasSound(frame)) {
                scene.setSound(frame, []);
            }

            const sounds = scene.getSound(frame);
            for (let idx = 0; idx < soundIds.length; ++idx) {

                const instance = workSpace.getLibrary(soundIds[idx]);

                sounds.push({
                    "characterId": instance.id,
                    "name":        instance.name,
                    "volume":      100,
                    "autoPlay":    false,
                    "loopCount":   0
                });

            }

            // 表示を更新
            Util.$soundController.setIcon(frame);
            Util.$soundController.createSoundElements();
        }

        // tweenが設定されて入れば終了
        const activeCharacter = layer.getActiveCharacter(frame);
        if (activeCharacter.length) {
            const character = activeCharacter[0];
            const range = character.getRange(frame);
            if (character.hasTween(range.startFrame)) {
                return ;
            }
        }

        // 座標
        const x = event.offsetX - Util.$offsetLeft;
        const y = event.offsetY - Util.$offsetTop;

        // スクリーンにアイテムを配置
        const location   = layer.adjustmentLocation(frame);
        const endFrame   = location.endFrame;
        const startFrame = location.startFrame;
        for (let idx = 0; idx < instanceIds.length; ++idx) {

            const libraryId = instanceIds[idx];

            // 前か後ろに同じDisplayObjectがあれば統合する
            const join = {
                "start": null,
                "end": null
            };

            // レイヤー内のDisplayObjectをチェック
            const characters = layer._$characters;
            for (let idx = 0; idx < characters.length; ++idx) {

                const character = characters[idx];
                if (character.libraryId !== libraryId) {
                    continue;
                }

                switch (true) {

                    case startFrame > 1 && character.endFrame === startFrame:
                        join.start = character;
                        break;

                    case character.startFrame === endFrame:
                        join.end = character;
                        break;

                }
            }

            const instance = workSpace.getLibrary(libraryId);
            const place = {
                "frame": location.startFrame,
                "matrix": [1, 0, 0, 1, x / Util.$zoomScale, y / Util.$zoomScale],
                "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                "blendMode": "normal",
                "filter": [],
                "depth": layer._$characters.length
            };

            // MovieClipの場合はループ設定
            if (instance.type === "container") {
                place.loop = Util.$getDefaultLoopConfig();
            }

            let character = null;
            if (join.start) {
                character = join.start;
                character.endFrame = endFrame;
            }

            if (join.end) {

                if (character) {

                    character.endFrame = join.end.endFrame;

                    for (let [frame, place] of join.end._$places) {
                        character.setPlace(frame, place);
                    }

                    for (let [frame, tween] of join.end._$tween) {
                        character.setTween(frame, tween);
                    }

                    layer.deleteCharacter(join.end.id);

                } else {

                    character = join.end;
                    character.startFrame = startFrame;

                }
            }

            // new character
            if (!character) {

                character = new Character();
                character.libraryId  = libraryId;
                character.startFrame = startFrame;
                character.endFrame   = endFrame;
                character.setPlace(startFrame, place);

                // added
                layer.addCharacter(character);

            } else {

                // add place
                character.setPlace(startFrame, place);

            }

            // ドロップ位置補正
            let dx = 0;
            let dy = 0;
            if (instance.type === "container") {
                const bounds = instance.getBounds([1, 0, 0, 1, 0, 0]);
                dx = bounds.xMin;
                dy = bounds.yMin;
            }

            let width = character.width;
            if (!width) {
                width = 10;
            }

            let height = character.height;
            if (!height) {
                height = 10;
            }

            dx += width  / 2;
            dy += height / 2;

            place.matrix[4] -= dx;
            place.matrix[5] -= dy;
        }

        // タイムラインの表示を再計算
        layer.reloadStyle();

        // 描画リセット
        if (instanceIds.length) {
            this.reloadScreen();
        }

        // 初期化
        this._$saved = false;
    }

    /**
     * @description オニオンスライス起動時に前後のフレームのDisplayObjectを半透明で配置
     *
     * @param  {Character} character
     * @param  {number} layer_id
     * @return {void}
     * @method
     * @public
     */
    appendOnionCharacter (character, layer_id)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        // create image
        const image           = character.getImage();
        const cloneImage      = image.cloneNode(true);
        cloneImage.width      = image._$width  * Util.$zoomScale;
        cloneImage.height     = image._$height * Util.$zoomScale;
        cloneImage.style.left = `${character.offsetX}px`;
        cloneImage.style.top  = `${character.offsetY}px`;

        // create div
        const div = document.createElement("div");

        div.dataset.child   = "true";
        div.dataset.preview = "true";
        div.appendChild(cloneImage);

        // mask attach
        const layer = scene.getLayer(layer_id);
        if (layer.maskId !== null) {

            const maskLayer = scene.getLayer(layer.maskId);
            if (!maskLayer) {
                layer.maskId = null;
            }

            if (maskLayer && maskLayer.lock && maskLayer._$characters.length) {

                const maskCharacter = maskLayer._$characters[0];
                const maskImage     = maskCharacter.image;

                const x = maskCharacter.screenX - character.screenX;
                const y = maskCharacter.screenY - character.screenY;

                div.style.mask         = `url(${maskImage.src}), none`;
                div.style.maskSize     = `${maskImage.width}px ${maskImage.height}px`;
                div.style.maskRepeat   = "no-repeat";
                div.style.maskPosition = `${x}px ${y}px`;
                div.style.mixBlendMode = image.style.mixBlendMode;
                div.style.filter       = image.style.filter;

            } else {

                div.style.mask         = "";
                div.style.maskSize     = "";
                div.style.maskRepeat   = "";
                div.style.maskPosition = "";
                div.style.mixBlendMode = "";
                div.style.filter       = "";

            }
        }

        div.style.position      = "absolute";
        div.style.left          = `${Util.$offsetLeft + character.screenX * Util.$zoomScale}px`;
        div.style.top           = `${Util.$offsetTop  + character.screenY * Util.$zoomScale}px`;
        div.style.pointerEvents = "none";
        div.style.opacity       = "0.25";

        document
            .getElementById("stage-area")
            .appendChild(div);
    }

    /**
     * @description 現在のフレームに配置されたDisplayObjectを配置
     *
     * @param  {Character} character
     * @param  {number}    frame
     * @param  {number}    layer_id
     * @param  {string}    [event="auto"]
     * @return {void}
     * @method
     * @public
     */
    appendCharacter (character, frame, layer_id, event = "auto")
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        // setup
        const place    = character.getPlace(frame);
        const instance = workSpace.getLibrary(character.libraryId);

        let doUpdate = character.libraryId === Util.$changeLibraryId;
        switch (instance.type) {

            case "container":
                if (instance.totalFrame > 1 && character._$currentFrame !== frame) {
                    doUpdate = true;
                    character._$currentFrame = frame;
                }
                break;

            case "video":
                if (character._$currentFrame !== frame) {
                    doUpdate = true;
                    character._$currentFrame = frame;
                }
                break;

            default:
                break;

        }

        if (place !== character._$currentPlace) {

            if (character._$currentPlace) {

                // check matrix
                const nextMatrix    = place.matrix;
                const currentMatrix = character._$currentPlace.matrix;
                switch (true) {

                    case nextMatrix[0] !== currentMatrix[0]:
                    case nextMatrix[1] !== currentMatrix[1]:
                    case nextMatrix[2] !== currentMatrix[2]:
                    case nextMatrix[3] !== currentMatrix[3]:
                        doUpdate = true;
                        break;

                    default:
                        character._$screenX += -currentMatrix[4] + nextMatrix[4];
                        character._$screenY += -currentMatrix[5] + nextMatrix[5];
                        break;
                }

                // check color transform
                if (!doUpdate) {
                    const nextColorTransform    = place.colorTransform;
                    const currentColorTransform = character._$currentPlace.colorTransform;
                    switch (true) {

                        case nextColorTransform[0] !== currentColorTransform[0]:
                        case nextColorTransform[1] !== currentColorTransform[1]:
                        case nextColorTransform[2] !== currentColorTransform[2]:
                        case nextColorTransform[3] !== currentColorTransform[3]:
                        case nextColorTransform[4] !== currentColorTransform[4]:
                        case nextColorTransform[5] !== currentColorTransform[5]:
                        case nextColorTransform[6] !== currentColorTransform[6]:
                        case nextColorTransform[7] !== currentColorTransform[7]:
                            doUpdate = true;
                            break;

                        default:
                            break;
                    }
                }

                // check blend mode
                if (!doUpdate
                    && place.blendMode !== character._$currentPlace.blendMode
                ) {
                    doUpdate = true;
                }

                // check filter
                if (!doUpdate) {

                    if (character._$currentPlace.filter.length !== place.filter.length) {
                        doUpdate = true;
                    }

                    if (!doUpdate) {

                        for (let idx = 0; idx < place.filter.length; ++idx) {

                            const nextFilter    = place.filter[idx];
                            const currentFilter = character._$currentPlace[idx];

                            if (!nextFilter || !currentFilter) {
                                doUpdate = true;
                                break;
                            }

                            if (currentFilter.constructor !== nextFilter.constructor) {
                                doUpdate = true;
                                break;
                            }

                            if (!currentFilter.isSame(nextFilter)) {
                                doUpdate = true;
                                break;
                            }

                        }
                    }
                }
            }

            // update
            character._$currentPlace = place;
        }

        // cache delete
        if (doUpdate) {
            character._$image = null;
        }

        const div = document.createElement("div");

        // Imageを取得してdivに追加
        const image = character.getImage();
        div.appendChild(image);

        document
            .getElementById("stage-area")
            .appendChild(div);

        div.id = `character-${character.id}`;
        div.dataset.characterId  = `${character.id}`;
        div.dataset.layerId      = `${layer_id}`;
        div.dataset.instanceType = instance.type;
        div.dataset.libraryId    = `${character.libraryId}`;
        div.dataset.child        = "true";
        div.dataset.pointer      = `${event}`;

        div.classList.add("display-object");

        let divStyle = "";
        divStyle += `pointer-events: ${event};`;

        div.addEventListener("mouseover", (event) =>
        {
            // 親のイベントを中止する
            event.stopPropagation();

            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                event.displayObject = true;
                activeTool.dispatchEvent(
                    EventType.MOUSE_OVER,
                    event
                );
            }
        });

        div.addEventListener("mouseout", (event) =>
        {
            // 親のイベントを中止する
            event.stopPropagation();

            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                event.displayObject = true;
                activeTool.dispatchEvent(
                    EventType.MOUSE_OUT,
                    event
                );
            }
        });

        div.addEventListener("mousedown", (event) =>
        {
            if (event.button) {
                return ;
            }

            // 親のイベントを中止する
            event.stopPropagation();

            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                event.displayObject = true;
                activeTool.dispatchEvent(
                    EventType.MOUSE_DOWN,
                    event
                );
            }
        });

        let width = character.width * Util.$zoomScale;
        if (!width) {
            width = 10;
        }

        let height = character.height * Util.$zoomScale;
        if (!height) {
            height = 10;
        }

        divStyle += `width: ${Math.ceil(width)}px;`;
        divStyle += `height: ${Math.ceil(height)}px;`;

        const range  = character.getRange(frame);
        const bounds = character.getBounds(place.matrix, place, range);

        let tx = Util.$offsetLeft + bounds.xMin * Util.$zoomScale;
        let ty = Util.$offsetTop  + bounds.yMin * Util.$zoomScale;
        divStyle += `left: ${tx}px;`;
        divStyle += `top: ${ty}px;`;

        image.width      = image._$width  * Util.$zoomScale;
        image.height     = image._$height * Util.$zoomScale;
        image.style.left = `${character.offsetX * Util.$zoomScale}px`;
        image.style.top  = `${character.offsetY * Util.$zoomScale}px`;

        // mask attach
        const layer = scene.getLayer(layer_id);
        if (layer.maskId !== null) {

            const maskLayer = scene.getLayer(layer.maskId);
            if (!maskLayer) {
                layer.maskId = null;
            }

            if (maskLayer && maskLayer.lock && maskLayer._$characters.length) {

                const maskCharacter = maskLayer._$characters[0];
                const maskImage     = maskCharacter.getImage();

                const x = maskCharacter.screenX - character.screenX;
                const y = maskCharacter.screenY - character.screenY;

                const maskSrc    = maskImage.src;
                const maskWidth  = maskImage.width;
                const maskHeight = maskImage.height;

                divStyle += `mask: url(${maskSrc}), none;`;
                divStyle += `-webkit-mask: url(${maskSrc}), none;`;
                divStyle += `mask-size: ${maskWidth}px ${maskHeight}px;`;
                divStyle += `-webkit-mask-size: ${maskWidth}px ${maskHeight}px;`;
                divStyle += "mask-repeat: no-repeat;";
                divStyle += "-webkit-mask-repeat: no-repeat;";
                divStyle += `mask-position: ${x}px ${y}px;`;
                divStyle += `-webkit-mask-position: ${x}px ${y}px;`;
                divStyle += `mix-blend-mode: ${image.style.mixBlendMode};`;
                divStyle += `filter: ${image.style.filter};`;

            }
        }

        div.setAttribute("style", divStyle);
        switch (instance._$type) {

            case "container":
                div.addEventListener("dblclick", (event) =>
                {
                    // 親のイベントを中止する
                    event.stopPropagation();

                    // シーン名をリストに追加
                    Util.$currentWorkSpace().scene.addSceneName();

                    // シーン移動
                    Util.$sceneChange.execute(
                        event.currentTarget.dataset.libraryId | 0
                    );
                });
                break;

            case "text":
                {
                    const borderDiv = document.createElement("div");

                    borderDiv.style.width  = `${width  - 2}px`;
                    borderDiv.style.height = `${height - 2}px`;
                    borderDiv.style.pointerEvents = "none";

                    borderDiv.style.position = "absolute";
                    borderDiv.style.left     = "0px";
                    borderDiv.style.top      = "0px";

                    borderDiv.style.border = instance._$border
                        ? "1px solid gray"
                        : "1px dashed gray";

                    div.appendChild(borderDiv);

                    div.addEventListener("dblclick", (event) =>
                    {
                        // 親のイベントを中止する
                        event.stopPropagation();

                        // ツールをリセット
                        Util.$tools.reset();

                        const children = document
                            .getElementById("stage-area")
                            .children;

                        for (let idx = 0; idx < children.length; ++idx) {

                            const node = children[idx];
                            node.style.pointerEvents = "none";

                        }

                        const element = event.currentTarget;
                        element.style.pointerEvents = "";

                        const image = element.firstChild;
                        image.remove();

                        const textarea = window.document.createElement("textarea");
                        element.style.display = "none";
                        element.parentNode.appendChild(textarea);

                        const scene       = Util.$currentWorkSpace().scene;
                        const layerId     = element.dataset.layerId | 0;
                        const layer       = scene.getLayer(layerId);
                        const characterId = element.dataset.characterId | 0;
                        const character   = layer.getCharacter(characterId);
                        const instance    = workSpace.getLibrary(character.libraryId);

                        textarea.value = instance._$text;

                        textarea.style.border = instance._$border
                            ? "1px solid gray"
                            : "1px dashed gray";

                        textarea.style.fontSize      = `${instance._$size}px`;
                        textarea.style.fontFamily    = instance._$font;
                        textarea.style.width         = `${image.width - 4}px`;
                        textarea.style.height        = `${image.height}px`;
                        textarea.style.position      = "absolute";
                        textarea.style.left          = element.style.left;
                        textarea.style.top           = element.style.top;
                        textarea.style.pointerEvents = "auto";

                        if (!instance._$border) {
                            textarea.style.backgroundColor = "transparent";
                        }

                        // set params
                        textarea.dataset.characterId = `${character.id}`;
                        textarea.dataset.layerId     = `${layer_id}`;
                        textarea.dataset.libraryId   = `${character.libraryId}`;
                        textarea.dataset.child       = "true";

                        if (!instance._$multiline) {
                            textarea.addEventListener("keydown", (event) =>
                            {
                                if (event.key === "Enter") {
                                    event.preventDefault();
                                    return false;
                                }
                            });
                        }

                        textarea.addEventListener("focusin", () =>
                        {
                            Util.$keyLock = true;
                        });

                        textarea.addEventListener("focusout", (event) =>
                        {
                            const element     = event.target;
                            const scene       = Util.$currentWorkSpace().scene;
                            const layerId     = element.dataset.layerId | 0;
                            const layer       = scene.getLayer(layerId);
                            const characterId = element.dataset.characterId | 0;
                            const character   = layer.getCharacter(characterId);
                            const instance    = workSpace.getLibrary(character.libraryId);

                            // update
                            instance._$text = element.value;

                            // clear
                            character._$image = null;
                            Util.$keyLock     = false;

                            const children = document
                                .getElementById("stage-area")
                                .children;

                            for (let idx = 0; idx < children.length; ++idx) {
                                const node = children[idx];
                                node.style.pointerEvents = "";
                            }

                            const frame = Util.$timelineFrame.currentFrame;
                            scene.changeFrame(frame);

                        });

                        textarea.focus();

                    });
                }
                break;

        }
    }
}

Util.$screen = new Screen();

/**
 * @class
 * @extends {KeyboardCommand}
 */
class ScreenKeyboardCommand extends KeyboardCommand
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("screen");

        /**
         * @type {string}
         * @default "close"
         * @private
         */
        this._$state = "close";

        /**
         * @type {CommonTool}
         * @default null
         * @private
         */
        this._$prevTool = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$activeTool = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endHandTool = null;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document
            .getElementById("screen");

        if (element) {

            element.addEventListener("mouseleave", () =>
            {
                this.active = false;
            });

            element.addEventListener("mouseover", () =>
            {
                if (!this.active) {
                    this.active = true;
                }
            });
        }

        this._$endHandTool = this.endHandTool.bind(this);

        // ハンドツール
        this.add(" ", this.startHandTool.bind(this));

        // 初期のショートカット
        const keys = [
            "v", // arrow
            "a", // Shape Transform
            "p", // Pen
            "t", // Text
            "k", // Bucket
            "o", // Circle
            "r", // Rectangle
            "z"  // Zoom
        ];
        this._$activeTool = this.activeTool.bind(this);
        for (let idx = 0; idx < keys.length; ++idx) {
            this.add(keys[idx], this._$activeTool);
        }

        this.add(
            Util.$generateShortcutKey("r", { "shift": true }),
            this._$activeTool
        );

        // ユーザー設定
        this.add("s", this.userSetting.bind(this));

        // 指定したDisplayObjectを移動
        const arrows = [
            "ArrowRight",
            "ArrowLeft",
            "ArrowUp",
            "ArrowDown"
        ];

        for (let idx = 0; idx < arrows.length; ++idx) {
            const key = arrows[idx];
            this.add(key, this.executeMoveDisplayObject);
            this.add(
                Util.$generateShortcutKey(key, { "shift": true }),
                this.executeMoveDisplayObject
            );
        }

        // プロジェクトファイルを読み込む
        this.add(Util.$generateShortcutKey("r", { "ctrl": true }), () =>
        {
            Util.$shiftKey = false;
            Util.$ctrlKey  = false;
            Util.$altKey   = false;
            Util.$project.open();
        });

        // プロジェクトデータを書き出し
        this.add(
            Util.$generateShortcutKey("s", { "ctrl": true, "shift": true }),
            Util.$project.save
        );

        // 選択中のDisplayObjectを削除
        this.add("Backspace", this.deleteDisplayObject);

        // 選択中のtweenのカーブポインターを削除
        this.add(
            Util.$generateShortcutKey("p", { "ctrl": true, "shift": true }),
            this.deleteTweenCurvePointer
        );

        // 最前面
        this.add(
            Util.$generateShortcutKey("ArrowUp", { "ctrl": true, "shift": true }),
            this.screenFront
        );

        // ひとつ前面へ
        this.add(
            Util.$generateShortcutKey("ArrowUp", { "ctrl": true }),
            this.screenFrontOne
        );

        // 最背面
        this.add(
            Util.$generateShortcutKey("ArrowDown", { "ctrl": true, "shift": true }),
            this.screenBack
        );

        // ひとつ背面へ
        this.add(
            Util.$generateShortcutKey("ArrowDown", { "ctrl": true }),
            this.screenBackOne
        );

        // 左揃え
        this.add("1", this.screenPositionLeft);

        // ステージ基準の左揃え
        this.add(
            Util.$generateShortcutKey("!", { "shift": true }),
            this.stagePositionLeft
        );

        // 中央揃え(水平方向)
        this.add("2", this.screenPositionCenter);

        // ステージ基準の中央揃え(水平方向)
        this.add(
            Util.$generateShortcutKey("\"", { "shift": true }),
            this.stagePositionCenter
        );

        // 右揃え
        this.add("3", this.screenPositionRight);

        // ステージ基準の右揃え
        this.add(
            Util.$generateShortcutKey("#", { "shift": true }),
            this.stagePositionRight
        );

        // 上揃え
        this.add("4", this.screenPositionTop);

        // ステージ基準の上揃え
        this.add(
            Util.$generateShortcutKey("$", { "shift": true }),
            this.stagePositionTop
        );

        // 中央揃え(垂直方向)
        this.add("5", this.screenPositionMiddle);

        // ステージ基準の中央揃え(垂直方向)
        this.add(
            Util.$generateShortcutKey("%", { "shift": true }),
            this.stagePositionMiddle
        );

        // 下揃え
        this.add("6", this.screenPositionBottom);

        // ステージ基準の下揃え
        this.add(
            Util.$generateShortcutKey("&", { "shift": true }),
            this.stagePositionBottom
        );

        // レイヤーに配分
        this.add(
            Util.$generateShortcutKey("d", { "ctrl": true }),
            this.distributeToLayers
        );

        // キーフレームに配分
        this.add(
            Util.$generateShortcutKey("k", { "ctrl": true }),
            this.distributeToKeyframes
        );

        // Shapeの結合
        this.add(
            Util.$generateShortcutKey("i", { "ctrl": true }),
            this.integratingPaths
        );

        // カーブポインターを追加
        this.add(Util.$generateShortcutKey("p", { "ctrl": true }), () =>
        {
            Util.$tweenController.addCurvePinter();
        });

        // MovieClipに変換
        this.add(Util.$generateShortcutKey("m", { "shift": true }), () =>
        {
            Util.$screenMenu.executeScreenChangeMovieClip();
        });
    }

    /**
     * @description 選択したShapeのパスを結合
     *
     * @return {void}
     * @method
     * @public
     */
    integratingPaths ()
    {
        Util
            .$screenMenu
            .executeScreenIntegratingPaths();
    }

    /**
     * @description 選択したDisplayObjectをキーフレームに配分
     *
     * @return {void}
     * @method
     * @public
     */
    distributeToKeyframes ()
    {
        Util
            .$screenMenu
            .executeScreenDistributeToKeyframes();
    }

    /**
     * @description 選択したDisplayObjectをレイヤーに配分
     *
     * @return {void}
     * @method
     * @public
     */
    distributeToLayers ()
    {
        Util
            .$screenMenu
            .executeScreenDistributeToLayers();
    }

    /**
     * @description 選択中のDisplayObjectの矩形内で下揃え
     *
     * @return {void}
     * @method
     * @public
     */
    screenPositionBottom ()
    {
        Util.$screenMenu.alignment("bottom");
    }

    /**
     * @description 選択中のDisplayObjectのステージ基準で下揃え
     *
     * @return {void}
     * @method
     * @public
     */
    stagePositionBottom ()
    {
        Util.$screenMenu.alignment("bottom", "stage");
    }

    /**
     * @description 選択中のDisplayObjectの矩形内で中央揃え(垂直方向)
     *
     * @return {void}
     * @method
     * @public
     */
    screenPositionMiddle ()
    {
        Util.$screenMenu.alignment("middle");
    }

    /**
     * @description 選択中のDisplayObjectのステージ基準で中央揃え(垂直方向)
     *
     * @return {void}
     * @method
     * @public
     */
    stagePositionMiddle ()
    {
        Util.$screenMenu.alignment("middle", "stage");
    }

    /**
     * @description 選択中のDisplayObjectの矩形内で上揃え
     *
     * @return {void}
     * @method
     * @public
     */
    screenPositionTop ()
    {
        Util.$screenMenu.alignment("top");
    }

    /**
     * @description 選択中のDisplayObjectのステージ基準で上揃え
     *
     * @return {void}
     * @method
     * @public
     */
    stagePositionTop ()
    {
        Util.$screenMenu.alignment("top", "stage");
    }

    /**
     * @description 選択中のDisplayObjectの矩形内の左側に揃える
     *
     * @return {void}
     * @method
     * @public
     */
    screenPositionCenter ()
    {
        Util.$screenMenu.alignment("center");
    }

    /**
     * @description 選択中のDisplayObjectのステージ基準で左側に揃える
     *
     * @return {void}
     * @method
     * @public
     */
    stagePositionCenter ()
    {
        Util.$screenMenu.alignment("center", "stage");
    }

    /**
     * @description 選択中のDisplayObjectのステージ基準で左側に揃える
     *
     * @return {void}
     * @method
     * @public
     */
    stagePositionRight ()
    {
        Util.$screenMenu.alignment("right", "stage");
    }

    /**
     * @description 選択中のDisplayObjectの矩形内の左側に揃える
     *
     * @return {void}
     * @method
     * @public
     */
    screenPositionRight ()
    {
        Util.$screenMenu.alignment("right");
    }

    /**
     * @description 選択中のDisplayObjectのステージ基準で左側に揃える
     *
     * @return {void}
     * @method
     * @public
     */
    stagePositionLeft ()
    {
        Util.$screenMenu.alignment("left", "stage");
    }

    /**
     * @description 選択中のDisplayObjectの矩形内の左側に揃える
     *
     * @return {void}
     * @method
     * @public
     */
    screenPositionLeft ()
    {
        Util.$screenMenu.alignment("left");
    }

    /**
     * @description 選択中のDisplayObjectを最背面へ移動
     *
     * @return {void}
     * @method
     * @public
     */
    screenBack ()
    {
        Util.$screenMenu.changeDepth("down");
    }

    /**
     * @description 選択中のDisplayObjectをひとつ背面へ移動
     *
     * @return {void}
     * @method
     * @public
     */
    screenBackOne ()
    {
        Util.$screenMenu.changeDepthOne("down");
    }

    /**
     * @description 選択中のDisplayObjectを最前面へ移動
     *
     * @return {void}
     * @method
     * @public
     */
    screenFront ()
    {
        Util.$screenMenu.changeDepth("up");
    }

    /**
     * @description 選択中のDisplayObjectをひとつ前面へ移動
     *
     * @return {void}
     * @method
     * @public
     */
    screenFrontOne ()
    {
        Util.$screenMenu.changeDepthOne("up");
    }

    /**
     * @description 選択中のDisplayObjectを削除
     *
     * @return {void}
     * @method
     * @public
     */
    deleteTweenCurvePointer ()
    {
        Util.$tweenController.deleteCurvePointer();
    }

    /**
     * @description 選択中のDisplayObjectを削除
     *
     * @return {void}
     * @method
     * @public
     */
    deleteDisplayObject ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.deleteDisplayObject();
    }

    /**
     * @description ユーザー設定画面を表示
     *
     * @return {void}
     * @method
     * @public
     */
    userSetting ()
    {
        const element = document
            .getElementById("user-setting");

        if (this._$state === "show"
            || element.classList.contains("fadeIn")
        ) {

            this._$state = "close";
            Util.$endMenu();

        } else {

            this._$state = "show";
            Util.$userSetting.show();

        }

    }

    /**
     * @description アローツールをアクティブに
     *
     * @param  {string} code
     * @return {void}
     * @method
     * @public
     */
    activeTool (code)
    {
        let name = "";
        switch (code) {

            case "v":
                name = "arrow";
                break;

            case "a":
                name = "transform";
                break;

            case "p":
                name = "pen";
                break;

            case "t":
                name = "text";
                break;

            case "z":
                name = "zoom";
                break;

            case "k":
                name = "bucket";
                break;

            case "r":
                name = "rectangle";
                break;

            case "o":
                name = "circle";
                break;

            case "rShift":
                name = "round-rect";
                break;

            default:
                break;

        }

        if (name) {
            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                activeTool.dispatchEvent(EventType.END);
            }

            const tool = Util.$tools.getDefaultTool(name);
            tool.dispatchEvent(EventType.START);
            Util.$tools.activeTool = tool;
        }

    }

    /**
     * @description ハンドツールを起動
     *
     * @return {void}
     * @method
     * @public
     */
    startHandTool ()
    {
        if (Util.$tools.activeTool.name === "hand") {
            return ;
        }

        // 直前のツールをキャッシュ
        this._$prevTool = Util.$tools.activeTool;
        if (this._$prevTool) {
            this._$prevTool.dispatchEvent(EventType.END);
        }

        // ハンドツールを起動
        const tool = Util.$tools.getDefaultTool("hand");
        tool.dispatchEvent(EventType.START);
        Util.$tools.activeTool = tool;

        // 選択ツールを中止
        Util.$tools.getDefaultTool("arrow").endRect();

        // 終了イベントを設定
        window.addEventListener("keyup", this._$endHandTool);
    }

    /**
     * @description ハンドツールを終了
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    endHandTool (event)
    {
        if (event.key !== " ") {
            return ;
        }

        // イベントを削除
        window.removeEventListener("keyup", this._$endHandTool);

        const tool = Util.$tools.getDefaultTool("hand");
        tool.dispatchEvent(EventType.END);

        if (this._$prevTool) {

            // 前のツールに戻す
            this._$prevTool.dispatchEvent(EventType.START);
            Util.$tools.activeTool = this._$prevTool;

            // 初期化
            this._$prevTool = null;

        } else {

            Util.$tools.reset();

        }
    }

    /**
     * @description 右に移動
     *
     * @param  {string} code
     * @return {void}
     * @method
     * @public
     */
    executeMoveDisplayObject (code)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        if (!tool.activeElements.length) {
            return ;
        }

        switch (code) {

            case "ArrowRight":
            case "ArrowRightShift":
                tool.pageX = Util.$shiftKey ? 10 : 1;
                tool.pageY = 0;
                break;

            case "ArrowLeft":
            case "ArrowLeftShift":
                tool.pageX = Util.$shiftKey ? -10 : -1;
                tool.pageY = 0;
                break;

            case "ArrowUp":
            case "ArrowUpShift":
                tool.pageX = 0;
                tool.pageY = Util.$shiftKey ? -10 : -1;
                break;

            case "ArrowDown":
            case "ArrowDownShift":
                tool.pageX = 0;
                tool.pageY = Util.$shiftKey ? 10 : 1;
                break;

            default:
                return;

        }

        tool.moveDisplayObject();
        tool._$saved = false;
    }
}

Util.$screenKeyboardCommand = new ScreenKeyboardCommand();

/**
 * @class
 */
class ScreenMenu extends BaseScreen
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @description 表示非表示の状態変数、初期値は非表示
         * @type {string}
         * @default "hide"
         * @private
         */
        this._$state = "hide";
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "screen-front",
            "screen-front-one",
            "screen-back-one",
            "screen-back",
            "screen-position-left",
            "screen-position-right",
            "screen-position-center",
            "screen-position-top",
            "screen-position-middle",
            "screen-position-bottom",
            "stage-position-left",
            "stage-position-right",
            "stage-position-center",
            "stage-position-top",
            "stage-position-middle",
            "stage-position-bottom",
            "screen-distribute-to-layers",
            "screen-distribute-to-keyframes",
            "screen-integrating-paths",
            "screen-add-tween-curve-pointer",
            "screen-delete-tween-curve-pointer",
            "screen-change-movie-clip",
            "screen-preview"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document
                .getElementById(elementIds[idx]);

            if (!element) {
                continue;
            }

            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event.target.id);
            });
        }
    }

    /**
     * @description Playerでのプレビュー
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPreview ()
    {
        Util.$showPreview();
    }

    /**
     * @description 選択したDisplayObjectをレイヤーに分割
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenDistributeToLayers ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        this.save();

        const characters = [];

        const frame  = Util.$timelineFrame.currentFrame;
        const layers = new Map();
        const scene  = Util.$currentWorkSpace().scene;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];

            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            if (!layer) {
                continue;
            }

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            if (!character) {
                continue;
            }

            const range = character.getRange(frame);
            if (!layers.has(layer.id)) {
                layers.set(layer.id, {
                    "layer": layer,
                    "range": range
                });
            }

            // キーフレーム情報をキャッシュ
            const place = character.getPlace(range.startFrame);
            place.depth = 0;

            characters.push({
                "libraryId": character.libraryId,
                "place": place,
                "startFrame": range.startFrame,
                "endFrame": range.endFrame
            });

            // 現在のレイヤーから削除
            character.remove(layer);
        }

        // タイムラインを再構成
        for (const object of layers.values()) {

            const layer = object.layer;
            const range = object.range;

            const characters = layer.getActiveCharacter(range.startFrame);
            if (characters.length) {

                // 深度順に並び替え
                layer.sort(characters, frame);

                for (let idx = 0; idx < characters.length; ++idx) {
                    characters[idx].getPlace(frame).depth = idx;
                }

            } else {

                layer.addEmptyCharacter(
                    new EmptyCharacter({
                        "startFrame": range.startFrame,
                        "endFrame": range.endFrame
                    })
                );

            }

            layer.reloadStyle();
        }

        // 選択をクリア
        Util.$timelineLayer.clear();

        // 複数選択準備
        const ctrlKey = Util.$ctrlKey;
        Util.$ctrlKey = true;

        // レイヤーを追加して配置
        for (let idx = 0; idx < characters.length; ++idx) {

            const object = characters[idx];

            const character = new Character();
            character.libraryId  = object.libraryId;
            character.startFrame = object.startFrame;
            character.endFrame   = object.endFrame;
            character.setPlace(object.startFrame, object.place);

            const layer = new Layer();
            layer.addCharacter(character);

            if (object.startFrame > 1) {
                layer.addEmptyCharacter(new EmptyCharacter({
                    "startFrame": 1,
                    "endFrame": object.startFrame
                }));
            }

            // シーンに追加
            scene.addLayer(layer);

            // アクティブ設定
            Util.$timelineLayer.activeLayer(
                document.getElementById(`layer-id-${layer.id}`)
            );
        }

        // 再描画
        this.reloadScreen();

        // 選択の再計算
        Util.$timelineLayer.activeCharacter();

        // 初期化
        Util.$ctrlKey = ctrlKey;
        this._$saved  = false;
    }

    /**
     * @description 選択したDisplayObjectをキーフレームに分割
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenDistributeToKeyframes ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        this.save();

        const scene = Util.$currentWorkSpace().scene;

        let frame = Util.$timelineFrame.currentFrame;

        const layers = new Map();
        for (const element of activeElements.values()) {

            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            if (!layers.has(layer.id)) {
                layers.set(layer.id, {
                    "range": character.getRange(frame),
                    "characters": []
                });
            }

            layers
                .get(layer.id)
                .characters
                .push(character);
        }

        for (const [layerId, object] of layers) {

            let characters = object.characters;
            if (characters.length === 1) {
                continue;
            }

            const layer = scene.getLayer(layerId);
            const range = object.range;

            // フレームで配置されてるDisplayObject
            const activeCharacters = layer.getActiveCharacter(frame);

            const rangeFrame = range.endFrame - range.startFrame;
            switch (true) {

                // レイヤーに配置されたDisplayObjectの数と選択した数が一致しない場合は補正
                case characters.length !== activeCharacters.length:
                    {
                        const indexes = new Map();

                        // 指定フレームに配置されたDisplayObjectを分割
                        const splits = [];
                        for (let idx = 0; idx < activeCharacters.length; ++idx) {

                            const character = activeCharacters[idx];

                            const index = characters.indexOf(character);

                            const splitCharacter = character.split(layer,
                                range.startFrame, range.endFrame
                            );

                            if (index > -1) {
                                indexes.set(splitCharacter.id, index);
                            }

                            splits.push(splitCharacter);
                        }

                        // 後方のDisplayObjectを後方に移動
                        for (let idx = 0; idx < layer._$characters.length; ++idx) {

                            const character = layer._$characters[idx];

                            if (range.endFrame > character.endFrame) {
                                continue;
                            }

                            if (character.startFrame > range.startFrame) {

                                character.move(characters.length);

                            } else {

                                const places = new Map();
                                for (const [keyFrame, place] of character._$places) {

                                    if (keyFrame > range.startFrame) {
                                        place.frame = keyFrame + characters.length;
                                    }

                                    places.set(place.frame, place);

                                }

                                character._$places  = places;
                                character.endFrame += characters.length;
                            }
                        }

                        // 空のフレームも移動
                        for (let idx = 0; layer._$emptys.length > idx; ++idx) {

                            const emptyCharacter = layer._$emptys[idx];

                            if (range.startFrame > emptyCharacter.startFrame) {
                                continue;
                            }

                            emptyCharacter.move(characters.length);
                        }

                        // レンジ幅を後方に移動
                        frame = range.endFrame;
                        range.startFrame = range.endFrame;
                        range.endFrame  += characters.length;

                        // 分割したDisplayObjectを分割対象か配置を判定
                        const newCharacters = [];
                        for (let idx = 0; idx < splits.length; ++idx) {

                            const character = splits[idx];

                            // 分割対象なら移動して終了
                            if (indexes.has(character.id)) {

                                // キーフレームを移動
                                character.setPlace(
                                    range.startFrame,
                                    character.getPlace(character.startFrame)
                                );
                                character.deletePlace(character.startFrame);

                                // フレーム情報を更新
                                character.startFrame = range.startFrame;
                                character.endFrame   = range.endFrame;

                                // レイヤーに登録して配列へ格納
                                layer.addCharacter(character);
                                newCharacters.push(character);

                            } else {

                                // 分割対象外であれば、前方のDisplayObjectを結合
                                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                                    const child = layer._$characters[idx];

                                    if (child.libraryId !== character.libraryId) {
                                        continue;
                                    }

                                    if (child.endFrame !== character.startFrame) {
                                        continue;
                                    }

                                    for (const [keyFrame, place] of character._$places) {
                                        child.setPlace(keyFrame, place);
                                    }

                                    child.endFrame = character.endFrame;
                                    break;
                                }

                            }
                        }

                        // 対象配列を上書き
                        characters = newCharacters;
                    }
                    break;

                // フレーム数がレンジ幅以上の場合は、後方のフレームを後方へ移動
                case characters.length > rangeFrame:
                    {
                        const moveFrame  = characters.length - rangeFrame;

                        for (let idx = 0; layer._$characters.length > idx; ++idx) {

                            const character = layer._$characters[idx];
                            if (range.endFrame >= character.endFrame) {
                                continue;
                            }

                            if (character.startFrame > range.endFrame) {

                                // レンジ幅より先で開始する単独DisplayObjectは単純な横移動
                                character.move(moveFrame);

                            } else {

                                // 開始位置が前方で、終了位置が後方のDisplayObjectはレンジ幅の対象だけ移動
                                const places = new Map();
                                for (const [keyFrame, place] of character._$places) {

                                    if (keyFrame >= range.endFrame) {
                                        place.frame = keyFrame + moveFrame;
                                    }

                                    places.set(place.frame, place);

                                }

                                character._$places  = places;
                                character.endFrame += moveFrame;
                            }
                        }

                        // 空のフレームも移動
                        for (let idx = 0; layer._$emptys.length > idx; ++idx) {

                            const emptyCharacter = layer._$emptys[idx];
                            if (range.endFrame >= emptyCharacter.endFrame) {
                                continue;
                            }

                            emptyCharacter.move(moveFrame);
                        }

                        // レンジ幅も更新
                        range.endFrame += moveFrame;
                    }
                    break;

                // 分割するフレーム数がレンジ以下の場合は、後方のフレームを前方へ移動
                case rangeFrame > characters.length:
                    {
                        const moveFrame = rangeFrame - characters.length;

                        for (let idx = 0; layer._$characters.length > idx; ++idx) {

                            const character = layer._$characters[idx];
                            if (range.endFrame > character.endFrame) {
                                continue;
                            }

                            if (character.startFrame > range.endFrame) {

                                // レンジ幅より先で開始する単独DisplayObjectは単純な横移動
                                character.move(-moveFrame);

                            } else {

                                const places = new Map();
                                for (const [keyFrame, place] of character._$places) {

                                    if (keyFrame >= range.endFrame) {
                                        place.frame = keyFrame - moveFrame;
                                    }

                                    places.set(place.frame, place);

                                }

                                character._$places  = places;
                                character.endFrame -= moveFrame;
                            }

                        }

                        // 空のフレームも移動
                        for (let idx = 0; layer._$emptys.length > idx; ++idx) {

                            const emptyCharacter = layer._$emptys[idx];
                            if (range.startFrame > emptyCharacter.startFrame) {
                                continue;
                            }

                            emptyCharacter.move(-moveFrame);
                        }

                        // レンジ幅も更新
                        range.endFrame -= moveFrame;
                    }
                    break;

                default:
                    break;

            }

            // 昇順
            // eslint-disable-next-line no-loop-func
            characters.sort((a, b) =>
            {
                const aDepth = a.getPlace(frame).depth;
                const bDepth = b.getPlace(frame).depth;
                switch (true) {

                    case aDepth > bDepth:
                        return 1;

                    case aDepth < bDepth:
                        return -1;

                    default:
                        return 0;

                }
            });

            let keyFrame = range.startFrame;
            for (let idx = 0; idx < characters.length; ++idx) {

                let character = characters[idx];

                // キーフレームが複数ある場合は分割
                if (character._$places.size !== 1) {
                    character = character.split(
                        layer,
                        range.startFrame,
                        range.endFrame
                    );
                    layer.addCharacter(character);
                }

                const place = character.getPlace(frame);

                let end = false;
                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                    const child = layer._$characters[idx];

                    // 同一のobjectならスキップ
                    if (child.id === character.id) {
                        continue;
                    }

                    // 同一のアイテムでないならスキップ
                    if (child.libraryId !== character.libraryId) {
                        continue;
                    }

                    if (child.endFrame !== keyFrame) {
                        continue;
                    }

                    // 分割したDisplayObjectをレイヤーから削除
                    layer.deleteCharacter(character.id);

                    // 既存のDisplayObjectと連結
                    child.endFrame = keyFrame + 1;
                    child.setPlace(keyFrame, place);

                    end = true;
                    break;
                }

                // 前方に同一のDisplayObjectがあれば結合して終了
                if (end) {
                    keyFrame++;
                    continue;
                }

                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                    const child = layer._$characters[idx];

                    // 同一のobjectならスキップ
                    if (child.id === character.id) {
                        continue;
                    }

                    // 同一のアイテムでないならスキップ
                    if (child.libraryId !== character.libraryId) {
                        continue;
                    }

                    if (child.startFrame !== keyFrame + 1) {
                        continue;
                    }

                    // 分割したDisplayObjectをレイヤーから削除
                    layer.deleteCharacter(character.id);

                    // 既存のDisplayObjectと連結
                    child.startFrame = keyFrame;
                    child.setPlace(keyFrame, place);

                    end = true;
                    break;
                }

                // 後方に同一のDisplayObjectがあれば結合して終了
                if (end) {
                    keyFrame++;
                    continue;
                }

                // 前後方に同一のDisplayObjectがなければ自身の情報を上書き
                character.startFrame = keyFrame;
                character.endFrame   = keyFrame + 1;
                character.deletePlace(place.frame);
                character.setPlace(keyFrame, place);

                keyFrame++;
            }

            // タイムラインを再構成
            layer.reloadStyle();

            console.log(layer);
        }

        // 再描画
        this.reloadScreen();

        this._$saved = false;
    }

    /**
     * @description 選択したShapeのパスを統合
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenIntegratingPaths ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        this.save();

        const workSpace = Util.$currentWorkSpace();

        const scene = workSpace.scene;
        const frame = Util.$timelineFrame.currentFrame;

        let baseShape     = null;
        let baseCharacter = null;

        let index = 0;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];
            if (element.dataset.instanceType !== "shape") {
                continue;
            }

            const instance = workSpace.getLibrary(
                element.dataset.libraryId | 0
            );

            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            const { Graphics } = window.next2d.display;
            if (!baseShape) {

                baseCharacter = character;

                baseShape = instance;
                for (let idx = 0; baseShape._$recodes.length > idx;) {

                    switch (baseShape._$recodes[idx++]) {

                        case Graphics.BEGIN_PATH:
                            break;

                        case Graphics.MOVE_TO:
                            idx += 2;
                            break;

                        case Graphics.LINE_TO:
                            idx += 2;
                            break;

                        case Graphics.CURVE_TO:
                            idx += 4;
                            break;

                        case Graphics.CUBIC:
                            idx += 6;
                            break;

                        case Graphics.FILL_STYLE:
                        case Graphics.GRADIENT_FILL:
                        case Graphics.STROKE_STYLE:
                        case Graphics.GRADIENT_STROKE:
                            index = idx - 1;
                            break;

                        case Graphics.CLOSE_PATH:
                        case Graphics.END_STROKE:
                        case Graphics.END_FILL:
                            break;

                        default:
                            break;

                    }

                    if (index) {
                        break;
                    }
                }

                continue;
            }

            const tx = baseCharacter.screenX
                - baseShape._$bounds.xMin
                - character.screenX;

            const ty = baseCharacter.screenY
                - baseShape._$bounds.yMin
                - character.screenY;

            const matrix  = character.getPlace(frame).matrix;
            const recodes = [];

            let done = false;
            for (let idx = 0; instance._$recodes.length > idx;) {

                switch (instance._$recodes[idx++]) {

                    case Graphics.BEGIN_PATH:
                        break;

                    case Graphics.MOVE_TO:
                        {
                            const x = instance._$recodes[idx++];
                            const y = instance._$recodes[idx++];
                            recodes.push(
                                Graphics.MOVE_TO,
                                x * matrix[0] + y * matrix[2] - tx,
                                x * matrix[1] + y * matrix[3] - ty
                            );
                        }
                        break;

                    case Graphics.LINE_TO:
                        {
                            const x = instance._$recodes[idx++];
                            const y = instance._$recodes[idx++];
                            recodes.push(
                                Graphics.LINE_TO,
                                x * matrix[0] + y * matrix[2] - tx,
                                x * matrix[1] + y * matrix[3] - ty
                            );
                        }
                        break;

                    case Graphics.CURVE_TO:
                        {
                            const cx = instance._$recodes[idx++];
                            const cy = instance._$recodes[idx++];
                            const x  = instance._$recodes[idx++];
                            const y  = instance._$recodes[idx++];
                            recodes.push(
                                Graphics.CURVE_TO,
                                cx * matrix[0] + cy * matrix[2] - tx,
                                cx * matrix[1] + cy * matrix[3] - ty,
                                x  * matrix[0] + y  * matrix[2] - tx,
                                x  * matrix[1] + y  * matrix[3] - ty
                            );
                        }
                        break;

                    case Graphics.CUBIC:
                        {
                            const ctx1 = instance._$recodes[idx++];
                            const cty1 = instance._$recodes[idx++];
                            const ctx2 = instance._$recodes[idx++];
                            const cty2 = instance._$recodes[idx++];
                            const x    = instance._$recodes[idx++];
                            const y    = instance._$recodes[idx++];
                            recodes.push(
                                Graphics.CUBIC,
                                ctx1 * matrix[0] + cty1 * matrix[2] - tx,
                                ctx1 * matrix[1] + cty1 * matrix[3] - ty,
                                ctx2 * matrix[0] + cty2 * matrix[2] - tx,
                                ctx2 * matrix[1] + cty2 * matrix[3] - ty,
                                x * matrix[0] + y * matrix[2] - tx,
                                x * matrix[1] + y * matrix[3] - ty
                            );
                        }
                        break;

                    case Graphics.FILL_STYLE:
                    case Graphics.GRADIENT_FILL:
                    case Graphics.STROKE_STYLE:
                    case Graphics.GRADIENT_STROKE:
                        done = true;

                        Array
                            .prototype
                            .splice
                            .apply(
                                baseShape._$recodes,
                                [index, 0].concat(recodes)
                            );

                        index += recodes.length;
                        break;

                    case Graphics.CLOSE_PATH:
                    case Graphics.END_STROKE:
                    case Graphics.END_FILL:
                        break;

                    default:
                        break;

                }

                if (done) {
                    break;
                }
            }
        }

        if (baseShape) {

            const bounds = baseShape.reloadBounds();
            baseShape._$bounds.xMin = bounds.xMin;
            baseShape._$bounds.xMax = bounds.xMax;
            baseShape._$bounds.yMin = bounds.yMin;
            baseShape._$bounds.yMax = bounds.yMax;
            baseShape.cacheClear();

            this.reloadScreen();
        }

        this._$saved = false;
    }

    /**
     * @description 選択中のDisplayObjectをMovieClipに格納
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenChangeMovieClip ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        this.save();

        const workSpace = Util.$currentWorkSpace();

        const scene = workSpace.scene;
        const frame = Util.$timelineFrame.currentFrame;

        const id = workSpace.nextLibraryId;

        const instance = workSpace.addLibrary(
            Util
                .$libraryController
                .createInstance("container", `MovieClip_${id}`, id)
        );

        // MovieClipに指定したDisplayObjectを登録
        const newLayer = new Layer();
        instance.setLayer(0, newLayer);

        const x = +document.getElementById("object-x").value;
        const y = +document.getElementById("object-y").value;
        const w = +document.getElementById("object-width").value;
        const h = +document.getElementById("object-height").value;

        const dx = x + w / 2;
        const dy = y + h / 2;

        const layers = new Map();
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];
            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            const range = character.getRange(frame);
            if (!layers.has(layer.id)) {
                layers.set(layer.id, {
                    "layer": layer,
                    "range": range
                });
            }

            const cloneCharacter = new Character();
            cloneCharacter.libraryId = character.libraryId;

            const place = character.getPlace(range.startFrame);

            const clonePlace = {
                "frame": 1,
                "matrix": place.matrix.slice(),
                "colorTransform": place.colorTransform.slice(),
                "blendMode": place.blendMode,
                "filter": place.filter.slice(),
                "loop": Util.$getDefaultLoopConfig(),
                "depth": newLayer._$characters.length
            };

            if (place.loop) {
                clonePlace.loop = place.loop;
            }

            cloneCharacter.setPlace(1, clonePlace);

            cloneCharacter.x -= dx;
            cloneCharacter.y -= dy;

            newLayer.addCharacter(cloneCharacter);

            // 削除
            character.remove(layer);
        }

        // 各レイヤーを再描画
        for (const object of layers.values()) {

            const layer = object.layer;
            const range = object.range;

            const characters = layer.getActiveCharacter(range.startFrame);
            if (characters.length) {

                // 深度順に並び替え
                layer.sort(characters, frame);

                for (let idx = 0; idx < characters.length; ++idx) {
                    characters[idx].getPlace(frame).depth = idx;
                }

            } else {

                layer.addEmptyCharacter(
                    new EmptyCharacter({
                        "startFrame": range.startFrame,
                        "endFrame": range.endFrame
                    })
                );

            }

            layer.reloadStyle();
        }

        // 選択中のelementを初期化
        tool.clearActiveElement();

        const character = new Character();
        character.libraryId = instance.id;
        character.endFrame  = frame + 1;

        character.setPlace(frame, {
            "frame": frame,
            "matrix": [1, 0, 0, 1, dx / Util.$zoomScale, dy / Util.$zoomScale],
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": [],
            "depth": 0,
            "loop": Util.$getDefaultLoopConfig()
        });

        const layer = new Layer();
        layer.addCharacter(character);
        scene.addLayer(layer);

        // 前方に空のキーフレームを追加
        if (frame > 1) {
            layer.addEmptyCharacter(new EmptyCharacter({
                "startFrame": 1,
                "endFrame": frame
            }));
        }

        layer.reloadStyle();

        // 再描画
        this.reloadScreen();

        // 初期化
        this._$saved = false;
    }

    /**
     * @description tweenのカーブポイントを追加
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenAddTweenCurvePointer ()
    {
        Util.$tweenController.addCurvePinter();
    }

    /**
     * @description tweenのカーブポイントを削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenDeleteTweenCurvePointer ()
    {
        Util.$tweenController.deleteCurvePointer();
    }

    /**
     * @description 指定したDisplayObjectを最前面に移動
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenFront ()
    {
        this.changeDepth("up");
    }

    /**
     * @description 指定したDisplayObjectを最背面に移動
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenBack ()
    {
        this.changeDepth("down");
    }

    /**
     * @description 指定したDisplayObjectをひとつ前面に移動
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenFrontOne ()
    {
        this.changeDepthOne("up");
    }

    /**
     * @description 指定したDisplayObjectをひとつ背面に移動
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenBackOne ()
    {
        this.changeDepthOne("down");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で左揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeStagePositionLeft ()
    {
        this.alignment("left", "stage");
    }

    /**
     * @description 指定したDisplayObjectを左揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPositionLeft ()
    {
        this.alignment("left");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で中央揃え(水平方向)
     *
     * @return {void}
     * @method
     * @public
     */
    executeStagePositionCenter ()
    {
        this.alignment("center", "stage");
    }

    /**
     * @description 指定したDisplayObjectを中央揃え(水平方向)
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPositionCenter ()
    {
        this.alignment("center");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で右揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeStagePositionRight ()
    {
        this.alignment("right", "stage");
    }

    /**
     * @description 指定したDisplayObjectを右揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPositionRight ()
    {
        this.alignment("right");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で上揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeStagePositionTop ()
    {
        this.alignment("top", "stage");
    }

    /**
     * @description 指定したDisplayObjectを上揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPositionTop ()
    {
        this.alignment("top");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で中央揃え(垂直方向)
     *
     * @return {void}
     * @method
     * @public
     */
    executeStagePositionMiddle ()
    {
        this.alignment("middle", "stage");
    }

    /**
     * @description 指定したDisplayObjectを中央揃え(垂直方向)
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPositionMiddle ()
    {
        this.alignment("middle");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で下揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeStagePositionBottom ()
    {
        this.alignment("bottom", "stage");
    }

    /**
     * @description 指定したDisplayObjectを下揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPositionBottom ()
    {
        this.alignment("bottom");
    }

    /**
     * @description 選択したDisplayObjectを選択した矩形で整列
     *
     * @param  {string} align
     * @param  {string} [mode="rect"]
     * @return {void}
     * @method
     * @public
     */
    alignment (align, mode = "rect")
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length
            || mode === "rect" && 2 > activeElements.length
        ) {
            return ;
        }

        this.save();

        const workSpace = Util.$currentWorkSpace();
        const stage = workSpace.stage;

        let x = 0;
        let y = 0;
        let w = 0;
        let h = 0;
        if (mode === "rect") {

            const element = document
                .getElementById("target-rect");

            x = element.offsetLeft - Util.$offsetLeft;
            y = element.offsetTop  - Util.$offsetTop;
            w = element.offsetWidth;
            h = element.offsetHeight;

        } else {

            w = stage.width;
            h = stage.height;

        }

        const scene = workSpace.scene;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];

            const layer = scene.getLayer(element.dataset.layerId | 0);
            if (!layer || layer.lock || layer.disable) {
                continue;
            }

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            switch (align) {

                case "left":
                    if (character.x === character.screenX) {
                        character.x = x;
                    } else {
                        character.x = x - character.screenX + character.x;
                    }
                    break;

                case "right":
                    if (character.x === character.screenX) {
                        character.x = x + w - character.width;
                    } else {
                        character.x = x + w - character.width - character.screenX + character.x;
                    }
                    break;

                case "center":
                    if (character.x === character.screenX) {
                        character.x = x + w / 2 - character.width / 2;
                    } else {
                        character.x = x + w / 2 - character.width / 2 - character.screenX + character.x;
                    }
                    break;

                case "top":
                    if (character.y === character.screenY) {
                        character.y = y;
                    } else {
                        character.y = y - character.screenY + character.y;
                    }
                    break;

                case "bottom":
                    if (character.y === character.screenY) {
                        character.y = y + h - character.height;
                    } else {
                        character.y = y + h - character.height - character.screenY + character.y;
                    }
                    break;

                case "middle":
                    if (character.y === character.screenY) {
                        character.y = y + h / 2 - character.height / 2;
                    } else {
                        character.y = y + h / 2 - character.height / 2 - character.screenY + character.y;
                    }
                    break;

            }
        }

        // 選択範囲を再計算
        Util.$transformController.relocation();

        // 初期化
        this._$saved = false;
    }

    /**
     * @param  {string} [mode="up"]
     * @return {void}
     * @public
     */
    changeDepthOne (mode = "up")
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        this.save();

        const scene = Util.$currentWorkSpace().scene;

        const frame = Util.$timelineFrame.currentFrame;

        const layers = new Map();
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];

            const layer = scene.getLayer(element.dataset.layerId | 0);

            if (!layers.has(layer.id)) {
                layers.set(layer.id, []);
            }

            layers.get(layer.id).push(
                layer.getCharacter(element.dataset.characterId | 0)
            );
        }

        for (const [layerId, values] of layers) {

            const layer = scene.getLayer(layerId);
            const characters = layer.getActiveCharacter(frame);
            if (1 >= characters.length) {
                continue;
            }

            // 降順
            characters.sort((a, b) =>
            {
                const aDepth = a.getPlace(frame).depth;
                const bDepth = b.getPlace(frame).depth;
                switch (true) {

                    case aDepth > bDepth:
                        return -1;

                    case aDepth < bDepth:
                        return 1;

                    default:
                        return 0;

                }
            });

            if (values.length > 1) {

                if (mode === "up") {

                    // 降順
                    values.sort((a, b) =>
                    {
                        const aDepth = a.getPlace(frame).depth;
                        const bDepth = b.getPlace(frame).depth;
                        switch (true) {

                            case aDepth > bDepth:
                                return -1;

                            case aDepth < bDepth:
                                return 1;

                            default:
                                return 0;

                        }
                    });

                } else {

                    // 昇順
                    values.sort((a, b) =>
                    {
                        const aDepth = a.getPlace(frame).depth;
                        const bDepth = b.getPlace(frame).depth;
                        switch (true) {

                            case aDepth > bDepth:
                                return 1;

                            case aDepth < bDepth:
                                return -1;

                            default:
                                return 0;

                        }
                    });

                }

            }

            let minDepth = 0;
            let maxDepth = characters.length - 1;
            for (let idx = 0; idx < values.length; ++idx) {

                const character = values[idx];

                const place = character.getPlace(frame);

                if (mode === "up") {

                    if (place.depth >= maxDepth) {
                        --maxDepth;
                        continue;
                    }

                    place.depth++;

                    const index = characters.indexOf(character);
                    characters[index - 1].getPlace(frame).depth--;

                } else {

                    if (minDepth >= place.depth) {
                        ++minDepth;
                        continue;
                    }

                    place.depth--;

                    const index = characters.indexOf(character);
                    characters[index + 1].getPlace(frame).depth++;

                }

                // 降順
                characters.sort((a, b) =>
                {
                    const aDepth = a.getPlace(frame).depth;
                    const bDepth = b.getPlace(frame).depth;
                    switch (true) {

                        case aDepth > bDepth:
                            return -1;

                        case aDepth < bDepth:
                            return 1;

                        default:
                            return 0;

                    }
                });

            }
        }

        // 再描画
        this.reloadScreen();

        // 初期化
        this._$saved = false;
    }

    /**
     * @param  {string} [mode="up"]
     * @return {void}
     * @public
     */
    changeDepth (mode = "up")
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        this.save();

        const scene = Util.$currentWorkSpace().scene;

        const frame = Util.$timelineFrame.currentFrame;

        const layers = new Map();
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];

            const layer = scene.getLayer(element.dataset.layerId | 0);

            if (!layers.has(layer.id)) {
                layers.set(layer.id, []);
            }

            layers.get(layer.id).push(
                layer.getCharacter(element.dataset.characterId | 0)
            );
        }

        for (const [layerId, values] of layers) {

            const layer = scene.getLayer(layerId);

            const characters = layer.getActiveCharacter(frame);
            if (1 >= characters.length) {
                continue;
            }

            // 降順
            characters.sort((a, b) =>
            {
                const aDepth = a.getPlace(frame).depth;
                const bDepth = b.getPlace(frame).depth;
                switch (true) {

                    case aDepth > bDepth:
                        return -1;

                    case aDepth < bDepth:
                        return 1;

                    default:
                        return 0;

                }
            });

            // 降順
            if (values.length > 1) {

                if (mode === "up") {

                    // 降順
                    values.sort((a, b) =>
                    {
                        const aDepth = a.getPlace(frame).depth;
                        const bDepth = b.getPlace(frame).depth;
                        switch (true) {

                            case aDepth > bDepth:
                                return -1;

                            case aDepth < bDepth:
                                return 1;

                            default:
                                return 0;

                        }
                    });

                } else {

                    // 昇順
                    values.sort((a, b) =>
                    {
                        const aDepth = a.getPlace(frame).depth;
                        const bDepth = b.getPlace(frame).depth;
                        switch (true) {

                            case aDepth > bDepth:
                                return 1;

                            case aDepth < bDepth:
                                return -1;

                            default:
                                return 0;

                        }
                    });
                }

            }

            const ignoreMap = new Map();

            let minDepth = 0;
            let maxDepth = characters.length - 1;
            for (let idx = 0; idx < values.length; ++idx) {

                const value = values[idx];

                const place = value.getPlace(frame);

                if (mode === "up") {

                    if (place.depth >= maxDepth) {
                        --maxDepth;
                        continue;
                    }

                    place.depth = maxDepth--;

                    ignoreMap.set(value.id, true);

                    let depth = maxDepth;
                    for (let idx = 0; characters.length > idx; ++idx) {

                        const character = characters[idx];
                        if (ignoreMap.has(character.id)) {
                            continue;
                        }

                        character.getPlace(frame).depth = depth--;
                        if (depth === -1) {
                            break;
                        }
                    }

                } else {

                    if (minDepth >= place.depth) {
                        ++minDepth;
                        continue;
                    }

                    place.depth = minDepth++;

                    ignoreMap.set(value.id, true);

                    let depth = minDepth;
                    for (let idx = characters.length - 1; idx > -1; --idx) {

                        const character = characters[idx];
                        if (ignoreMap.has(character.id)) {
                            continue;
                        }

                        character.getPlace(frame).depth = depth++;
                        if (depth === characters.length) {
                            break;
                        }
                    }
                }
            }
        }

        // 再描画
        this.reloadScreen();

        // 初期化
        this._$saved = false;
    }

    /**
     * @description スクリーンエリアのメニューモーダルを表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    show (event)
    {
        Util.$endMenu("screen-menu");

        const element = document.getElementById("screen-menu");

        const height = element.clientHeight / 2 + 15;

        element.style.left = `${event.pageX + 5}px`;
        element.style.top  = `${event.pageY - height}px`;

        if (15 > element.offsetTop) {
            element.style.top = "10px";
        }

        if (event.pageY + height > window.innerHeight) {
            const moveY = window.innerHeight - (event.pageY + height - 15);
            element.style.top = `${element.offsetTop + moveY}px`;
        }

        element.setAttribute("class", "fadeIn");
    }
}

Util.$screenMenu = new ScreenMenu();

/**
 * @class
 */
class ScreenTab
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$dropTab = null;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;
    }

    /**
     * @description タブエリアの起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    run ()
    {
        // 読込がWorkSpaceがあればタブのElementを追加
        for (let idx = 0; idx < Util.$workSpaces.length; ++idx) {
            this.createElement(Util.$workSpaces[idx], idx);
        }

        // タブの追加ボタン
        const button = document
            .getElementById("view-tab-add");

        if (button) {
            button.addEventListener("click", (event) =>
            {
                this.addTab(event);
            });
        }

        // タブの一覧ボタン
        const tabList = document.getElementById("view-tab-list");
        if (tabList) {
            tabList.addEventListener("mousedown", (event) =>
            {
                this.showTabList(event);
            });
        }
    }

    /**
     * @description タブの一覧をモーダルで表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    showTabList (event)
    {
        // 親のイベントを中止
        event.stopPropagation();

        const element = document.getElementById("tab-name-menu");
        if (element.classList.contains("fadeIn")) {
            return Util.$endMenu();
        }

        Util.$endMenu("tab-name-menu");

        const target = event.currentTarget;
        element.style.left = `${target.offsetLeft + target.offsetWidth}px`;
        element.style.top  = `${target.offsetTop + 25}px`;
        element.setAttribute("class", "fadeIn");
    }

    /**
     * @description スクリーンエリアのタブを追加
     *
     * @param  {WorkSpace} work_space
     * @param  {number}    id
     * @return {void}
     * @method
     * @public
     */
    createElement (work_space, id)
    {
        if (!work_space.name) {
            work_space.name = `Untitled-${id + 1}`;
        }

        // スクリーンエリアにタブのElementを追加
        document
            .getElementById("view-tab-area")
            .insertAdjacentHTML("beforeend", `
<div draggable="true" id="tab-id-${id}" data-tab-id="${id}" class="tab">
    <p id="tab-text-id-${id}" data-tab-id="${id}" data-detail="{{タブの移動・名前を変更}}" data-shortcut-key="ArrowLeftCtrl" data-shortcut-text="Ctrl + ◀︎ or ▶" data-area="global">${work_space.name}</p>
    <input type="text" id="tab-input-id-${id}" data-tab-id="${id}" value="${work_space.name}">
    <i id="tab-delete-id-${id}" data-tab-id="${id}" data-detail="{{プロジェクトを閉じる}}"></i>
</div>`);

        const div = document.getElementById(`tab-id-${id}`);

        // モーダル表示を登録
        Util.$addModalEvent(div);

        div
            .classList
            .add(Util.$activeWorkSpaceId === id ? "active" : "disable");

        div.addEventListener("mousedown", (event) =>
        {
            this.activeTab(event);
        });

        // ドロップでタブを移動する
        div.addEventListener("dragstart", (event) =>
        {
            this.dragStart(event);
        });

        div.addEventListener("dragover", (event) =>
        {
            this.dragOver(event);
        });

        div.addEventListener("dragleave", (event) =>
        {
            this.dragLeave(event);
        });

        div.addEventListener("drop", (event) =>
        {
            this.drop(event);
        });

        // 削除アイコンに削除関数を登録
        document
            .getElementById(`tab-delete-id-${id}`)
            .addEventListener("click", (event) =>
            {
                this.deleteTab(event);
            });

        // タイトルインプットタグをコントロールする関数を追加
        document
            .getElementById(`tab-text-id-${id}`)
            .addEventListener("dblclick", (event) =>
            {
                this.editStart(event);
            });

        // inputタグは非表示にする
        const input = document
            .getElementById(`tab-input-id-${id}`);

        if (input) {
            input.style.display = "none";

            input.addEventListener("focusout", (event) =>
            {
                this.editEnd(event);
            });
            input.addEventListener("keypress", (event) =>
            {
                this.editEnd(event);
            });
        }

        // タブ一覧にElementを追加
        document
            .getElementById("tab-name-menu-list")
            .insertAdjacentHTML("beforeend", `
<div id="tab-menu-id-${id}" data-tab-id="${id}">${work_space.name}</div>`);

        // マウスイベントでアクティブになるよう関数を登録
        const menu = document
            .getElementById(`tab-menu-id-${id}`);

        if (menu) {
            menu.addEventListener("mousedown", (event) =>
            {
                this.activeTab(event, true);
            });
        }
    }

    /**
     * @description ドロップ先のElementとドラッグしたElementを入れ替える
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    drop (event)
    {
        // 親のイベントを中止
        event.preventDefault();

        this.save();

        // スタイルを削除
        event
            .currentTarget
            .classList
            .remove("drop-target");

        const nextElement = event
            .currentTarget
            .nextElementSibling;

        document
            .getElementById("view-tab-area")
            .insertBefore(
                this._$dropTab,
                this._$dropTab === nextElement
                    ? event.currentTarget
                    : nextElement
            );

        // 初期化
        this._$dropTab = null;
        this._$saved   = false;
    }

    /**
     * @description ヒットしたElementから抜けたスタイルを削除
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    dragLeave (event)
    {
        // 親のイベントを中止
        event.preventDefault();

        event
            .currentTarget
            .classList
            .remove("drop-target");
    }

    /**
     * @description ドラッグしたElementがヒットしたElementにスタイルを追加
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    dragOver (event)
    {
        // 親のイベントを中止
        event.preventDefault();

        event
            .currentTarget
            .classList
            .add("drop-target");
    }

    /**
     * @description ドラッグスタート関数、ドラッグするElementを変数に格納
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    dragStart (event)
    {
        // モーダルを非表示にする
        Util.$endMenu();

        // ドラッグするElementを変数に格納
        this._$dropTab = event.currentTarget;
    }

    /**
     * @description タブのリスト移動した時
     *
     * @param  {MouseEvent} event
     * @param  {boolean} move_tab
     * @return {void}
     * @method
     * @public
     */
    activeTab (event, move_tab = false)
    {
        // モーダルを非表示にする
        Util.$endMenu();

        // アクティブなタブを非アクティブな状態に
        const activeElement = document
            .getElementById(`tab-id-${Util.$activeWorkSpaceId}`);

        if (activeElement) {
            activeElement
                .classList
                .remove("active");

            activeElement
                .classList
                .add("disable");
        }

        // 非アクティブなタブをアクティブな状態に
        const tabId = event.currentTarget.dataset.tabId | 0;

        const tab = document
            .getElementById(`tab-id-${tabId}`);
        if (tab) {
            tab
                .classList
                .remove("disable");

            tab
                .classList
                .add("active");

            // 指定したタブを左端に移動
            if (move_tab) {
                const area = document
                    .getElementById("view-tab-area");

                tab.remove();
                area.prepend(tab);
            }
        }

        // 対象のWorkSpaceに切り替える
        if (Util.$activeWorkSpaceId !== tabId) {
            Util.$changeWorkSpace(tabId);
        }
    }

    /**
     * @description タブの削除関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    deleteTab (event)
    {
        event.preventDefault();

        const message = Util.$currentLanguage.replace(
            "{{プロジェクトが保存されていない場合、" +
            "このタブのプロジェクトデータを復旧する事はできません。" +
            "タブを削除しますか？}}"
        );

        // 削除前に警告を表示
        if (!window.confirm(message)) {
            return ;
        }

        // 作業スペースを削除
        const tabId = event.currentTarget.dataset.tabId | 0;

        Util.$workSpaces[tabId] = null;

        document
            .getElementById(`tab-id-${tabId}`)
            .remove();

        document
            .getElementById(`tab-menu-id-${tabId}`)
            .remove();

        // ライブラリタブのプレビュー表示を削除
        const previewElement = document
            .getElementById("library-preview-area");

        while (previewElement.children.length) {
            previewElement.children[0].remove();
        }

        // タブが0になった場合は空のタブを追加する
        const parent = document.getElementById("view-tab-area");
        if (!parent.children.length) {

            // reset
            Util.$workSpaces.length = 0;
            Util.$activeWorkSpaceId = 0;

            // new WorkSpace
            const workSpace = new WorkSpace();
            Util.$workSpaces.push(workSpace);

            // create tab
            this.createElement(workSpace, 0);

            // start
            workSpace.run();

            const element = parent.children[0];
            element.setAttribute("class", "tab active");

        } else {

            // アクティブなタブを削除する場合は、左端のタブをアクティブにする
            if (Util.$activeWorkSpaceId === tabId) {

                const element = parent.children[0];
                element.setAttribute("class", "tab active");

                Util.$activeWorkSpaceId = element.dataset.tabId | 0;

                Util.$currentWorkSpace().run();
            }

        }
    }

    /**
     * @description タブのタイトル編集を開始
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    editStart (event)
    {
        Util.$keyLock = true;

        const element = event.currentTarget;
        const tabId   = element.dataset.tabId | 0;

        const input = document
            .getElementById(`tab-input-id-${tabId}`);

        if (input.style.display === "none") {

            input.style.width     = `${element.offsetWidth}px`;
            input.style.display   = "";
            element.style.display = "none";
            input.focus();

            const parent = document
                .getElementById(`tab-id-${tabId}`);

            parent.draggable = false;
        }
    }

    /**
     * @description タブのタイトル編集を終了する関数
     *
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    editEnd (event)
    {
        if (event.key === "Enter") {
            event.target.blur();
            return ;
        }

        if (event.type === "focusout") {

            this.save();

            const element = event.currentTarget;
            element.style.display = "none";

            const tabId = element.dataset.tabId | 0;

            const p = document
                .getElementById(`tab-text-id-${tabId}`);

            const menu = document.getElementById(`tab-menu-id-${tabId}`);
            const workSpace = Util.$workSpaces[tabId];

            workSpace.name   = element.value;
            menu.textContent = element.value;
            p.textContent    = element.value;
            p.style.display  = "";

            const parent = document
                .getElementById(`tab-id-${tabId}`);

            parent.draggable = true;

            this._$saved = false;
        }
    }

    /**
     * @description タブ追加関数、WorkSpaceクラスを作成して、タブのElementを追加する
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    addTab (event)
    {
        Util.$endMenu();

        // 親のイベントを中止
        event.stopPropagation();

        this.save();

        const id = Util.$workSpaces.length;
        const workSpace = new WorkSpace();

        Util.$workSpaces.push(workSpace);
        this.createElement(workSpace, id);

        this._$saved = false;
    }

    /**
     * @description undo用にデータを内部保管する
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }
}

Util.$screenTab = new ScreenTab();

/**
 * @class
 * @extends {BaseScreen}
 */
class ScreenZoom extends BaseScreen
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$currentValue = 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_LEVEL ()
    {
        return 0.25;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_LEVEL ()
    {
        return 5;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document
            .getElementById("screen-scale");

        if (element) {
            this.setInputEvent(element);
        }
    }

    /**
     * @description ズームのスケールのInput処理
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeScreenScale (value)
    {
        value = Util.$clamp(value | 0,
            ScreenZoom.MIN_LEVEL * 100,
            ScreenZoom.MAX_LEVEL * 100
        );

        this.execute(
            (this._$currentValue - value) / 100 * -1
        );

        this._$currentValue = value;

        return value;
    }

    /**
     * @param  {number} delta
     * @return {void}
     * @public
     */
    execute (delta)
    {
        Util.$zoomScale += delta;
        Util.$zoomScale = Math.min(
            ScreenZoom.MAX_LEVEL,
            Math.max(ScreenZoom.MIN_LEVEL, Util.$zoomScale)
        );

        document
            .getElementById("screen-scale")
            .value = `${Util.$zoomScale * 100 | 0}`;

        const workSpace = Util.$currentWorkSpace();

        // ズームした幅と高さを算出
        const width  = workSpace.stage.width  * Util.$zoomScale;
        const height = workSpace.stage.height * Util.$zoomScale;

        // 対象Element
        const screen    = document.getElementById("screen");
        const stageArea = document.getElementById("stage-area");
        const stage     = document.getElementById("stage");

        const beforeWidth  = screen.clientWidth  / (stageArea.clientWidth  / screen.clientWidth);
        const beforeHeight = screen.clientHeight / (stageArea.clientHeight / screen.clientHeight);

        const positionX = screen.scrollLeft / screen.scrollWidth;
        const positionY = screen.scrollTop  / screen.scrollHeight;

        // 値を更新
        stage.style.width      = `${width}px`;
        stage.style.height     = `${height}px`;
        stageArea.style.width  = `${width  + window.screen.width}px`;
        stageArea.style.height = `${height + window.screen.height}px`;

        const afterWidth  = screen.clientWidth  / (stageArea.clientWidth  / screen.clientWidth);
        const afterHeight = screen.clientHeight / (stageArea.clientHeight / screen.clientHeight);

        screen.scrollLeft = screen.scrollWidth  * positionX + (beforeWidth  - afterWidth);
        screen.scrollTop  = screen.scrollHeight * positionY + (beforeHeight - afterHeight);

        // DisplayObjectのキャッシュを全て削除
        const frame = Util.$timelineFrame.currentFrame;
        const scene = workSpace.scene;
        for (const layer of scene._$layers.values()) {

            const characters = layer.getActiveCharacter(frame);
            for (let idx = 0; idx < characters.length; ++idx) {
                characters[idx]._$image = null;
            }

        }

        // 再描画
        scene.changeFrame(frame);
    }
}

Util.$screenZoom = new ScreenZoom();

/**
 * @class
 * @extends {BaseController}
 */
class BlendController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("blend");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        this.setChangeEvent(
            document.getElementById("blend-select")
        );
    }

    /**
     * @description ブレンドモードの値を変更
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeBlendSelect (value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        const element   = activeElements[0];

        // 対象レイヤーオブジェクト
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        // スクリーンで選択しているDisplayObject
        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        const frame = Util.$timelineFrame.currentFrame;

        // 対象のカラーを更新
        let place = character.getPlace(frame);
        if (place.tweenFrame) {

            if (character.endFrame - 1 > frame && !character.hasTween(frame)) {

                Util
                    .$timelineTool
                    .executeTimelineKeyAdd();

                place = character.getPlace(frame);
            }

            place = character.getPlace(place.tweenFrame);
        }
        place.blendMode = `${value}`;

        // tween情報があれば更新
        character.updateTweenBlend(frame);

        // 再描画ように、キャッシュを削除
        character._$image = null;
    }
}

Util.$blendController = new BlendController();

/**
 * @class
 * @extends {BaseController}
 */
class ColorTransformController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("color");
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_OFFSET ()
    {
        return -255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_OFFSET ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_MULTIPLIER ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_MULTIPLIER ()
    {
        return 100;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "color-alpha-offset",
            "color-red-offset",
            "color-green-offset",
            "color-blue-offset",
            "color-alpha-multiplier",
            "color-red-multiplier",
            "color-green-multiplier",
            "color-blue-multiplier"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            this.setInputEvent(element);
        }
    }

    /**
     * @description Offsetの値を補正
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    offsetClamp (value)
    {
        return Util.$clamp(
            value | 0,
            ColorTransformController.MIN_OFFSET,
            ColorTransformController.MAX_OFFSET
        );
    }

    /**
     * @description 値を補正
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    multiplierClamp (value)
    {
        return Util.$clamp(
            +value,
            ColorTransformController.MIN_MULTIPLIER,
            ColorTransformController.MAX_MULTIPLIER
        );
    }

    /**
     * @description 赤の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeColorRedMultiplier (value)
    {
        // 補正
        value = this.multiplierClamp(value);

        this.updateColor(0, value / 100);

        return value;
    }

    /**
     * @description 緑の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeColorGreenMultiplier (value)
    {
        // 補正
        value = this.multiplierClamp(value);

        this.updateColor(1, value / 100);

        return value;
    }

    /**
     * @description 青の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeColorBlueMultiplier (value)
    {
        // 補正
        value = this.multiplierClamp(value);

        this.updateColor(2, value / 100);

        return value;
    }

    /**
     * @description 透明度の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeColorAlphaMultiplier (value)
    {
        // 補正
        value = this.multiplierClamp(value);

        this.updateColor(3, value / 100);

        return value;
    }

    /**
     * @description Offsetの赤の値を更新
     *
     * @param {string} value
     * @method
     * @public
     */
    changeColorRedOffset (value)
    {
        // 補正
        value = this.offsetClamp(value);

        this.updateColor(4, value);

        return value;
    }

    /**
     * @description Offsetの緑の値を更新
     *
     * @param {string} value
     * @method
     * @public
     */
    changeColorGreenOffset (value)
    {
        // 補正
        value = this.offsetClamp(value);

        this.updateColor(5, value);

        return value;
    }

    /**
     * @description Offsetの青の値を更新
     *
     * @param {string} value
     * @method
     * @public
     */
    changeColorBlueOffset (value)
    {
        // 補正
        value = this.offsetClamp(value);

        this.updateColor(6, value);

        return value;
    }

    /**
     * @description Offsetの透明度の値を更新
     *
     * @param {string} value
     * @method
     * @public
     */
    changeColorAlphaOffset (value)
    {
        // 補正
        value = this.offsetClamp(value);

        this.updateColor(7, value);

        return value;
    }

    /**
     * @description 値更新の分岐関数
     *
     * @param  {number} index
     * @param  {number} value
     * @return {number}
     * @method
     * @public
     */
    updateColor (index, value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        const element   = activeElements[0];

        // 対象レイヤーオブジェクト
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        // スクリーンで選択しているDisplayObject
        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        const frame = Util.$timelineFrame.currentFrame;

        // 対象のカラーを更新
        const place = character.getPlace(frame);
        place.colorTransform[index] = value;

        // tweenの座標を再計算してポインターを再配置
        character.relocationTween(frame);

        // 再描画ように、キャッシュを削除
        character._$image = null;
    }
}

Util.$colorTransformController = new ColorTransformController();

/**
 * @class
 */
class ConfirmModal extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("");

        /**
         * @type {array}
         * @private
         */
        this._$files = [];

        /**
         * @type {string}
         * @default "hide"
         * @private
         */
        this._$state = "hide";

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$currentObject = null;
    }

    /**
     * @return {array}
     * @public
     */
    get files ()
    {
        return this._$files;
    }

    /**
     * @param  {array} files
     * @return {void}
     * @public
     */
    set files (files)
    {
        this._$files = files;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elements = [
            "confirm-overwriting",
            "confirm-skip",
            "confirm-all-overwriting",
            "confirm-all-skip"
        ];

        for (let idx = 0; idx < elements.length; ++idx) {

            const element = document
                .getElementById(elements[idx]);

            if (!element) {
                continue;
            }

            element.addEventListener("mousedown", (event) =>
            {
                event.stopPropagation();

                const names = event.target.id.split("-");

                let functionName = names
                    .map((value) =>
                    {
                        return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
                    })
                    .join("");

                return this[`execute${functionName}`](event);
            });
        }
    }

    /**
     * @description 全て上書き
     *
     * @return {void}
     * @method
     * @public
     */
    executeConfirmAllOverwriting ()
    {
        this.save();

        // 上書きするIDを指定
        const libraryId = Util
            .$currentWorkSpace()
            ._$nameMap
            .get(this._$currentObject.path);

        Util
            .$libraryController
            .loadFile(
                this._$currentObject.file,
                this._$currentObject.folderId,
                this._$currentObject.file.name,
                libraryId
            );

        for (let idx = 0; idx < this._$files.length; ++idx) {

            const object = this._$files[idx];

            // 上書きするIDを指定
            const libraryId = Util
                .$currentWorkSpace()
                ._$nameMap
                .get(object.path);

            Util
                .$libraryController
                .loadFile(
                    object.file,
                    object.folderId,
                    object.file.name,
                    libraryId
                );
        }

        this._$files.length  = 0;

        // モーダルを非表示
        this.hide();

        this._$saved = false;
    }

    /**
     * @description 全ての上書きをスキップ
     *
     * @return {void}
     * @method
     * @public
     */
    executeConfirmAllSkip ()
    {
        this._$state         = "hide";
        this._$currentObject = null;
        this._$files.length  = 0;

        document
            .getElementById("confirm-modal")
            .setAttribute("class", "fadeOut");
    }

    /**
     * @description 上書きを実行
     *
     * @return {void}
     * @method
     * @public
     */
    executeConfirmOverwriting ()
    {
        this.save();

        const inputValue = document
            .getElementById("confirm-file-name")
            .value;

        let name = this._$currentObject.file.name;
        if (name.indexOf(".swf") > -1) {
            name = name.replace(".swf", "");
        }

        let libraryId = 0;
        if (inputValue === name) {

            // 上書きならIDを指定
            libraryId = Util
                .$currentWorkSpace()
                ._$nameMap
                .get(this._$currentObject.path);

        }

        Util
            .$libraryController
            .loadFile(
                this._$currentObject.file,
                this._$currentObject.folderId,
                inputValue,
                libraryId
            );

        this.setup();

        this._$saved = false;
    }

    /**
     * @description スキップ
     *
     * @return {void}
     * @method
     * @public
     */
    executeConfirmSkip ()
    {
        this.setup();
    }

    /**
     * @description 設定を初期化
     *
     * @return {void}
     * @method
     * @public
     */
    hide ()
    {
        this._$state         = "hide";
        this._$currentObject = null;

        document
            .getElementById("confirm-modal")
            .setAttribute("class", "fadeOut");
    }

    /**
     * @description 上書き確認モーダルを表示
     *
     * @return {void}
     * @method
     * @public
     */
    show ()
    {
        if (this._$state === "show") {
            return ;
        }

        // 状態を更新
        this._$state = "show";

        // 全てのモーダルを非表示に
        Util.$endMenu();

        document
            .getElementById("confirm-modal")
            .setAttribute("class", "fadeIn");

        this.setup();
    }

    /**
     * @description プールしたオブジェクトから表示を更新
     *
     * @return {void}
     * @method
     * @public
     */
    setup ()
    {
        this._$currentObject = this._$files.shift();

        // 表示項目がなければモーダル表示を終了
        if (!this._$currentObject) {
            this.hide();
            return ;
        }

        // 表示を初期化
        const beforeElement = document
            .getElementById("confirm-before-preview");

        while (beforeElement.firstChild) {
            beforeElement.firstChild.remove();
        }

        // 表示を初期化
        const afterElement = document
            .getElementById("confirm-after-preview");

        while (afterElement.firstChild) {
            afterElement.firstChild.remove();
        }

        const input = document
            .getElementById("confirm-file-name");

        let name = this._$currentObject.file.name;
        if (name.indexOf(".swf") > -1) {
            name = name.replace(".swf", "");
        }

        input.value = name;
        input.focus();

        const workSpace = Util.$currentWorkSpace();

        const libraryId = workSpace
            ._$nameMap.get(this._$currentObject.path);

        const instance = workSpace.getLibrary(libraryId);
        if (instance) {
            beforeElement.appendChild(instance.getPreview());
        }

        const file = this._$currentObject.file;
        switch (file.type) {

            case "image/svg+xml":
            case "image/png":
            case "image/jpeg":
            case "image/gif":
                {
                    const image = new Image();
                    image.onload = () =>
                    {
                        afterElement.appendChild(image);
                    };

                    image.src = URL.createObjectURL(file);
                }
                break;

            case "video/mp4":
                {
                    const video = document.createElement("video");
                    video.crossOrigin = "anonymous";
                    video.type        = "video/mp4";
                    video.muted       = true;
                    video.autoplay    = false;
                    video.controls    = true;

                    video.onloadedmetadata = () =>
                    {
                        afterElement.appendChild(video);
                    };
                    video.src = URL.createObjectURL(file);
                    video.load();
                }
                break;

            case "audio/mpeg":
                {
                    const audio = document.createElement("audio");
                    audio.preload  = "auto";
                    audio.autoplay = false;
                    audio.loop     = false;
                    audio.controls = true;

                    audio.src = URL.createObjectURL(file);
                    audio.load();
                    afterElement.appendChild(audio);
                }
                break;

        }
    }
}

Util.$confirmModal = new ConfirmModal();

/**
 * @class
 * @extends {BaseController}
 */
class Controller extends BaseController
{
    /**
     * @return {void}
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document
            .getElementById("controller");

        if (element) {
            element.addEventListener("mouseover", () =>
            {
                Util.$setCursor("auto");
            });
        }
    }

    /**
     * @description 指定したIDを表示にする
     *
     * @param  {array} names
     * @return {void}
     * @method
     * @public
     */
    showObjectSetting (names)
    {
        for (let idx = 0; idx < names.length; ++idx) {
            document.getElementById(names[idx]).style.display = "";
        }
    }

    /**
     * @description 指定したIDを非表示にする
     *
     * @param  {array} names
     * @return {void}
     * @method
     * @public
     */
    hideObjectSetting (names)
    {
        for (let idx = 0; idx < names.length; ++idx) {
            document.getElementById(names[idx]).style.display = "none";
        }
    }

    /**
     * @description 初期表示に戻す
     *
     * @return {void}
     * @method
     * @public
     */
    default ()
    {
        // フィルターを初期化
        Util.$filterController.clearFilters();

        this.hideObjectSetting([
            "object-area",
            "instance-setting",
            "fill-color-setting"
        ]);

        this.showObjectSetting([
            "stage-setting",
            "sound-setting",
            "object-setting",
            "color-setting",
            "blend-setting",
            "filter-setting"
        ]);

        const scene = Util.$currentWorkSpace().scene;

        document
            .getElementById("object-name")
            .value = scene.name;

        document
            .getElementById("object-symbol")
            .value = scene.symbol;
    }
}

Util.$controller = new Controller();

/**
 * @class
 */
class ControllerAdjustment
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pointX = 0;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get CONTROLLER_DEFAULT_SIZE ()
    {
        return 360;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        document
            .documentElement
            .style
            .setProperty(
                "--controller-width",
                `${ControllerAdjustment.CONTROLLER_DEFAULT_SIZE}px`
            );

        const element = document
            .getElementById("controller-adjustment");

        if (element) {
            element.addEventListener("mousedown", (event) =>
            {
                this.mouseDown(event);
            });
        }

        Util.$initializeEnd();
    }

    /**
     * @description コントローラーのサイズ変更イベントを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        event.preventDefault();

        this._$pointX = event.screenX;

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description コントローラーのサイズ変更処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        Util.$setCursor("col-resize");

        window.requestAnimationFrame(() =>
        {
            const diff = this._$pointX - event.screenX;

            const value = document
                .documentElement
                .style
                .getPropertyValue("--controller-width")
                .split("px")[0] | 0;

            const width = Math.max(
                ControllerAdjustment.CONTROLLER_DEFAULT_SIZE,
                value + diff
            );

            document
                .documentElement
                .style
                .setProperty(
                    "--controller-width",
                    `${width}px`
                );

            Util.$currentWorkSpace()._$controllerWidth = width;

            this._$pointX = event.screenX;
        });
    }

    /**
     * @description コントローラーのサイズ変更イベントを終了
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        Util.$setCursor("auto");
    }
}

Util.$controllerAdjustment = new ControllerAdjustment();

/**
 * @class
 * @extends {GradientFilterController}
 */
class FilterController extends GradientFilterController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("filter");

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$filterId = 0;

        /**
         * @type {Map}
         * @private
         */
        this._$filters = new Map();
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_BLUR ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_BLUR ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_ALPHA ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_ALPHA ()
    {
        return 100;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_STRENGTH ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_STRENGTH ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_ROTATE ()
    {
        return -360;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_ROTATE ()
    {
        return 360;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_DISTANCE ()
    {
        return -255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_DISTANCE ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_COLOR ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_COLOR ()
    {
        return 0xffffff;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_QUALITY ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_QUALITY ()
    {
        return 16;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document.getElementById("filter-add");
        if (element) {
            element
                .addEventListener("mousedown", () =>
                {
                    this.addFilter();
                    this.disposeCharacterImage();
                    this.reloadScreen();
                });
        }
    }

    /**
     * @description 幅高さの変更のロックのOn/Off関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    lock (event)
    {
        event.stopPropagation();

        // ロックのOn/Off
        const filterId = event.currentTarget.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return ;
        }

        const object = this._$filters.get(filterId);
        object.lock  = !object.lock;

        // 初期化
        this._$currentValue = null;

        event
            .currentTarget
            .childNodes[1]
            .setAttribute("class", object.lock
                ? "active"
                : "disable"
            );
    }

    /**
     * @description フィルターの表示・非表示の処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    clickNodeTitle (event)
    {
        const filterId = event.target.dataset.filterId | 0;

        const element = document
            .getElementById(`filter-view-area-${filterId}`);

        if (element.style.display === "none") {

            element.style.display = "";
            document
                .getElementById(`filter-title-arrow-${filterId}`)
                .setAttribute("class", "arrow active");

        } else {

            element.style.display = "none";
            document
                .getElementById(`filter-title-arrow-${filterId}`)
                .setAttribute("class", "arrow disable");

        }
    }

    /**
     * @description フィルターの有効・無効の処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    changeState (event)
    {
        const filterId = event.target.dataset.filterId | 0;

        if (!this._$filters.has(filterId)) {
            return ;
        }

        const object = this._$filters.get(filterId);

        // 値を更新
        object.filter.state = !object.filter.state;

        document
            .getElementById(`filter-state-${filterId}`)
            .setAttribute("class", object.filter.state
                ? "filter-active"
                : "filter-disable"
            );

        this.disposeCharacterImage();
    }

    /**
     * @description フィルターの削除の処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    removeFilter (event)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const filterId = event.target.dataset.filterId | 0;

        const target  = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                target.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            target.dataset.characterId | 0
        );

        const frame = Util.$timelineFrame.currentFrame;

        let place = character.getPlace(frame);
        if (place.tweenFrame) {

            if (character.endFrame - 1 > frame && !character.hasTween(frame)) {

                Util
                    .$timelineTool
                    .executeTimelineKeyAdd();

                place = character.getPlace(frame);
            }

            place = character.getPlace(place.tweenFrame);
        }

        const object = this._$filters.get(filterId);
        const index  = place.filter.indexOf(object.filter);
        place.filter.splice(index, 1);

        // tween情報があれば更新
        character.updateTweenFilter(frame);

        // remove
        this._$filters.delete(filterId);
        if (!this._$filters.size) {
            document
                .querySelectorAll(".filter-none")[0]
                .style.display = "";
        }

        document
            .getElementById(`filter-id-${filterId}`)
            .remove();

        super.focusOut();

        // 再描画用にキャッシュを削除
        character._$image = null;
    }

    /**
     * @description InputElementにフォーカスした際の処理関数
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    focusIn (event)
    {
        super.focusIn(event);
        this.setLockElement(event);
    }

    /**
     * @description InputElement上でマウスを押下した際の処理関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        super.mouseDown(event);
        this.setLockElement(event);
    }

    /**
     * @description ロックが有効の際に対象となるElementを変数にセット
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    setLockElement (event)
    {
        if (this._$focus) {
            return ;
        }

        const filterId = event.target.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return ;
        }

        const object = this._$filters.get(filterId);
        if (!object.lock) {
            return ;
        }

        switch (this._$currentTarget.dataset.name) {

            case "blurX":
                this._$lockTarget = document
                    .getElementById(`blurY-${filterId}`);
                break;

            case "blurY":
                this._$lockTarget = document
                    .getElementById(`blurX-${filterId}`);
                break;

            default:
                break;

        }
    }

    /**
     * @description blueXの変更値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeBlurX (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_BLUR,
            FilterController.MAX_BLUR
        );

        this.updateProperty("blurX", value);

        return value;
    }

    /**
     * @description blueYの変更値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeBlurY (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_BLUR,
            FilterController.MAX_BLUR
        );

        this.updateProperty("blurY", value);

        return value;
    }

    /**
     * @description strengthの変更値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeStrength (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_STRENGTH,
            FilterController.MAX_STRENGTH
        );

        this.updateProperty("strength", value);

        return value;
    }

    /**
     * @description filterの透明度を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeAlpha (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_ALPHA,
            FilterController.MAX_ALPHA
        );

        this.updateProperty("alpha", value);

        return value;
    }

    /**
     * @description filterのシャドーの透明度を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeShadowAlpha (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_ALPHA,
            FilterController.MAX_ALPHA
        );

        this.updateProperty("shadowAlpha", value);

        return value;
    }

    /**
     * @description filterのハイライトの透明度を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeHighlightAlpha (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_ALPHA,
            FilterController.MAX_ALPHA
        );

        this.updateProperty("highlightAlpha", value);

        return value;
    }

    /**
     * @description filterの回転の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeAngle (value)
    {
        value = Util.$clamp(
            (value | 0) % 360,
            FilterController.MIN_ROTATE,
            FilterController.MAX_ROTATE
        );
        if (0 > value) {
            value += 360;
        }

        this.updateProperty("angle", value);

        return value;
    }

    /**
     * @description filterのdistanceの値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeDistance (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_DISTANCE,
            FilterController.MAX_DISTANCE
        );

        this.updateProperty("distance", value);

        return value;
    }

    /**
     * @description filterの指定カラーの値を更新
     *
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    changeColor (value)
    {
        this.updateProperty("color", Util.$clamp(
            `0x${value.slice(1)}` | 0,
            FilterController.MIN_COLOR,
            FilterController.MAX_COLOR
        ));

        return value;
    }

    /**
     * @description filterの指定シャドーカラーの値を更新
     *
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    changeShadowColor (value)
    {
        this.updateProperty("shadowColor", Util.$clamp(
            `0x${value.slice(1)}` | 0,
            FilterController.MIN_COLOR,
            FilterController.MAX_COLOR
        ));
        return value;
    }

    /**
     * @description filterの指定ハイライトカラーの値を更新
     *
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    changeHighlightColor (value)
    {
        this.updateProperty("highlightColor", Util.$clamp(
            `0x${value.slice(1)}` | 0,
            FilterController.MIN_COLOR,
            FilterController.MAX_COLOR
        ));
        return value;
    }

    /**
     * @description filterの指定カラーの値を更新
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeQuality (value)
    {
        value = Util.$clamp(
            value | 0,
            FilterController.MIN_QUALITY,
            FilterController.MAX_QUALITY
        );
        this.updateProperty("quality", value);
    }

    /**
     * @description filterのタイプの値を更新
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeType (value)
    {
        switch (value) {

            case "inner":
            case "outer":
            case "full":
                this.updateProperty("type", value);
                break;

            default:
                break;

        }
    }

    /**
     * @description Knockoutの変更値を更新
     *
     * @return {void}
     * @method
     * @public
     */
    changeKnockout ()
    {
        this.updateProperty("knockout", this._$currentTarget.checked);
    }

    /**
     * @description innerの変更値を更新
     *
     * @return {void}
     * @method
     * @public
     */
    changeInner ()
    {
        this.updateProperty("inner", this._$currentTarget.checked);
    }

    /**
     * @description hideObjectの変更値を更新
     *
     * @return {void}
     * @method
     * @public
     */
    changeHideObject ()
    {
        this.updateProperty("hideObject", this._$currentTarget.checked);
    }

    /**
     * @description filterのプロパティーを更新
     *
     * @param  {string} name
     * @param  {*} value
     * @return {void}
     * @method
     * @public
     */
    updateProperty (name, value)
    {
        const filterId = this._$currentTarget.dataset.filterId | 0;

        if (!this._$filters.has(filterId)) {
            return ;
        }

        const object = this._$filters.get(filterId);
        if (object.filter[name] === value) {
            return ;
        }

        object.filter[name] = value;
        this.disposeCharacterImage();
    }

    /**
     * @description 更新したDisplayObjectを再描画する為、内部キャッシュを削除する
     *
     * @return {void}
     * @method
     * @public
     */
    disposeCharacterImage ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const element = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                element.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        // tween情報があれば更新
        character.relocationTween(
            Util.$timelineFrame.currentFrame
        );

        // 再描画用にキャッシュを削除
        character._$image = null;
    }

    /**
     * @description フィルターの共有イベント処理
     *              (ロック・表示/非表示・有効/無効・削除)
     *
     * @param  {number} id
     * @return {void}
     * @method
     * @public
     */
    setCommonEvent (id)
    {
        this.setLockEvent(
            document.getElementById(`filter-${id}-lock`)
        );
        this.setTitleEvent(
            document.getElementById(`filter-name-${id}`)
        );
        this.setStateEvent(
            document.getElementById(`filter-state-${id}`)
        );
        this.setTrashEvent(
            document.getElementById(`trash-${id}`)
        );
    }

    /**
     * @description blurのロックイベントを登録
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setLockEvent (element)
    {
        if (!element) {
            return ;
        }

        element.addEventListener("mousedown", (event) =>
        {
            this.lock(event);
        });
    }

    /**
     * @description フィルターの表示・非表示イベント
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setTitleEvent (element)
    {
        if (!element) {
            return ;
        }

        element.addEventListener("mousedown", (event) =>
        {
            this.clickNodeTitle(event);
        });
    }

    /**
     * @description フィルターの有効・無効イベント
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setStateEvent (element)
    {
        if (!element) {
            return ;
        }

        const filterId = element.dataset.filterId | 0;
        if (this._$filters.has(filterId)) {
            const object = this._$filters.get(filterId);
            element
                .setAttribute("class", object.filter.state
                    ? "filter-active"
                    : "filter-disable"
                );
        }

        element.addEventListener("mousedown", (event) =>
        {
            this.save();

            this.changeState(event);

            this.reloadScreen();

            this._$saved = false;
        });
    }

    /**
     * @description フィルターの削除イベント
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setTrashEvent (element)
    {
        if (!element) {
            return ;
        }

        element.addEventListener("click", (event) =>
        {
            this.removeFilter(event);
            this.reloadScreen();
        });
    }

    /**
     * @description フィルターの追加処理関数
     *
     * @return {void}
     * @method
     * @public
     */
    addFilter ()
    {
        document
            .querySelectorAll(".filter-none")[0]
            .style.display = "none";

        const select = document.getElementById("filter-select");
        this[`add${select.value}`](
            document.getElementById("filter-setting-list")
        );
    }

    /**
     * @description フィルター表示を初期化
     *
     * @return {void}
     * @methodq
     * @public
     */
    clearFilters ()
    {
        this._$filterId = 0;
        this._$filters.clear();

        const element = document
            .getElementById("filter-setting-list");

        // テキストのElementは消えてもいいようにここで変数に格納しておく
        const textElement = document
            .querySelectorAll(".filter-none")[0];

        while (element.children.length) {
            element.children[0].remove();
        }

        // 表示してDOMに追加
        textElement.style.display = "";
        element.appendChild(textElement);
    }

    /**
     * @param  {function} filterClass
     * @param  {DropShadowFilter|BlurFilter|GlowFilter|BevelFilter|GradientGlowFilter|GradientBevelFilter} [filter=null]
     * @return {number}
     */
    createFilter (filterClass, filter = null)
    {
        const id = this._$filterId++;

        if (!filter) {

            filter = new filterClass();

            /**
             * @type {ArrowTool}
             */
            const tool = Util.$tools.getDefaultTool("arrow");
            const activeElements = tool.activeElements;
            if (!activeElements.length) {
                return ;
            }

            const target = activeElements[0];
            const scene  = Util.$currentWorkSpace().scene;
            const layer  = scene.getLayer(
                target.dataset.layerId | 0
            );

            const character = layer.getCharacter(
                target.dataset.characterId | 0
            );

            const frame = Util.$timelineFrame.currentFrame;

            let place = character.getPlace(frame);
            if (place.tweenFrame) {

                if (character.endFrame - 1 > frame && !character.hasTween(frame)) {

                    Util
                        .$timelineTool
                        .executeTimelineKeyAdd();

                    place = character.getPlace(frame);
                }

                place = character.getPlace(place.tweenFrame);
            }

            place.filter.push(filter);

            // tweenの情報を更新
            character.updateTweenFilter(frame);
        }

        // 複数のフィルターを管理するので、Mapで状態管理を行う
        this._$filters.set(id, {
            "id": id,
            "lock": false,
            "filter": filter,
            "context": null
        });

        return id;
    }

    /**
     * @description フィルター表示で共有化しているマークアップを返す
     *
     * @param  {number} id
     * @param  {string} name
     * @return {string}
     * @method
     * @public
     */
    getFilterHeaderHTML (id, name)
    {
        return `
<div id="filter-id-${id}" class="filter-border">

    <div class="filter-title">
        <i id="filter-title-arrow-${id}" class="arrow active"></i>
        <span id="filter-name-${id}" data-filter-id="${id}">${name}</span>
        <i class="filter-active" id="filter-state-${id}" data-filter-id="${id}" data-detail="{{フィルターを表示・非表示する}}"></i>
        <i class="trash" id="trash-${id}" data-filter-id="${id}" data-detail="{{フィルターを削除}}"></i>
    </div>
    
    <div id="filter-view-area-${id}" class="filter-view-area">
    
        <div class="filter-view-area-left">
        
            <div id="filter-${id}-lock" data-filter-id="${id}" class="filter-lock">
                ┌
                <div class="disable" data-detail="{{比率を固定}}"></div>
                └
            </div>
        
        </div>
`;
    }

    /**
     * @description DropShadowFilterを追加
     *
     * @param  {HTMLDivElement} element
     * @param  {DropShadowFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    addDropShadowFilter (element, filter = null, reload = true)
    {

        const id = this.createFilter(DropShadowFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = this.getFilterHeaderHTML(id, "DropShadow") + `

        <div class="filter-view-area-right">
        
            <div class="filter-container">
                <div class="filter-text">BlurX</div>
                <div><input type="text" id="blurX-${id}" value="${filter.blurX}" data-name="blurX" data-filter-id="${id}" data-detail="{{水平方向にぼかす}}"></div>
                
                <div class="filter-text">Strength</div>
                <div><input type="text" id="strength-${id}" value="${filter.strength}" data-filter-id="${id}" data-name="strength" data-detail="{{フィルター強度}}"></div>
            </div>
    
            <div class="filter-container">
                <div class="filter-text">BlurY</div>
                <div><input type="text" id="blurY-${id}" value="${filter.blurY}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
                
                <div class="filter-text">Angle</div>
                <div><input type="text" id="angle-${id}" value="${filter.angle}" data-filter-id="${id}" data-name="angle" data-detail="{{フィルター角度}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">Distance</div>
                <div><input type="text" id="distance-${id}" value="${filter.distance}" data-filter-id="${id}" data-name="distance" data-detail="{{フィルター距離}}"></div>
            </div>
    
            <div class="filter-container">
                <div class="filter-text">Shadow</div>
                <div><input type="color" id="color-${id}" value="#${filter.color.toString(16).padStart(6, "0")}" data-filter-id="${id}" data-name="color" data-detail="{{シャドウのカラー}}"></div>
                
                <div class="filter-text">Alpha</div>
                <div><input type="text" id="alpha-${id}" value="${filter.alpha}" data-filter-id="${id}" data-name="alpha" data-detail="{{シャドウのアルファ}}"></div>
            </div>
            
            <div class="filter-container">
                <div><input type="checkbox" id="knockout-${id}" data-name="knockout" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="knockout-${id}">Knockout</label>
                </div>
            </div>

            <div class="filter-container">
                <div><input type="checkbox" id="inner-${id}" data-name="inner" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="inner-${id}">Inner Shadow</label>
                </div>
            </div>
    
            <div class="filter-container">
                <div><input type="checkbox" id="hideObject-${id}" data-name="hideObject" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="hideObject-${id}">Hide Object</label>
                </div>
            </div>

            <div class="filter-container">
                <div class="filter-text-long">Quality</div>
                <div>
                    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
                        <option value="1">Low</option>
                        <option value="2">Middle</option>
                        <option value="3">High</option>
                    </select>
                </div>
            </div> 
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // 共有イベント処理
        this.setCommonEvent(id);

        // 保存データの場合はcheckboxの値を更新
        if (filter.knockout) {
            document
                .getElementById(`knockout-${id}`)
                .checked = true;
        }
        if (filter.inner) {
            document
                .getElementById(`inner-${id}`)
                .checked = true;
        }
        if (filter.hideObject) {
            document
                .getElementById(`hideObject-${id}`)
                .checked = true;
        }

        const inputIds = [
            `blurX-${id}`,
            `blurY-${id}`,
            `strength-${id}`,
            `angle-${id}`,
            `alpha-${id}`,
            `distance-${id}`
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const clickIds = [
            `knockout-${id}`,
            `inner-${id}`,
            `hideObject-${id}`
        ];

        for (let idx = 0; idx < clickIds.length; ++idx) {
            this.setClickEvent(
                document.getElementById(clickIds[idx])
            );
        }

        const changeIds = [
            `color-${id}`,
            `quality-${id}`
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(changeIds[idx])
            );
        }

        // 内部キャッシュを削除
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(
            document.getElementById(`filter-id-${id}`)
        );
    }

    /**
     * @param  {HTMLDivElement} element
     * @param  {BlurFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    addBlurFilter (element, filter = null, reload = true)
    {

        const id = this.createFilter(BlurFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = this.getFilterHeaderHTML(id, "Blur") + `
    
        <div class="filter-view-area-right">
        
            <div class="filter-container">
                <div class="filter-text">BlurX</div>
                <div><input type="text" id="blurX-${id}" value="${filter.blurX}" data-name="blurX" data-filter-id="${id}" data-detail="{{水平方向にぼかす}}"></div>
            </div>
        
            <div class="filter-container">
                <div class="filter-text">BlurY</div>
                <div><input type="text" id="blurY-${id}" value="${filter.blurY}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
            </div>
        
            <div class="filter-container">
                <div class="filter-text-long">Quality</div>
                <div>
                    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
                        <option value="1">Low</option>
                        <option value="2">Middle</option>
                        <option value="3">High</option>
                    </select>
                </div>
            </div> 
        
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // 共有イベント処理
        this.setCommonEvent(id);

        const inputIds = [
            `blurX-${id}`,
            `blurY-${id}`
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const changeIds = [
            `quality-${id}`
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(changeIds[idx])
            );
        }

        // 内部キャッシュを削除
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(
            document.getElementById(`filter-id-${id}`)
        );
    }

    /**
     * @param  {HTMLDivElement} element
     * @param  {GlowFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    addGlowFilter (element, filter = null, reload = true)
    {

        const id = this.createFilter(GlowFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = this.getFilterHeaderHTML(id, "Glow") + `

        <div class="filter-view-area-right">

            <div class="filter-container">
                <div class="filter-text">BlurX</div>
                <div><input type="text" id="blurX-${id}" value="${filter.blurX}" data-name="blurX" data-filter-id="${id}" data-detail="{{水平方向にぼかす}}"></div>
                
                <div class="filter-text">Strength</div>
                <div><input type="text" id="strength-${id}" value="${filter.strength}" data-filter-id="${id}" data-name="strength" data-detail="{{フィルター強度}}"></div>
            </div>
            
            <div class="filter-container">
                <div class="filter-text">BlurY</div>
                <div><input type="text" id="blurY-${id}" value="${filter.blurY}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">Color</div>
                <div><input type="color" id="color-${id}" value="#${filter.color.toString(16).padStart(6, "0")}" data-filter-id="${id}" data-name="color" data-detail="{{シャドウのカラー}}"></div>
                
                <div class="filter-text">Alpha</div>
                <div><input type="text" id="alpha-${id}" value="${filter.alpha}" data-filter-id="${id}" data-name="alpha" data-detail="{{シャドウのアルファ}}"></div>
            </div>
            
            <div class="filter-container">
                <div><input type="checkbox" id="inner-${id}" data-name="inner" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="inner-${id}">Inner Glow</label>
                </div>
            </div>
            
            <div class="filter-container">
                <div><input type="checkbox" id="knockout-${id}" data-name="knockout" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="knockout-${id}">Knockout</label>
                </div>
            </div>

            <div class="filter-container">
                <div class="filter-text-long">Quality</div>
                <div>
                    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
                        <option value="1">Low</option>
                        <option value="2">Middle</option>
                        <option value="3">High</option>
                    </select>
                </div>
            </div> 
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // 共有イベント処理
        this.setCommonEvent(id);

        // 保存データの場合はcheckboxの値を更新
        if (filter.knockout) {
            document
                .getElementById(`knockout-${id}`)
                .checked = true;
        }
        if (filter.inner) {
            document
                .getElementById(`inner-${id}`)
                .checked = true;
        }

        const inputIds = [
            `blurX-${id}`,
            `blurY-${id}`,
            `strength-${id}`,
            `alpha-${id}`,
            `distance-${id}`
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const clickIds = [
            `knockout-${id}`,
            `inner-${id}`
        ];

        for (let idx = 0; idx < clickIds.length; ++idx) {
            this.setClickEvent(
                document.getElementById(clickIds[idx])
            );
        }

        const changeIds = [
            `color-${id}`,
            `quality-${id}`
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(changeIds[idx])
            );
        }

        // 内部キャッシュを削除
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(
            document.getElementById(`filter-id-${id}`)
        );
    }

    /**
     * @param  {HTMLDivElement} element
     * @param  {BevelFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    addBevelFilter (element, filter = null, reload = true)
    {

        const id = this.createFilter(BevelFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = this.getFilterHeaderHTML(id, "Bevel") + `

        <div class="filter-view-area-right">

            <div class="filter-container">
                <div class="filter-text">BlurX</div>
                <div><input type="text" id="blurX-${id}" value="${filter.blurX}" data-name="blurX" data-filter-id="${id}" data-detail="{{水平方向にぼかす}}"></div>
                 
                <div class="filter-text">Strength</div>
                <div><input type="text" id="strength-${id}" value="${filter.strength}" data-filter-id="${id}" data-name="strength" data-detail="{{フィルター強度}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">BlurY</div>
                <div><input type="text" id="blurY-${id}" value="${filter.blurY}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
                               
                <div class="filter-text">Angle</div>
                <div><input type="text" id="angle-${id}" value="${filter.angle}" data-filter-id="${id}" data-name="angle" data-detail="{{フィルター角度}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">Distance</div>
                <div><input type="text" id="distance-${id}" value="${filter.distance}" data-filter-id="${id}" data-name="distance" data-detail="{{フィルター距離}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">Shadow<br>Color</div>
                <div><input type="color" id="shadowColor-${id}" value="#${filter.shadowColor.toString(16).padStart(6, "0")}" data-filter-id="${id}" data-name="shadowColor" data-detail="{{シャドウのカラー}}"></div>
                
                <div class="filter-text">Shadow<br>Alpha</div>
                <div><input type="text" id="shadowAlpha-${id}" value="${filter.shadowAlpha}" data-filter-id="${id}" data-name="shadowAlpha" data-detail="{{シャドウのアルファ}}"></div>
            </div>
            
            <div class="filter-container">
                <div class="filter-text">Highlight<br>Color</div>
                <div><input type="color" id="highlightColor-${id}" value="#${filter.highlightColor.toString(16).padStart(6, "0")}" data-filter-id="${id}" data-name="highlightColor" data-detail="{{ハイライトのカラー}}"></div>
                
                <div class="filter-text">Highlight<br>Alpha</div>
                <div><input type="text" id="highlightAlpha-${id}" value="${filter.highlightAlpha}" data-filter-id="${id}" data-name="highlightAlpha" data-detail="{{ハイライトのアルファ}}"></div>
            </div>
            
            <div class="filter-container">
                <div><input type="checkbox" id="knockout-${id}" data-name="knockout" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="knockout-${id}">Knockout</label>
                </div>
            </div>

            <div class="filter-container">
                <div class="filter-text-long">Type</div>
                <div>
                    <select id="type-${id}" data-name="type" data-filter-id="${id}">
                        <option value="inner">Inner</option>
                        <option value="outer">Outer</option>
                        <option value="full">Full</option>
                    </select>
                </div>
    
                <div class="filter-text-long">Quality</div>
                <div>
                    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
                        <option value="1">Low</option>
                        <option value="2">Middle</option>
                        <option value="3">High</option>
                    </select>
                </div>
            </div>
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // 共有イベント処理
        this.setCommonEvent(id);

        // 保存データの場合はcheckboxの値を更新
        if (filter.knockout) {
            document
                .getElementById(`knockout-${id}`)
                .checked = true;
        }

        const inputIds = [
            `blurX-${id}`,
            `blurY-${id}`,
            `strength-${id}`,
            `angle-${id}`,
            `shadowAlpha-${id}`,
            `highlightAlpha-${id}`,
            `distance-${id}`
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const clickIds = [
            `knockout-${id}`
        ];

        for (let idx = 0; idx < clickIds.length; ++idx) {
            this.setClickEvent(
                document.getElementById(clickIds[idx])
            );
        }

        const changeIds = [
            `shadowColor-${id}`,
            `highlightColor-${id}`,
            `type-${id}`,
            `quality-${id}`
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(changeIds[idx])
            );
        }

        // 内部キャッシュを削除
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(
            document.getElementById(`filter-id-${id}`)
        );
    }

    /**
     * @param  {HTMLDivElement} element
     * @param  {GradientGlowFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    addGradientGlowFilter (element, filter = null, reload = true)
    {

        const id = this.createFilter(GradientGlowFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = this.getFilterHeaderHTML(id, "GradientGlow") + `

        <div class="filter-view-area-right">

            <div class="filter-container">
                <div class="filter-text">BlurX</div>
                <div><input type="text" id="blurX-${id}" value="${filter.blurX}" data-name="blurX" data-filter-id="${id}" data-detail="{{水平方向にぼかす}}"></div>
                          
                <div class="filter-text">Strength</div>
                <div><input type="text" id="strength-${id}" value="${filter.strength}" data-filter-id="${id}" data-name="strength" data-detail="{{フィルター強度}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">BlurY</div>
                <div><input type="text" id="blurY-${id}" value="${filter.blurY}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
            
                <div class="filter-text">Angle</div>
                <div><input type="text" id="angle-${id}" value="${filter.angle}" data-filter-id="${id}" data-name="angle" data-detail="{{フィルター角度}}"></div>
            </div>

            <div class="filter-container">
                <div class="filter-text">Distance</div>
                <div><input type="text" id="distance-${id}" value="${filter.distance}" data-filter-id="${id}" data-name="distance" data-detail="{{フィルター距離}}"></div>
            </div>

            <div class="filter-container">
                <div id="gradient-color-palette-${id}" class="gradient-color-palette">
                    <div id="color-palette-${id}" class="color-palette">
                        <canvas id="gradient-canvas-${id}"></canvas>
                    </div>
                    <div id="color-pointer-list-${id}" data-filter-id="${id}" class="color-pointer-list" data-detail="{{カラーポインターを追加}}"></div>
                </div>
            </div>
            
            <div class="filter-container">
                <div class="filter-text">Color</div>
                <div><input type="color" id="gradientColor-${id}" value="#000000" data-detail="{{グラデーションカラー}}"></div>
                
                <div class="filter-text">Alpha</div>
                <div><input type="text" id="gradientAlpha-${id}" value="100" data-detail="{{グラデーションのアルファ}}"></div>
            </div>
            
            <div class="filter-container">
                <div><input type="checkbox" id="knockout-${id}" data-name="knockout" data-filter-id="${id}"></div>
                <div class="filter-text-long">
                    <label for="knockout-${id}">Knockout</label>
                </div>
            </div>

            <div class="filter-container">
                <div class="filter-text-long">Type</div>
                <div>
                    <select id="type-${id}" data-name="type" data-filter-id="${id}">
                        <option value="inner">Inner</option>
                        <option value="outer">Outer</option>
                        <option value="full">Full</option>
                    </select>
                </div>
    
                <div class="filter-text-long">Quality</div>
                <div>
                    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
                        <option value="1">Low</option>
                        <option value="2">Middle</option>
                        <option value="3">High</option>
                    </select>
                </div>
            </div>
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // グラデーションコントロール用のcanvas
        const canvas  = document.getElementById(`gradient-canvas-${id}`);
        canvas.width  = FilterController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio;
        canvas.height = FilterController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio;

        canvas.style.transform          = `scale(${1 / window.devicePixelRatio}, ${1 / window.devicePixelRatio})`;
        canvas.style.backfaceVisibility = "hidden";
        canvas.style.transformOrigin    = "0 0";

        filter.context = canvas.getContext("2d");

        // 共有イベント処理
        this.setCommonEvent(id);

        // 保存データの場合はcheckboxの値を更新
        if (filter.knockout) {
            document
                .getElementById(`knockout-${id}`)
                .checked = true;
        }

        const inputIds = [
            `blurX-${id}`,
            `blurY-${id}`,
            `strength-${id}`,
            `angle-${id}`,
            `gradientAlpha-${id}`,
            `distance-${id}`
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const clickIds = [
            `knockout-${id}`
        ];

        for (let idx = 0; idx < clickIds.length; ++idx) {
            this.setClickEvent(
                document.getElementById(clickIds[idx])
            );
        }

        const changeIds = [
            `gradientColor-${id}`,
            `type-${id}`,
            `quality-${id}`
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(changeIds[idx])
            );
        }

        // ポインターを追加
        for (let idx = 0; idx < filter.ratios.length; ++idx) {

            const ratio = filter.ratios[idx];
            const color = `#${filter.colors[idx].toString(16).padStart(6, "0")}`;
            const alpha = filter.alphas[idx];

            this.addFilterGradientColorPointer(id, idx, ratio, color, alpha);

        }

        // ポインター追加イベント
        this.setCreateGradientColorPointerEvent(id);

        // canvasを更新
        this.updateFilterGradientCanvas(filter);

        // 内部キャッシュを削除
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(
            document.getElementById(`filter-id-${id}`)
        );
    }
}

Util.$filterController = new FilterController();

/**
 * @class
 * @extends {BaseController}
 */
class GridController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("nine-slice");

        /**
         * @description 表示非表示の状態変数、初期値は非表示
         * @type {string}
         * @default "hide"
         * @private
         */
        this._$state = "hide";

        /**
         * @type {array}
         * @private
         */
        this._$elementIds = [
            "grid-top-left",
            "grid-top-right",
            "grid-bottom-left",
            "grid-bottom-right"
        ];

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$gridMouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$gridMouseUp = null;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const inputIds = [
            "nine-slice-setting-x",
            "nine-slice-setting-y",
            "nine-slice-setting-w",
            "nine-slice-setting-h"
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        // スクリーンのグリッドElementのイベントを登録
        for (let idx = 0; idx < this._$elementIds.length; ++idx) {

            const element = document.getElementById(this._$elementIds[idx]);
            if (!element) {
                continue;
            }

            // 初期は非表示
            element.style.display = "none";
            element.addEventListener("mousedown", (event) =>
            {
                this.standbyPointer(event);
            });
        }
    }

    /**
     * @description スクリーンの変形Elementの選択時の関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    standbyPointer (event)
    {
        // 親のイベントを中止する
        event.stopPropagation();

        const activeTool = Util.$tools.activeTool;
        if (activeTool) {
            event.grid = true;
            activeTool.dispatchEvent(
                EventType.MOUSE_DOWN,
                event
            );
        }
    }

    /**
     * @description グリッドのx座標の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeNineSliceSettingX (value)
    {
        this.updateShapeGrid (
            +value,
            +document.getElementById("nine-slice-setting-y").value,
            +document.getElementById("nine-slice-setting-w").value,
            +document.getElementById("nine-slice-setting-h").value
        );
        return +value;
    }

    /**
     * @description グリッドのy座標の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeNineSliceSettingY (value)
    {
        this.updateShapeGrid (
            +document.getElementById("nine-slice-setting-x").value,
            +value,
            +document.getElementById("nine-slice-setting-w").value,
            +document.getElementById("nine-slice-setting-h").value
        );
        return +value;
    }

    /**
     * @description グリッドの幅の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeNineSliceSettingW (value)
    {
        this.updateShapeGrid (
            +document.getElementById("nine-slice-setting-x").value,
            +document.getElementById("nine-slice-setting-y").value,
            +value,
            +document.getElementById("nine-slice-setting-h").value
        );
        return +value;
    }

    /**
     * @description グリッドの高さの値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeNineSliceSettingH (value)
    {
        this.updateShapeGrid (
            +document.getElementById("nine-slice-setting-x").value,
            +document.getElementById("nine-slice-setting-y").value,
            +document.getElementById("nine-slice-setting-w").value,
            +value
        );
        return +value;
    }

    /**
     * @description グリッドのElementの値を更新
     *
     * @param  {number} [x=0]
     * @param  {number} [y=0]
     * @param  {number} [w=0]
     * @param  {number} [h=0]
     * @return {void}
     * @method
     * @public
     */
    updateShapeGrid (x, y, w, h)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                activeElements[0].dataset.libraryId | 0
            );

        switch (0) {

            case x:
            case y:
                instance._$grid = null;
                this.hide();
                break;

            default:
                instance._$grid = {
                    "x": x,
                    "y": y,
                    "w": w,
                    "h": h
                };

                this
                    .show()
                    .relocation();
                break;

        }

        instance.cacheClear();
    }

    /**
     * @description スクリーンのグリッドElementを表示
     *
     * @return {GridController}
     * @method
     * @public
     */
    show ()
    {
        if (this._$state !== "show") {
            this._$state = "show";

            for (let idx = 0; idx < this._$elementIds.length; ++idx) {

                const element = document
                    .getElementById(this._$elementIds[idx]);

                if (!element) {
                    continue;
                }

                element.style.display = "";
            }
        }

        return this;
    }

    /**
     * @description スクリーンのグリッドElementを非表示
     *
     * @return {void}
     * @method
     * @public
     */
    hide ()
    {
        if (this._$state === "hide") {
            return ;
        }

        for (let idx = 0; idx < this._$elementIds.length; ++idx) {

            const element = document
                .getElementById(this._$elementIds[idx]);

            if (!element) {
                continue;
            }

            element.style.display = "none";
        }
        this._$state = "hide";
    }

    /**
     * @description スクリーンのグリッドElementを再配置
     *
     * @return {void}
     * @method
     * @public
     */
    relocation ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return this.hide();
        }

        const target      = activeElements[0];
        const characterId = target.dataset.characterId | 0;

        const element = document
            .getElementById(`character-${characterId}`);

        if (!element) {
            return this.hide();
        }

        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace.getLibrary(
            target.dataset.libraryId | 0
        );

        if (!instance || instance.type !== "shape") {
            return this.hide();
        }

        const grid = instance._$grid;
        if (!grid) {
            return this.hide();
        }

        const layerId   = target.dataset.layerId | 0;
        const layer     = workSpace.scene.getLayer(layerId);
        const character = layer.getCharacter(
            target.dataset.characterId | 0
        );

        if (character.rotation) {
            this.hide();
            return;
        }

        const bounds = character.getBounds();

        const x = element.offsetLeft;
        const y = element.offsetTop;
        const w = character.width  - Math.abs(bounds.xMax - bounds.xMin);
        const h = character.height - Math.abs(bounds.yMax - bounds.yMin);

        const topLeft = document.getElementById("grid-top-left");
        topLeft.style.left = `${x + grid.x - 4}px`;
        topLeft.style.top  = `${y + grid.y - 4}px`;

        const topRight = document.getElementById("grid-top-right");
        topRight.style.left = `${x + grid.x + grid.w + w - 4}px`;
        topRight.style.top  = `${y + grid.y - 4}px`;

        const bottomLeft = document.getElementById("grid-bottom-left");
        bottomLeft.style.left = `${x + grid.x - 4}px`;
        bottomLeft.style.top  = `${y + grid.y + grid.h + h - 4}px`;

        const bottomRight = document.getElementById("grid-bottom-right");
        bottomRight.style.left = `${x + grid.x + grid.w + w - 4}px`;
        bottomRight.style.top  = `${y + grid.y + grid.h + h - 4}px`;
    }
}

Util.$gridController = new GridController();

/**
 * @class
 */
class InstanceSelectController extends BaseController
{
    /**
     * @description ライブラリの選択インスタンスのプルダウン制御
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        // インスタンス設定は初期は非表示
        const element = document.getElementById("instance-setting");
        if (element) {
            element.style.display = "none";
        }
    }

    /**
     * @description ライブラリの選択可能なインスタンスをプルダウンにセット
     *
     * @param  {object} instance
     * @return {void}
     * @method
     * @public
     */
    createInstanceSelect (instance)
    {
        const workSpace = Util.$currentWorkSpace();

        const element = document
            .getElementById("instance-type-name");

        while (element.children.length) {
            element.children[0].remove();
        }

        // アイコンを登録
        const i = document.createElement("i");
        i.setAttribute("class", `library-type-${instance.type}`);
        element.appendChild(i);

        const select = document.createElement("select");
        select.classList.add("instance-select");

        select.addEventListener("change", (event) =>
        {
            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                event.displayObject = true;
                activeTool.dispatchEvent(
                    EventType.CHANGE,
                    event
                );
            }
        });

        for (const value of workSpace._$libraries.values()) {

            if (!value.id) {
                continue;
            }

            switch (value.type) {

                case "folder":
                case "sound":
                    continue;

                default:
                    break;

            }

            const option = document.createElement("option");
            option.value = value.id;

            // フォルダの場合はパス名を追加する
            let path = value.name;
            if (value._$folderId) {
                let parent = value;
                while (parent._$folderId) {
                    parent = workSpace.getLibrary(parent._$folderId);
                    path = `${parent.name}/${path}`;
                }
            }
            option.innerHTML = path;

            if (value.id === instance.id) {
                option.defaultSelected = true;
            }

            select.appendChild(option);
        }

        // DOMに登録
        element.appendChild(select);
    }
}

Util.$instanceSelectController = new InstanceSelectController();


/**
 * @class
 */
class JavascriptController
{
    /**
     * @return {void}
     * @method
     * @public
     */
    reload ()
    {
        const element = document
            .getElementById("javascript-internal-list-box");

        if (!element) {
            return;
        }

        // 表示リストを初期化
        const children = element.children;
        while (children.length) {
            children[0].remove();
        }

        const workSpaces = Util.$currentWorkSpace();

        for (const instance of workSpaces._$libraries.values()) {

            if (instance._$type !== "container") {
                continue;
            }

            if (!instance._$actions.size) {
                continue;
            }

            const id = instance.id;
            const parentTag = `<div id="script-${id}" data-library-id="${id}" class="internal-parent"><i></i>${instance._$name}</div>`;

            element.insertAdjacentHTML("beforeend", parentTag);

            const parentElement = document
                .getElementById(`script-${id}`);

            // eslint-disable-next-line no-loop-func
            parentElement.addEventListener("dblclick", (event) =>
            {
                Util.$sceneChange.reload(
                    event.currentTarget.dataset.libraryId | 0
                );
            });

            for (const frame of instance._$actions.keys()) {

                const childTag = `<div id="script-${id}-${frame}" data-library-id="${id}" data-frame="${frame}" class="internal-child"><i></i>frame ${frame}</div>`;

                element.insertAdjacentHTML("beforeend", childTag);

                const childElement = document
                    .getElementById(`script-${id}-${frame}`);

                // eslint-disable-next-line no-loop-func
                childElement.addEventListener("mousedown", (event) =>
                {
                    Util.$javaScriptEditor.hide();

                    const target = event.currentTarget;

                    const scene = Util
                        .$currentWorkSpace()
                        .getLibrary(target.dataset.libraryId | 0);

                    const frame = target.dataset.frame | 0;
                    Util.$javaScriptEditor.show(null, frame, scene);
                });
            }

        }
    }
}

Util.$javascriptController = new JavascriptController();

/**
 * @class
 */
class LibraryController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;

        /**
         * @type {Map}
         * @private
         */
        this._$activeInstances = new Map();

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @return {Map}
     * @public
     */
    get activeInstances ()
    {
        return this._$activeInstances;
    }

    /**
     * @param  {HTMLDivElement} element
     * @return {void}
     * @public
     */
    set activeInstance (element)
    {
        switch (true) {

            case Util.$ctrlKey && this.activeInstances.size > 0:
                {
                    const libraryId = element.dataset.libraryId | 0;

                    // 選択中であれば非アクティブに
                    if (this.activeInstances.has(libraryId)) {

                        this.activeInstances.delete(libraryId);

                        element
                            .classList
                            .remove("active");

                    } else {

                        // アクティブ化
                        this.activeInstances.set(libraryId, element);

                        element
                            .classList
                            .add("active");

                    }
                }
                break;

            case Util.$shiftKey && this.activeInstances.size > 0:
                {
                    const children = Array.from(document
                        .getElementById("library-list-box")
                        .children);

                    const startIndex = children.indexOf(
                        this.activeInstances.values().next().value
                    );

                    const selectIndex = children.indexOf(element);
                    if (selectIndex === -1 || selectIndex === startIndex) {
                        break;
                    }

                    // 初期化
                    this.clearActive();
                    if (selectIndex > startIndex) {

                        const length = selectIndex - startIndex + 1;
                        for (let idx = 0; length > idx; ++idx) {

                            const element = children[startIndex + idx];

                            this.activeInstances.set(
                                element.dataset.libraryId | 0, element
                            );

                            element
                                .classList
                                .add("active");
                        }

                    } else {

                        const length = startIndex - selectIndex + 1;
                        for (let idx = 0; length > idx; ++idx) {

                            const element = children[startIndex - idx];

                            this.activeInstances.set(
                                element.dataset.libraryId | 0, element
                            );

                            element
                                .classList
                                .add("active");
                        }

                    }

                }
                break;

            default:

                // 初期化
                this.clearActive();

                if (element) {
                    this.activeInstances.set(
                        element.dataset.libraryId | 0, element
                    );

                    element
                        .classList
                        .add("active");
                }
                break;

        }

    }

    /**
     * @description 選択中のアイテムを非アクティブ化
     *
     * @return {void}
     * @method
     * @public
     */
    clearActive ()
    {
        for (const element of this.activeInstances.values()) {
            element
                .classList
                .remove("active");
        }
        this.activeInstances.clear();

        // プレビューを初期化
        Util.$libraryPreview.dispose();
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const element = document
            .getElementById("library-list-box");

        if (element) {

            element.addEventListener("dragover", function (event)
            {
                event.preventDefault();
            });

            element.addEventListener("drop", (event) =>
            {
                this.drop(event);
            });

            element.addEventListener("dragstart", () =>
            {
                this.dragstart();
            });

            element.addEventListener("dragend", () =>
            {
                this.dragend();
            });

            element.addEventListener("mousedown", (event) =>
            {
                // 全てのイベントを中止
                event.stopPropagation();

                if (event.button) {
                    return ;
                }

                this.clearActive();
            });
        }

        // 終了コール
        Util.$initializeEnd();
    }

    /**
     * @description サウンドのselectを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clearSoundSelect ()
    {
        const element = document
            .getElementById("sound-select");

        while (element.children.length) {
            element.children[0].remove();
        }
    }

    /**
     * @description ライブラリのリストを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clearLibrary ()
    {
        const element = document
            .getElementById("library-list-box");

        while (element.children.length) {
            element.children[0].remove();
        }

        // 上書き管理のマップも初期化
        Util
            .$currentWorkSpace()
            ._$nameMap
            .clear();

        Util.$confirmModal.hide();
    }

    /**
     * @description ライブラリの情報の再読み込み
     *
     * @param  {array} libraries
     * @return {void}
     * @method
     * @public
     */
    reload (libraries = null)
    {
        const workSpace = Util.$currentWorkSpace();

        // 指定がなければ現在のタブのライブラリを使用する
        if (!libraries) {
            libraries = Array.from(
                workSpace._$libraries.values()
            );
        }

        // ライブラリ一覧を初期化
        this.clearLibrary();

        // サウンド情報を初期化
        this.clearSoundSelect();

        // 名前順に並び替え
        libraries.sort((a, b) =>
        {
            const aString = a.name.toLowerCase();
            const bString = b.name.toLowerCase();
            switch (true) {

                case aString > bString:
                    return 1;

                case aString < bString:
                    return -1;

                default:
                    return 0;

            }
        });

        const folderMap   = new Map();
        const childrenMap = new Map();

        // ライブラリにセット
        for (let idx = 0; idx < libraries.length; ++idx) {

            const value = libraries[idx];

            if (!value.id) {
                continue;
            }

            Util
                .$libraryController
                .createInstance(
                    value.type, value.name, value.id, value.symbol
                );

            let path = value.name;
            if (value._$folderId) {
                let parent = workSpace.getLibrary(value._$folderId);
                path = `${parent.name}/${path}`;
                while (parent._$folderId) {
                    parent = workSpace.getLibrary(parent._$folderId);
                    path = `${parent.name}/${path}`;
                }
            }

            workSpace
                ._$nameMap
                .set(path, value.id);

            // fixed logic
            if (value.type === "folder" && value.mode === Util.FOLDER_OPEN) {

                this.openFolder(value);

            }

            if (value.folderId) {

                const element = document
                    .getElementById(`library-child-id-${value.id}`);

                element.remove();

                if (!childrenMap.has(value.folderId)) {
                    childrenMap.set(value.folderId, []);
                }

                childrenMap
                    .get(value.folderId)
                    .push(element);
            }

            if (value.type === "folder") {
                folderMap.set(value.id, value);
            }
        }

        if (folderMap.size) {

            const parent = document
                .getElementById("library-list-box");

            const dup = new Map();
            while (folderMap.size !== dup.size) {

                for (const [folderId, folder] of folderMap) {

                    // 空のフォルダはスキップ
                    if (!childrenMap.has(folderId)) {
                        dup.set(folderId, true);
                        continue;
                    }

                    // 処理済みであればスキップ
                    if (dup.has(folderId)) {
                        continue;
                    }

                    const element = document
                        .getElementById(`library-child-id-${folder.id}`);

                    // 順番的にまだelementがない時は後続のタスクにする
                    if (!element) {
                        continue;
                    }

                    const children = childrenMap.get(folderId);
                    for (let idx = 0; idx < children.length; ++idx) {

                        const child = children[idx];

                        parent.insertBefore(
                            child, element.nextElementSibling
                        );

                        if (folder.mode === Util.FOLDER_CLOSE) {
                            child.style.display = "none";
                        }

                    }

                    // 終了管理
                    dup.set(folderId, true);
                }

                // 一番上位のフォルダから処理を実行
                for (const [folderId, folder] of folderMap) {

                    // 空のフォルダか、子孫のフォルダならスキップ
                    if (!childrenMap.has(folderId) || folder.folderId) {
                        continue;
                    }

                    this.updateFolderStyle(folder, folder.mode);
                }

            }

            dup.clear();
            folderMap.clear();
            childrenMap.clear();
        }

        // 重複登録防止のnameMapを生成
    }

    /**
     * @description ライブラリにコンテンツを生成
     *
     * @param  {string} type
     * @param  {string} name
     * @param  {uint}   id
     * @param  {string} [symbol=""]
     * @return {object}
     * @method
     * @public
     */
    createInstance (type, name, id, symbol = "")
    {
        const htmlTag = `
<div draggable="true" class="library-list-box-child" id="library-child-id-${id}" data-library-id="${id}">
    <div class="library-list-box-name">
        <i class="library-type-${type === "folder" ? "arrow close" : "space"}" id="arrow-${id}" data-library-id="${id}"></i>
        <i class="library-type-${type} " id="${type}-${id}" data-library-id="${id}"></i>
        <p>
            <span id="library-name-${id}" class="view-text" data-type="name" data-library-id="${id}">${name}</span>
            <input type="text" id="library-name-input-${id}" data-library-id="${id}" data-type="name" value="${name}" style="display: none;">
        </p>
    </div>
    <div class="library-list-box-symbol">
        <p>
            <span id="library-symbol-name-${id}" class="view-symbol-text" data-type="symbol" data-library-id="${id}">${symbol}</span>
            <input type="text" id="library-symbol-name-input-${id}" data-library-id="${id}" data-type="symbol" value="${symbol}" style="display: none;">
        </p>
    </div>
</div>`;

        const element = document
            .getElementById("library-list-box");

        element.insertAdjacentHTML("beforeend", htmlTag);

        if (type === "container") {
            document
                .getElementById(`${type}-${id}`)
                .addEventListener("dblclick", (event) =>
                {
                    Util.$sceneChange.reload(
                        event.currentTarget.dataset.libraryId | 0
                    );
                });
        }

        const child = document
            .getElementById(`library-child-id-${id}`);

        // 選択中のアイテムであれば上書きしてアクティブ化
        if (this.activeInstances.has(id)) {

            this.activeInstances.set(id, child);

            child
                .classList
                .add("active");
        }

        // elementの選択処理
        child.addEventListener("mousedown", (event) =>
        {
            this.selectInstance(event);
        });

        if (type === "folder") {

            child.addEventListener("dragover", (event) =>
            {
                event.preventDefault();
            });

            child.addEventListener("drop", (event) =>
            {
                this.folderIn(event);
            });

            const arrowElement = document.getElementById(`arrow-${id}`);
            arrowElement.addEventListener("mousedown", (event) =>
            {
                this.clickFolder(event);
            });

            const iconElement = document.getElementById(`${type}-${id}`);
            iconElement.addEventListener("dblclick", (event) =>
            {
                this.clickFolder(event);
            });

            iconElement
                .classList
                .remove("library-type-folder");

            iconElement
                .classList
                .add("library-type-folder-close");

        }

        if (type === "sound") {

            const option = document.createElement("option");
            option.value     = `${id}`;
            option.innerHTML = name;

            document
                .getElementById("sound-select")
                .appendChild(option);

        }

        const viewElements = [
            `library-name-${id}`
        ];

        if (type !== "folder") {
            viewElements.push(`library-symbol-name-${id}`);
        }

        for (let idx = 0; idx < viewElements.length; ++idx) {

            document
                .getElementById(viewElements[idx])
                .addEventListener("dblclick", (event) =>
                {
                    this.inputStart(event);
                });

        }

        const inputElements = [
            `library-name-input-${id}`
        ];

        if (type !== "folder") {
            inputElements.push(`library-symbol-name-input-${id}`);
        }

        for (let idx = 0; idx < inputElements.length; ++idx) {

            const input = document
                .getElementById(inputElements[idx]);

            input.addEventListener("focusout", (event) =>
            {
                this.inputEnd(event);
            });

            input.addEventListener("keypress", (event) =>
            {
                this.inputEnd(event);
            });

        }

        return {
            "id": id,
            "type": type,
            "name": name,
            "symbol": symbol
        };
    }

    /**
     * @description ライブラリアイテムの選択処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    selectInstance (event)
    {
        if (event.button) {
            return ;
        }

        // モーダルを非表示に
        Util.$endMenu();

        // 全てのイベントw中止
        event.stopPropagation();

        if (Util.$keyLock) {
            return ;
        }

        const target = event.currentTarget;

        if (!Util.$ctrlKey && !Util.$shiftKey
            && target.classList.contains("active")
        ) {
            return ;
        }

        this.activeInstance = target;

        // プレビューに表示
        Util
            .$libraryPreview
            .loadImage(
                target.dataset.libraryId | 0
            );
    }

    /**
     * @description inputタグを有効にする、移動を無効化
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    inputStart (event)
    {
        // キーロック
        Util.$keyLock = true;

        // 全てのイベントを中止
        event.stopPropagation();

        const target = event.target;
        const libraryId = target.dataset.libraryId | 0;

        const parent = document
            .getElementById(`library-child-id-${libraryId}`);

        parent
            .classList
            .remove("active");

        parent.draggable = false;

        const inputId = target.dataset.type === "name"
            ? `library-name-input-${libraryId}`
            : `library-symbol-name-input-${libraryId}`;

        const input = document.getElementById(inputId);
        input.value = target.textContent;
        input.style.display = "";
        input.focus();

        target.style.display = "none";
    }

    /**
     * @description inputタグを無効にする
     *
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    inputEnd (event)
    {
        if (event.key === "Enter") {
            event.target.blur();
            return ;
        }

        if (event.type === "focusout") {

            this.save();

            const target    = event.target;
            const libraryId = target.dataset.libraryId | 0;

            const library = Util
                .$currentWorkSpace()
                .getLibrary(libraryId);

            const viewId = target.dataset.type === "name"
                ? `library-name-${libraryId}`
                : `library-symbol-name-${libraryId}`;

            const element = document
                .getElementById(viewId);

            // データを更新
            library[target.dataset.type] = target.value;
            element.textContent   = target.value;
            element.style.display = "";

            const parent = document
                .getElementById(`library-child-id-${libraryId}`);

            if (this.activeInstances.has(libraryId)) {
                parent
                    .classList
                    .add("active");
            }

            target.style.display = "none";
            parent.draggable     = true;
            Util.$keyLock        = false;
            this._$saved         = false;

            if (target.dataset.type === "name") {
                this.reload();
            }
        }
    }

    /**
     * @description フォルダーアイコンをダブルクリックした処理
     *
     * @return {void}
     * @method
     * @public
     */
    clickFolder (event)
    {
        // 全てのイベント中止
        event.stopPropagation();

        const folder = Util
            .$currentWorkSpace()
            .getLibrary(
                event.target.dataset.libraryId | 0
            );

        if (folder.mode === Util.FOLDER_OPEN) {

            // 閉じる処理
            this.closeFolder(folder);

        } else {

            // 開く処理
            this.openFolder(folder);

        }

        this.updateFolderStyle(folder, folder.mode);
    }

    /**
     * @description フォルダーの内部にelementのスタイルを変更する
     *
     * @param  {Folder} folder
     * @param  {string} mode
     * @return {void}
     * @public
     */
    updateFolderStyle (folder, mode)
    {
        const workSpace = Util.$currentWorkSpace();

        const children = document
            .getElementById("library-list-box")
            .children;

        let depth = 20;
        let instanceId = folder.folderId;
        if (instanceId) {
            for (;;) {

                const instance = workSpace.getLibrary(instanceId);
                if (!instance) {
                    break;
                }

                depth += 20;

                instanceId = instance.folderId;
                if (!instanceId) {
                    break;
                }

            }
        }

        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];

            const instance = workSpace
                .getLibrary(node.dataset.libraryId | 0);

            if (!instance.folderId) {
                continue;
            }

            if (instance.folderId !== folder.id) {
                continue;
            }

            node.style.paddingLeft = `${depth}px`;
            node.style.display = mode === Util.FOLDER_OPEN
                ? ""
                : "none";

            if (instance.type === "folder") {
                this.updateFolderStyle(
                    instance,
                    mode === Util.FOLDER_OPEN ? instance.mode : mode
                );
            }
        }
    }

    /**
     * @description フォルダーを開く
     *
     * @param  {Folder} folder
     * @return {void}
     * @method
     * @public
     */
    openFolder (folder)
    {
        folder.mode = Util.FOLDER_OPEN;

        const iconElement = document
            .getElementById(`folder-${folder.id}`);

        iconElement
            .classList
            .remove("library-type-folder-close");

        iconElement
            .classList
            .add("library-type-folder-open");

        const arrowElement = document
            .getElementById(`arrow-${folder.id}`);

        arrowElement
            .classList
            .add("open");

        arrowElement
            .classList
            .remove("close");
    }

    /**
     * @description フォルダーを閉じる
     *
     * @param  {Folder} folder
     * @return {void}
     * @method
     * @public
     */
    closeFolder (folder)
    {
        folder.mode = Util.FOLDER_CLOSE;

        const iconElement = document
            .getElementById(`folder-${folder.id}`);

        iconElement
            .classList
            .remove("library-type-folder-open");

        iconElement
            .classList
            .add("library-type-folder-close");

        const arrowElement = document
            .getElementById(`arrow-${folder.id}`);

        arrowElement
            .classList
            .remove("open");

        arrowElement
            .classList
            .add("close");
    }

    /**
     * @description ドラッグ時はスクリーンのイベントを無効にする
     *
     * @return {void}
     * @method
     * @public
     */
    dragstart ()
    {
        const children = document
            .getElementById("stage-area")
            .children;

        for (let idx = 1; idx < children.length; ++idx) {
            children[idx].style.pointerEvents = "none";
        }
    }

    /**
     * @description ドラッグ終了時はスクリーンのイベントを有効にする
     *
     * @return {void}
     * @method
     * @public
     */
    dragend ()
    {
        const children = document
            .getElementById("stage-area")
            .children;

        for (let idx = 1; idx < children.length; ++idx) {

            const node = children[idx];
            if (node.dataset.preview) {
                continue;
            }

            node.style.pointerEvents = "";
        }
    }

    /**
     * @description ライブラリエリアにコンテンツのドロップ処理
     *
     * @param  {DragEvent} event
     * @return {void}
     * @method
     * @public
     */
    drop (event)
    {
        event.preventDefault();
        event.stopPropagation();

        this.save();

        const items = event.dataTransfer.items;
        if (items.length) {

            // 選択中のコンテンツを非アクティブに
            this.clearActive();

            const items = event.dataTransfer.items;
            for (let idx = 0; idx < items.length; ++idx) {
                this.scanFiles(
                    items[idx].webkitGetAsEntry()
                );
            }

        } else {

            // フォルダーの外に移動
            this.folderOut();

            // 再読み込み
            this.reload();
        }

        this._$saved = false;
    }

    /**
     * @description 読み込んだファイルのチェック
     *
     * @param  {FileSystemDirectoryEntry} entry
     * @param  {number} [folder_id=0]
     * @return {void}
     * @method
     * @public
     */
    scanFiles (entry, folder_id = 0)
    {
        switch (true) {

            case entry.isDirectory:
                {
                    const instance = Util
                        .$currentWorkSpace()
                        .addLibrary({
                            "id": Util.$currentWorkSpace().nextLibraryId,
                            "type": "folder",
                            "name": entry.name,
                            "symbol": ""
                        });

                    if (folder_id) {
                        instance.folderId = folder_id;
                    }

                    entry
                        .createReader()
                        .readEntries((entries) =>
                        {
                            for (let idx = 0; idx < entries.length; ++idx) {
                                this.scanFiles(entries[idx], instance.id);
                            }
                        });

                    this.updateFolderStyle(instance, instance.mode);
                }
                break;

            case entry.isFile:
                entry.file((file) =>
                {
                    this.loadFile(file, folder_id);
                });
                break;

        }
    }

    /**
     * @description 関連するコンテンツを表示と内部データから削除
     *
     * @param  {number} library_id
     * @return {void}
     * @method
     * @public
     */
    removeLibrary (library_id)
    {
        const element = document
            .getElementById(`library-child-id-${library_id}`);

        if (element) {
            element.remove();
        }

        const workSpace = Util.$currentWorkSpace();

        const instance = workSpace.getLibrary(library_id);
        if (!instance) {
            return ;
        }

        // SWFとSVGの場合はコンテナを基準に削除処理を行う
        if (instance.type === "container") {

            const libraryIds = new Map();
            for (const layer of instance._$layers.values()) {

                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                    const character = layer._$characters[idx];

                    if (!libraryIds.has(character.libraryId)) {
                        libraryIds.set(character.libraryId, true);
                    }

                    const instance = workSpace
                        .getLibrary(character.libraryId);

                    if (instance && instance.type === "container") {
                        this.removeLibrary(character.libraryId);
                    }
                }
            }

            if (libraryIds.size) {

                // 削除対象でないMovieClipで利用されていれば削除
                for (const libraryId of libraryIds.keys()) {

                    const instance = workSpace.getLibrary(libraryId);
                    if (!instance) {
                        continue;
                    }

                    const element = document
                        .getElementById(`library-child-id-${libraryId}`);

                    if (element) {
                        element.remove();
                    }

                    instance.remove();

                    workSpace.removeLibrary(libraryId);
                }
            }
        }

        workSpace.removeLibrary(library_id);
    }

    /**
     * @description 読み込み処理
     *
     * @param  {File} file
     * @param  {number} [folder_id=0]
     * @param  {string} [name=""]
     * @param  {number} [library_id=0]
     * @return {void}
     * @method
     * @public
     */
    loadFile (file, folder_id = 0, name = "", library_id = 0)
    {
        const workSpace = Util.$currentWorkSpace();

        let path = name || file.name;

        // swfの場合は拡張子を削除
        if (path.indexOf(".swf") > -1) {
            path = path.replace(".swf", "");
        }

        if (folder_id) {
            let parent = workSpace.getLibrary(folder_id);
            path = `${parent.name}/${path}`;
            while (parent._$folderId) {
                parent = workSpace.getLibrary(parent._$folderId);
                path = `${parent.name}/${path}`;
            }
        }

        // 上書き確認
        if (!library_id && workSpace._$nameMap.has(path)) {

            Util.$confirmModal.files.push({
                "file": file,
                "folderId": folder_id,
                "path": path
            });

            Util.$confirmModal.show();

            return ;
        }

        // 上書きの場合はElementと内部データを削除
        if (library_id) {
            this.removeLibrary(library_id);
        }

        switch (file.type) {

            case "image/svg+xml":
                file
                    .text()
                    .then((value) =>
                    {
                        const object = this.createInstance(
                            "container",
                            name || file.name,
                            library_id || workSpace.nextLibraryId
                        );

                        const movieClip = workSpace.addLibrary(object);

                        workSpace
                            ._$nameMap
                            .set(path, object.id);

                        // ドロップしたアイテムをアクティブ化
                        const element = document
                            .getElementById(`library-child-id-${object.id}`);

                        if (element) {
                            this.activeInstances.set(object.id, element);

                            element
                                .classList
                                .add("active");
                        }

                        if (folder_id) {
                            movieClip.folderId = folder_id;

                            const folder = workSpace.getLibrary(folder_id);

                            this.updateFolderStyle(folder, folder.mode);
                        }

                        SVGToShape.parse(value, movieClip);

                        // ライブラリ選択のselectを更新
                        Util
                            .$instanceSelectController
                            .createInstanceSelect(movieClip);

                        // ライブラリ一覧を再構成
                        Util.$libraryController.reload();

                        // プレビューを表示
                        Util.$libraryPreview.loadImage(movieClip.id);

                        // 上書きならスクリーンを再描画
                        if (library_id) {
                            this.reloadScreen(library_id);
                        }
                    });
                break;

            case "image/png":
            case "image/jpeg":
            case "image/gif":
                file
                    .arrayBuffer()
                    .then((buffer) =>
                    {

                        const blob = new Blob([buffer], {
                            "type": file.type
                        });

                        const image = new Image();
                        image.src = URL.createObjectURL(blob);
                        image
                            .decode()
                            .then(() =>
                            {
                                const width   = image.width;
                                const height  = image.height;

                                const canvas  = document.createElement("canvas");
                                canvas.width  = width;
                                canvas.height = height;
                                const context = canvas.getContext("2d");

                                context.drawImage(image, 0, 0, width, height);
                                const buffer = new Uint8Array(
                                    context.getImageData(0, 0, width, height).data
                                );

                                const object = this.createInstance(
                                    "bitmap",
                                    name || file.name,
                                    library_id || workSpace.nextLibraryId
                                );

                                workSpace
                                    ._$nameMap
                                    .set(path, object.id);

                                // ドロップしたアイテムをアクティブ化
                                const element = document
                                    .getElementById(`library-child-id-${object.id}`);

                                if (element) {
                                    this.activeInstances.set(object.id, element);

                                    element
                                        .classList
                                        .add("active");
                                }

                                object.width     = image.width;
                                object.height    = image.height;
                                object.imageType = file.type;
                                object.buffer    = new Uint8Array(buffer);

                                const instance = workSpace.addLibrary(object);

                                if (folder_id) {

                                    instance.folderId = folder_id;

                                    const folder = workSpace.getLibrary(folder_id);

                                    this.updateFolderStyle(folder, folder.mode);
                                }

                                // ライブラリ選択のselectを更新
                                Util
                                    .$instanceSelectController
                                    .createInstanceSelect(instance);

                                // ライブラリ一覧を再構成
                                Util.$libraryController.reload();

                                // プレビューを表示
                                Util.$libraryPreview.loadImage(instance.id);

                                // 上書きならスクリーンを再描画
                                if (library_id) {
                                    this.reloadScreen(library_id);
                                }
                            });

                    });
                break;

            case "video/mp4":
                file
                    .arrayBuffer()
                    .then((buffer) =>
                    {
                        const blob = new Blob([buffer], {
                            "type": file.type
                        });

                        const video = document.createElement("video");
                        video.onloadedmetadata = () =>
                        {
                            const object = this.createInstance(
                                "video",
                                name || file.name,
                                library_id || workSpace.nextLibraryId
                            );

                            workSpace
                                ._$nameMap
                                .set(path, object.id);

                            // ドロップしたアイテムをアクティブ化
                            const element = document
                                .getElementById(`library-child-id-${object.id}`);

                            if (element) {
                                this.activeInstances.set(object.id, element);

                                element
                                    .classList
                                    .add("active");
                            }

                            object.width  = video.videoWidth;
                            object.height = video.videoHeight;
                            object.buffer = new Uint8Array(buffer);

                            const instance = workSpace.addLibrary(object);
                            if (folder_id) {

                                instance.folderId = folder_id;

                                const folder = workSpace.getLibrary(folder_id);

                                this.updateFolderStyle(folder, folder.mode);
                            }

                            // ライブラリ選択のselectを更新
                            Util
                                .$instanceSelectController
                                .createInstanceSelect(instance);

                            // ライブラリ一覧を再構成
                            Util.$libraryController.reload();

                            // プレビューを表示
                            Util.$libraryPreview.loadImage(instance.id);

                            // 上書きならスクリーンを再描画
                            if (library_id) {
                                this.reloadScreen(library_id);
                            }
                        };

                        video.src = URL.createObjectURL(blob);
                        video.load();
                    });
                break;

            case "audio/mpeg":
                file
                    .arrayBuffer()
                    .then((buffer) =>
                    {
                        const object = this.createInstance(
                            "sound",
                            name || file.name,
                            library_id || workSpace.nextLibraryId
                        );

                        workSpace
                            ._$nameMap
                            .set(path, object.id);

                        // ドロップしたアイテムをアクティブ化
                        const element = document
                            .getElementById(`library-child-id-${object.id}`);

                        if (element) {
                            this.activeInstances.set(object.id, element);

                            element
                                .classList
                                .add("active");
                        }

                        object.buffer = new Uint8Array(buffer);

                        const instance = workSpace.addLibrary(object);

                        if (folder_id) {

                            instance.folderId = folder_id;

                            const folder = workSpace.getLibrary(folder_id);

                            this.updateFolderStyle(folder, folder.mode);

                        }

                        // ライブラリ一覧を再構成
                        Util.$libraryController.reload();

                        // プレビューを表示
                        Util.$libraryPreview.loadImage(instance.id);

                        // 上書きならスクリーンを再描画
                        if (library_id) {
                            this.reloadScreen(library_id);
                        }
                    });
                break;

            case "application/x-shockwave-flash":
                file
                    .arrayBuffer()
                    .then((buffer) =>
                    {
                        new ReComposition()
                            .setData(new Uint8Array(buffer))
                            .run(name || file.name, folder_id, library_id);
                    });
                break;

            default:
                break;

        }
    }

    /**
     * @description フォルダ外に移動
     *
     * @return {void}
     * @method
     * @public
     */
    folderOut ()
    {
        if (!this.activeInstances.size) {
            return ;
        }

        for (const element of this.activeInstances.values()) {

            const instance = Util
                .$currentWorkSpace()
                .getLibrary(
                    element.dataset.libraryId | 0
                );

            if (!instance) {
                continue;
            }

            // スタイルを初期化
            if (instance.folderId) {

                instance.folderId = 0;

                element.style.display     = "";
                element.style.paddingLeft = "";

            }

        }
    }

    /**
     * @description フォルダーにコンテンツを移動する
     *
     * @param  {DragEvent} event
     * @return {void}
     * @method
     * @public
     */
    folderIn (event)
    {
        if (!this.activeInstances.size) {
            return ;
        }

        this.save();

        event.stopPropagation();
        event.preventDefault();

        const workSpace = Util.$currentWorkSpace();

        const folderElement = event.currentTarget;
        const folder = workSpace
            .getLibrary(folderElement.dataset.libraryId | 0);

        for (const element of this.activeInstances.values()) {

            const instance = workSpace
                .getLibrary(element.dataset.libraryId | 0);

            // 格納するフォルダのIDをセット
            instance.folderId = folder.id;
        }

        this.reload();

        // 初期化
        this._$saved = false;
    }

    /**
     * @description undo用にデータを内部保管する
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }

    /**
     * @description スクリーンエリアで変更があったElementを再描画
     *
     * @param  {number} library_id
     * @return {void}
     * @method
     * @public
     */
    reloadScreen (library_id)
    {
        Util.$changeLibraryId = library_id;
        const frame = Util.$timelineFrame.currentFrame;

        Util
            .$currentWorkSpace()
            .scene
            .changeFrame(frame);

        Util.$changeLibraryId = 0;
    }
}

Util.$libraryController = new LibraryController();

/**
 * @class
 * @extends {BaseController}
 */
class LibraryExport extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$lock = false;

        /**
         * @type {Instance}
         * @default null
         * @private
         */
        this._$instance = null;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$xScale = 1;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$yScale = 1;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$currentFrame = 1;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$startFrame = 1;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$endFrame = 1;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$width = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$height = 0;
    }

    /**
     * @return {number}
     * @static
     */
    static get MAX_SIZE ()
    {
        return 0xfff;
    }

    /**
     * @return {number}
     * @static
     */
    static get MIN_SIZE ()
    {
        return 1;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "library-menu-export",
            "library-export-hide-icon",
            "library-export-size-lock",
            "library-export-execution"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                if (event.button) {
                    return ;
                }

                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                const names = event.currentTarget.id.split("-");

                let functionName = names
                    .map((value) =>
                    {
                        return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
                    })
                    .join("");

                this[`execute${functionName}`](event);
            });

        }

        const inputIds = [
            "export-width",
            "export-height",
            "export-start-frame",
            "export-end-frame",
            "export-current-frame"
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {

            const element = document.getElementById(inputIds[idx]);
            if (!element) {
                continue;
            }

            this.setInputEvent(element);
        }
    }

    /**
     * @description 書き出しの実行
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryExportExecution ()
    {
        // モーダルを終了
        Util.$endMenu();

        const ext = document
            .getElementById("library-export-file-type")
            .value;

        const name = document
            .getElementById("export-name")
            .value;

        switch (this._$instance.type) {

            case "container":
                {
                    const zip = new JSZip();
                    for (let frame = this._$startFrame; this._$endFrame >= frame; ++frame) {

                        const bitmapData = this.getBitmapData(frame);
                        const context    = bitmapData.getContext2D();

                        zip.file(
                            `${name}_frame_${frame}.${ext}`,
                            context.canvas.toDataURL(`image/${ext}`, 1).replace(/^.*,/, ""),
                            { "base64" : true }
                        );
                    }

                    zip
                        .generateAsync({ "type" : "blob" })
                        .then((content) =>
                        {
                            const url = URL.createObjectURL(content);

                            const anchor    = document.createElement("a");
                            anchor.download = `${name}.zip`;
                            anchor.href     = url;
                            anchor.click();

                            URL.revokeObjectURL(url);
                        });
                }
                break;

            case "video":
                {
                    const names = name.split(".");
                    if (names[names.length - 1] === "mp4") {
                        names.pop();
                    }

                    const anchor = document.createElement("a");

                    anchor.download = `${names.join(".")}.mp4`;
                    anchor.href = URL.createObjectURL(new Blob(
                        [new Uint8Array(this._$instance._$buffer)],
                        { "type": "video/mp4" }
                    ));

                    anchor.click();
                }
                break;

            case "sound":
                {
                    const names = name.split(".");
                    if (names[names.length - 1] === "mp3") {
                        names.pop();
                    }

                    const anchor = document.createElement("a");

                    anchor.download = `${names.join(".")}.mp3`;
                    anchor.href = URL.createObjectURL(new Blob(
                        [new Uint8Array(this._$instance._$buffer)],
                        { "type": "audio/mp3" }
                    ));

                    anchor.click();
                }
                break;

            default:
                {
                    const bitmapData = this.getBitmapData();
                    const context    = bitmapData.getContext2D();

                    const anchor    = document.createElement("a");
                    anchor.download = `${name}.${ext}`;
                    anchor.href     = context.canvas.toDataURL(`image/${ext}`, 1);
                    anchor.click();
                }
                break;
        }
    }

    /**
     * @description ロックのOn/Off関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeLibraryExportSizeLock (event)
    {
        // ロックのOn/Off
        this._$lock = !this._$lock;

        // 初期化
        this._$currentValue = null;

        event
            .currentTarget
            .childNodes[1]
            .setAttribute("class", this._$lock
                ? "active"
                : "disable"
            );
    }

    /**
     * @description 書き出しの幅の設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeExportWidth (value)
    {
        value = Util.$clamp(+value,
            LibraryExport.MIN_SIZE,
            LibraryExport.MAX_SIZE
        );

        // xスケールの更新
        this._$xScale = value / this._$width;

        if (this._$lock) {
            this._$yScale = this._$xScale;

            document
                .getElementById("export-height")
                .value = `${Math.ceil(this._$height * this._$yScale)}`;
        }

        this.appendImage();

        return value;
    }

    /**
     * @description 書き出しの高さの設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeExportHeight (value)
    {
        value = Util.$clamp(+value,
            LibraryExport.MIN_SIZE,
            LibraryExport.MAX_SIZE
        );

        // yスケールの更新
        this._$yScale = value / this._$height;

        if (this._$lock) {
            this._$xScale = this._$yScale;

            document
                .getElementById("export-width")
                .value = `${Math.ceil(this._$width * this._$xScale)}`;
        }

        this.appendImage();

        return value;
    }

    /**
     * @description MovieClipの書き出しの開始フレームの設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeExportStartFrame (value)
    {
        value = Util.$clamp(value | 0,
            1,
            this._$instance.totalFrame
        );

        this._$startFrame = value;

        // 開始フレームが最終フレーム設定を上回った補正
        const element = document
            .getElementById("export-end-frame");

        const endFrame = element.value | 0;
        if (value > endFrame) {
            element.value   = `${value}`;
            this._$endFrame = value;
        }

        if (value > this._$currentFrame) {
            document
                .getElementById("export-current-frame")
                .value = `${value}`;
            this._$currentFrame = value;
        }

        // 再計算
        this.reloadMovieClip();

        this.appendImage();

        return value;
    }

    /**
     * @description MovieClipの書き出しの終了フレームの設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeExportEndFrame (value)
    {
        value = Util.$clamp(value | 0,
            1,
            this._$instance.totalFrame
        );

        // 最終フレームが開始フレーム設定を下回った補正
        const element = document
            .getElementById("export-start-frame");

        const startFrame = element.value | 0;
        if (startFrame > value) {
            element.value     = `${value}`;
            this._$startFrame = value;
        }

        if (this._$currentFrame > value) {
            document
                .getElementById("export-current-frame")
                .value = `${value}`;
            this._$currentFrame = value;
        }

        // 再計算
        this.reloadMovieClip();

        this.appendImage();

        return value;
    }

    /**
     * @description MovieClipの表示したいフレームの設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeExportCurrentFrame (value)
    {
        value = Util.$clamp(value | 0,
            this._$startFrame,
            this._$endFrame
        );

        this._$currentFrame = value;

        this.appendImage();

        return value;
    }

    /**
     * @description 書き出しモーダルを非表示に
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryExportHideIcon ()
    {
        Util.$endMenu();
    }

    /**
     * @description 指定範囲のMovieClipの表示幅を再計算
     *
     * @return {void}
     * @method
     * @public
     */
    reloadMovieClip ()
    {
        const bounds  = this.getBounds();
        this._$width  = Math.abs(bounds.xMax - bounds.xMin);
        this._$height = Math.abs(bounds.yMax - bounds.yMin);

        document
            .getElementById("export-start-frame")
            .value = `${this._$startFrame}`;

        document
            .getElementById("export-end-frame")
            .value = `${this._$endFrame}`;

        document
            .getElementById("export-width")
            .value = `${Math.ceil(this._$width)}`;

        document
            .getElementById("export-height")
            .value = `${Math.ceil(this._$height)}`;
    }

    /**
     * @description 指定したアイテムを画像として書き出す
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuExport ()
    {
        const activeInstances = Util
            .$libraryController
            .activeInstances;

        if (!activeInstances.size) {
            return ;
        }

        // 書き出すアイテムの情報をセット
        const LibraryElement = activeInstances.values().next().value;

        this._$instance = Util.$currentWorkSpace().getLibrary(
            LibraryElement.dataset.libraryId | 0
        );

        // 初期化
        this._$lock   = false;
        this._$xScale = 1;
        this._$yScale = 1;

        document
            .getElementById("library-export-size-lock")
            .childNodes[1]
            .setAttribute("class", "disable");

        const containerArea = document
            .getElementById("library-export-container-area");

        const sizeArea = document
            .getElementById("library-export-size-area");

        const fileArea = document
            .getElementById("library-export-file-area");

        switch (this._$instance.type) {

            case "container":
                this._$currentFrame = 1;
                this._$startFrame   = 1;
                this._$endFrame     = this._$instance.totalFrame;

                // 書き出し項目のを表示設定
                containerArea.style.display = "";
                sizeArea.style.display      = "";
                fileArea.style.display      = "";

                this.reloadMovieClip();
                break;

            case "video":
            case "sound":
                // 書き出し項目のを表示設定
                containerArea.style.display = "none";
                sizeArea.style.display      = "none";
                fileArea.style.display      = "none";
                break;

            default:
                {
                    // 書き出し項目のを表示設定
                    containerArea.style.display = "none";
                    sizeArea.style.display      = "";
                    fileArea.style.display      = "";

                    const bounds = this._$instance.getBounds();
                    this._$width  = Math.abs(bounds.xMax - bounds.xMin);
                    this._$height = Math.abs(bounds.yMax - bounds.yMin);

                    // サイズをセット
                    document
                        .getElementById("export-width")
                        .value  = `${Math.ceil(this._$width)}`;

                    document
                        .getElementById("export-height")
                        .value = `${Math.ceil(this._$height)}`;
                }
                break;

        }

        document
            .getElementById("export-name")
            .value = `${this._$instance.name}`;

        // プレビュー画面を初期化して画像をセット
        this.appendImage();

        // 書き出しモーダル以外を終了
        Util.$endMenu("library-export-modal");

        // 書き出しのモーダルを表示
        const element = document
            .getElementById("library-export-modal");

        element.style.display = "";
        element.setAttribute("class", "fadeIn");
    }

    /**
     * @description 表示領域を返す
     *
     * @return {object}
     * @method
     * @public
     */
    getBounds ()
    {
        const matrix = [1, 0, 0, 1, 0, 0];

        const place = {
            "frame": 1,
            "matrix": matrix,
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": [],
            "loop": Util.$getDefaultLoopConfig()
        };

        const range = {
            "startFrame": 1,
            "endFrame": this._$instance.totalFrame + 1
        };

        const currentFrame = Util.$currentFrame;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;
        for (let frame = this._$startFrame; this._$endFrame >= frame; ++frame) {

            place.frame = Util.$currentFrame = frame;

            const bounds = this._$instance.getBounds(matrix, place, range);

            xMin = Math.min(bounds.xMin, xMin);
            xMax = Math.max(bounds.xMax, xMax);
            yMin = Math.min(bounds.yMin, yMin);
            yMax = Math.max(bounds.yMax, yMax);
        }

        // reset
        Util.$currentFrame = currentFrame;

        return {
            "xMin": xMin,
            "xMax": xMax,
            "yMin": yMin,
            "yMax": yMax
        };
    }

    /**
     * @description プレビューのイメージを初期化
     *
     * @return {LibraryExport}
     * @method
     * @public
     */
    removeImage ()
    {
        const element = document.getElementById("library-export-image");
        if (element) {
            while (element.firstChild) {
                element.firstChild.remove();
            }
        }
    }

    /**
     * @description プレビュー画像をセット
     *
     * @return {void}
     * @method
     * @public
     */
    appendImage ()
    {
        this.removeImage();

        switch (this._$instance.type) {

            case "video":
            case "sound":
                document
                    .getElementById("library-export-image")
                    .appendChild(this._$instance.getPreview());
                break;

            default:
                {
                    const bitmapData = this.getBitmapData(this._$currentFrame);

                    const ratio  = window.devicePixelRatio;

                    const element  = new Image();
                    element.src    = bitmapData.toDataURL();
                    element.width  = bitmapData.width  / ratio;
                    element.height = bitmapData.height / ratio;

                    // BitmapDataを解放
                    bitmapData.dispose();

                    document
                        .getElementById("library-export-image")
                        .appendChild(element);
                }
                break;

        }
    }

    /**
     * @param  {number} width
     * @param  {number} height
     * @param  {object} place
     * @param  {object} [range=null]
     * @param  {number} [dx=0]
     * @param  {number} [dy=0]
     * @return {next2d.display.BitmapData}
     * @method
     * @public
     */
    createBitmapData (width, height, place, range, dx = 0, dy = 0)
    {
        const { Matrix } = window.next2d.geom;

        const instance = this
            ._$instance
            .createInstance(place, range);

        const matrix = this._$instance.calcMatrix(
            instance, width, height, place, dx, dy
        );

        instance
            .transform
            .matrix = new Matrix(
                place.matrix[0], place.matrix[1],
                place.matrix[2], place.matrix[3],
                0, 0
            );

        instance
            .transform
            .colorTransform = this._$instance.calcColorTransform(place);

        const object = this
            ._$instance
            .calcFilter(width, height, place, matrix);

        instance.filters = object.filters;

        const container = this
            ._$instance
            .createContainer(instance);

        const bitmapData = this
            ._$instance
            .createBitmapData(width, height);

        bitmapData.draw(container, matrix);

        return bitmapData;
    }

    /**
     * @description Elementを生成
     *
     * @param  {number} frame
     * @return {next2d.display.BitmapData}
     * @method
     * @public
     */
    getBitmapData (frame = 1)
    {
        const currentFrame = Util.$currentFrame;
        const zoomScale    = Util.$zoomScale;

        let xScale = 1;
        if (this._$width * this._$xScale > 450) {
            xScale = 450 / (this._$width * this._$xScale);
        }

        let yScale = 1;
        if (this._$height * this._$yScale > 450) {
            yScale = 450 / (this._$height * this._$yScale);
        }

        const scale = Math.min(xScale, yScale);

        Util.$currentFrame = frame;
        Util.$zoomScale    = 1;

        const range = this._$instance.type === "container"
            ? {
                "startFrame": 1,
                "endFrame": this._$instance.totalFrame + 1
            }
            : null;

        const place = {
            "frame": frame,
            "matrix": [1, 0, 0, 1, 0, 0],
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": [],
            "loop": Util.$getDefaultLoopConfig()
        };

        const bounds = this.getBounds();

        const instanceBounds = this
            ._$instance
            .getBounds([1, 0, 0, 1, 0, 0], place, range);

        place.matrix[0] = this._$xScale * scale;
        place.matrix[3] = this._$yScale * scale;

        const bitmapData = this.createBitmapData(
            Math.ceil(this._$width  * this._$xScale * scale),
            Math.ceil(this._$height * this._$yScale * scale),
            place, range,
            -bounds.xMin + instanceBounds.xMin,
            -bounds.yMin + instanceBounds.yMin
        );

        // reset
        Util.$zoomScale    = zoomScale;
        Util.$currentFrame = currentFrame;

        return bitmapData;
    }
}

Util.$libraryExport = new LibraryExport();

/**
 * @class
 * @extends {KeyboardCommand}
 */
class LibraryKeyboardCommand extends KeyboardCommand
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("library");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document
            .getElementById("library-list-box");

        if (element) {

            element.addEventListener("mouseleave", () =>
            {
                this.active = false;
            });

            element.addEventListener("mouseover", () =>
            {
                if (!this.active) {
                    this.active = true;
                }
            });
        }

        // 選択したアイテムを削除
        this.add("Backspace", this.executeInstanceDelete);

        // スクリーンで使用してないアイテムを全て削除
        this.add(
            Util.$generateShortcutKey("Backspace", { "ctrl": true, "shift": true }),
            this.executeNoUseInstanceDelete
        );

        // MovieClipを追加
        this.add(
            Util.$generateShortcutKey("m", { "ctrl": true }),
            this.addMovieClip
        );

        // フォルダーを追加
        this.add(
            Util.$generateShortcutKey("f", { "ctrl": true }),
            this.addFolder
        );

        // 外部ファイル読み込み
        this.add(
            Util.$generateShortcutKey("r", { "ctrl": true }),
            this.loadFile
        );

        // Shapeを複製
        this.add(
            Util.$generateShortcutKey("s", { "alt": true }),
            this.cloneShape
        );

        // 指定したアイテムの書き出し
        this.add(
            Util.$generateShortcutKey("s", { "ctrl": true, "shift": true }),
            this.showOutputModal
        );
    }

    /**
     * @description 指定したアイテムを書き出し
     *
     * @return {void}
     * @method
     * @public
     */
    showOutputModal ()
    {
        Util
            .$libraryExport
            .executeLibraryMenuExport();
    }

    /**
     * @description 指定したShapeを複製
     *
     * @return {void}
     * @method
     * @public
     */
    cloneShape ()
    {
        Util
            .$libraryMenu
            .executeLibraryMenuContentShapeClone();
    }

    /**
     * @description 外部ファイルの読み込み
     *
     * @return {void}
     * @method
     * @public
     */
    loadFile ()
    {
        Util.$shiftKey = false;
        Util.$ctrlKey  = false;
        Util.$altKey   = false;

        document
            .getElementById("library-menu-file-input")
            .click();
    }

    /**
     * @description フォルダーを追加
     *
     * @return {void}
     * @method
     * @public
     */
    addFolder ()
    {
        Util
            .$libraryMenu
            .executeLibraryMenuFolderAdd();
    }

    /**
     * @description 空のMovieClipを追加
     *
     * @return {void}
     * @method
     * @public
     */
    addMovieClip ()
    {
        Util
            .$libraryMenu
            .executeLibraryMenuContainerAdd();
    }

    /**
     * @description 選択したアイテムを削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeInstanceDelete ()
    {
        Util
            .$libraryMenu
            .executeLibraryMenuDelete();
    }

    /**
     * @description 選択したアイテムを削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeNoUseInstanceDelete ()
    {
        Util.$libraryMenu.executeLibraryMenuNoUseDelete();
    }
}

Util.$libraryKeyboardCommand = new LibraryKeyboardCommand();

/**
 * @class
 */
class LibraryMenu
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const element = document.getElementById("library-list-box");
        if (element) {

            element.addEventListener("contextmenu", (event) =>
            {
                this.show(event);
            });

            element.addEventListener("mousedown", (event) =>
            {
                if (event.button) {
                    return ;
                }

                this.hide();
            });

        }

        const elementIds = [
            "library-menu-container-add",
            "library-menu-folder-add",
            "library-menu-content-shape-clone",
            "library-menu-file",
            "library-menu-delete",
            "library-menu-no-use-delete"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                if (event.button) {
                    return ;
                }

                // 表示モーダルを全て終了
                Util.$endMenu();

                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                const names = event.target.id.split("-");

                let functionName = names
                    .map((value) =>
                    {
                        return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
                    })
                    .join("");

                this[`execute${functionName}`](event);
            });

        }

        const fileInput = document
            .getElementById("library-menu-file-input");

        if (fileInput) {

            fileInput.addEventListener("change", (event) =>
            {
                this.save();

                const files = event.target.files;
                for (let idx = 0; idx < files.length; ++idx) {
                    Util.$libraryController.loadFile(files[idx]);
                }

                event.target.value = "";
                this._$saved = false;
            });
        }

        // 終了コール
        Util.$initializeEnd();
    }

    /**
     * @description 新規のコンテナを生成
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuContainerAdd ()
    {
        this.save();

        const workSpace = Util.$currentWorkSpace();

        const id = workSpace.nextLibraryId;
        workSpace.addLibrary({
            "id": id,
            "type": "container",
            "name": `MovieClip_${id}`,
            "symbol": ""
        });

        this._$saved = false;

        // 再読み込み
        Util.$libraryController.reload();
    }

    /**
     * @description 新規のフォルダを生成
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuFolderAdd ()
    {
        this.save();

        const workSpace = Util.$currentWorkSpace();

        const id = workSpace.nextLibraryId;
        const folder = workSpace.addLibrary({
            "id": id,
            "type": "folder",
            "name": `Folder_${id}`,
            "symbol": ""
        });

        // 選択中のアイテムがあればフォルダーの中に格納
        const activeInstances = Util
            .$libraryController
            .activeInstances;

        if (activeInstances.size) {
            for (let libraryId of activeInstances.keys()) {

                const instance = workSpace.getLibrary(libraryId);

                instance.folderId = id;
            }

            folder.mode = Util.FOLDER_OPEN;
        }

        // 再読み込み
        Util.$libraryController.reload();

        this._$saved = false;
    }

    /**
     * @description 指定したShapeを複製する
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuContentShapeClone ()
    {
        const activeInstances = Util
            .$libraryController
            .activeInstances;

        if (!activeInstances.size) {
            return ;
        }

        let reload = false;
        const workSpace = Util.$currentWorkSpace();
        for (const libraryId of activeInstances.keys()) {

            const instance = workSpace.getLibrary(libraryId);
            if (instance.type !== "shape") {
                continue;
            }

            reload = true;
            this.save();

            const id = workSpace.nextLibraryId;
            const shape = workSpace.addLibrary(
                Util
                    .$libraryController
                    .createInstance(instance.type, `${instance.name}_Clone`, id)
            );

            instance.copyFrom(shape);
        }

        if (reload) {
            Util.$libraryController.reload();
        }

        this._$saved = false;
    }

    /**
     * @description 外部ファイルの読み込み処理
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuFile (event)
    {
        event.preventDefault();

        document
            .getElementById("library-menu-file-input")
            .click();
    }

    /**
     * @description 選択中のアイテムを削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuDelete ()
    {
        const activeInstances = Util
            .$libraryController
            .activeInstances;

        if (!activeInstances.size) {
            return ;
        }

        this.save();

        const workSpace = Util.$currentWorkSpace();
        for (const element of activeInstances.values()) {

            const libraryId = element.dataset.libraryId | 0;
            const instance = workSpace.getLibrary(libraryId);
            if (!instance) {
                continue;
            }

            // 削除関数を実行
            instance.remove();

            // elementを削除
            element.remove();

            // 内部データからも削除
            workSpace.removeLibrary(libraryId);
        }

        // 選択中のアイテムを解放
        activeInstances.clear();

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clearActiveElement();

        // スクリーンエリアの変形Elementを非表示に
        Util.$transformController.hide();
        Util.$gridController.hide();
        Util.$tweenController.clearPointer();

        // コントローラーエリアを初期化
        Util.$controller.default();

        // JavaScriptのリストを再読み込み
        Util.$javascriptController.reload();

        // ライブラリを再読み込み
        Util.$libraryController.reload();

        // プレビューを初期化
        Util.$libraryPreview.dispose();

        // 現在の配置での再計算
        Util.$timelineLayer.activeCharacter();

        // シーンを再読み込み
        workSpace.scene.changeFrame(
            Util.$timelineFrame.currentFrame
        );

        this._$saved = false;
    }

    /**
     * @description スクリーンに配置されていないアイテムを全て削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuNoUseDelete ()
    {
        let reload = false;
        const workSpace = Util.$currentWorkSpace();

        // 使用中のidを検索
        const useIds = new Map();
        for (let instance of workSpace._$libraries.values()) {

            if (instance.type !== "container") {
                continue;
            }

            for (let layer of instance._$layers.values()) {

                const characters = layer._$characters;
                for (let idx = 0; idx < characters.length; ++idx) {

                    const libraryId = characters[idx].libraryId;
                    if (useIds.has(libraryId)) {
                        continue;
                    }

                    useIds.set(libraryId, true);
                }
            }

            if (instance._$sounds.size) {
                for (const sounds of instance._$sounds.values()) {
                    for (let idx = 0; idx < sounds.length; ++idx) {

                        const sound = sounds[idx];
                        useIds.set(sound.characterId, true);

                    }
                }
            }
        }

        // 削除処理
        for (let instance of workSpace._$libraries.values()) {

            if (useIds.has(instance.id)
                || instance.type === "folder"
                || instance.type === "container"
            ) {
                continue;
            }

            this.save();
            reload = true;

            workSpace.removeLibrary(instance.id);
        }

        if (reload) {

            Util
                .$libraryController
                .clearActive();

            // JavaScriptのリストを再読み込み
            Util.$javascriptController.reload();

            // ライブラリを再読み込み
            Util.$libraryController.reload();
        }

        this._$saved = false;
    }

    /**
     * @description ライブラリのメニューを表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    show (event)
    {
        const element = document
            .getElementById("library-menu");

        element.style.left = element.clientWidth + event.pageX + 5 > window.innerWidth
            ? `${event.pageX - (element.clientWidth + event.pageX + 10 - window.innerWidth)}px`
            : `${event.pageX + 5}px`;

        element.style.top = `${event.pageY - element.clientHeight / 2}px`;
        element.setAttribute("class", "fadeIn");

        Util.$endMenu("library-menu");
    }

    /**
     * @description モーダルを非表示
     *
     * @return {void}
     * @method
     * @public
     */
    hide ()
    {
        Util.$endMenu();
    }

    /**
     * @description undo用にデータを内部保管する
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }
}

Util.$libraryMenu = new LibraryMenu();

/**
 * @class
 */
class LibraryPreview
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$currentId = -1;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const element = document
            .getElementById("library-preview-area");

        if (element) {

            element.addEventListener("mousedown", (event) =>
            {
                this.mousedown(event);
            });

            element.addEventListener("dragstart", () =>
            {
                Util.$libraryController.dragstart();
            });

            element.addEventListener("dragend", () =>
            {
                Util.$libraryController.dragend();
            });
        }

        // 終了コール
        Util.$initializeEnd();
    }

    /**
     * @description プレビューエリアのドラッグを無効化
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseout (event)
    {
        if (this._$currentId === -1) {
            return ;
        }

        // 全てのイベントを中止
        event.stopPropagation();

        document
            .getElementById("library-preview-area")
            .draggable = false;
    }

    /**
     * @description プレビューエリアをタップした時の処理関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mousedown (event)
    {
        if (this._$currentId === -1) {
            return ;
        }

        // 全てのイベントを中止
        event.stopPropagation();

        const target = document
            .getElementById(`library-child-id-${this._$currentId}`);

        if (target) {

            // 現在のプレビューをキャッシュ
            const preview = document
                .getElementById("library-preview-area");

            const children = Array.from(document
                .getElementById("library-preview-area")
                .children);

            Util
                .$libraryController
                .activeInstance = target;

            // プレビューを再描画
            for (let idx = 0; idx < children.length; ++idx) {
                preview.appendChild(children[idx]);
            }

            preview.draggable = true;
        }
    }

    /**
     * @description プレビューエリアを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    dispose ()
    {
        this._$currentId = -1;

        // 初期化
        const element = document
            .getElementById("library-preview-area");

        while (element.firstChild) {
            element.firstChild.remove();
        }

        element.draggable = false;
    }

    /**
     * @description 選択したインスタンスの情報をプレビューエリアに表示
     *
     * @param  {number} library_id
     * @return {void}
     * @method
     * @public
     */
    loadImage (library_id)
    {
        // 初期化
        this.dispose();

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(library_id);

        if (instance.type !== "folder") {

            this._$currentId = library_id;

            document
                .getElementById("library-preview-area")
                .appendChild(instance.getPreview());

        }
    }
}

Util.$libraryPreview = new LibraryPreview();

/**
 * @class
 */
class LibrarySearch
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const element = document
            .getElementById("library-search");

        if (element) {

            element.addEventListener("focusin", () =>
            {
                Util.$keyLock = true;
            });
            element.addEventListener("focusout", () =>
            {
                Util.$keyLock = false;
            });
            element.addEventListener("input", (event) =>
            {
                this.execute(event);
            });

        }

        // 終了コール
        Util.$initializeEnd();
    }

    /**
     * @description inputの値をライブラリ内で検索
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    execute (event)
    {
        const value = event.target.value;

        const children = document
            .getElementById("library-list-box")
            .children;

        const length = children.length;
        for (let idx = 0; idx < length; ++idx) {

            const node = children[idx];

            if (!value
                || node.children[0].innerText.indexOf(value) > -1
                || node.children[1].innerText.indexOf(value) > -1
            ) {
                node.style.display = "";
                continue;
            }

            node.style.display = "none";
        }
    }
}

Util.$librarySearch = new LibrarySearch();

/**
 * @class
 * @extends {BaseController}
 */
class LoopController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super("loop");

        /**
         * @type {string}
         * @default "start"
         * @private
         */
        this._$frameTarget = "start";
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "no-use-loop",
            "loop-repeat",
            "loop-no-repeat",
            "fixed-one",
            "loop-no-repeat-reversal",
            "loop-repeat-reversal",
            "frame-picker-button",
            "target-start-button",
            "target-end-button"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            element.addEventListener("mousedown", (event) =>
            {
                // 他のイベントを中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event.target.id, event);
            });
        }

        const inputIds = [
            "loop-start-frame",
            "loop-end-frame"
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {

            const element = document.getElementById(inputIds[idx]);
            if (!element) {
                continue;
            }

            this.setInputEvent(element);
        }
    }

    /**
     * @description ループの開始フレームを設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeLoopStartFrame (value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return value;
        }

        const element = activeElements[0];

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        if (!character) {
            return value;
        }

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                character.libraryId
            );

        if (!instance) {
            return value;
        }

        value = Util.$clamp(value | 0, 1, instance.totalFrame);

        const frame = Util.$timelineFrame.currentFrame;
        const range = character.getRange(frame);

        let place = character.getPlace(range.startFrame);
        if (!place.loop) {
            return value;
        }

        // ループタイプを更新してキャッシュを削除
        place.loop.start  = value;
        character._$image = null;

        // 再描画
        this.reloadScreen();

        return value;
    }

    /**
     * @description ループの終了フレームを設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeLoopEndFrame (value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return value;
        }

        const element = activeElements[0];

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        if (!character) {
            return value;
        }

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                character.libraryId
            );

        if (!instance) {
            return value;
        }

        value = Util.$clamp(value | 0, 0, instance.totalFrame);

        const frame = Util.$timelineFrame.currentFrame;
        const range = character.getRange(frame);

        let place = character.getPlace(range.startFrame);
        if (!place.loop) {
            return value;
        }

        // ループタイプを更新してキャッシュを削除
        place.loop.end    = value;
        character._$image = null;

        // 再描画
        this.reloadScreen();

        return value ? value : "-";
    }

    /**
     * @description フレーム毎のイメージを生成
     *
     * @return {void}
     * @method
     * @public
     */
    changeFramePickerButton ()
    {
        document
            .getElementById("loop-image-list")
            .style.display = "none";

        this.loadLoopFrameList();
    }

    /**
     * @description
     *
     * @return {void}
     * @method
     * @public
     */
    changeTargetStartButton ()
    {
        const element = document
            .getElementById("target-start-button");

        if (!element.classList.contains("active")) {
            element.classList.add("active");
        }

        document
            .getElementById("target-end-button")
            .classList.remove("active");

        this._$frameTarget = "start";
    }

    /**
     * @description
     *
     * @return {void}
     * @method
     * @public
     */
    changeTargetEndButton ()
    {
        const element = document
            .getElementById("target-end-button");

        if (!element.classList.contains("active")) {
            element.classList.add("active");
        }

        document
            .getElementById("target-start-button")
            .classList.remove("active");

        this._$frameTarget = "end";
    }

    /**
     * @description カスタムループ機能をOnに
     *
     * @return {void}
     * @method
     * @public
     */
    changeLoopRepeat ()
    {
        const element = document
            .getElementById("loop-repeat");

        // 全てのボタンを非アクティブに
        this.clearLoopButton(element);

        element.classList.add("active");

        this.updateLoopType(0);
    }

    /**
     * @description カスタムループの1回終了機能をOnに
     *
     * @return {void}
     * @method
     * @public
     */
    changeLoopNoRepeat ()
    {
        const element = document
            .getElementById("loop-no-repeat");

        // 全てのボタンを非アクティブに
        this.clearLoopButton(element);

        element.classList.add("active");

        this.updateLoopType(1);
    }

    /**
     * @description 指定フレームに固定
     *
     * @return {void}
     * @method
     * @public
     */
    changeFixedOne ()
    {
        const element = document
            .getElementById("fixed-one");

        // 全てのボタンを非アクティブに
        this.clearLoopButton(element);

        element.classList.add("active");

        this.updateLoopType(2);
    }

    /**
     * @description カスタムループの逆再生の1回終了機能をOnに
     *
     * @return {void}
     * @method
     * @public
     */
    changeLoopNoRepeatReversal ()
    {
        const element = document
            .getElementById("loop-no-repeat-reversal");

        // 全てのボタンを非アクティブに
        this.clearLoopButton(element);

        element.classList.add("active");

        this.updateLoopType(3);
    }

    /**
     * @description カスタムループ機能の逆再生をOnに
     *
     * @return {void}
     * @method
     * @public
     */
    changeLoopRepeatReversal ()
    {
        const element = document
            .getElementById("loop-repeat-reversal");

        // 全てのボタンを非アクティブに
        this.clearLoopButton(element);

        element.classList.add("active");

        this.updateLoopType(4);
    }

    /**
     * @description Playerのループ機能をOn
     *
     * @return {void}
     * @method
     * @public
     */
    changeNoUseLoop ()
    {
        const element = document
            .getElementById("no-use-loop");

        // 全てのボタンを非アクティブに
        this.clearLoopButton(element);

        element.classList.add("active");

        this.updateLoopType(5);
    }

    /**
     * @description 全てのボタンを非アクティブに
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    clearLoopButton (element)
    {
        // 全てのボタンを非アクティブに
        const children = element.parentNode.children;
        for (let idx = 0; idx < children.length; ++idx) {
            children[idx]
                .classList
                .remove("active");
        }
    }

    /**
     * @description 初期化
     *
     * @param  {object} loop_setting
     * @return {void}
     * @method
     * @public
     */
    reload (loop_setting)
    {
        const children = document
            .getElementById("loop-setting-view-area")
            .firstElementChild.children;

        for (let idx = 0; idx < children.length; ++idx) {
            children[idx].classList.remove("active");
        }

        const element = document
            .getElementById("loop-image-list");

        while (element.children.length) {
            element.children[0].remove();
        }

        const types = [
            "loop-repeat",
            "loop-no-repeat",
            "fixed-one",
            "loop-no-repeat-reversal",
            "loop-repeat-reversal",
            "no-use-loop"
        ];

        document
            .getElementById(types[loop_setting.type])
            .classList.add("active");

        document
            .getElementById("loop-start-frame")
            .value = `${loop_setting.start}`;

        document
            .getElementById("loop-end-frame")
            .value = `${loop_setting.end ? loop_setting.end : "-"}`;
    }

    /**
     * @return {void}
     * @public
     */
    loadLoopFrameList ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        // イメージ表示を初期化
        const element = document
            .getElementById("loop-image-list");

        const children = element.children;
        while (children.length) {
            children[0].remove();
        }

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        const target = activeElements[0];

        const layerId = target.dataset.layerId | 0;
        const layer   = scene.getLayer(layerId);

        const characterId = target.dataset.characterId | 0;
        const character   = layer.getCharacter(characterId);

        const range = {
            "startFrame": character.startFrame,
            "endFrame": character.endFrame
        };

        const instance = workSpace.getLibrary(character.libraryId);

        const currentFrame = Util.$timelineFrame.currentFrame;

        const promises = [];
        const endFrame = instance.totalFrame;
        for (let frame = 1; endFrame >= frame; ++frame) {

            // eslint-disable-next-line no-loop-func
            promises.push(new Promise((resolve) =>
            {
                window.requestAnimationFrame(() =>
                {
                    const { Sprite, BitmapData } = window.next2d.display;
                    const { Matrix, ColorTransform } = window.next2d.geom;

                    Util.$currentFrame = frame;

                    const sprite = new Sprite();

                    const placeObject = {
                        "frame": frame,
                        "matrix": [1, 0, 0, 1, 0, 0],
                        "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                        "blendMode": "normal",
                        "filter": [],
                        "loop": Util.$getDefaultLoopConfig()
                    };

                    const displayObject = sprite
                        .addChild(
                            instance.createInstance(placeObject, range)
                        );

                    displayObject
                        .transform
                        .matrix = new Matrix();

                    displayObject
                        .transform
                        .colorTransform = new ColorTransform();

                    const bounds = instance.getBounds(
                        [1, 0, 0, 1, 0, 0], placeObject, range
                    );

                    const width  = Math.ceil(Math.abs(bounds.xMax - bounds.xMin));
                    const height = Math.ceil(Math.abs(bounds.yMax - bounds.yMin));
                    const scale  = Math.min(95 / width, 95 / height);
                    const ratio  = window.devicePixelRatio;

                    const bitmapData = new BitmapData(
                        width  * scale * ratio,
                        height * scale * ratio,
                        true, 0
                    );

                    const matrix = new Matrix(
                        ratio, 0, 0, ratio,
                        -bounds.xMin * ratio,
                        -bounds.yMin * ratio
                    );

                    matrix.scale(scale, scale);
                    bitmapData.draw(sprite, matrix);

                    const image = new Image();
                    image.onload = () =>
                    {
                        return resolve({
                            "index": frame - 1,
                            "image": image
                        });
                    };

                    image.src    = bitmapData.toDataURL();
                    image.width  = bitmapData.width  / ratio;
                    image.height = bitmapData.height / ratio;

                    bitmapData.dispose();
                });
            }));
        }

        Promise.all(promises)
            .then((results) =>
            {
                // reset
                Util.$currentFrame = currentFrame;

                const images = [];
                for (let idx = 0; idx < results.length; ++idx) {
                    const object = results[idx];
                    images[object.index] = object.image;
                }

                for (let idx = 0; idx < images.length; ++idx) {

                    const frame = idx + 1;

                    const span = document.createElement("span");
                    span.textContent = `[ ${frame} ]`;

                    const p = document.createElement("p");
                    p.appendChild(images[idx]);

                    const div = document.createElement("div");
                    div.dataset.frame = `${frame}`;

                    div.appendChild(p);
                    div.appendChild(span);

                    // eslint-disable-next-line no-loop-func
                    div.addEventListener("click", (event) =>
                    {
                        this.clickImage(event);
                    });

                    element.appendChild(div);
                }

                element.style.display = "";
            });
    }

    /**
     * @description フレームのイメージを押下してフレーム番号を適用
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    clickImage (event)
    {
        // 他のイベントを中止
        event.stopPropagation();

        const element = document
            .getElementById(
                `loop-${this._$frameTarget}-frame`
            );

        this.save();

        element.focus();
        element.value = event.currentTarget.dataset.frame;
        element.blur();

        this._$saved = false;
    }

    /**
     * @description ループタイプの更新
     *
     * @param  {number} [type=0]
     * @return {void}
     * @method
     * @public
     */
    updateLoopType (type = 0)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const element = activeElements[0];

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        if (!character) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;
        const range = character.getRange(frame);

        let place = character.getPlace(range.startFrame);
        if (place.loop.type === type) {
            return ;
        }

        // ループタイプを更新してキャッシュを削除
        place.loop.type   = type;
        character._$image = null;

        // 再描画
        this.reloadScreen();
    }
}

Util.$loopController = new LoopController();

/**
 * @class
 */
class ObjectController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("object");
    }

    /**
     * @description オブジェクトコントローラーの初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const objectName = document.getElementById("object-name");
        if (objectName) {
            objectName.addEventListener("focusout", (event) =>
            {
                this.finishInput(event, false);
            });
            objectName.addEventListener("keypress", (event) =>
            {
                this.finishInput(event, false);
            });
            objectName.addEventListener("focusin", (event) =>
            {
                this.focusIn(event);
            });
        }

        const objectSymbol = document.getElementById("object-symbol");
        if (objectSymbol) {
            objectSymbol.addEventListener("focusout", (event) =>
            {
                this.finishInput(event, false);
            });
            objectSymbol.addEventListener("keypress", (event) =>
            {
                this.finishInput(event, false);
            });
            objectSymbol.addEventListener("focusin", (event) =>
            {
                this.focusIn(event);
            });
        }
    }

    /**
     * @description シンボル名を反映
     *
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    changeObjectSymbol (value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        switch (tool.activeElements.length) {

            case 0:
                Util
                    .$currentWorkSpace()
                    .scene
                    .symbol = value;
                break;

            case 1:
                {
                    const element = tool.activeElements[0];
                    Util
                        .$currentWorkSpace()
                        .getLibrary(
                            element.dataset.libraryId | 0
                        )
                        .symbol = value;
                }
                break;

            default:
                break;

        }

        return value;
    }

    /**
     * @description インスタン名を反映
     *
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    changeObjectName (value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        switch (tool.activeElements.length) {

            case 0:
                Util
                    .$currentWorkSpace()
                    .scene
                    .name = value;
                break;

            case 1:
                {
                    const element = tool.activeElements[0];

                    const layer = Util
                        .$currentWorkSpace()
                        .scene
                        .getLayer(
                            element.dataset.layerId | 0
                        );

                    const character = layer.getCharacter(
                        element.dataset.characterId | 0
                    );

                    character.name = value;
                }
                break;

            default:
                break;

        }

        return value;
    }
}

Util.$objectController = new ObjectController();

/**
 * @class
 */
class PluginController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$selectElement = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$deleteCommand = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        this._$deleteCommand = this.deleteCommand.bind(this);

        const element = document.getElementById("plugin-list-box");
        if (element) {

            element.addEventListener("mouseleave", () =>
            {
                this.mouseleave();
            });

            element.addEventListener("dragover", (event) =>
            {
                event.preventDefault();
            });

            element.addEventListener("drop", (event) =>
            {
                this.dropElement(event);
            });
        }

        // 終了コール
        Util.$initializeEnd();
    }

    /**
     * @description 選択したElementを解放
     *
     * @param  {DragEvent} event
     * @return {void}
     * @method
     * @public
     */
    dropElement (event)
    {
        this.save();

        event.preventDefault();

        const workSpace = Util.$currentWorkSpace();

        const promises = [];

        const files = event.dataTransfer.files;
        for (let idx = 0; idx < files.length; ++idx) {

            const file = files[idx];

            promises.push(file
                .text()
                .then((src) =>
                {
                    // 上書き
                    workSpace._$plugins.set(file.name, {
                        "name": file.name,
                        "src": src
                    });
                }));

        }

        Promise
            .all(promises)
            .then(() =>
            {
                this.reload(
                    Array.from(Util.$currentWorkSpace()._$plugins.values())
                );

                this._$saved = false;
            });
    }

    /**
     * @description 選択したElementを解放
     *
     * @return {void}
     * @method
     * @public
     */
    mouseleave ()
    {
        if (this._$selectElement) {
            this
                ._$selectElement
                .classList
                .remove("active");
        }

        window
            .removeEventListener("keydown", this._$deleteCommand);

        this._$selectElement = null;
    }

    /**
     * @description プラグインデータを追加
     *
     * @param  {array} plugins
     * @return {void}
     * @method
     * @public
     */
    reload (plugins)
    {
        // elementを初期化
        const elementIds = [
            "plugin-list-box",
            "plugin-tools",
            "plugin-menu"
        ];

        // プラグインで追加されたelementを初期化
        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document
                .getElementById(elementIds[idx]);

            if (!element) {
                continue;
            }

            while (element.children.length) {
                element.children[0].remove();
            }

        }

        const scripts = document.getElementsByTagName("script");
        for (let idx = 0; idx < scripts.length; ++idx) {

            const element = scripts[idx];
            if (!element.dataset.plugin) {
                continue;
            }

            element.remove();
        }

        for (let idx = 0; idx < plugins.length; ++idx) {

            const plugin = plugins[idx];

            const element = document.getElementById(plugin.name);
            if (element) {
                continue;
            }

            this.appendScript(plugin.name, plugin.src);
            this.appendNode(plugin.name);
        }
    }

    /**
     * @description 取り込んだscriptをhtmlに挿入する
     *
     * @param  {string} name
     * @param  {string} src
     * @return {void}
     * @method
     * @public
     */
    appendScript (name, src)
    {
        const script = document.createElement("script");
        script.dataset.plugin = "true";

        script.async = true;
        script.id    = name;
        script.type  = "text/javascript";
        script.src   = URL.createObjectURL(
            new Blob([src], {
                "type": "text/javascript"
            })
        );

        document
            .getElementsByTagName("head")[0]
            .appendChild(script);
    }

    /**
     * @description プラグインの一覧にelementを追加
     *
     * @param  {string} name
     * @return {void}
     * @method
     * @public
     */
    appendNode (name)
    {
        const div = document.createElement("div");
        div.dataset.id   = `${name}_node`;
        div.dataset.name = `${name}`;
        div.classList.add("plugin-list");
        div.innerHTML = `<i></i>${name}`;

        div.addEventListener("mousedown", (event) =>
        {
            if (!this._$selectElement) {
                window
                    .addEventListener("keydown", this._$deleteCommand);
            }

            if (this._$selectElement) {
                this
                    ._$selectElement
                    .classList
                    .remove("active");
            }

            // 選択したelementをセット
            this._$selectElement = event.currentTarget;

            this
                ._$selectElement
                .classList
                .add("active");
        });

        document
            .getElementById("plugin-list-box")
            .appendChild(div);
    }

    /**
     * @description 選択しているプラグインを削除
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    deleteCommand (event)
    {
        if (Util.$keyLock) {
            return ;
        }

        // 削除キー以外はスキップ
        if (event.key !== "Backspace") {
            return ;
        }

        this.save();

        window
            .removeEventListener("keydown", this._$deleteCommand);

        // 削除処理
        this.dispose(this._$selectElement);

        // 初期化
        this._$selectElement = null;
        this._$saved = false;
    }

    /**
     * @description 削除処理
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    dispose (element)
    {
        const name = element.dataset.name;

        // スクリプトを削除
        const plugin = document.getElementById(name);
        if (plugin) {
            plugin.remove();
        }

        Util
            .$currentWorkSpace()
            ._$plugins.delete(name);

        // elementを削除
        element.remove();
    }

    /**
     * @description undo用にデータを内部保管する
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }
}

Util.$pluginController = new PluginController();

/**
 * @class
 */
class PluginPanel
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$screenX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$screenY = 0;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$moveModal = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endModal = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const elementIds = [
            "plugin-bar",
            "plugin-hide-icon"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                const names = event.target.id.split("-");

                let functionName = names
                    .map((value) =>
                    {
                        return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
                    })
                    .join("");

                this[`execute${functionName}`](event);

                // 表示モーダルを全て終了
                Util.$endMenu();
            });

        }

        document
            .documentElement
            .style
            .setProperty(
                "--plugin-panel-width",
                `${PluginPanel.PLUGIN_DEFAULT_WIDTH}px`
            );

        document
            .documentElement
            .style
            .setProperty(
                "--plugin-panel-height",
                `${PluginPanel.PLUGIN_DEFAULT_HEIGHT}px`
            );

        // 終了コール
        Util.$initializeEnd();
    }

    /**
     * @return {number}
     * @static
     * @const
     */
    static get PLUGIN_DEFAULT_WIDTH ()
    {
        return 200;
    }

    /**
     * @return {number}
     * @static
     * @const
     */
    static get PLUGIN_DEFAULT_HEIGHT ()
    {
        return 200;
    }

    /**
     * @description プラグインのモーダルの移動イベントを起動
     *
     * @return {void}
     * @method
     * @public
     */
    executePluginBar (event)
    {
        this._$screenX = event.screenX;
        this._$screenY = event.screenY;

        if (!this._$moveModal) {
            this._$moveModal = this.moveModal.bind(this);
        }

        if (!this._$endModal) {
            this._$endModal = this.endModal.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$moveModal);
        window.addEventListener("mouseup", this._$endModal);
    }

    /**
     * @description プラグインのモーダルの移動処理
     *
     * @return {void}
     * @method
     * @public
     */
    moveModal (event)
    {
        const element = document
            .getElementById("plugin-modal");

        element.style.left = `${element.offsetLeft + (event.screenX - this._$screenX)}px`;
        element.style.top  = `${element.offsetTop  + (event.screenY - this._$screenY)}px`;

        this._$screenX = event.screenX;
        this._$screenY = event.screenY;
    }

    /**
     * @description プラグインのモーダルの移動を終了
     *
     * @return {void}
     * @method
     * @public
     */
    endModal ()
    {
        Util.$setCursor("auto");
        window.removeEventListener("mousemove", this._$moveModal);
        window.removeEventListener("mouseup", this._$endModal);
    }

    /**
     * @description プラグインのモーダルを非表示にする
     *
     * @return {void}
     * @method
     * @public
     */
    executePluginHideIcon ()
    {
        window.nt.hidePanel();
    }
}

Util.$pluginPanel = new PluginPanel();

/**
 * @class
 * @extends {BaseController}
 */
class ReferenceController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("reference");

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$pointer = null;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        this._$pointer = { "x": 0, "y": 0 };

        const elementIds = [
            "transform-reference-x",
            "transform-reference-y"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(elementIds[idx])
            );
        }

        const element = document.getElementById("reference-point");
        if (element) {
            element.addEventListener("dblclick", (event) =>
            {
                // イベントを全て中止
                event.stopPropagation();

                this.resetPointer();
            });
        }

        const parent = document
            .getElementById("reference-setting-box");

        if (parent) {
            const elements = parent
                .getElementsByClassName("reference-setting-box-child");

            for (let idx = 0; idx < elements.length; ++idx) {

                const node = elements[idx];

                node.addEventListener("mousedown", (event) =>
                {
                    // イベントを全て中止
                    event.stopPropagation();

                    this.moveNineReferencePoint(event);
                });
            }
        }
    }

    /**
     * @return {object}
     * @readonly
     * @public
     */
    get pointer ()
    {
        return this._$pointer;
    }

    /**
     * @description 9点の固定位置に中心点を移動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveNineReferencePoint (event)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const width  = +document.getElementById("object-width").value;
        const height = +document.getElementById("object-height").value;

        let dx = 0;
        let dy = 0;
        switch (event.target.dataset.position) {

            case "top-left":
                dx = -width / 2;
                dy = -height / 2;
                break;

            case "top-center":
                dy = -height / 2;
                break;

            case "top-right":
                dx = width / 2;
                dy = -height / 2;
                break;

            case "center-left":
                dx = -width / 2;
                break;

            case "center-right":
                dx = width / 2;
                break;

            case "bottom-left":
                dx = -width / 2;
                dy = height / 2;
                break;

            case "bottom-center":
                dy = height / 2;
                break;

            case "bottom-right":
                dx = width / 2;
                dy = height / 2;
                break;

        }

        if (activeElements.length > 1) {

            this._$pointer.x = dx;
            this._$pointer.y = dy;

        } else {

            const target = activeElements[0];
            const layer  = Util
                .$currentWorkSpace()
                .scene
                .getLayer(
                    target.dataset.layerId | 0
                );

            const character = layer.getCharacter(
                target.dataset.characterId | 0
            );

            if (!character) {
                return ;
            }

            character._$referencePoint.x = dx;
            character._$referencePoint.y = dy;

        }

        // コントローラーの値を更新
        this.setInputValue(dx, dy);

        // 再計算
        Util
            .$transformController
            .relocation();
    }

    /**
     * @description 中心点のx座標を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeTransformReferenceX (value)
    {
        value = Util.$clamp(+value, -Number.MAX_VALUE, Number.MAX_VALUE);

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return value;
        }

        // 中心点を0,0にリセット
        if (activeElements.length === 1) {

            const target = activeElements[0];
            const layer  = Util
                .$currentWorkSpace()
                .scene
                .getLayer(
                    target.dataset.layerId | 0
                );

            const character = layer.getCharacter(
                target.dataset.characterId | 0
            );

            if (!character) {
                return value;
            }

            character._$referencePoint.x = value;

        } else {

            this._$pointer.x = value;

        }

        return value;
    }

    /**
     * @description 中心点のx座標を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeTransformReferenceY (value)
    {
        value = Util.$clamp(+value, -Number.MAX_VALUE, Number.MAX_VALUE);

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return value;
        }

        // 中心点を0,0にリセット
        if (activeElements.length === 1) {

            const target = activeElements[0];
            const layer  = Util
                .$currentWorkSpace()
                .scene
                .getLayer(
                    target.dataset.layerId | 0
                );

            const character = layer.getCharacter(
                target.dataset.characterId | 0
            );

            if (!character) {
                return value;
            }

            character._$referencePoint.y = value;

        } else {

            this._$pointer.y = value;

        }

        return value;
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    resetPointer ()
    {
        // 初期化
        this._$pointer.x = 0;
        this._$pointer.y = 0;

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        // 中心点を0,0にリセット
        if (activeElements.length === 1) {

            const target = activeElements[0];
            const layer  = Util
                .$currentWorkSpace()
                .scene
                .getLayer(
                    target.dataset.layerId | 0
                );

            const character = layer.getCharacter(
                target.dataset.characterId | 0
            );

            if (!character) {
                return ;
            }

            character._$referencePoint.x = 0;
            character._$referencePoint.y = 0;
        }

        // 再計算
        Util
            .$transformController
            .relocation();
    }

    /**
     * @description コントローラーの値を更新
     *
     * @param {number} x
     * @param {number} y
     */
    setInputValue (x = 0, y = 0)
    {
        document.getElementById("transform-reference-x").value = `${x}`;
        document.getElementById("transform-reference-y").value = `${y}`;
    }
}

Util.$referenceController = new ReferenceController();

/**
 * @class
 * @extends {BaseController}
 */
class ShapeController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("fill-color");

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$currentPointer = null;

        /**
         * @type {CanvasRenderingContext2D}
         * @default null
         * @private
         */
        this._$viewGradientContext = null;

        /**
         * @type {CanvasRenderingContext2D}
         * @default null
         * @private
         */
        this._$drawGradientContext = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMoveGradientColorPointer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUpGradientColorPointer = null;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get GRADIENT_CANVAS_WIDTH ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get GRADIENT_CANVAS_HEIGHT ()
    {
        return 30;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_COLOR ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_COLOR ()
    {
        return 100;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_ALPHA ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_ALPHA ()
    {
        return 100;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_STROKE ()
    {
        return 1;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_STROKE ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_GRADIENT_POINTER ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_GRADIENT_POINTER ()
    {
        return 255;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const canvas = document.getElementById("gradient-canvas");
        if (canvas) {

            canvas.style.transform          = `scale(${1 / window.devicePixelRatio}, ${1 / window.devicePixelRatio})`;
            canvas.style.backfaceVisibility = "hidden";
            canvas.style.transformOrigin    = "0 0";

            const width  = ShapeController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio;
            const height = ShapeController.GRADIENT_CANVAS_HEIGHT  * window.devicePixelRatio;

            canvas.width  = width;
            canvas.height = height;
            this._$viewGradientContext = canvas.getContext("2d");

            const drawCanvas  = document.createElement("canvas");
            drawCanvas.width  = width;
            drawCanvas.height = height;
            this._$drawGradientContext = drawCanvas.getContext("2d");
        }

        const inputIds = [
            "fill-alpha-value",
            "fill-stroke-width-value"
        ];
        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const selectIds = [
            "fill-color-type-select",
            "fill-color-value",
            "fill-bitmap-select"
        ];

        for (let idx = 0; idx < selectIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(selectIds[idx])
            );
        }

        const element = document
            .getElementById("color-pointer-list");

        if (element) {
            element.addEventListener("mousedown", (event) =>
            {
                this.setGradientColorPointerEvent(event);
            });
        }
    }

    /**
     * @description グラデーションのポインターを削除
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    removeGradientColorPointer (event)
    {
        const element = document
            .getElementById("color-pointer-list");

        if (element.children.length > 2 && Util.$hitColor) {

            const index = event.target.dataset.index | 0;

            Util.$hitColor.ratios.splice(index, 1);

            // remove
            event.target.remove();

            // adj
            for (let idx = index; idx < element.children.length; ++idx) {

                const child = element.children[idx];
                const index = (child.dataset.index | 0) - 1;

                child.dataset.index = `${index}`;
            }

            // グラデーションレビューを再描画
            this.updateGradientCanvas();

            // 再描画ようにキャッシュを削除
            Util.$hitColor.shape.cacheClear();

            // 再描画
            this.reloadScreen();
        }
    }

    /**
     * @description グラデーションのポインター追加イベント
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    setGradientColorPointerEvent (event)
    {
        if (!this._$currentPointer || !Util.$hitColor) {
            return ;
        }

        const color  = document.getElementById("fill-color-value").value;
        const alpha  = document.getElementById("fill-alpha-value").value | 0;
        const object = Util.$intToRGB(`0x${color.slice(1)}` | 0);

        const stopObject = {
            "R": object.R,
            "G": object.G,
            "B": object.B,
            "A": alpha / 100 * 255,
            "ratio": event.offsetX / 255
        };

        Util.$hitColor.ratios.push(stopObject);

        Util.$hitColor.ratios.sort((a, b) =>
        {
            switch (true) {

                case a.ratio > b.ratio:
                    return 1;

                case a.ratio < b.ratio:
                    return -1;

                default:
                    return 0;

            }
        });

        // グラデーションレビューを再描画
        this.initializeGradient();

        // 再描画ようにキャッシュを削除
        Util.$hitColor.shape.cacheClear();

        // 再描画
        this.reloadScreen();

        // 新しいポインターElementをセット
        this._$currentPointer = event.target.children[
            Util.$hitColor.ratios.indexOf(stopObject)
        ];
    }

    /**
     * @description 塗りの透明度
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFillAlphaValue (value)
    {
        value = Util.$clamp(
            value | 0,
            ShapeController.MIN_ALPHA,
            ShapeController.MAX_ALPHA
        );

        if (Util.$hitColor) {

            const { GradientType } = window.next2d.display;
            switch (Util.$hitColor.type) {

                case GradientType.LINEAR:
                case GradientType.RADIAL:
                    if (this._$currentPointer) {
                        this._$currentPointer.dataset.alpha = value;
                        Util.$hitColor.shape.changeColor(
                            this._$currentPointer.dataset.index | 0
                        );
                        this.updateGradientCanvas();
                    }
                    break;

                default:
                    Util.$hitColor.shape.changeColor();
                    break;

            }

        }

        return value;
    }

    /**
     * @description 線の幅
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFillStrokeWidthValue (value)
    {
        value = Util.$clamp(
            value | 0,
            ShapeController.MIN_STROKE,
            ShapeController.MAX_STROKE
        );

        if (this._$currentValue !== value && Util.$hitColor) {

            Util.$hitColor.shape.changeColor();

            const { GradientType } = window.next2d.display;
            switch (Util.$hitColor.type) {

                case GradientType.LINEAR:
                case GradientType.RADIAL:
                    this.updateGradientCanvas();
                    break;

                default:
                    break;

            }

        }

        return value;
    }

    /**
     * @description 塗りのカラータイプの設定
     *
     * @param  {string} [value=""]
     * @return {void}
     * @method
     * @public
     */
    changeFillColorTypeSelect (value = "")
    {
        const gradientElement = document
            .getElementById("fill-color-gradient-container");

        const bitmapElement = document
            .getElementById("fill-color-bitmap-container");

        const colorElement = document
            .getElementById("fill-color-rgba-container");

        const widthElement = document
            .getElementById("fill-stroke-color-rgba-container");

        // reset
        if (value) {
            Util.$hitColor.shape.bitmapId = 0;
        }

        // 表示切り替え
        switch (document.getElementById("fill-color-type-select").value) {

            case "rgba":
                gradientElement.style.display = "none";
                bitmapElement.style.display   = "none";
                colorElement.style.display    = "";
                widthElement.style.display    = Util.$hitColor.width ? "" : "none";
                break;

            case "bitmap":
                gradientElement.style.display = "none";
                bitmapElement.style.display   = "";
                colorElement.style.display    = "none";
                widthElement.style.display    = Util.$hitColor.width ? "" : "none";
                this.createBitmapList();
                break;

            default:
                gradientElement.style.display = "";
                bitmapElement.style.display   = "none";
                colorElement.style.display    = "";
                widthElement.style.display    = Util.$hitColor.width ? "" : "none";
                if (!value) {
                    this.initializeGradient();
                }
                break;

        }

        if (value) {
            Util.$hitColor.shape.changeStyle(value);
        }
    }

    /**
     * @description 塗りのカラー設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFillColorValue (value)
    {
        if (Util.$hitColor) {

            if (this._$currentPointer) {

                const pointerColor = this
                    ._$currentPointer
                    .getElementsByTagName("i")[0];

                this._$currentPointer.dataset.color = value;
                pointerColor.style.backgroundColor  = value;

                Util.$hitColor.shape.changeColor(
                    this._$currentPointer.dataset.index | 0
                );

                this.updateGradientCanvas();

            } else {

                Util.$hitColor.shape.changeColor();

            }
        }
    }

    /**
     * @description 塗りの画像設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFillBitmapSelect (value)
    {
        if (!Util.$hitColor) {
            return ;
        }

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                value | 0
            );

        Util.$hitColor.shape.bitmapId = instance.id;
        Util.$hitColor.shape.cacheClear();
    }

    /**
     * @description 画像のSelectを生成
     *
     * @return {void}
     * @method
     * @public
     */
    createBitmapList ()
    {
        const element = document
            .getElementById("fill-bitmap-select");

        const children = element.children;
        while (children.length) {
            children[0].remove();
        }

        const option = document.createElement("option");
        option.innerHTML       = "Image Selection";
        option.defaultSelected = true;
        option.disabled        = true;
        element.appendChild(option);

        const bitmapId = Util.$hitColor.shape.bitmapId;

        const workSpace = Util.$currentWorkSpace();
        for (const instance of workSpace._$libraries.values()) {

            if (instance.type !== "bitmap") {
                continue;
            }

            const option = document.createElement("option");

            option.value     = instance.id;
            option.innerHTML = instance.name;

            if (bitmapId && bitmapId === instance.id) {
                option.selected = true;
            }

            element.appendChild(option);
        }
    }

    /**
     * @description グラデーション初期化
     *
     * @return {void}
     * @method
     * @public
     */
    initializeGradient ()
    {
        if (!Util.$hitColor) {
            return ;
        }

        const children = document
            .getElementById("color-pointer-list")
            .children;

        while (children.length) {
            children[0].remove();
        }

        const length = Util.$hitColor.ratios.length;
        for (let idx = 0; idx < length; ++idx) {

            const color = Util.$hitColor.ratios[idx];
            const R = color.R.toString(16).padStart(2, "0");
            const G = color.G.toString(16).padStart(2, "0");
            const B = color.B.toString(16).padStart(2, "0");

            this.addGradientColorPointer(
                idx, color.ratio * 255, `#${R}${G}${B}`, color.A / 255 * 100
            );

            if (idx + 1 === length) {
                document
                    .getElementById("fill-color-value")
                    .value = `#${R}${G}${B}`;

                document
                    .getElementById("fill-alpha-value")
                    .value = color.A / 255 * 100;
            }
        }

        this.updateGradientCanvas();
    }

    /**
     * @description グラデーションのポインターを追加
     *
     * @param  {number} index
     * @param  {number} ratio
     * @param  {string} color
     * @param  {number} alpha
     * @return {void}
     * @method
     * @public
     */
    addGradientColorPointer (index, ratio, color, alpha)
    {
        const element = document
            .getElementById("color-pointer-list");

        const htmlTag = `
<div class="color-pointer" style="left: ${ratio - 4}px;" data-index="${index}" data-color="${color}" data-alpha="${alpha}">
    <div class="color-pointer-triangle"></div>
    <div class="color-pointer-rect">
        <i class="pointer-color" style="background-color: ${color}"></i>
    </div>
</div>
`;

        element.insertAdjacentHTML("beforeend", htmlTag);

        const pointer = element.lastElementChild;

        pointer.addEventListener("mousedown", (event) =>
        {
            this.mouseDownGradientColorPointer(event);
        });

        pointer.addEventListener("dblclick", (event) =>
        {
            this.removeGradientColorPointer(event);
        });

        // 初期値は最後に生成されたポインターのElement
        this._$currentPointer = pointer;
    }

    /**
     * @description グラデーションプレビューの再描画
     *
     * @return {void}
     * @method
     * @public
     */
    updateGradientCanvas ()
    {
        const drawContext = this._$drawGradientContext;

        // clear
        drawContext.clearRect(0, 0,
            ShapeController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            ShapeController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );

        drawContext.beginPath();

        const ratios = Util.$hitColor.ratios;

        const length = ratios.length;
        const x1 = Math.ceil(ratios[length - 1].ratio * 255 * window.devicePixelRatio);

        const gradient = drawContext.createLinearGradient(0, 0, x1, 0);
        for (let idx = 0; idx < length; ++idx) {

            const object = ratios[idx];

            gradient.addColorStop(
                object.ratio,
                `rgba(${object.R}, ${object.G}, ${object.B}, ${object.A / 255})`
            );

        }

        drawContext.fillStyle = gradient;
        drawContext.rect(0, 0,
            ShapeController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            ShapeController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );

        drawContext.fill();

        const viewContext = this._$viewGradientContext;
        viewContext.clearRect(0, 0,
            ShapeController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            ShapeController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );
        viewContext.drawImage(drawContext.canvas, 0, 0);
    }

    /**
     * @description ポインターのマウスダウンで移動イベントを起動する
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDownGradientColorPointer (event)
    {
        // 親のイベントを中止
        event.stopPropagation();

        // 初期化
        this._$saved          = false;
        this._$pointX         = event.screenX;
        this._$currentPointer = event.target;

        document
            .getElementById("fill-color-value")
            .value = event.target.dataset.color;

        document
            .getElementById("fill-alpha-value")
            .value = event.target.dataset.alpha;

        if (!this._$mouseMoveGradientColorPointer) {
            this._$mouseMoveGradientColorPointer =
                this.mouseMoveGradientColorPointer.bind(this);
        }

        if (!this._$mouseUpGradientColorPointer) {
            this._$mouseUpGradientColorPointer =
                this.mouseUpGradientColorPointer.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMoveGradientColorPointer);
        window.addEventListener("mouseup", this._$mouseUpGradientColorPointer);
    }

    /**
     * @description グラデーションのカラーポインターの移動処理
     *
     * @return {void}
     * @method
     * @public
     */
    mouseMoveGradientColorPointer (event)
    {
        const element = this._$currentPointer;
        if (!element) {
            return ;
        }

        window.requestAnimationFrame(() =>
        {
            if (!Util.$hitColor) {
                return ;
            }

            this.save();

            event.preventDefault();

            const currentPoint = parseFloat(
                element.style.left
            );

            const value = Util.$clamp(
                currentPoint + (event.screenX - this._$pointX) + 4,
                ShapeController.MIN_GRADIENT_POINTER,
                ShapeController.MAX_GRADIENT_POINTER
            );

            element.style.left = `${value - 4}px`;

            Util.$hitColor.ratios[element.dataset.index].ratio = value / 255;

            if (this._$pointX) {
                this._$pointX = event.screenX;
            }

            // グラデーションプレビューを更新
            this.updateGradientCanvas();

            // 再描画ようにキャッシュを削除
            Util.$hitColor.shape.cacheClear();

            // 再描画
            this.reloadScreen();
        });
    }

    /**
     * @description グラデーションのカラーポインターの移動を終了、イベントも削除
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUpGradientColorPointer ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMoveGradientColorPointer);
        window.removeEventListener("mouseup", this._$mouseUpGradientColorPointer);
        Util.$setCursor("auto");

        // 設定を初期化
        super.focusOut();
    }
}

Util.$shapeController = new ShapeController();

/**
 * @class
 * @extends {BaseController}
 */
class SoundController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("sound");
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_VOLUME ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_VOLUME ()
    {
        return 100;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_LOOP_COUNT ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_LOOP_COUNT ()
    {
        return 0xffff;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document
            .getElementById("sound-add");

        if (element) {
            element
                .addEventListener("mousedown", () =>
                {
                    const element = document.getElementById("sound-select");
                    if (element && element.options.length) {
                        // undo用にセーブ
                        this.save();

                        // DOM追加
                        this.addSound();

                        // saveフラグを初期化
                        this._$saved = false;
                    }
                });
        }
    }

    /**
     * @description タイムラインにサウンドを追加
     *              タイムラインでフレームを指定した際に引数がセットされる
     *
     * @param  {object} [object=null]
     * @param  {number} [id=0]
     * @return {void}
     * @method
     * @public
     */
    addSound (object = null, id = 0)
    {
        if (!object) {

            const element = document.getElementById("sound-select");
            const option  = element.options[element.selectedIndex];

            const frame = Util.$timelineFrame.currentFrame;

            const scene = Util.$currentWorkSpace().scene;
            if (!scene._$sounds.has(frame)) {
                scene._$sounds.set(frame, []);
            }

            const sounds = scene._$sounds.get(frame);
            id = sounds.length;

            object = {
                "characterId": element.value | 0,
                "name":        option.textContent,
                "volume":      100,
                "loopCount":   0,
                "autoPlay":    false
            };

            sounds.push(object);

            // アイコンをセット
            this.setIcon(frame);
        }

        const htmlTag = `
<div id="sound-id-${id}" class="sound-border">
    <div class="sound-title">
      <span id="sound-name-${id}" data-sound-id="${id}">${object.name}</span>
      <i class="trash" id="sound-trash-${id}" data-sound-id="${id}" data-detail="{{サウンドを削除}}"></i>
    </div>

    <div class="sound-container">
        <div class="sound-setting-container">
            <div class="sound-text">Volume</div>
            <div><input type="text" id="sound-volume-${id}" data-sound-id="${id}" data-name="volume" value="100" data-detail="{{音量設定}}"></div>
        
            <div class="sound-text">Loop<br>Count</div>
            <div><input type="text" id="sound-loop-count-${id}" data-sound-id="${id}" data-name="loop-count" value="0" data-detail="{{ループ回数}}"></div>
        </div>
    </div>
</div>
`;
        document
            .getElementById("sound-list-area")
            .insertAdjacentHTML("beforeend", htmlTag);

        const soundVolume = document
            .getElementById(`sound-volume-${id}`);
        soundVolume.value = `${object.volume}`;
        this.setInputEvent(soundVolume);

        const soundLoopCount = document
            .getElementById(`sound-loop-count-${id}`);
        soundLoopCount.value = `${object.loopCount}`;
        this.setInputEvent(soundLoopCount);

        document
            .getElementById(`sound-trash-${id}`)
            .addEventListener("click", (event) =>
            {
                // undo用にセーブ
                this.save();

                this.trash(
                    event.target.dataset.soundId | 0
                );

                // 再描画
                this.createSoundElements();

                // saveフラグを初期化
                this._$saved = false;
            });

        Util.$addModalEvent(
            document.getElementById(`sound-id-${id}`)
        );
    }

    /**
     * @description ボリュームをコントロール
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeSoundVolume (value)
    {
        value = Util.$clamp(
            value | 0,
            SoundController.MIN_VOLUME,
            SoundController.MAX_VOLUME
        );

        this.updateSoundProperty("volume", value);

        return value;
    }

    /**
     * @description ボリュームをコントロール
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeSoundLoopCount (value)
    {
        value = Util.$clamp(
            value | 0,
            SoundController.MIN_LOOP_COUNT,
            SoundController.MAX_LOOP_COUNT
        );

        this.updateSoundProperty("loopCount", value);

        return value;
    }

    /**
     * @description 指定したサウンドの値を更新
     *
     * @param {string} name
     * @param {*} value
     * @method
     * @public
     */
    updateSoundProperty (name, value)
    {
        if (!this._$currentTarget) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;

        const scene  = Util.$currentWorkSpace().scene;
        const index  = this._$currentTarget.dataset.soundId | 0;
        const object = scene._$sounds.get(frame)[index];
        object[name] = value;
    }

    /**
     * @description タイムラインのヘッダーに音符アイコンを追加
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    setIcon (frame)
    {
        const element = document
            .getElementById(`frame-label-sound-${frame}`);

        if (!element.classList.contains("frame-border-box-sound")) {
            element
                .setAttribute("class", "frame-border-box-sound");
        }
    }

    /**
     * @description タイムラインヘッダーの音符アイコンを削除
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    deleteIcon (frame)
    {
        const element = document
            .getElementById(`frame-label-sound-${frame}`);

        if (element) {
            element.setAttribute("class", "frame-border-box");
        }
    }

    /**
     * @description 指定のサウンドを削除
     *
     * @param {number} index
     * @method
     * @public
     */
    trash (index)
    {
        const frame = Util.$timelineFrame.currentFrame;

        const scene  = Util.$currentWorkSpace().scene;
        const sounds = scene._$sounds.get(frame);
        sounds.splice(index, 1);

        if (!sounds.length) {

            scene._$sounds.delete(frame);

            // 音符アイコンを削除
            this.deleteIcon(frame);
        }
    }

    /**
     * @description 指定のシーンとフレームからサウンド設定を反映
     *
     * @return {void}
     * @method
     * @public
     */
    createSoundElements ()
    {
        const element = document
            .getElementById("sound-list-area");

        if (element) {
            while (element.children.length) {
                element.children[0].remove();
            }
        }

        const frame = Util.$timelineFrame.currentFrame;

        const scene = Util.$currentWorkSpace().scene;
        if (scene.hasSound(frame)) {

            const sounds = scene.getSound(frame);
            for (let idx = 0; idx < sounds.length; ++idx) {
                this.addSound(sounds[idx], idx);
            }

        }
    }
}

Util.$soundController = new SoundController();


/**
 * @class
 * @extends {BaseController}
 */
class StageController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("stage");

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$stageLock = false;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_FPS ()
    {
        return 1;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_FPS ()
    {
        return 60;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_STAGE_SIZE ()
    {
        return 1;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_STAGE_SIZE ()
    {
        return 3000;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_STROKE_SIZE ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_STROKE_SIZE ()
    {
        return 200;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const stageLock = document.getElementById("stage-lock");
        if (stageLock) {
            stageLock
                .addEventListener("mousedown", (event) =>
                {
                    this.stageLock(event);
                });
        }

        const elementIds = [
            "stage-width",
            "stage-height",
            "stage-fps"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(elementIds[idx])
            );
        }

        this.setChangeEvent(
            document.getElementById("stage-bgColor")
        );

    }

    /**
     * @description 幅高さの変更のロックのOn/Off関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    stageLock (event)
    {
        event.stopPropagation();

        // ロックのOn/Off
        this._$stageLock = !this._$stageLock;

        // 初期化
        this._$currentValue = null;

        event
            .currentTarget
            .childNodes[1]
            .setAttribute("class", this._$stageLock
                ? "active"
                : "disable"
            );
    }

    /**
     * @description Stageの背景色を変更
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeStageBgColor (value)
    {
        document
            .getElementById("stage")
            .style.backgroundColor = value;

        document
            .getElementById("library-preview-area")
            .style.backgroundColor = value;

        const workSpace = Util.$currentWorkSpace();
        workSpace.stage.bgColor = value;
    }

    /**
     * @description Stageの幅を設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeStageWidth (value)
    {
        value = Util.$clamp(
            value | 0,
            StageController.MIN_STAGE_SIZE,
            StageController.MAX_STAGE_SIZE
        );

        const stageArea = document.getElementById("stage-area");
        const stage     = document.getElementById("stage");
        const workSpace = Util.$currentWorkSpace();

        stageArea.style.width = `${value + window.screen.width}px`;
        stage.style.width     = `${value}px`;
        workSpace.stage.width = value;

        Util.$offsetLeft = stage.offsetLeft;
        Util.$offsetTop  = stage.offsetTop;

        return value;
    }

    /**
     * @description Stageの高さを設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeStageHeight (value)
    {
        value = Util.$clamp(
            value | 0,
            StageController.MIN_STAGE_SIZE,
            StageController.MAX_STAGE_SIZE
        );

        const stageArea = document.getElementById("stage-area");
        const stage     = document.getElementById("stage");
        const workSpace = Util.$currentWorkSpace();

        stageArea.style.height = `${value + window.screen.height}px`;
        stage.style.height     = `${value}px`;
        workSpace.stage.height = value;

        Util.$offsetLeft = stage.offsetLeft;
        Util.$offsetTop  = stage.offsetTop;

        return value;
    }

    /**
     * @description StageのFPS設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeStageFps (value)
    {
        value = Util.$clamp(
            value | 0,
            StageController.MIN_FPS,
            StageController.MAX_FPS
        );

        Util.$timelineHeader.create(true);

        const workSpace = Util.$currentWorkSpace();
        workSpace.stage.fps = value;

        return value;
    }
}

Util.$stageController = new StageController();

/**
 * @class
 */
class TabController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {HTMLDivElement}
         * @private
         */
        this._$active = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState === "loading") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description コントローラーのタブのイベント登録
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const tabArea = document
            .getElementById("controller-tab-area");

        if (tabArea) {

            const tabs = tabArea.children;
            for (let idx = 0; idx < tabs.length; ++idx) {

                const tab = tabs[idx];

                // 一番左のタブを初期アクティブに設定
                if (!this._$active) {
                    tab.classList.add("active");
                    this._$active = tab;
                }

                tab.addEventListener("click", (event) =>
                {
                    this.mouseDown(event);
                });

            }
        }

        const controllerArea = document
            .getElementById("controller-area");

        if (controllerArea) {

            const nodes = controllerArea.children;
            for (let idx = 0; idx < nodes.length; ++idx) {

                const node = nodes[idx];
                if (idx) {
                    node.style.display = "none";
                }

            }
        }

        Util.$initializeEnd();
    }

    /**
     * @description 選択したタブをアクティブ表示する
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        event.stopPropagation();
        Util.$endMenu();

        // アクティブになっているタブのcssを初期化
        this
            ._$active
            .classList
            .remove("active");

        this
            ._$active
            .classList
            .add("disable");

        // 選択したタブをアクティブに
        event
            .target
            .classList
            .remove("disable");

        event
            .target
            .classList
            .add("active");

        this._$active = event.target;

        // タブの対象となるDOMを表示してそれ以外を非表示
        const nodes = document
            .getElementById("controller-area")
            .children;

        for (let idx = 0; idx < nodes.length; ++idx) {

            const node = nodes[idx];

            if (node.id !== event.target.dataset.tabType) {
                node.style.display = "none";
                continue;
            }

            node.style.display = "";
        }

        if (event.target.dataset.tabType === "controller-area-property") {
            this.showController();
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    showController ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (activeElements.length !== 1) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        const target    = activeElements[0];

        const layer = scene.getLayer(
            target.dataset.layerId | 0
        );

        const character = layer.getCharacter(
            target.dataset.characterId | 0
        );

        character.showController();
    }
}

Util.$tabController = new TabController();

/**
 * @class
 * @extends {BaseController}
 */
class TextController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("text");
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_SIZE ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_SIZE ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_FONT_SIZE ()
    {
        return 10;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_FONT_SIZE ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_STROKE_SIZE ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_STROKE_SIZE ()
    {
        return 200;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const selectIds = [
            "font-select",
            "font-style-select",
            "font-align-select",
            "font-wrap-select",
            "font-input-select",
            "font-scroll-select",
            "font-border-select",
            "font-auto-size-select",
            "font-color",
            "font-stroke-color"
        ];

        for (let idx = 0; idx < selectIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(selectIds[idx])
            );
        }

        const inputIds = [
            "font-size",
            "font-stroke-size",
            "font-leading",
            "font-letterSpacing",
            "font-leftMargin",
            "font-rightMargin"
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }
    }

    /**
     * @description 行間の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFontLeading (value)
    {
        value = Util.$clamp(
            value | 0,
            TextController.MIN_SIZE,
            TextController.MAX_SIZE
        );

        this.updateText({
            "name": "leading",
            "value": value
        });

        return value;
    }

    /**
     * @description 文字幅の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFontLetterSpacing (value)
    {
        value = Util.$clamp(
            value | 0,
            -TextController.MAX_SIZE,
            TextController.MAX_SIZE
        );

        this.updateText({
            "name": "letterSpacing",
            "value": value
        });

        return value;
    }

    /**
     * @description 左マージンの値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFontLeftMargin (value)
    {
        value = Util.$clamp(
            value | 0,
            TextController.MIN_SIZE,
            TextController.MAX_SIZE
        );

        this.updateText({
            "name": "leftMargin",
            "value": value
        });

        return value;
    }

    /**
     * @description 右マージンの値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFontRightMargin (value)
    {
        value = Util.$clamp(
            value | 0,
            TextController.MIN_SIZE,
            TextController.MAX_SIZE
        );

        this.updateText({
            "name": "rightMargin",
            "value": value
        });

        return value;
    }

    /**
     * @description テキスト枠のサイズを変更
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFontStrokeSize (value)
    {
        value = Util.$clamp(
            value | 0,
            TextController.MIN_STROKE_SIZE,
            TextController.MAX_STROKE_SIZE
        );

        this.updateText({
            "name": "thickness",
            "value": value
        });

        return value;
    }

    /**
     * @description テキストサイズを変更
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFontSize (value)
    {
        value = Util.$clamp(
            value | 0,
            TextController.MIN_FONT_SIZE,
            TextController.MAX_FONT_SIZE
        );

        this.updateText({
            "name": "size",
            "value": value
        });

        return value;
    }

    /**
     * @description テキスト枠のカラーを設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontStrokeColor (value)
    {
        this.updateText({
            "name": "thicknessColor",
            "value": `0x${value.slice(1)}` | 0
        });
    }

    /**
     * @description テキストのカラーを設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontColor (value)
    {
        this.updateText({
            "name": "color",
            "value": `0x${value.slice(1)}` | 0
        });
    }

    /**
     * @description テキストのフォントを指定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontSelect (value)
    {
        this.updateText({
            "name": "font",
            "value": value
        });
    }

    /**
     * @description テキストエリアの改行設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontStyleSelect (value)
    {
        value |= 0;
        this.updateText({
            "name": "fontType",
            "value": Util.$clamp(value, 0, 3)
        });
    }

    /**
     * @description テキストエリアの改行設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontAlignSelect (value)
    {
        switch (value) {

            case "left":
            case "center":
            case "right":
                this.updateText({
                    "name": "align",
                    "value": value
                });
                break;

            default:
                break;

        }
    }

    /**
     * @description テキストエリアの改行設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontWrapSelect (value)
    {
        switch (value | 0) {

            case 0:
                this.updateText({
                    "name": "wordWrap",
                    "value": false
                });
                this.updateText({
                    "name": "multiline",
                    "value": false
                });
                break;

            case 1:
                this.updateText({
                    "name": "wordWrap",
                    "value": false
                });
                this.updateText({
                    "name": "multiline",
                    "value": true
                });
                break;

            case 2:
                this.updateText({
                    "name": "wordWrap",
                    "value": true
                });
                this.updateText({
                    "name": "multiline",
                    "value": true
                });
                break;

        }
    }

    /**
     * @description テキストエリアのスクロール機能のOn/Off設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontInputSelect (value)
    {
        value |= 0;
        this.updateText({
            "name": "inputType",
            "value": value ? "input" : "static"
        });
    }

    /**
     * @description テキストエリアのスクロール機能のOn/Off設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontScrollSelect (value)
    {
        this.updateText({
            "name": "scroll",
            "value": !!(value | 0)
        });
    }

    /**
     * @description テキストエリアのボータ表示設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontBorderSelect (value)
    {
        this.updateText({
            "name": "border",
            "value": !!(value | 0)
        });
    }

    /**
     * @description オートリサイズのSelect変更時の関数
     * @param  {number} value
     * @return {void}
     * @method
     * @public
     */
    changeFontAutoSizeSelect (value)
    {
        value |= 0;
        this.updateText({
            "name": "autoSize",
            "value": Util.$clamp(value, 0, 2)
        });
    }

    /**
     * @description テキストのプロパティーを更新
     *
     * @param  {object} object
     * @return {void}
     * @method
     * @public
     */
    updateText (object)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        const element   = activeElements[0];

        // 対象レイヤーオブジェクト
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        // スクリーンで選択しているDisplayObject
        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        // ライブラリ内のインスタンスオブジェクト
        const instance = workSpace.getLibrary(character.libraryId);

        // 対象のプロパティーを更新
        instance[object.name] = object.value;

        // 再描画ように、キャッシュを削除
        character._$image = null;
    }
}

Util.$textController = new TextController();

/**
 * @class
 * @extends {BaseController}
 */
class TransformController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("transform");

        /**
         * @description 表示非表示の状態変数、初期値は非表示
         * @type {string}
         * @default "hide"
         * @private
         */
        this._$state = "hide";

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$sizeLock = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$scaleLock = false;

        /**
         * @description スクリーンに表示するElementのID名の配列
         * @type {array}
         * @private
         */
        this._$screenTargets = [
            "target-rect",         // 枠
            "scale-top-left",      // 左上
            "scale-top-right",     // 右上
            "scale-bottom-left",   // 左下
            "scale-bottom-right",  // 右下
            "scale-center-left",   // 左中央
            "scale-center-top",    // 中央上
            "scale-center-right",  // 右中央
            "scale-center-bottom", // 中央下
            "target-rotation",     // 回転表示
            "reference-point"      // 中心点
        ];
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_SIZE ()
    {
        return 1;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_SIZE ()
    {
        return 3000;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_SCALE ()
    {
        return -32768;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_SCALE ()
    {
        return 32767;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_ROTATE ()
    {
        return -360;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_ROTATE ()
    {
        return 360;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        // スクリーンに配置されてるElementにイベントを登録して非表示に
        for (let idx = 0; idx < this._$screenTargets.length; ++idx) {

            const element = document
                .getElementById(this._$screenTargets[idx]);

            if (!element) {
                continue;
            }

            // 初期値は非表示
            element.style.display = "none";
            element.addEventListener("mousedown", (event) =>
            {
                this.standbyPointer(event);
            });
        }

        // 幅高さのロック機能
        const transformSizeLock = document
            .getElementById("transform-size-lock");

        if (transformSizeLock) {
            transformSizeLock
                .addEventListener("mousedown", (event) =>
                {
                    this.sizeLock(event);
                });
        }

        // スケールのロック機能
        const transformScaleLock = document
            .getElementById("transform-scale-lock");

        if (transformScaleLock) {
            transformScaleLock
                .addEventListener("mousedown", (event) =>
                {
                    this.scaleLock(event);
                });
        }

        const elementIds = [
            "object-width",
            "object-height",
            "object-x",
            "object-y",
            "transform-scale-x",
            "transform-scale-y",
            "transform-rotate"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(elementIds[idx])
            );
        }
    }

    /**
     * @description DisplayObjectの幅を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeObjectWidth (value)
    {
        value = Util.$clamp(
            +value,
            TransformController.MIN_SIZE,
            TransformController.MAX_SIZE
        );

        this.updateWidth(value);

        return value;
    }

    /**
     * @description DisplayObjectの高さを更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeObjectHeight (value)
    {
        value = Util.$clamp(
            +value,
            TransformController.MIN_SIZE,
            TransformController.MAX_SIZE
        );

        this.updateHeight(value);

        return value;
    }

    /**
     * @description DisplayObjectのx座標を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeObjectX (value)
    {
        value = Util.$clamp(
            +value,
            TransformController.MIN_SCALE,
            TransformController.MAX_SCALE
        );

        this.updateX(value);

        return value;
    }

    /**
     * @description DisplayObjectのy座標を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeObjectY (value)
    {
        value = Util.$clamp(
            +value,
            TransformController.MIN_SCALE,
            TransformController.MAX_SCALE
        );

        this.updateY(value);

        return value;
    }

    /**
     * @description DisplayObjectのxスケールを更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeTransformScaleX (value)
    {
        value = Util.$clamp(
            +value,
            TransformController.MIN_SCALE,
            TransformController.MAX_SCALE
        );

        this.updateScaleX(value / 100);

        return value;
    }

    /**
     * @description DisplayObjectのyスケールを更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeTransformScaleY (value)
    {
        value = Util.$clamp(
            +value,
            TransformController.MIN_SCALE,
            TransformController.MAX_SCALE
        );

        this.updateScaleY(value / 100);

        return value;
    }

    /**
     * @description DisplayObjectの回転を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeTransformRotate (value)
    {
        value = Util.$clamp(
            (value | 0) % 360,
            TransformController.MIN_ROTATE,
            TransformController.MAX_ROTATE
        );
        if (0 > value) {
            value += 360;
        }

        this.updateRotate(value);

        return value;
    }

    /**
     * @description InputElementにフォーカスした際の処理関数
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    focusIn (event)
    {
        super.focusIn(event);
        this.setLockElement(event);
    }

    /**
     * @description InputElement上でマウスを押下した際の処理関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        super.mouseDown(event);
        this.setLockElement(event);
    }

    /**
     * @description ロックが有効の際に対象となるElementを変数にセット
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    setLockElement (event)
    {
        if (this._$focus) {
            return ;
        }

        switch (event.target.id) {

            case "object-width":
                if (this._$sizeLock) {
                    this._$lockTarget = document.getElementById("object-height");
                }
                break;

            case "object-height":
                if (this._$sizeLock) {
                    this._$lockTarget = document.getElementById("object-width");
                }
                break;

            case "transform-scale-x":
                if (this._$scaleLock) {
                    this._$lockTarget = document.getElementById("transform-scale-y");
                }
                break;

            case "transform-scale-y":
                if (this._$scaleLock) {
                    this._$lockTarget = document.getElementById("transform-scale-x");
                }
                break;

        }
    }

    /**
     * @description 拡大縮小の変更のロックのOn/Off関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    scaleLock (event)
    {
        event.stopPropagation();

        // ロックのOn/Off
        this._$scaleLock = !this._$scaleLock;

        // 初期化
        this._$currentValue = null;

        if (!this._$scaleLock) {
            this._$lockTarget = null;
        }

        event
            .currentTarget
            .childNodes[1]
            .setAttribute("class", this._$scaleLock
                ? "active"
                : "disable"
            );
    }

    /**
     * @description 幅高さの変更のロックのOn/Off関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    sizeLock (event)
    {
        event.stopPropagation();

        // ロックのOn/Off
        this._$sizeLock = !this._$sizeLock;

        // 初期化
        this._$currentValue = null;

        if (!this._$sizeLock) {
            this._$lockTarget = null;
        }

        event
            .currentTarget
            .childNodes[1]
            .setAttribute("class", this._$sizeLock
                ? "active"
                : "disable"
            );
    }

    /**
     * @description スクリーンの変形Elementの選択時の関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    standbyPointer (event)
    {
        // 親のイベントを中止する
        event.stopPropagation();

        const activeTool = Util.$tools.activeTool;
        if (activeTool) {
            event.transform = true;
            activeTool.dispatchEvent(
                EventType.MOUSE_DOWN,
                event
            );
        }
    }

    /**
     * @description スクリーンエリアの変形Elementを表示
     *
     * @return {TransformController}
     * @method
     * @public
     */
    show ()
    {
        if (this._$state !== "show") {
            this._$state = "show";
            for (let idx = 0; idx < this._$screenTargets.length; ++idx) {

                const element = document
                    .getElementById(this._$screenTargets[idx]);

                if (!element) {
                    continue;
                }

                element.style.display = "";
            }
        }
        return this;
    }

    /**
     * @description スクリーンエリアの変形Elementを非表示
     *
     * @return {void}
     * @method
     * @public
     */
    hide ()
    {
        if (this._$state === "hide") {
            return ;
        }

        for (let idx = 0; idx < this._$screenTargets.length; ++idx) {

            const element = document
                .getElementById(this._$screenTargets[idx]);

            if (!element) {
                continue;
            }

            element.setAttribute("style", "display:none;");
        }

        this._$state = "hide";
    }

    /**
     * @description 選択中のDisplayObjectの矩形範囲を計算してElementを配置
     *
     * @return {void}
     * @method
     * @public
     */
    relocation ()
    {
        // 非表示中なら何もしない
        if (this._$state === "hide") {
            return;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return this.hide();
        }

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        const frame = Util.$timelineFrame.currentFrame;

        let skipCount = 0;
        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const target = activeElements[idx];

            const layer = scene.getLayer(target.dataset.layerId | 0);
            if (!layer || layer.lock || layer.disable) {
                skipCount++;
                continue;
            }

            const characterId = target.dataset.characterId | 0;

            const element = document
                .getElementById(`character-${characterId}`);

            if (!element) {
                continue;
            }

            const character = layer.getCharacter(characterId);

            // const x = element.offsetLeft;
            // const y = element.offsetTop;
            const place  = character.getPlace(frame);
            const range  = character.getRange(frame);
            const bounds = character.getBounds(place.matrix, place, range);

            let tx = Util.$offsetLeft + bounds.xMin * Util.$zoomScale;
            let ty = Util.$offsetTop  + bounds.yMin * Util.$zoomScale;

            xMin = Math.min(xMin, tx);
            xMax = Math.max(xMax, tx + Math.ceil(Math.abs(bounds.xMax - bounds.xMin)) * Util.$zoomScale);
            yMin = Math.min(yMin, ty);
            yMax = Math.max(yMax, ty + Math.ceil(Math.abs(bounds.yMax - bounds.yMin)) * Util.$zoomScale);
        }

        if (activeElements.length - skipCount === 0) {
            return this.hide();
        }

        const width  = xMax - xMin;
        const height = yMax - yMin;

        const referencePoint = document
            .getElementById("reference-point");

        if (activeElements.length === 1) {

            const target = activeElements[0];
            const layer  = scene.getLayer(target.dataset.layerId | 0);

            const character = layer
                .getCharacter(target.dataset.characterId | 0);

            // 画面の拡大縮小対応
            const point = character.referencePoint;

            Util
                .$referenceController
                .setInputValue(point.x, point.y);

            const pointX = point.x * Util.$zoomScale;
            const pointY = point.y * Util.$zoomScale;

            const characterElement = document
                .getElementById(`character-${character.id}`);

            // 非表示などでElementがない時は非表示にして終了
            if (!characterElement) {
                return this.hide();
            }

            referencePoint.style.left = `${pointX + xMin + width  / 2 - 8}px`;
            referencePoint.style.top  = `${pointY + yMin + height / 2 - 8}px`;

        } else {

            const point = Util.$referenceController.pointer;

            // 画面の拡大縮小対応
            const pointX = point.x * Util.$zoomScale;
            const pointY = point.y * Util.$zoomScale;

            referencePoint.style.left = `${pointX + xMin + width  / 2 - 8}px`;
            referencePoint.style.top  = `${pointY + yMin + height / 2 - 8}px`;

        }

        document
            .getElementById("target-rect")
            .setAttribute(
                "style",
                `width: ${width - 2}px; height: ${height - 2}px; left: ${xMin}px; top: ${yMin}px;`
            );

        document
            .getElementById("scale-top-left")
            .setAttribute(
                "style",
                `left: ${xMin - 5}px; top: ${yMin - 5}px;`
            );

        document
            .getElementById("scale-top-right")
            .setAttribute(
                "style",
                `left: ${xMax - 5}px; top: ${yMin - 5}px;`
            );

        document
            .getElementById("scale-bottom-left")
            .setAttribute(
                "style",
                `left: ${xMin - 5}px; top: ${yMax - 5}px;`
            );

        document
            .getElementById("scale-bottom-right")
            .setAttribute(
                "style",
                `left: ${xMax - 5}px; top: ${yMax - 5}px;`
            );

        document
            .getElementById("target-rotation")
            .setAttribute(
                "style",
                `left: ${xMax + 5}px; top: ${yMax + 5}px;`
            );

        document
            .getElementById("scale-center-left")
            .setAttribute(
                "style",
                `left: ${xMin - 5}px; top: ${yMin + height / 2 - 5}px;`
            );

        document
            .getElementById("scale-center-top")
            .setAttribute(
                "style",
                `left: ${xMin + width / 2 - 5}px; top: ${yMin - 5}px;`
            );

        document
            .getElementById("scale-center-right")
            .setAttribute(
                "style",
                `left: ${xMax - 5}px; top: ${yMin + height / 2 - 5}px;`
            );

        document
            .getElementById("scale-center-bottom")
            .setAttribute(
                "style",
                `left: ${xMin + width / 2 - 5}px; top: ${yMax - 5}px;`
            );

    }

    /**
     * @param  {number} x
     * @return {void}
     * @method
     * @public
     */
    updateX (x)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = Util.$timelineFrame.currentFrame;

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const target  = activeElements[idx];
            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            character.x = x;

            //  tweenの座標を再計算してポインターを再配置
            character.relocationTween(frame);
        }

        this.relocation();
    }

    /**
     * @param  {number} y
     * @return {void}
     * @method
     * @public
     */
    updateY (y)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = Util.$timelineFrame.currentFrame;

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const target  = activeElements[idx];
            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            character.y = y;

            //  tweenの座標を再計算してポインターを再配置
            character.relocationTween(frame);
        }

        this.relocation();
    }

    /**
     * @param  {number} width
     * @return {void}
     * @method
     * @public
     */
    updateWidth (width)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        width = Util.$clamp(
            width,
            TransformController.MIN_SIZE,
            TransformController.MAX_SIZE
        );

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        if (activeElements.length > 1) {

            let xMin =  Number.MAX_VALUE;
            let xMax = -Number.MAX_VALUE;
            let yMin =  Number.MAX_VALUE;
            let yMax = -Number.MAX_VALUE;

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const instance = workSpace
                    .getLibrary(character.libraryId);

                const bounds = instance.getBounds([1, 0, 0, 1, 0, 0]);

                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);
            }

            this.updateScaleX(width / Math.abs(xMax - xMin));

        } else {

            const target  = activeElements[0];
            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            const instance = workSpace
                .getLibrary(character.libraryId);

            const bounds = instance.getBounds([1, 0, 0, 1, 0, 0]);

            this.updateScaleX(
                width / Math.abs(bounds.xMax - bounds.xMin)
            );

            document
                .getElementById("transform-scale-x")
                .value = `${character.scaleX * 100}`;

        }

    }

    /**
     * @param  {number} scale_x
     * @return {void}
     * @method
     * @public
     */
    updateScaleX (scale_x)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        scale_x = Util.$clamp(
            scale_x,
            TransformController.MIN_SCALE,
            TransformController.MAX_SCALE
        );

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = Util.$timelineFrame.currentFrame;

        let tx = Number.MAX_VALUE;
        let ty = Number.MAX_VALUE;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        if (activeElements.length > 1)  {

            let baseXMin =  Number.MAX_VALUE;
            let baseXMax = -Number.MAX_VALUE;
            let baseYMin =  Number.MAX_VALUE;
            let baseYMax = -Number.MAX_VALUE;
            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const bounds = character.getBounds();

                baseXMin = Math.min(baseXMin, bounds.xMin);
                baseXMax = Math.max(baseXMax, bounds.xMax);
                baseYMin = Math.min(baseYMin, bounds.yMin);
                baseYMax = Math.max(baseYMax, bounds.yMax);

            }

            // 基準となる幅と高さを算出
            const baseWidth  = Math.abs(baseXMax - baseXMin);
            const baseHeight = Math.abs(baseYMax - baseYMin);
            const halfWidth  = baseWidth  / 2;
            const halfHeight = baseHeight / 2;

            // 中心点の座標情報
            const referencePoint = Util.$referenceController.pointer;

            // 中止点から座標を取得
            const percentX = (halfWidth  + referencePoint.x) / baseWidth;
            const percentY = (halfHeight + referencePoint.y) / baseHeight;

            const parentMatrix = Util.$multiplicationMatrix(
                [scale_x, 0, 0, 1, 0, 0],
                [
                    1, 0, 0, 1,
                    -halfWidth  - baseXMin - referencePoint.x,
                    -halfHeight - baseYMin - referencePoint.y
                ]
            );

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const place = character.getPlace(frame);

                const multiMatrix = Util.$multiplicationMatrix(
                    parentMatrix, place.matrix
                );

                place.matrix[0] = multiMatrix[0];
                place.matrix[1] = multiMatrix[1];
                place.matrix[2] = multiMatrix[2];
                place.matrix[3] = multiMatrix[3];
                place.matrix[4] = multiMatrix[4] + halfWidth  + baseXMin + referencePoint.x;
                place.matrix[5] = multiMatrix[5] + halfHeight + baseYMin + referencePoint.y;

                const bounds = character.getBounds();
                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);

                character._$image = null;

                //  tweenの座標を再計算してポインターを再配置
                character.relocationTween(frame);
            }

            document
                .getElementById("transform-scale-y")
                .value = "100";

            document
                .getElementById("transform-scale-x")
                .value = "100";

            // 中心点を移動
            const afterWidth  = Math.abs(xMax - xMin);
            const afterHeight = Math.abs(yMax - yMin);
            referencePoint.x = afterWidth  * percentX - afterWidth  / 2;
            referencePoint.y = afterHeight * percentY - afterHeight / 2;

        } else {

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId    = target.dataset.characterId | 0;
                const character      = layer.getCharacter(characterId);
                const referencePoint = character.referencePoint;

                const range    = character.getRange(frame);
                const place    = character.getPlace(frame);
                const library  = workSpace.getLibrary(character.libraryId);
                const instance = library.createInstance(place, range);

                // 中止点から座標を取得
                const beforeBounds = character.getBounds();
                const beforeWidth  = Math.abs(beforeBounds.xMax - beforeBounds.xMin);
                const beforeHeight = Math.abs(beforeBounds.yMax - beforeBounds.yMin);
                const percentX = (beforeWidth  / 2 + referencePoint.x) / beforeWidth;
                const percentY = (beforeHeight / 2 + referencePoint.y) / beforeHeight;

                // 中心点を算出
                const rectangle  = instance.getBounds();
                const referenceX = rectangle.x + rectangle.width  * percentX;
                const referenceY = rectangle.y + rectangle.height * percentY;

                const baseMatrix = [1, 0, 0, 1,
                    -referenceX,
                    -referenceY
                ];

                const beforeMatrix  = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    referenceX,
                    referenceY
                ], baseMatrix);

                character.x -= beforeMatrix[4];
                character.y -= beforeMatrix[5];

                character.scaleX = scale_x;

                const afterMatrix = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    referenceX,
                    referenceY
                ], baseMatrix);

                character.x += afterMatrix[4];
                character.y += afterMatrix[5];

                character._$image = null;

                tx = Math.min(tx, character.x);
                ty = Math.min(ty, character.y);

                const afterBounds = character.getBounds();
                xMin = Math.min(xMin, afterBounds.xMin);
                xMax = Math.max(xMax, afterBounds.xMax);
                yMin = Math.min(yMin, afterBounds.yMin);
                yMax = Math.max(yMax, afterBounds.yMax);

                // 中心点を移動
                const afterWidth  = Math.abs(xMax - xMin);
                const afterHeight = Math.abs(yMax - yMin);

                character.referencePoint = {
                    "x": afterWidth  * percentX - afterWidth  / 2,
                    "y": afterHeight * percentY - afterHeight / 2
                };

                document
                    .getElementById("transform-scale-x")
                    .value = `${scale_x * 100}`;

                //  tweenの座標を再計算してポインターを再配置
                character.relocationTween(frame);
            }
        }

        document
            .getElementById("object-x")
            .value = `${tx}`;

        document
            .getElementById("object-y")
            .value = `${ty}`;

        document
            .getElementById("object-width")
            .value = `${Math.abs(xMax - xMin)}`;

        document
            .getElementById("object-height")
            .value = `${Math.abs(yMax - yMin)}`;
    }

    /**
     * @param  {number} height
     * @return {void}
     * @method
     * @public
     */
    updateHeight (height)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        height = Util.$clamp(
            height,
            TransformController.MIN_SIZE,
            TransformController.MAX_SIZE
        );

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        if (activeElements.length > 1) {

            let xMin =  Number.MAX_VALUE;
            let xMax = -Number.MAX_VALUE;
            let yMin =  Number.MAX_VALUE;
            let yMax = -Number.MAX_VALUE;

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const instance = workSpace
                    .getLibrary(character.libraryId);

                const bounds = instance.getBounds([1, 0, 0, 1, 0, 0]);

                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);
            }

            this.updateScaleY(height / Math.abs(yMax - yMin));

        } else {

            const target  = activeElements[0];
            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            const instance = workSpace
                .getLibrary(character.libraryId);

            const bounds = instance.getBounds([1, 0, 0, 1, 0, 0]);

            this.updateScaleY(
                height / Math.abs(bounds.yMax - bounds.yMin)
            );

            document
                .getElementById("transform-scale-y")
                .value = `${character.scaleY * 100}`;

        }
    }

    /**
     * @param  {number} scale_y
     * @return {void}
     * @method
     * @public
     */
    updateScaleY (scale_y)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        scale_y = Util.$clamp(
            scale_y,
            TransformController.MIN_SCALE,
            TransformController.MAX_SCALE
        );

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = Util.$timelineFrame.currentFrame;

        let tx = Number.MAX_VALUE;
        let ty = Number.MAX_VALUE;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        if (activeElements.length > 1) {

            let baseXMin =  Number.MAX_VALUE;
            let baseXMax = -Number.MAX_VALUE;
            let baseYMin =  Number.MAX_VALUE;
            let baseYMax = -Number.MAX_VALUE;
            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const bounds = character.getBounds();
                baseXMin = Math.min(baseXMin, bounds.xMin);
                baseXMax = Math.max(baseXMax, bounds.xMax);
                baseYMin = Math.min(baseYMin, bounds.yMin);
                baseYMax = Math.max(baseYMax, bounds.yMax);

            }

            // 基準となる幅と高さを算出
            const baseWidth  = Math.abs(baseXMax - baseXMin);
            const baseHeight = Math.abs(baseYMax - baseYMin);
            const halfWidth  = baseWidth  / 2;
            const halfHeight = baseHeight / 2;

            // 中心点の座標情報
            const referencePoint = Util.$referenceController.pointer;

            // 中止点から座標を取得
            const percentX = (halfWidth  + referencePoint.x) / baseWidth;
            const percentY = (halfHeight + referencePoint.y) / baseHeight;

            const parentMatrix = Util.$multiplicationMatrix(
                [1, 0, 0, scale_y, 0, 0],
                [
                    1, 0, 0, 1,
                    -halfWidth  - baseXMin - referencePoint.x,
                    -halfHeight - baseYMin - referencePoint.y
                ]
            );

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const place = character.getPlace(frame);

                const multiMatrix = Util.$multiplicationMatrix(
                    parentMatrix, place.matrix
                );

                place.matrix[0] = multiMatrix[0];
                place.matrix[1] = multiMatrix[1];
                place.matrix[2] = multiMatrix[2];
                place.matrix[3] = multiMatrix[3];
                place.matrix[4] = multiMatrix[4] + halfWidth  + baseXMin + referencePoint.x;
                place.matrix[5] = multiMatrix[5] + halfHeight + baseYMin + referencePoint.y;

                const bounds = character.getBounds();

                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);

                character._$image = null;

                //  tweenの座標を再計算してポインターを再配置
                character.relocationTween(frame);
            }

            document
                .getElementById("transform-scale-y")
                .value = "100";

            document
                .getElementById("transform-scale-x")
                .value = "100";

            // 中心点を移動
            const afterWidth  = Math.abs(xMax - xMin);
            const afterHeight = Math.abs(yMax - yMin);
            referencePoint.x = afterWidth  * percentX - afterWidth  / 2;
            referencePoint.y = afterHeight * percentY - afterHeight / 2;

        } else {

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId    = target.dataset.characterId | 0;
                const character      = layer.getCharacter(characterId);
                const referencePoint = character.referencePoint;

                const range    = character.getRange(frame);
                const place    = character.getPlace(frame);
                const library  = workSpace.getLibrary(character.libraryId);
                const instance = library.createInstance(place, range);

                // 中止点から座標を取得
                const beforeBounds = character.getBounds();
                const beforeWidth  = Math.abs(beforeBounds.xMax - beforeBounds.xMin);
                const beforeHeight = Math.abs(beforeBounds.yMax - beforeBounds.yMin);
                const percentX = (beforeWidth  / 2 + referencePoint.x) / beforeWidth;
                const percentY = (beforeHeight / 2 + referencePoint.y) / beforeHeight;

                // 中心点を算出
                const rectangle = instance.getBounds();
                const referenceX = rectangle.width  * percentX;
                const referenceY = rectangle.height * percentY;

                const baseMatrix = [
                    1, 0, 0, 1,
                    -referenceX,
                    -referenceY
                ];

                const beforeMatrix  = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    referenceX,
                    referenceY
                ], baseMatrix);

                character.x -= beforeMatrix[4];
                character.y -= beforeMatrix[5];

                character.scaleY  = scale_y;

                const afterMatrix = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    referenceX,
                    referenceY
                ], baseMatrix);

                character.x += afterMatrix[4];
                character.y += afterMatrix[5];

                character._$image = null;

                tx = Math.min(tx, character.x);
                ty = Math.min(ty, character.y);

                const afterBounds = character.getBounds();

                xMin = Math.min(xMin, afterBounds.xMin);
                xMax = Math.max(xMax, afterBounds.xMax);
                yMin = Math.min(yMin, afterBounds.yMin);
                yMax = Math.max(yMax, afterBounds.yMax);

                // 中心点を移動
                const afterWidth  = Math.abs(xMax - xMin);
                const afterHeight = Math.abs(yMax - yMin);

                character.referencePoint = {
                    "x": afterWidth  * percentX - afterWidth  / 2,
                    "y": afterHeight * percentY - afterHeight / 2
                };

                document
                    .getElementById("transform-scale-y")
                    .value = `${scale_y * 100}`;

                //  tweenの座標を再計算してポインターを再配置
                character.relocationTween(frame);
            }

        }

        document
            .getElementById("object-x")
            .value = `${tx}`;

        document
            .getElementById("object-y")
            .value = `${ty}`;

        document
            .getElementById("object-width")
            .value = `${Math.abs(xMax - xMin)}`;

        document
            .getElementById("object-height")
            .value = `${Math.abs(yMax - yMin)}`;

    }

    /**
     * @param  {number} rotate
     * @return {void}
     * @method
     * @public
     */
    updateRotate (rotate)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        const frame = Util.$timelineFrame.currentFrame;

        let tx = Number.MAX_VALUE;
        let ty = Number.MAX_VALUE;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        if (activeElements.length > 1) {

            let baseXMin =  Number.MAX_VALUE;
            let baseXMax = -Number.MAX_VALUE;
            let baseYMin =  Number.MAX_VALUE;
            let baseYMax = -Number.MAX_VALUE;
            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const bounds = character.getBounds();

                baseXMin = Math.min(baseXMin, bounds.xMin);
                baseXMax = Math.max(baseXMax, bounds.xMax);
                baseYMin = Math.min(baseYMin, bounds.yMin);
                baseYMax = Math.max(baseYMax, bounds.yMax);

            }

            // 基準となる幅と高さを算出
            const baseWidth  = Math.abs(baseXMax - baseXMin);
            const baseHeight = Math.abs(baseYMax - baseYMin);
            const halfWidth  = baseWidth  / 2;
            const halfHeight = baseHeight / 2;

            // 中心点の座標情報
            const referencePoint = Util.$referenceController.pointer;

            // 中止点から座標を取得
            const percentX = (halfWidth  + referencePoint.x) / baseWidth;
            const percentY = (halfHeight + referencePoint.y) / baseHeight;

            const radian = rotate * Util.$Deg2Rad;
            const parentMatrix = Util.$multiplicationMatrix(
                [Math.cos(radian), Math.sin(radian), -Math.sin(radian), Math.cos(radian), 0, 0],
                [
                    1, 0, 0, 1,
                    -halfWidth  - baseXMin - referencePoint.x,
                    -halfHeight - baseYMin - referencePoint.y
                ]
            );

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const place = character.getPlace(frame);

                const multiMatrix = Util.$multiplicationMatrix(
                    parentMatrix, place.matrix
                );

                place.matrix[0] = multiMatrix[0];
                place.matrix[1] = multiMatrix[1];
                place.matrix[2] = multiMatrix[2];
                place.matrix[3] = multiMatrix[3];
                place.matrix[4] = multiMatrix[4] + halfWidth  + baseXMin + referencePoint.x;
                place.matrix[5] = multiMatrix[5] + halfHeight + baseYMin + referencePoint.y;

                const bounds = character.getBounds();

                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);

                character._$image = null;

                //  tweenの座標を再計算してポインターを再配置
                character.relocationTween(frame);
            }

            document
                .getElementById("transform-scale-y")
                .value = "100";

            document
                .getElementById("transform-scale-x")
                .value = "100";

            // 中心点を移動
            const afterWidth  = Math.abs(xMax - xMin);
            const afterHeight = Math.abs(yMax - yMin);
            referencePoint.x = afterWidth  * percentX - afterWidth  / 2;
            referencePoint.y = afterHeight * percentY - afterHeight / 2;

        } else {

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target = activeElements[idx];

                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);
                if (character.rotation === rotate) {
                    return ;
                }

                const range    = character.getRange(frame);
                const place    = character.getPlace(frame);
                const library  = workSpace.getLibrary(character.libraryId);
                const instance = library.createInstance(place, range);

                // 中止点
                const referencePoint = character.referencePoint;

                // 中止点から座標を取得
                const beforeBounds = character.getBounds();
                const beforeWidth  = Math.abs(beforeBounds.xMax - beforeBounds.xMin);
                const beforeHeight = Math.abs(beforeBounds.yMax - beforeBounds.yMin);
                const percentX = (beforeWidth  / 2 + referencePoint.x) / beforeWidth;
                const percentY = (beforeHeight / 2 + referencePoint.y) / beforeHeight;

                // 中心点を算出
                const rectangle  = instance.getBounds();
                const referenceX = rectangle.x + rectangle.width  * percentX;
                const referenceY = rectangle.y + rectangle.height * percentY;

                const baseMatrix = [1, 0, 0, 1,
                    -referenceX,
                    -referenceY
                ];

                const beforeMatrix  = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    referenceX,
                    referenceY
                ], baseMatrix);

                character.x -= beforeMatrix[4];
                character.y -= beforeMatrix[5];

                // fixed
                character.rotation = rotate;

                const afterMatrix = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    referenceX,
                    referenceY
                ], baseMatrix);

                character.x += afterMatrix[4];
                character.y += afterMatrix[5];

                // clear
                character._$image = null;

                let xScale = character.scaleX;
                if (Math.atan2(place.matrix[1], place.matrix[0]) >= Math.PI) {
                    xScale *= -1;
                }

                document
                    .getElementById("transform-rotate")
                    .value = `${rotate}`;

                document
                    .getElementById("transform-scale-x")
                    .value = `${xScale * 100}`;

                document
                    .getElementById("transform-scale-y")
                    .value = `${character.scaleY * 100}`;

                tx = Math.min(tx, character.x);
                ty = Math.min(ty, character.y);

                const afterBounds = character.getBounds();
                xMin = Math.min(xMin, afterBounds.xMin);
                xMax = Math.max(xMax, afterBounds.xMax);
                yMin = Math.min(yMin, afterBounds.yMin);
                yMax = Math.max(yMax, afterBounds.yMax);

                // 中心点を移動
                const afterWidth  = Math.abs(xMax - xMin);
                const afterHeight = Math.abs(yMax - yMin);

                character.referencePoint = {
                    "x": afterWidth  * percentX - afterWidth  / 2,
                    "y": afterHeight * percentY - afterHeight / 2
                };

                //  tweenの座標を再計算してポインターを再配置
                character.relocationTween(frame);
            }
        }

        document
            .getElementById("object-x")
            .value = `${tx}`;

        document
            .getElementById("object-y")
            .value = `${ty}`;

        document
            .getElementById("object-width")
            .value = `${Math.abs(xMax - xMin)}`;

        document
            .getElementById("object-height")
            .value = `${Math.abs(yMax - yMin)}`;

    }
}

Util.$transformController = new TransformController();

/**
 * @class
 * @extends {BaseController}
 */
class TweenController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super("ease");

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$easeTarget = null;

        /**
         * @type {CanvasRenderingContext2D}
         * @default null
         * @private
         */
        this._$viewContext = null;

        /**
         * @type {CanvasRenderingContext2D}
         * @default null
         * @private
         */
        this._$drawContext = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$moveCurvePointer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endMoveCurvePointer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$moveEasingPointer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endMoveEasingPointer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$deleteEasingPointer = null;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_CANVAS_WIDTH ()
    {
        return 300;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_CANVAS_HEIGHT ()
    {
        return 400;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_BASE_CANVAS_SIZE ()
    {
        return 200;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_MIN_POINTER_X ()
    {
        return 6;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_MIN_POINTER_Y ()
    {
        return -5;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_MAX_POINTER_X ()
    {
        return 306;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_MAX_POINTER_Y ()
    {
        return 395;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_SCREEN_X ()
    {
        return 57;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_SCREEN_Y ()
    {
        return 94;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_MOVE_Y ()
    {
        return 294;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_OFFSET_X ()
    {
        return 50;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_OFFSET_Y ()
    {
        return 100;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_RANGE ()
    {
        return 100;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const ratio = window.devicePixelRatio;

        const drawCanvas   = document.createElement("canvas");
        drawCanvas.width   = TweenController.EASE_CANVAS_WIDTH  * ratio;
        drawCanvas.height  = TweenController.EASE_CANVAS_HEIGHT * ratio;
        this._$drawContext = drawCanvas.getContext("2d");

        const viewCanvas = document.getElementById("ease-custom-canvas");
        if (viewCanvas) {

            viewCanvas.width  = TweenController.EASE_CANVAS_WIDTH  * ratio;
            viewCanvas.height = TweenController.EASE_CANVAS_HEIGHT * ratio;

            viewCanvas.style.transform          = `scale(${1 / ratio}, ${1 / ratio})`;
            viewCanvas.style.backfaceVisibility = "hidden";

            this._$viewContext = viewCanvas.getContext("2d");

            // 新規カーブポインター追加処理
            viewCanvas.addEventListener("dblclick", (event) =>
            {
                this.addEasingPointer(event);
            });
        }

        const element = document
            .getElementById("ease-canvas-view-area");

        // 削除イベント用の関数
        this._$deleteEasingPointer = this.deleteEasingPointer.bind(this);
        if (element) {

            // 非表示
            element.style.display = "none";

            // 削除イベントを無効化
            element.addEventListener("mouseleave", () =>
            {
                window
                    .removeEventListener("keydown", this._$deleteEasingPointer);
            });
        }

        const changeIds = [
            "ease-select",
            "ease-custom-file-input"
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {

            const element = document.getElementById(changeIds[idx]);
            if (!element) {
                continue;
            }

            element.addEventListener("change", (event) =>
            {
                // 他のイベントを中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event.target.id, event);
            });

        }

        const elementIds = [
            "ease-custom-data-export",
            "ease-custom-data-load"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            element.addEventListener("click", (event) =>
            {
                // 他のイベントを中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event.target.id, event);
            });
        }
    }

    /**
     * @description カスタムイージングのJSONデータをfile inputへ転送
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    changeEaseCustomDataLoad (event)
    {
        event.preventDefault();

        const input = document
            .getElementById("ease-custom-file-input");

        input.click();
    }

    /**
     * @description カスタムイージングの情報をJSONとしてダウンロード
     *
     * @return {void}
     * @method
     * @public
     */
    changeEaseCustomDataExport ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const activeElement = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                activeElement.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            activeElement.dataset.characterId | 0
        );
        if (!character) {
            return ;
        }

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(character.libraryId);
        if (!instance) {
            return ;
        }

        const anchor    = document.createElement("a");
        anchor.download = `${instance.name}_${range.startFrame}.json`;
        anchor.href     = URL.createObjectURL(new Blob(
            [JSON.stringify(character.getTween(range.startFrame).custom)],
            { "type" : "application/json" }
        ));
        anchor.click();
    }

    /**
     * @description カスタムイージングのJSONデータの取り込み実行
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    changeEaseCustomFileInput (event)
    {
        const file = event.target.files[0];

        file
            .text()
            .then((text) =>
            {
                /**
                 * @type {ArrowTool}
                 */
                const tool = Util.$tools.getDefaultTool("arrow");
                const activeElements = tool.activeElements;
                if (!activeElements.length || activeElements.length > 1) {
                    return ;
                }

                const activeElement = activeElements[0];

                const layer = Util
                    .$currentWorkSpace()
                    .scene
                    .getLayer(
                        activeElement.dataset.layerId | 0
                    );

                const character = layer.getCharacter(
                    activeElement.dataset.characterId | 0
                );
                if (!character) {
                    return ;
                }

                const range = character.getRange(
                    Util.$timelineFrame.currentFrame
                );
                if (!character.hasTween(range.startFrame)) {
                    return ;
                }

                // データの読み込み
                const tweenObject  = character.getTween(range.startFrame);
                tweenObject.custom = JSON.parse(text);

                // 変数を初期化
                this._$easeTarget = null;

                // 初期化して再生成
                this.clearEasingPointer();
                this.createEasingPointer();

                // 再描画
                this.drawEasingGraph();

                // 再計算
                this.relocationPlace(character, range.startFrame);

                // 再配置
                this
                    .clearPointer()
                    .relocationPointer();

            });

        // reset
        event.target.value = "";
    }

    /**
     * @description カスタムイージングポインターを追加
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    addEasingPointer (event)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const activeElement = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                activeElement.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            activeElement.dataset.characterId | 0
        );
        if (!character) {
            return ;
        }

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const parent = document
            .getElementById("ease-cubic-pointer-area");

        const children = parent.children;
        const tween    = character.getTween(range.startFrame);
        const types    = ["curve", "pointer", "curve"];
        const points   = [-20, 0, 20];

        const scale = TweenController.EASE_BASE_CANVAS_SIZE / TweenController.EASE_RANGE;

        const x = (event.layerX - TweenController.EASE_BASE_CANVAS_SIZE) / scale;
        const y = (TweenController.EASE_BASE_CANVAS_SIZE - (event.layerY - 300)) / scale;

        // new pointer
        for (let idx = 0; idx < types.length; ++idx) {

            const type = types[idx];

            const dx = x + points[idx];
            const dy = y + points[idx];

            const div = this.createEasingPointerDiv(dx, dy, type);

            parent.insertBefore(
                div, children[children.length - 1]
            );

            tween.custom.splice(-2, 0, {
                "type": type,
                "x": dx,
                "y": dy
            });
        }

        for (let idx = 0; idx < children.length; ++idx) {
            const child = children[idx];
            child.dataset.index = `${idx + 1}`;
        }

        // 変数を初期化
        this._$easeTarget = null;

        // 再描画
        this.drawEasingGraph();

        // 再計算
        this.relocationPlace(character, range.startFrame);

        // 再配置
        this
            .clearPointer()
            .relocationPointer();
    }

    /**
     * @description イージング関数の変更
     *
     * @return {void}
     * @method
     * @public
     */
    changeEaseSelect ()
    {
        const targetFrame = Util.$timelineLayer.targetFrame;
        if (!targetFrame) {
            return ;
        }

        const element = document.getElementById("ease-select");
        if (element.value === "custom") {
            this.showCustomArea();
        } else {
            this.hideCustomArea();
        }

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(
            targetFrame.dataset.layerId | 0
        );

        const frame = targetFrame.dataset.frame | 0;
        const characters = layer.getActiveCharacter(frame);

        if (!characters.length && characters.length > 1) {
            return ;
        }

        const character = characters[0];

        const range = character.getRange(frame);
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        character
            .getTween(range.startFrame)
            .method = element.value;

        //  tweenの座標を再計算してポインターを再配置
        character.relocationTween(range.startFrame);
    }

    /**
     * @description tweenの座標位置を再計算
     *
     * @param  {Character} character
     * @param  {number} frame
     * @param  {string} [mode="none"]
     * @return {void}
     * @method
     * @public
     */
    relocationPlace (character, frame, mode = "none")
    {
        const range = character.getRange(frame);

        // 指定レンジ以前のtweenがあれば再計算
        if (mode === "none" && range.startFrame - 1) {
            const prevRange = character.getRange(range.startFrame - 1);
            if (character.hasTween(prevRange.startFrame)) {
                this.relocationPlace(character, prevRange.startFrame, "prev");
            }
        }

        // tweenのplaceを再構築
        character.updateTweenPlace(range.startFrame, range.endFrame);

        const library = Util
            .$currentWorkSpace()
            .getLibrary(character.libraryId);

        // translate
        const instance = library.createInstance(character.getPlace(frame));

        const point = character.referencePoint;

        const w = instance.width  / 2;
        const h = instance.height / 2;

        const baseBounds = library.getBounds();
        const rectangle  = instance.getBounds();
        const baseMatrix = [
            1, 0, 0, 1,
            -w - rectangle.x - point.x,
            -h - rectangle.y - point.y
        ];

        // start params
        const startPlace  = character.getPlace(range.startFrame);
        const startMatrix = startPlace.matrix;

        const startScaleX = Math.sqrt(
            startMatrix[0] * startMatrix[0]
            + startMatrix[1] * startMatrix[1]
        );
        const startScaleY = Math.sqrt(
            startMatrix[2] * startMatrix[2]
            + startMatrix[3] * startMatrix[3]
        );

        let startRotate = Math.atan2(startMatrix[1], startMatrix[0]) * Util.$Rad2Deg;
        if (0 > startRotate) {
            startRotate += 360;
        }

        const startMultiMatrix = Util.$multiplicationMatrix(
            [startMatrix[0], startMatrix[1], startMatrix[2], startMatrix[3], 0, 0],
            baseMatrix
        );

        const startX = startMatrix[4] - (startMultiMatrix[4] + w + rectangle.x + point.x);
        const startY = startMatrix[5] - (startMultiMatrix[5] + h + rectangle.y + point.y);

        const startDiv = document
            .getElementById(`tween-marker-${character.id}-${range.startFrame}`);

        if (startDiv) {
            const bounds = Util.$boundsMatrix(baseBounds, startMatrix);
            const width  = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2 * Util.$zoomScale);
            const height = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2 * Util.$zoomScale);

            startDiv.style.left = `${Util.$offsetLeft + bounds.xMin * Util.$zoomScale + width  - 2}px`;
            startDiv.style.top  = `${Util.$offsetTop  + bounds.yMin * Util.$zoomScale + height - 2}px`;
        }

        // end params
        let endFrame = range.endFrame - 1;
        let endPlace = character.getPlace(endFrame);
        if (character.hasTween(range.endFrame)) {
            endFrame = range.endFrame;
            endPlace = character.getPlace(range.endFrame);
        }

        const endMatrix = endPlace.matrix;
        const endScaleX = Math.sqrt(
            endMatrix[0] * endMatrix[0]
            + endMatrix[1] * endMatrix[1]
        );
        const endScaleY = Math.sqrt(
            endMatrix[2] * endMatrix[2]
            + endMatrix[3] * endMatrix[3]
        );

        let endRotate = Math.atan2(endMatrix[1], endMatrix[0]) * Util.$Rad2Deg;
        if (0 > endRotate) {
            endRotate += 360;
        }

        const endMultiMatrix = Util.$multiplicationMatrix(
            [endMatrix[0], endMatrix[1], endMatrix[2], endMatrix[3], 0, 0],
            baseMatrix
        );

        const endX = endMatrix[4] - (endMultiMatrix[4] + w + rectangle.x + point.x);
        const endY = endMatrix[5] - (endMultiMatrix[5] + h + rectangle.y + point.y);

        const endDiv = document
            .getElementById(`tween-marker-${character.id}-${endFrame}`);

        if (endDiv) {
            const bounds = Util.$boundsMatrix(baseBounds, endMatrix);
            const width  = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2 * Util.$zoomScale);
            const height = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2 * Util.$zoomScale);

            endDiv.style.left = `${Util.$offsetLeft + bounds.xMin * Util.$zoomScale + width  - 2}px`;
            endDiv.style.top  = `${Util.$offsetTop  + bounds.yMin * Util.$zoomScale + height - 2}px`;
        }

        const tween = character.getTween(range.startFrame);
        const functionName = tween.method;

        // (fixed logic)
        const totalFrame = endFrame - range.startFrame;

        // diff
        const diffX = endX - startX;
        const diffY = endY - startY;

        // scale
        const diffScaleX = endScaleX - startScaleX;
        const diffScaleY = endScaleY - startScaleY;

        // rotate
        const diffRotate = endRotate - startRotate;

        // ColorTransform
        const startColorTransform = startPlace.colorTransform;
        const endColorTransform   = endPlace.colorTransform;
        const ct0 = endColorTransform[0] - startColorTransform[0];
        const ct1 = endColorTransform[1] - startColorTransform[1];
        const ct2 = endColorTransform[2] - startColorTransform[2];
        const ct3 = endColorTransform[3] - startColorTransform[3];
        const ct4 = endColorTransform[4] - startColorTransform[4];
        const ct5 = endColorTransform[5] - startColorTransform[5];
        const ct6 = endColorTransform[6] - startColorTransform[6];
        const ct7 = endColorTransform[7] - startColorTransform[7];

        const { Easing } = window.next2d.ui;

        let time = 1;
        for (let frame = range.startFrame + 1; frame < endFrame; ++frame) {

            const place = character.getPlace(frame);

            const t = time / totalFrame;
            let customValue = 0;
            if (functionName === "custom") {
                for (let idx = 0; idx < tween.custom.length; idx += 3) {

                    const curve1 = tween.custom[idx + 1];

                    let pointer = tween.custom[idx + 3];
                    if (pointer.off) {
                        idx += 3;
                        for (;;) {
                            pointer = tween.custom[idx + 3];
                            if (pointer.fixed || !pointer.off) {
                                break;
                            }
                            idx += 3;
                        }
                    }

                    if (pointer.x / TweenController.EASE_RANGE > t) {

                        const curve2 = tween.custom[idx + 2];

                        customValue = this.cubicBezier(
                            curve1.x / TweenController.EASE_RANGE,
                            curve1.y / TweenController.EASE_RANGE,
                            curve2.x / TweenController.EASE_RANGE,
                            curve2.y / TweenController.EASE_RANGE
                        )(t);

                        break;
                    }
                }
            }

            const matrix = place.matrix;

            // scale
            const xScale = !diffScaleX
                ? startScaleX
                : functionName === "custom"
                    ? diffScaleX * customValue + startScaleX
                    : Easing[functionName](time, startScaleX, diffScaleX, totalFrame);

            const yScale = !diffScaleY
                ? startScaleY
                : functionName === "custom"
                    ? diffScaleY * customValue + startScaleY
                    : Easing[functionName](time, startScaleY, diffScaleY, totalFrame);

            const rotation = !diffRotate
                ? startRotate
                : functionName === "custom"
                    ? diffRotate * customValue + startRotate
                    : Easing[functionName](time, startRotate, diffRotate, totalFrame) % 360;

            // rotation
            let radianX  = Math.atan2(matrix[1],  matrix[0]);
            let radianY  = Math.atan2(-matrix[2], matrix[3]);
            const radian = rotation * Util.$Deg2Rad;
            radianY      = radianY + radian - radianX;
            radianX      = radian;

            // new matrix
            matrix[0] = xScale  * Math.cos(radianX);
            matrix[1] = xScale  * Math.sin(radianX);
            matrix[2] = -yScale * Math.sin(radianY);
            matrix[3] = yScale  * Math.cos(radianY);

            matrix[4] = !diffX
                ? startX
                : functionName === "custom"
                    ? customValue * diffX + startX
                    : Easing[functionName](time, startX, diffX, totalFrame);

            matrix[5] = !diffY
                ? startY
                : functionName === "custom"
                    ? customValue * diffY + startY
                    : Easing[functionName](time, startY, diffY, totalFrame);

            if (tween.curve.length) {

                const baseDistance = Math.sqrt(
                    Math.pow(diffX, 2)
                    + Math.pow(diffY, 2)
                );

                const distance = Math.sqrt(
                    Math.pow(matrix[4] - startX, 2)
                    + Math.pow(matrix[5] - startY, 2)
                );

                if (distance && baseDistance) {

                    const curvePoint = this.getCurvePoint(
                        distance / baseDistance,
                        startX, startY, endX, endY,
                        tween.curve
                    );

                    if (curvePoint) {
                        matrix[4] = curvePoint.x;
                        matrix[5] = curvePoint.y;
                    }
                }
            }

            const multiMatrix = Util.$multiplicationMatrix(
                [matrix[0], matrix[1], matrix[2], matrix[3], 0, 0],
                baseMatrix
            );

            matrix[4] += multiMatrix[4] + w + rectangle.x + point.x;
            matrix[5] += multiMatrix[5] + h + rectangle.y + point.y;

            // ColorTransform
            const colorTransform = place.colorTransform;

            colorTransform[0] = !ct0
                ? startColorTransform[0]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct0 * customValue + startColorTransform[0]
                        : Easing[functionName](time, startColorTransform[0], ct0, totalFrame),
                    ColorTransformController.MIN_MULTIPLIER,
                    ColorTransformController.MAX_MULTIPLIER
                );

            colorTransform[1] = !ct1
                ? startColorTransform[1]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct1 * customValue + startColorTransform[1]
                        : Easing[functionName](time, startColorTransform[1], ct1, totalFrame),
                    ColorTransformController.MIN_MULTIPLIER,
                    ColorTransformController.MAX_MULTIPLIER
                );

            colorTransform[2] = !ct2
                ? startColorTransform[2]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct2 * customValue + startColorTransform[2]
                        : Easing[functionName](time, startColorTransform[2], ct2, totalFrame),
                    ColorTransformController.MIN_MULTIPLIER,
                    ColorTransformController.MAX_MULTIPLIER
                );

            colorTransform[3] = !ct3
                ? startColorTransform[3]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct3 * customValue + startColorTransform[3]
                        : Easing[functionName](time, startColorTransform[3], ct3, totalFrame),
                    ColorTransformController.MIN_MULTIPLIER,
                    ColorTransformController.MAX_MULTIPLIER
                );

            colorTransform[4] = !ct4
                ? startColorTransform[4]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct4 * customValue + startColorTransform[4]
                        : Easing[functionName](time, startColorTransform[4], ct4, totalFrame),
                    ColorTransformController.MIN_OFFSET,
                    ColorTransformController.MAX_OFFSET
                );

            colorTransform[5] = !ct5
                ? startColorTransform[5]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct5 * customValue + startColorTransform[5]
                        : Easing[functionName](time, startColorTransform[5], ct5, totalFrame),
                    ColorTransformController.MIN_OFFSET,
                    ColorTransformController.MAX_OFFSET
                );

            colorTransform[6] = !ct6
                ? startColorTransform[6]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct6 * customValue + startColorTransform[6]
                        : Easing[functionName](time, startColorTransform[6], ct6, totalFrame),
                    ColorTransformController.MIN_OFFSET,
                    ColorTransformController.MAX_OFFSET
                );

            colorTransform[7] = !ct7
                ? startColorTransform[7]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct7 * customValue + startColorTransform[7]
                        : Easing[functionName](time, startColorTransform[7], ct7, totalFrame),
                    ColorTransformController.MIN_OFFSET,
                    ColorTransformController.MAX_OFFSET
                );

            const div = document
                .getElementById(`tween-marker-${character.id}-${frame}`);

            if (div) {
                const bounds = Util.$boundsMatrix(baseBounds, matrix);
                const width  = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2 * Util.$zoomScale);
                const height = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2 * Util.$zoomScale);

                div.style.left = `${Util.$offsetLeft + bounds.xMin * Util.$zoomScale + width  - 2}px`;
                div.style.top  = `${Util.$offsetTop  + bounds.yMin * Util.$zoomScale + height - 2}px`;
            }

            time++;
        }

        // filter
        const startFilters = startPlace.filter;
        const endFilters   = endPlace.filter;
        if (startFilters.length && endFilters.length) {

            const params = [
                "blurX",
                "blurY",
                "quality",
                "color",
                "alpha",
                "distance",
                "angle",
                "highlightColor",
                "highlightAlpha",
                "shadowColor",
                "shadowAlpha",
                "strength"
            ];

            const length = startFilters.length;
            for (let idx = 0; idx < length; ++idx) {

                const startFilter = startFilters[idx];
                const endFilter   = endFilters[idx];

                if (startFilter.name !== endFilter.name) {
                    continue;
                }

                let time = 1;
                for (let frame = range.startFrame + 1; range.endFrame > frame; ++frame) {

                    const filters = character.getPlace(frame).filter;
                    if (!filters[idx]) {
                        filters[idx] = new Util.$filterClasses[startFilter.name]();
                    }

                    const filter = filters[idx];
                    for (let idx = 0; idx < params.length; ++idx) {

                        const name = params[idx];

                        if (name in filter) {

                            const diff = endFilter[name] - startFilter[name];
                            if (!diff) {
                                continue;
                            }

                            filter[name] = functionName === "custom"
                                ? diff * customValue + startFilter[name]
                                : Easing[functionName](time, startFilter[name], diff, totalFrame);

                        }

                    }

                    time++;
                }
            }
        }

        character._$image = null;
    }

    /**
     * @description tweenのポインターをスクリーンに配置
     *
     * @return {void}
     * @method
     * @public
     */
    relocationPointer ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;
        const scene = Util.$currentWorkSpace().scene;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];

            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            if (!character) {
                continue;
            }

            const range = character.getRange(frame);
            if (!character.hasTween(range.startFrame)) {
                continue;
            }

            let startFrame = range.startFrame;
            while (character.startFrame !== startFrame && startFrame > 1) {

                const range = character.getRange(startFrame - 1);
                if (!character.hasTween(range.startFrame)) {
                    break;
                }

                startFrame = range.startFrame;
            }

            let endFrame = range.endFrame;
            while (character.hasTween(endFrame)) {
                endFrame = character.getTween(endFrame).endFrame;
            }

            const instance = Util
                .$currentWorkSpace()
                .getLibrary(character.libraryId);

            const baseBounds = instance.getBounds();
            const parentElement = document.getElementById("stage-area");
            for (let frame = startFrame; frame < endFrame; ++frame) {

                const div = document.createElement("div");

                // 表示座標
                const matrix = character.getPlace(frame).matrix;
                const bounds = Util.$boundsMatrix(baseBounds, matrix);
                const width  = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2 * Util.$zoomScale);
                const height = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2 * Util.$zoomScale);
                div.style.left = `${Util.$offsetLeft + bounds.xMin * Util.$zoomScale + width  - 2}px`;
                div.style.top  = `${Util.$offsetTop  + bounds.yMin * Util.$zoomScale + height - 2}px`;

                // 表示用データ
                div.id = `tween-marker-${character.id}-${frame}`;
                div.classList.add("tween-marker");
                div.dataset.child = "tween";

                parentElement.appendChild(div);
            }

            const tweenObject = character.getTween(range.startFrame);
            for (let idx = 0; idx < tweenObject.curve.length; ++idx) {

                const pointer = tweenObject.curve[idx];

                parentElement.appendChild(
                    this.createTweenCurveElement(pointer, idx, layer.id)
                );

            }
        }
    }

    /**
     * @description スクリーンのポインターを非表示にする
     *
     * @return {TweenController}
     * @method
     * @public
     */
    clearPointer ()
    {
        const element = document
            .getElementById("stage-area");

        let idx = 0;
        while (element.children.length > idx) {

            const node = element.children[idx];
            if (node.dataset.child !== "tween") {
                idx++;
                continue;
            }

            node.remove();
        }

        return this;
    }

    /**
     * @description カーブポインターの移動開始関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    startMoveCurvePointer (event)
    {
        if (event.button) {
            return ;
        }

        Util.$endMenu();

        // 他のイベントを中止
        event.stopPropagation();

        this._$currentTarget = event.target;

        this._$pointX = event.pageX;
        this._$pointY = event.pageY;

        if (!this._$moveCurvePointer) {
            this._$moveCurvePointer = this.moveCurvePointer.bind(this);
        }

        if (!this._$endMoveCurvePointer) {
            this._$endMoveCurvePointer = this.endMoveCurvePointer.bind(this);
        }

        // 保存開始
        this.save();

        window.addEventListener("mousemove", this._$moveCurvePointer);
        window.addEventListener("mouseup", this._$endMoveCurvePointer);
    }

    /**
     * @description カーブポインターを削除
     *
     * @return {void}
     * @method
     * @public
     */
    deleteCurvePointer ()
    {
        const element = this._$currentTarget;
        if (!element) {
            return ;
        }

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                element.dataset.layerId | 0
            );

        const frame = Util.$timelineFrame.currentFrame;
        const characters = layer.getActiveCharacter(frame);

        if (!characters.length || characters.length > 1) {
            return ;
        }

        // set select
        const character = characters[0];
        const range = character.getRange(frame);

        // カーブポインターを削除
        character
            .getTween(range.startFrame)
            .curve
            .splice(element.dataset.index | 0, 1);

        // カーブElementを削除
        element.remove();

        // 再計算
        this.relocationPlace(character, range.startFrame);

        // 再配置
        this
            .clearPointer()
            .relocationPointer();

        this.save();

        // 初期化
        this._$saved = false;
        this._$currentTarget = null;
    }

    /**
     * @description カーブポインターの移動関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveCurvePointer (event)
    {
        // 全てのイベントを中止
        event.preventDefault();

        window.requestAnimationFrame(() =>
        {
            const element = this._$currentTarget;
            if (!element) {
                return ;
            }

            const x = (event.pageX - this._$pointX) / Util.$zoomScale;
            const y = (event.pageY - this._$pointY) / Util.$zoomScale;

            const layer = Util
                .$currentWorkSpace()
                .scene
                .getLayer(
                    element.dataset.layerId | 0
                );

            const frame = Util.$timelineFrame.currentFrame;

            const characters = layer.getActiveCharacter(frame);
            if (!characters.length && characters.length > 1) {
                return ;
            }

            // set select
            const character = characters[0];

            // tweenがなければ終了
            const range = character.getRange(frame);
            if (!character.hasTween(range.startFrame)) {
                return ;
            }

            const point = character
                .getTween(range.startFrame)
                .curve[element.dataset.index];

            point.x += x;
            point.y += y;

            // 再計算
            this.relocationPlace(character, range.startFrame);

            // 再配置
            this
                .clearPointer()
                .relocationPointer();

            // 再描画
            this.reloadScreen();

            this._$pointX = event.pageX;
            this._$pointY = event.pageY;
        });
    }

    /**
     * @description カーブポインターの移動終了
     *
     * @return {void}
     * @method
     * @public
     */
    endMoveCurvePointer ()
    {
        // イベントを終了
        window.removeEventListener("mousemove", this._$moveCurvePointer);
        window.removeEventListener("mouseup", this._$endMoveCurvePointer);

        // 初期化
        this._$saved = false;
    }

    /**
     * @description カーブポインターのアクティブon/off
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    switchingCurvePointer (event)
    {
        const element = event.target;

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(element.dataset.layerId | 0);

        const frame = Util.$timelineFrame.currentFrame;

        const characters = layer.getActiveCharacter(frame);
        if (!characters.length && characters.length > 1) {
            return ;
        }

        // set select
        const character = characters[0];

        // tweenがなければ終了
        const range = character.getRange(frame);
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const pointer = character
            .getTween(range.startFrame)
            .curve[element.dataset.index];

        pointer.usePoint = !pointer.usePoint;

        if (pointer.usePoint) {

            element.classList.remove("tween-pointer-disabled");
            element.classList.add("tween-pointer-active");

        } else {

            element.classList.add("tween-pointer-disabled");
            element.classList.remove("tween-pointer-active");

        }

        // 再計算
        this.relocationPlace(character, range.startFrame);

        // ポインターを再配置
        this
            .clearPointer()
            .relocationPointer();

        // 再描画
        this.reloadScreen();
    }

    /**
     * @param  {object} pointer
     * @param  {number} index
     * @param  {number} layerId
     * @return {HTMLDivElement|null}
     * @method
     * @public
     */
    createTweenCurveElement (pointer, index, layerId)
    {
        const div = document.createElement("div");
        div.classList.add(
            "tween-pointer-marker",
            "tween-pointer-disabled"
        );

        const frame = Util.$timelineFrame.currentFrame;

        div.textContent     = `${index + 1}`;
        div.dataset.child   = "tween";
        div.dataset.curve   = "true";
        div.dataset.layerId = `${layerId}`;
        div.dataset.index   = `${index}`;
        div.dataset.detail  = "{{カーブポインター(ダブルクリックでON/OFF)}}";

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(layerId);

        const characters = layer.getActiveCharacter(frame);
        if (!characters.length || characters.length > 1) {
            return null;
        }

        const character = characters[0];

        const bounds = Util
            .$currentWorkSpace()
            .getLibrary(character.libraryId)
            .getBounds();

        const width  = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2 * Util.$zoomScale);
        const height = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2 * Util.$zoomScale);

        div.style.left = `${Util.$offsetLeft + pointer.x * Util.$zoomScale + width  - 7}px`;
        div.style.top  = `${Util.$offsetTop  + pointer.y * Util.$zoomScale + height - 7}px`;

        if (pointer.usePoint) {
            div.classList.remove("tween-pointer-disabled");
            div.classList.add("tween-pointer-active");
        } else {
            div.classList.add("tween-pointer-disabled");
            div.classList.remove("tween-pointer-active");
        }

        div.addEventListener("mousedown", (event) =>
        {
            this.startMoveCurvePointer(event);
        });

        div.addEventListener("dblclick", (event) =>
        {
            this.switchingCurvePointer(event);
        });

        div.addEventListener("mouseover", Util.$fadeIn);
        div.addEventListener("mouseout",  Util.$fadeOut);

        return div;
    }

    /**
     * @description イージングポインターの初期オブジェクト
     *
     * @return {object}
     * @method
     * @public
     */
    createEasingObject ()
    {
        return [
            {
                "type": "pointer",
                "fixed": true,
                "x": 0,
                "y": 0
            },
            {
                "type": "curve",
                "x": 0,
                "y": 0
            },
            {
                "type": "curve",
                "x": 100,
                "y": 100
            },
            {
                "type": "pointer",
                "fixed": true,
                "x": 100,
                "y": 100
            }
        ];
    }

    /**
     * @description カスタムイージングのポインターを生成
     *
     * @return {void}
     * @method
     * @public
     */
    createEasingPointer ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const activeElement = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                activeElement.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            activeElement.dataset.characterId | 0
        );
        if (!character) {
            return ;
        }

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const tweenObject = character.getTween(range.startFrame);

        const element = document
            .getElementById("ease-cubic-pointer-area");

        for (let idx = 0; idx < tweenObject.custom.length; ++idx) {

            const custom = tweenObject.custom[idx];
            if (custom.fixed) {
                continue;
            }

            const div = this.createEasingPointerDiv(
                custom.x, custom.y, custom.type, idx
            );

            if (custom.off) {
                div.classList.add("ease-cubic-disable");
            }

            element.appendChild(div);
        }
    }

    /**
     * @description カスタムイージングのポインターの移動開始処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    startMoveEasingPointer (event)
    {
        this._$easeTarget = event.currentTarget;
        this._$pointX     = event.screenX;
        this._$pointY     = event.screenY;

        if (!this._$moveEasingPointer) {
            this._$moveEasingPointer = this.moveEasingPointer.bind(this);
        }

        if (!this._$endMoveEasingPointer) {
            this._$endMoveEasingPointer = this.endMoveEasingPointer.bind(this);
        }

        this.save();

        // イベントを登録
        window.addEventListener("mousemove", this._$moveEasingPointer);
        window.addEventListener("mouseup", this._$endMoveEasingPointer);
        window.removeEventListener("keydown", this._$deleteEasingPointer);
    }

    /**
     * @description カスタムイージングのポインターを削除
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    deleteEasingPointer (event)
    {
        if (event.key !== "Backspace" || !this._$easeTarget) {
            return ;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const activeElement = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                activeElement.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            activeElement.dataset.characterId | 0
        );
        if (!character) {
            return ;
        }

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const tweenObject = character.getTween(range.startFrame);
        const index  = this._$easeTarget.dataset.index | 0;
        tweenObject.custom.splice(index - 1, 3);

        const children = document
            .getElementById("ease-cubic-pointer-area")
            .children;

        children[index].remove();
        children[index - 1].remove();
        children[index - 2].remove();

        for (let idx = 0; idx < children.length; ++idx) {
            const child = children[idx];
            child.dataset.index = `${idx + 1}`;
        }

        // 再描画
        this.drawEasingGraph();

        // 再計算
        this.relocationPlace(character, range.startFrame);

        // 再配置
        this
            .clearPointer()
            .relocationPointer();
    }

    /**
     * @description カスタムイージングのポインターの移動関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveEasingPointer (event)
    {
        window.requestAnimationFrame(() =>
        {
            if (!this._$easeTarget) {
                return ;
            }

            /**
             * @type {ArrowTool}
             */
            const tool = Util.$tools.getDefaultTool("arrow");
            const activeElements = tool.activeElements;
            if (!activeElements.length || activeElements.length > 1) {
                return ;
            }

            const activeElement = activeElements[0];

            const layer = Util
                .$currentWorkSpace()
                .scene
                .getLayer(
                    activeElement.dataset.layerId | 0
                );

            const character = layer.getCharacter(
                activeElement.dataset.characterId | 0
            );
            if (!character) {
                return ;
            }

            const range = character.getRange(
                Util.$timelineFrame.currentFrame
            );
            if (!character.hasTween(range.startFrame)) {
                return ;
            }

            const element = this._$easeTarget;
            let x = element.offsetLeft + event.screenX - this._$pointX;
            let y = element.offsetTop  + event.screenY - this._$pointY;

            // update
            this._$pointX = event.screenX;
            this._$pointY = event.screenY;

            if (TweenController.EASE_MIN_POINTER_Y > y) {
                y = TweenController.EASE_MIN_POINTER_Y;
            }

            if (TweenController.EASE_MAX_POINTER_Y < y) {
                y = TweenController.EASE_MAX_POINTER_Y;
            }

            if (TweenController.EASE_MIN_POINTER_X > x) {
                x = TweenController.EASE_MIN_POINTER_X;
            }

            if (TweenController.EASE_MAX_POINTER_X < x) {
                x = TweenController.EASE_MAX_POINTER_X;
            }

            element.style.left = `${x}px`;
            element.style.top  = `${y}px`;

            const tweenObject = character.getTween(range.startFrame);
            const custom = tweenObject.custom[element.dataset.index];

            const scale = TweenController.EASE_BASE_CANVAS_SIZE / TweenController.EASE_RANGE;
            custom.x = (x - TweenController.EASE_SCREEN_X) / scale;
            custom.y = (TweenController.EASE_MOVE_Y - y) / scale;

            document
                .getElementById("ease-cubic-current-text")
                .textContent = `(${custom.x / TweenController.EASE_RANGE * 100 | 0})`;

            document
                .getElementById("ease-cubic-current-tween")
                .textContent = `(${custom.y / TweenController.EASE_RANGE * 100 | 0})`;

            // 再描画
            this.drawEasingGraph();

            // 再計算
            this.relocationPlace(character, range.startFrame);

            // 再配置
            this
                .clearPointer()
                .relocationPointer();
        });
    }

    /**
     * @description カスタムイージングのポインターの移動を終了
     *
     * @return {void}
     * @method
     * @public
     */
    endMoveEasingPointer ()
    {
        // イベントを登録
        window.removeEventListener("mousemove", this._$moveEasingPointer);
        window.removeEventListener("mouseup", this._$endMoveEasingPointer);
        window.addEventListener("keydown", this._$deleteEasingPointer);

        // 初期化
        this._$saved = false;
    }

    /**
     * @description カスタムイージングポインターを削除
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    disabledEasingPointer (event)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const activeElement = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                activeElement.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            activeElement.dataset.characterId | 0
        );
        if (!character) {
            return ;
        }

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const tweenObject = character.getTween(range.startFrame);

        const index  = event.target.dataset.index | 0;
        const custom = tweenObject.custom[index];

        custom.off = !custom.off;
        tweenObject.custom[index - 1].off = custom.off;
        tweenObject.custom[index + 1].off = custom.off;

        const children = document
            .getElementById("ease-cubic-pointer-area")
            .children;

        if (custom.off) {
            children[index - 2].classList.add("ease-cubic-disable");
            children[index - 1].classList.add("ease-cubic-disable");
            children[index    ].classList.add("ease-cubic-disable");
        } else {
            children[index - 2].classList.remove("ease-cubic-disable");
            children[index - 1].classList.remove("ease-cubic-disable");
            children[index    ].classList.remove("ease-cubic-disable");
        }

        // 変数を初期化
        this._$easeTarget = null;

        // 再描画
        this.drawEasingGraph();

        // 再計算
        this.relocationPlace(character, range.startFrame);

        // 再配置
        this
            .clearPointer()
            .relocationPointer();
    }

    /**
     * @description カスタムイージングのdivを生成
     *
     * @param  {number}  [x=0]
     * @param  {number}  [y=0]
     * @param  {string}  [type="pointer"]
     * @param  {number}  [index=0]
     * @return {HTMLDivElement}
     * @method
     * @public
     */
    createEasingPointerDiv (x = 0, y = 0, type = "pointer", index = 0)
    {
        const div = document.createElement("div");

        // 移動開始イベント
        div.addEventListener("mousedown", (event) =>
        {
            this.startMoveEasingPointer(event);
        });

        if (type === "pointer") {
            // ポインターを非アクティブ化
            div.addEventListener("dblclick", (event) =>
            {
                this.disabledEasingPointer(event);
            });
        }

        div.classList.add(`ease-cubic-${type}`);
        div.dataset.index = `${index}`;
        div.dataset.type  = `${type}`;

        const scale = TweenController.EASE_BASE_CANVAS_SIZE / TweenController.EASE_RANGE;

        div.style.left = `${TweenController.EASE_SCREEN_X + x * scale}px`;
        div.style.top  = `${TweenController.EASE_SCREEN_Y + (TweenController.EASE_RANGE - y) * scale}px`;

        return div;
    }

    /**
     * @description カスタムイージングの状態を描画
     *
     * @return {void}
     * @method
     * @public
     */
    drawEasingGraph ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const activeElement = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                activeElement.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            activeElement.dataset.characterId | 0
        );
        if (!character) {
            return ;
        }

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const tweenObject = character.getTween(range.startFrame);

        const ratio   = window.devicePixelRatio;
        const offsetX = TweenController.EASE_OFFSET_X * ratio;
        const offsetY = TweenController.EASE_OFFSET_Y * ratio;

        const ctx = this._$drawContext;
        ctx.fillStyle = "rgb(240, 240, 240)";

        const size = TweenController.EASE_BASE_CANVAS_SIZE * ratio;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.fillRect(offsetX, offsetY, size, size);

        ctx.lineCap = "round";
        ctx.translate(offsetX, offsetY);

        // ベースの描画
        ctx.beginPath();
        ctx.strokeStyle = "rgba(200, 200, 200, 0.6)";
        ctx.lineWidth   = 10;
        ctx.moveTo(0, 0);
        ctx.lineTo(size, size);
        ctx.stroke();

        const scale = TweenController.EASE_BASE_CANVAS_SIZE
            / TweenController.EASE_RANGE * ratio;

        for (let idx = 0; idx < tweenObject.custom.length; idx += 3) {

            const startPointer = tweenObject.custom[idx    ];
            const startCurve   = tweenObject.custom[idx + 1];
            let endCurve       = tweenObject.custom[idx + 2];
            let endPointer     = tweenObject.custom[idx + 3];

            if (endPointer.off) {
                idx += 3;
                for (;;) {
                    endCurve   = tweenObject.custom[idx + 2];
                    endPointer = tweenObject.custom[idx + 3];
                    if (endPointer.fixed || !endPointer.off) {
                        break;
                    }
                    idx += 3;
                }
            }

            // start line
            ctx.beginPath();
            ctx.strokeStyle = "rgb(160, 160, 160)";
            ctx.lineWidth   = 3;
            ctx.moveTo(startPointer.x * scale, startPointer.y * scale);
            ctx.lineTo(startCurve.x * scale, startCurve.y * scale);
            ctx.stroke();

            // end line
            ctx.beginPath();
            ctx.strokeStyle = "rgb(160, 160, 160)";
            ctx.lineWidth   = 3;
            ctx.moveTo(endPointer.x * scale, endPointer.y * scale);
            ctx.lineTo(endCurve.x * scale, endCurve.y * scale);
            ctx.stroke();

            // bezier curve
            ctx.beginPath();
            ctx.strokeStyle = "rgb(80, 80, 80)";
            ctx.lineWidth   = 10;
            ctx.moveTo(startPointer.x * scale, startPointer.y * scale);
            ctx.bezierCurveTo(
                startCurve.x * scale, startCurve.y * scale,
                endCurve.x * scale, endCurve.y * scale,
                endPointer.x * scale, endPointer.y * scale
            );
            ctx.stroke();

            if (endPointer.fixed) {
                break;
            }
        }

        const viewContext = this._$viewContext;

        // clear
        viewContext.setTransform(1, 0, 0, 1, 0, 0);
        viewContext.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        // 反転して出力
        viewContext.scale(1, -1);
        viewContext.translate(0, -ctx.canvas.height);
        viewContext.drawImage(ctx.canvas, 0, 0);
    }

    /**
     * @description カーブポインターのxy座標計算
     *
     * @param  {number} d
     * @param  {number} sx
     * @param  {number} sy
     * @param  {number} ex
     * @param  {number} ey
     * @param  {array} curves
     * @return {object}
     * @method
     * @public
     */
    getCurvePoint (d, sx, sy, ex, ey, curves)
    {
        const targets = [];
        for (let idx = 0; idx < curves.length; ++idx) {

            const pointer = curves[idx];

            if (!pointer.usePoint) {
                continue;
            }

            targets.push(pointer);
        }

        if (!targets.length) {
            return null;
        }

        const t = 1 - d;
        const l = targets.length + 1;
        for (let idx = 0; idx < l; ++idx) {
            sx *= t;
            sy *= t;
            ex *= d;
            ey *= d;
        }

        let x = sx + ex;
        let y = sy + ey;
        for (let idx = 0; idx < targets.length; ++idx) {

            const curve = targets[idx];

            const p = idx + 1;

            let cx = curve.x * l;
            let cy = curve.y * l;
            for (let jdx = 0; jdx < p; ++jdx) {
                cx *= d;
                cy *= d;
            }

            for (let jdx = 0; jdx < l - p; ++jdx) {
                cx *= t;
                cy *= t;
            }

            x += cx;
            y += cy;
        }

        return {
            "x": x,
            "y": y
        };
    }

    /**
     * @description 3次ベジェのカーブの計算
     *
     * @param  {number} $x1
     * @param  {number} $y1
     * @param  {number} $x2
     * @param  {number} $y2
     * @return {function}
     * @method
     * @public
     */
    cubicBezier ($x1, $y1, $x2, $y2)
    {
        const cx = 3 * $x1,
            bx = 3 * ($x2 - $x1) - cx,
            ax = 1 - cx - bx;

        const cy = 3 * $y1,
            by = 3 * ($y2 - $y1) - cy,
            ay = 1 - cy - by;

        const bezierX = ($t) =>
        {
            return $t * (cx + $t * (bx + $t * ax));
        };

        const bezierDX = ($t) =>
        {
            return cx + $t * (2 * bx + 3 * ax * $t);
        };

        const newtonRaphson = ($x) =>
        {
            if ($x <= 0) {
                return 0;
            }

            if ($x >= 1) {
                return 1;
            }

            let limit = 0;
            let prev = 0, t = $x;
            while (Math.abs(t - prev) > 1e-4) {

                prev = t;
                t = t - (bezierX(t) - $x) / bezierDX(t);

                limit++;
                if (limit > 1000) {
                    break;
                }
            }

            return t;
        };

        return ($t) =>
        {
            const t = newtonRaphson($t);
            return t * (cy + t * (by + t * ay));
        };
    }

    /**
     * @description カスタムイージングポインターを初期化
     *
     * @return {TweenController}
     * @method
     * @public
     */
    clearEasingPointer ()
    {
        // 初期化
        const element = document
            .getElementById("ease-cubic-pointer-area");

        if (element) {
            while (element.children.length) {
                element.children[0].remove();
            }
        }
    }

    /**
     * @description イージングコントローラーを表示
     *
     * @return {TweenController}
     * @method
     * @public
     */
    showCustomArea ()
    {
        // 初期化
        this.clearEasingPointer();
        this._$easeTarget = null;

        document
            .getElementById("ease-canvas-view-area")
            .style.display = "";

        this.createEasingPointer();
        this.drawEasingGraph();
    }

    /**
     * @description イージングコントローラーを非表示
     *
     * @return {void}
     * @method
     * @public
     */
    hideCustomArea ()
    {
        const element = document
            .getElementById("ease-canvas-view-area");

        if (element) {
            element.style.display = "none";
        }
    }

    /**
     * @description tweenのカーブポイントを追加
     *
     * @return {void}
     * @method
     * @public
     */
    addCurvePinter ()
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(
            targetLayer.dataset.layerId | 0
        );

        const characters = layer.getActiveCharacter(frame);
        if (!characters.length || characters.length > 1) {
            return ;
        }

        const character = characters[0];

        const range = character.getRange(frame);
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const tweenObject = character.getTween(range.startFrame);

        const index  = tweenObject.curve.length;
        const bounds = character.getBounds();

        const pointer = {
            "usePoint": true,
            "x": bounds.xMin,
            "y": bounds.yMin
        };
        tweenObject.curve.push(pointer);

        const div = this.createTweenCurveElement(pointer, index, layer.id);
        if (div) {
            document
                .getElementById("stage-area")
                .appendChild(div);
        }

        // 再計算
        this.relocationPlace(character, range.startFrame);

        // ポインターを再配置
        this
            .clearPointer()
            .relocationPointer();
    }
}

Util.$tweenController = new TweenController();

/**
 * @class
 * @extends {BaseController}
 */
class VideoController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("video");
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_VOLUME ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_VOLUME ()
    {
        return 100;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "video-loop-select",
            "video-auto-select"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(elementIds[idx])
            );
        }

        this.setInputEvent(
            document.getElementById("video-volume")
        );
    }

    /**
     * @description Videoのループ設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeVideoLoopSelect (value)
    {
        this.updateVideoProperty("loop", (value | 0) === 1);
    }

    /**
     * @description Videoの自動再生設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeVideoAutoSelect (value)
    {
        this.updateVideoProperty("autoPlay", (value | 0) === 1);
    }

    /**
     * @description Videoの音声設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeVideoVolume (value)
    {
        value = Util.$clamp(
            value | 0,
            VideoController.MIN_VOLUME,
            VideoController.MAX_VOLUME
        );

        this.updateVideoProperty("volume", value);

        return value;
    }

    /**
     * @description Videoコントローラーの値を更新
     * @param {string} name
     * @param {*} value
     * @method
     * @public
     */
    updateVideoProperty (name, value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const element  = activeElements[0];
        const instance = Util.$currentWorkSpace().getLibrary(
            element.dataset.libraryId | 0
        );

        instance[name] = value;
    }
}

Util.$videoController = new VideoController();

/**
 * @class
 */
class DrawingLayer
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        this._$begin = false;
    }

    /**
     * @method
     * @public
     */
    beginDraw ()
    {
        this._$begin = true;
    }
}

/**
 * @class
 */
class ExternalDocument
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        /**
         * @type {ExternalTimeline}
         * @private
         */
        this._$timeline = new ExternalTimeline();

        /**
         * @type {ExternalLibrary}
         * @private
         */
        this._$library = new ExternalLibrary();
    }

    /**
     * @return {ExternalTimeline}
     * @method
     * @public
     */
    getTimeline ()
    {
        return this._$timeline;
    }

    /**
     * @return {ExternalLibrary}
     */
    get library ()
    {
        return this._$library;
    }
}

/**
 * @class
 */
class ExternalElement
{
    /**
     * @param {Character} character
     * @param {ExternalLayer} parent
     * @constructor
     * @public
     */
    constructor (character, parent)
    {
        /**
         * @type {Character}
         * @private
         */
        this._$character = character;

        /**
         * @type {ExternalLayer}
         * @private
         */
        this._$parent = parent;
    }

    /**
     * @return {number}
     * @public
     */
    get x ()
    {
        return this._$character.x;
    }

    /**
     * @param  {number} x
     * @return {void}
     * @public
     */
    set x (x)
    {
        this._$character.x = x;

        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace
            .getLibrary(this._$character.libraryId);

        let frame = Util.$timelineFrame.currentFrame;

        const place = this._$character.getPlace(frame);

        let keys = Object.keys(place);
        const placeObject = {};
        for (let idx = 0; idx < keys.length; ++idx) {
            const name = keys[idx];
            placeObject[name] = place[name];
        }

        placeObject.loop = Util.$getDefaultLoopConfig();

        // setup
        placeObject.startFrame = this._$character.startFrame;
        placeObject.endFrame   = this._$character.endFrame;

        const bounds = Util.$boundsMatrix(
            instance.getBounds(placeObject),
            placeObject.matrix
        );

        const tx = Util.$offsetLeft + bounds.xMin * Util.$zoomScale;
        this._$character._$screenX = tx;
        document
            .getElementById(`character-${this._$character.id}`)
            .style.left = `${tx}px`;
    }

    /**
     * @return {number}
     * @public
     */
    get y ()
    {
        return this._$character.y;
    }

    /**
     * @param  {number} y
     * @return {void}
     * @public
     */
    set y (y)
    {
        this._$character.y = y;

        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace
            .getLibrary(this._$character.libraryId);

        let frame = Util.$timelineFrame.currentFrame;

        const place = this._$character.getPlace(frame);

        let keys = Object.keys(place);
        const placeObject = {};
        for (let idx = 0; idx < keys.length; ++idx) {
            const name = keys[idx];
            placeObject[name] = place[name];
        }

        placeObject.loop = Util.$getDefaultLoopConfig();

        // setup
        placeObject.startFrame = this._$character.startFrame;
        placeObject.endFrame   = this._$character.endFrame;

        const bounds = Util.$boundsMatrix(
            instance.getBounds(placeObject),
            placeObject.matrix
        );

        const ty = Util.$offsetTop + bounds.yMin * Util.$zoomScale;
        this._$character._$screenY = ty;
        document
            .getElementById(`character-${this._$character.id}`)
            .style.top = `${ty}px`;
    }

    /**
     * @return {ExternalLibrary}
     * @readonly
     * @public
     */
    get libraryItem ()
    {
        return new ExternalLibrary(Util
            .$currentWorkSpace()
            .getLibrary(this._$character.libraryId)
        );
    }

    /**
     * @return {string}
     * @public
     */
    get loop ()
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                this._$character.libraryId
            );

        if (instance.type !== "container") {
            return "";
        }

        const place = this._$character.getPlace(this._$character.startFrame);
        if (!place.loop) {
            return "loop";
        }

        switch (place.loop.type) {

            case 1:
            case 3:
                return "play once";

            case 2:
                return "single frame";

            default:
                return "loop";

        }
    }

    /**
     *
     * @param  {string} loop_type
     * @return {void}
     * @public
     */
    set loop (loop_type)
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                this._$character.libraryId
            );

        if (instance.type !== "container") {
            return ;
        }

        const place = this
            ._$character
            .getPlace(this._$character.startFrame);

        switch (loop_type) {

            case "loop":
                place.loop.type = 0;
                break;

            case "play once":
                place.loop.type = 1;
                break;

            case "single frame":
                place.loop.type = 2;
                break;

            default:
                place.loop.type = Util.DEFAULT_LOOP;
                break;

        }
    }

    /**
     * @return {string}
     * @public
     */
    get symbolType ()
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                this._$character.libraryId
            );

        return instance.type === "container" ? "movie clip" : "";
    }

    /**
     * @param  {string} symbol_type
     * @return {void}
     * @public
     */
    set symbolType (symbol_type)
    {
        switch (symbol_type) {

            case "button":
            case "movie clip":
            case "graphic":
                {
                    const workSpace = Util.$currentWorkSpace();

                    const beforeInstance = workSpace.getLibrary(
                        this._$character.libraryId
                    );
                    if (beforeInstance.type === "container") {
                        return ;
                    }

                    const id = workSpace.nextLibraryId;
                    const instance = workSpace.addLibrary(
                        Util.$controller.createContainer("container", `MovieClip_${id}`, id)
                    );

                    const character  = this._$character.clone();
                    const totalFrame = character._$endFrame - character._$startFrame + 1;

                    const moveFrame = character._$startFrame - 1;
                    const places = new Map();
                    for (let [frame, place] of character._$places) {
                        place.frame = frame - moveFrame;
                        places.set(place.frame, place);
                    }
                    character._$places     = places;
                    character._$startFrame = 1;
                    character._$endFrame   = totalFrame;

                    const layer = new Layer();

                    // clone frame
                    const frameClass = this._$parent._$layer._$frame;
                    for (let [frame, css] of frameClass._$classes) {
                        if (1 > frame - moveFrame) {
                            continue;
                        }
                        layer._$frame._$classes.set(frame - moveFrame, css);
                    }

                    instance.setLayer(instance._$layerId++, layer);
                    layer.addCharacter(character);

                    // cache clear
                    this._$character._$currentFrame = 0;
                    this._$character._$currentPlace = null;
                    this._$character._$image        = null;

                    // update
                    this._$character._$libraryId = id;
                    for (let place of this._$character._$places.values()) {
                        place.loop = Util.$getDefaultLoopConfig();
                    }

                    workSpace.scene.changeFrame(
                        Util.$timelineFrame.currentFrame
                    );
                }
                break;

            default:
                break;

        }
    }

}

/**
 * @class
 */
class ExternalFrame
{
    /**
     * @param {number} frame
     * @param {ExternalLayer} parent
     * @constructor
     * @public
     */
    constructor (frame, parent)
    {
        this._$frame  = frame;
        this._$parent = parent;
    }

    /**
     * @return {array}
     * @public
     */
    get elements ()
    {
        const characters = this
            ._$parent
            ._$layer
            .getActiveCharacter(this._$frame);

        const elements = [];
        for (let idx = 0; idx < characters.length; ++idx) {
            elements.push(new ExternalElement(characters[idx], this._$parent));
        }

        return elements;
    }
}

/**
 * @class
 */
class ExternalInterface
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {ExternalDocument}
         * @private
         */
        this._$dom = new ExternalDocument();

        /**
         * @type {Map}
         * @private
         */
        this._$panel = new Map();

        /**
         * @type {DrawingLayer}
         * @private
         */
        this._$drawingLayer = new DrawingLayer();
    }

    /**
     * @return {DrawingLayer}
     * @public
     */
    get drawingLayer ()
    {
        return this._$drawingLayer;
    }

    /**
     * @param  {string} text
     * @param  {function} [callback=null]
     * @return {void}
     * @method
     * @public
     */
    addMenu (text, callback = null)
    {
        const element = document
            .getElementById("plugin-menu");

        const div = document.createElement("div");
        div.classList.add("screen-menu-bottom");
        div.textContent = text;

        if (callback) {
            div.addEventListener("mousedown", callback);
        }

        element.appendChild(div);
    }

    /**
     * @param {string}  name
     * @param {Element} element
     * @param {number}  [width = 200]
     * @param {number}  [height = 200]
     */
    createPanel (name, element, width = 200, height = 200)
    {
        this._$panel.set(name, {
            "width": width,
            "height": height,
            "element": element
        });
    }

    /**
     * @param {string} name
     * @method
     * @public
     */
    showPanel (name)
    {
        if (!this._$panel.has(name)) {
            return ;
        }

        document
            .getElementById("plugin-title")
            .textContent = name;

        const panel = this._$panel.get(name);
        document
            .getElementById("plugin-modal-element")
            .appendChild(panel.element);

        document
            .documentElement
            .style
            .setProperty(
                "--plugin-modal-width",
                `${panel.width}px`
            );

        document
            .documentElement
            .style
            .setProperty(
                "--plugin-modal-height",
                `${panel.height}px`
            );

        const element = document
            .getElementById("plugin-modal");

        element.style.top  = "100px";
        element.style.left = "100px";

        element.setAttribute("class", "fadeIn");
        Util.$endMenu("plugin-modal");
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    hidePanel ()
    {
        Util.$endMenu();

        const children = document
            .getElementById("plugin-modal-element")
            .children;

        while (children.length) {
            children[0].remove();
        }
    }

    /**
     * @return {ExternalDocument}
     * @method
     * @public
     */
    getDocumentDOM ()
    {
        return this._$dom;
    }

    /**
     * @description 新規ツールを追加
     *
     * @param  {string} name
     * @return {ExternalTool}
     */
    addTool (name)
    {
        return new ExternalTool(name);
    }

    /**
     * @description オリジナルのショートカットコマンドを登録
     *
     * @param  {string} area
     * @param  {string} key
     * @param  {function} callback
     * @return {void}
     * @method
     * @public
     */
    setShortcut (area, key, callback)
    {
        switch (area) {

            case "global":
                Util.$setShortcut(key, callback);
                break;

            case "screen":
                Util.$screenKeyboardCommand.add(key, callback);
                break;

            case "timeline":
                Util.Util.$timelineKeyboardCommand.add(key, callback);
                break;

            case "library":
                Util.Util.$libraryKeyboardCommand.add(key, callback);
                break;

            default:
                break;

        }
    }

    /**
     * @description 登録済みのショートカットコマンドを削除
     *
     * @param  {string} area
     * @param  {string} key
     * @return {void}
     * @method
     * @public
     */
    deleteShortcut (area, key)
    {
        switch (area) {

            case "global":
                Util.$deleteShortcut(key);
                break;

            case "screen":
                Util.$screenKeyboardCommand.delete(key);
                break;

            case "timeline":
                Util.Util.$timelineKeyboardCommand.delete(key);
                break;

            case "library":
                Util.Util.$libraryKeyboardCommand.delete(key);
                break;

            default:
                break;

        }
    }
}

/**
 * @class
 */
class ExternalLayer
{
    /**
     * @param {Layer} layer
     */
    constructor (layer)
    {
        this._$layer = layer;
    }

    /**
     * @return {array}
     */
    get frames ()
    {
        const frames = [undefined];
        const totalFrame = this._$layer.totalFrame;
        for (let frame = 1; totalFrame >= frame; ++frame) {
            frames.push(new ExternalFrame(frame, this));
        }
        return frames;
    }

    /**
     * @return {boolean}
     * @public
     */
    get locked ()
    {
        return this._$layer.lock;
    }

    /**
     * @param  {boolean} lock
     * @return {void}
     * @public
     */
    set locked (lock)
    {
        this._$layer.lock = !!lock;

        const element = document
            .getElementById(`layer-lock-icon-${this._$layer.id}`);

        element.classList.remove("icon-disable", "icon-active");
        element.classList.add(this._$layer.lock ? "icon-active" : "icon-disable");
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$layer.name;
    }
}

/**
 * @class
 */
class ExternalLibrary
{
    /**
     * @param {Instance} [instance=null]
     */
    constructor (instance = null)
    {
        this._$instance = instance;
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        if (!this._$instance) {
            return "";
        }

        const workSpace = Util.$currentWorkSpace();

        let name = this._$instance.name;
        if (this._$instance._$folderId) {
            let parent = this._$instance;
            while (parent._$folderId) {
                parent = workSpace.getLibrary(parent._$folderId);
                name = `${parent.name}/${name}`;
            }
        }

        return name;
    }

    /**
     * @param  {string} path
     * @return {ExternalLibrary|null}
     */
    getItem (path)
    {
        path = `${path}`;

        const paths = path.split("/");
        const name  = paths.pop();

        const workSpace = Util.$currentWorkSpace();
        for (let instance of workSpace._$libraries.values()) {

            if (instance.name !== name) {
                continue;
            }

            if (paths.length) {

                if (!instance._$folderId) {
                    continue;
                }

                let match  = true;

                let length = paths.length - 1;
                let parent = instance;
                while (parent._$folderId) {

                    parent = workSpace.getLibrary(parent._$folderId);
                    if (parent.name !== paths[length--]) {
                        match = false;
                        break;
                    }

                }

                if (!match) {
                    continue;
                }
            }

            return new ExternalLibrary(instance);
        }

        return null;
    }

    /**
     * @param  {number} [width=0]
     * @param  {number} [height=0]
     * @param  {number} [frame=1]
     * @return {HTMLImageElement}
     * @method
     * @public
     */
    toImage (width = 0, height = 0, frame = 1)
    {
        if (!this._$instance) {
            return new Image(width, height);
        }

        const bounds = this._$instance.getBounds();
        if (!width) {
            width  = Math.abs(bounds.xMax - bounds.xMin);
        }
        if (!height) {
            height = Math.abs(bounds.yMax - bounds.yMin);
        }

        const currentFrame = Util.$currentFrame;

        Util.$currentFrame = frame;
        const image = this._$instance.toImage(
            Math.ceil(width),
            Math.ceil(height),
            {
                "frame": 1,
                "matrix": [1, 0, 0, 1, 0, 0],
                "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                "blendMode": "normal",
                "filter": [],
                "loop": Util.$getDefaultLoopConfig()
            }
        );

        Util.$currentFrame = currentFrame;

        return image;
    }

    /**
     * @param  {object} point
     * @param  {string} path
     * @return {boolean}
     * @method
     * @public
     */
    addItemToDocument (point, path)
    {
        if (!point || !path) {
            return false;
        }

        path = `${path}`;

        const paths = path.split("/");
        const name  = paths.pop();

        const workSpace = Util.$currentWorkSpace();
        for (let instance of workSpace._$libraries.values()) {

            if (instance.name !== name) {
                continue;
            }

            if (paths.length) {

                if (!instance._$folderId) {
                    continue;
                }

                let match  = true;

                let length = paths.length - 1;
                let parent = instance;
                while (parent._$folderId) {

                    parent = workSpace.getLibrary(parent._$folderId);
                    if (parent.name !== paths[length--]) {
                        match = false;
                        break;
                    }

                }

                if (!match) {
                    continue;
                }
            }

            // ライブラリを選択状態に
            Util
                .$libraryController
                .activeInstance = document.getElementById(
                    `library-child-id-${instance.id}`
                );

            Util.$dragElement = {
                "dataset": {
                    "libraryId": instance.id
                }
            };

            Util.$screen.drop({
                "offsetX": point.x + Util.$offsetLeft,
                "offsetY": point.y + Util.$offsetTop
            });

            Util.$dragElement = null;

            return true;
        }

        return false;
    }
}

/**
 * @class
 */
class ExternalTimeline
{
    /**
     * @return {number}
     * @readonly
     * @public
     */
    get currentFrame ()
    {
        return Util.$timelineFrame.currentFrame;
    }

    /**
     * @return {number}
     * @public
     */
    get currentLayer ()
    {
        const layerElement = Util.$timelineLayer.targetLayer;
        if (!layerElement) {
            return 0;
        }

        const layerId = layerElement.dataset.layerId | 0;
        const scene   = Util.$currentWorkSpace().scene;
        return Array.from(scene._$layers.keys()).indexOf(layerId) | 0;
    }

    /**
     * @param  {number} index
     * @return {void}
     * @public
     */
    set currentLayer (index)
    {
        const scene = Util.$currentWorkSpace().scene;
        const id    = Array.from(scene._$layers.keys())[index];

        // target layer
        Util.$timelineLayer.targetLayer = document
            .getElementById(`layer-id-${id}`);
    }

    /**
     * @return {array}
     * @readonly
     * @public
     */
    get layers ()
    {
        const children = Array.from(
            document.getElementById("timeline-content").children
        );

        const scene  = Util.$currentWorkSpace().scene;
        const layers = [];
        for (const layer of scene._$layers.values()) {

            const index = children.indexOf(
                document.getElementById(`layer-id-${layer.id}`)
            );

            layers[index] = new ExternalLayer(layer);
        }

        return layers;
    }

    /**
     * @return {array}
     * @method
     * @public
     */
    getSelectedLayers ()
    {
        const indexes = [];

        const children = Array.from(
            document.getElementById("timeline-content").children
        );

        const targetLayers = Util.$timelineLayer.targetLayers;
        for (const layerElement of targetLayers.values()) {

            const layerId = layerElement.dataset.layerId | 0;

            const index = children.indexOf(
                document.getElementById(`layer-id-${layerId}`)
            );

            indexes.push(index);
        }

        if (indexes.length > 1) {
            indexes.sort((a, b) =>
            {
                // 昇順
                switch (true) {

                    case a > b:
                        return 1;

                    case a < b:
                        return -1;

                    default:
                        return 0;

                }
            });
        }

        return indexes;
    }

    /**
     * @param  {string}  [name=""]
     * @param  {string}  [type="normal"]
     * @param  {boolean} [above=true]
     * @return {ExternalLayer}
     * @method
     * @public
     */
    addNewLayer (name = "", type = "normal", above = true)
    {
        const scene = Util.$currentWorkSpace().scene;
        const layer = new Layer();
        if (name) {
            layer.name = name;
        }

        switch (type) {

            case "mask":
                layer.mode = Util.LAYER_MODE_MASK;
                break;

            case "masked":
                layer.mode = Util.LAYER_MODE_MASK_IN;
                break;

            default:
                break;

        }

        // cache(fixed logic)
        const targetIndex = this.currentLayer;

        let index = 0;
        const layers = new Map();
        for (const value of scene._$layers.values()) {

            if (above && index === targetIndex) {
                layers.set(index++, layer);
            }

            layers.set(index++, value);

            if (!above && index === targetIndex + 1) {
                layers.set(index++, layer);
            }
        }

        scene._$layers = layers;
        scene.initialize();

        // target layer
        Util.$timelineLayer.targetLayer = document
            .getElementById(`layer-id-${layer.id}`);

        // target frame
        Util.$timelineLayer.clearActiveFrames();

        Util
            .$timelineLayer
            .addTargetFrame(
                layer.id,
                document.getElementById(`${layer.id}-${this.currentFrame}`)
            );

        return new ExternalLayer(layer);
    }

    /**
     * @param  {number} start_frame
     * @param  {number} end_frame
     * @return {void}
     * @method
     * @public
     */
    setSelectedFrames (start_frame, end_frame)
    {
        const layerElement = Util.$timelineLayer.targetLayer;
        if (!layerElement) {
            return ;
        }

        Util.$timelineLayer.clearActiveFrames();

        end_frame = Math.max(start_frame, end_frame);

        const layerId = layerElement.dataset.layerId | 0;
        for (let frame = start_frame; end_frame >= frame; ++frame) {

            Util
                .$timelineLayer
                .addTargetFrame(
                    layerId,
                    document.getElementById(`${layerId}-${frame}`)
                );

        }

        Util.$timelineFrame.currentFrame = start_frame;
    }

    /**
     * @param  {number} [start_frame = -1]
     * @param  {number} [end_frame = -1]
     * @return {void}
     * @public
     */
    clearKeyframes (start_frame = -1, end_frame = -1)
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const layerId = targetLayer.dataset.layerId | 0;
        if (Util.$timelineLayer.targetFrames.has(layerId)) {

            const targetFrames = Util
                .$timelineLayer
                .targetFrames
                .get(layerId)
                .slice();

            if (targetFrames.length > 1) {
                targetFrames.sort((a, b) =>
                {
                    const aFrame = a.dataset.frame | 0;
                    const bFrame = b.dataset.frame | 0;

                    // 昇順
                    switch (true) {

                        case aFrame > bFrame:
                            return 1;

                        case aFrame < bFrame:
                            return -1;

                        default:
                            return 0;

                    }
                });
            }

            if (start_frame === -1) {
                start_frame = targetFrames[0].dataset.frame | 0;
            }

            if (end_frame === -1) {
                end_frame = targetFrames[targetFrames.length - 1].dataset.frame | 0;
            }

        }

        if (end_frame === -1) {
            end_frame = start_frame;
        }

        if (start_frame === -1 || end_frame === -1) {
            return ;
        }

        this.setSelectedFrames(start_frame, end_frame);
    }

    /**
     * @param  {number} [start_frame = -1]
     * @param  {number} [end_frame = -1]
     * @return {void}
     * @public
     */
    convertToBlankKeyframes (start_frame = -1, end_frame = -1)
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const layerId = targetLayer.dataset.layerId | 0;
        if (Util.$timelineLayer.targetFrames.has(layerId)) {

            const targetFrames = Util
                .$timelineLayer
                .targetFrames
                .get(layerId)
                .slice();

            if (targetFrames.length > 1) {
                targetFrames.sort((a, b) =>
                {
                    const aFrame = a.dataset.frame | 0;
                    const bFrame = b.dataset.frame | 0;

                    // 昇順
                    switch (true) {

                        case aFrame > bFrame:
                            return 1;

                        case aFrame < bFrame:
                            return -1;

                        default:
                            return 0;

                    }
                });
            }

            if (start_frame === -1) {
                start_frame = targetFrames[0].dataset.frame | 0;
            }

            if (end_frame === -1) {
                end_frame = targetFrames[targetFrames.length - 1].dataset.frame | 0;
            }

        }

        if (end_frame === -1) {
            end_frame = start_frame;
        }

        if (start_frame === -1 || end_frame === -1) {
            return ;
        }

        this.setSelectedFrames(start_frame, end_frame);

        Util.$timelineTool.executeTimelineFrameAdd();
        Util.$timelineTool.executeTimelineEmptyAdd();
    }

}

/**
 * @class
 */
class ExternalTool extends CommonTool
{
    /**
     * @param {string} name
     * @constructor
     * @public
     */
    constructor (name)
    {
        super(name);
    }
}


        global["nt"] = global["fl"] = new ExternalInterface();
    })(this);
}
