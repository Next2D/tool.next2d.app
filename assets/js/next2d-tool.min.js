/*!
 * licenses: MIT Licenses.
 * version: 0.144.0
 * author: Toshiyuki Ienaga <ienaga@tvon.jp>
 * copyright: (c) 2021-2022 Toshiyuki Ienaga.
 */

if (!("nt" in window)) {
    (function (global)
    {
        "use strict";

/**
 * @class
 */
class Language
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        this.mapping = this.createMapping();
        requestAnimationFrame(this.initialize.bind(this));
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        const elements = document.getElementsByClassName("language");
        for (let idx = 0; idx < elements.length; ++idx) {

            const element = elements[idx];

            const text = element.dataset.text;
            if (!this.mapping.has(text)) {
                continue;
            }

            let value = this.mapping.get(text);

            let shortcutKey = element.dataset.shortcutKey;
            if (shortcutKey) {
                const mapping = Util.$shortcutSetting.viewMapping.get(
                    element.dataset.area
                );

                const shortcutText = mapping.has(shortcutKey)
                    ? mapping.get(shortcutKey).text
                    : element.dataset.shortcutText;

                value += ` (${shortcutText})`;
            }

            element.innerText = value;
        }
    }

    /**
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    replace (value)
    {
        return this.mapping.has(value)
            ? this.mapping.get(value)
            : value;
    }
}

/**
 * @class
 * @extends Language
 */
class Chinese extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{自由変形ツール}}", "免费转换工具"],
            ["{{キーフレームに変換}}", "转换为关键帧"],
            ["{{空のキーフレームに変換}}", "转换为空关键帧"],
            ["{{最初のフレームに移動}}", "转到第一帧"],
            ["{{最後のフレームに移動}}", "转到最后一帧"],
            ["{{SWFを解析中}}", "正在分析的SWF"],
            ["{{JSONを生成}}", "生成JSON"],
            ["{{ファイルを生成}}", "生成文件"],
            ["{{N2Dファイルの読み込み}}", "加载N2D文件"],
            ["{{JSONの読み込み}}", "读取JSON"],
            ["{{データを解凍中}}", "对数据进行解压"],
            ["{{データを圧縮中}}", "压缩数据"],
            ["{{エンコード}}", "编码"],
            ["{{外部ファイルの読み込み}}", "加载外部文件"],
            ["{{バイナリデータを生成}}", "生成二进制数据"],
            ["{{データベースを起動}}", "启动数据库"],
            ["{{データを保存中}}", "储存数据"],
            ["{{完了}}", "完成"],
            ["{{ステージ左揃え}}", "舞台左侧对齐"],
            ["{{ステージ中央揃え(水平方向)}}", "对准舞台中心（水平）"],
            ["{{ステージ右揃え}}", "舞台右侧的对齐"],
            ["{{ステージ上揃え}}", "对齐舞台"],
            ["{{ステージ中央揃え(垂直方向)}}", "对准舞台中心（垂直）"],
            ["{{ステージ下揃え}}", "对准舞台底部"],
            ["{{定規}}", "尺子"],
            ["{{表示}}", "展示"],
            ["{{ショートカット}}", "快捷方式"],
            ["{{レイヤーを複製}}", "复制图层"],
            ["{{未使用のフォルダを削除}}", "删除未使用的文件夹"],
            ["{{同名のアイテムが存在します}}", "存在相同名称的项目"],
            ["{{追加ファイル}}", "附加文件"],
            ["{{既存のコンテンツ}}", "现有的内容"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "你可以选择覆盖、重命名和添加文件或跳过"],
            ["{{全て上書き}}", "覆盖所有"],
            ["{{全てスキップ}}", "跳过所有"],
            ["{{追加・上書き}}", "添加和覆盖"],
            ["{{スキップ}}", "跳过"],
            ["{{表示確認したいフレームを指定}}", "指定你要检查显示的框架"],
            ["{{ファイル名を指定}}", "指定文件名"],
            ["{{ファイル名}}", "文件名"],
            ["{{終了フレームを指定}}", "指定终端框架"],
            ["{{開始フレームを指定}}", "指定起始框架"],
            ["{{フレーム設定}}", "框架设置"],
            ["{{書き出し設定}}", "出口设置"],
            ["{{ファイル形式の選択}}", "选择文件格式"],
            ["{{ファイル形式}}", "文件格式"],
            ["{{サイズ設定}}", "尺寸"],
            ["{{左上}}", "左上"],
            ["{{中央上}}", "中-上"],
            ["{{右上}}", "右上"],
            ["{{中央左}}", "中间偏左"],
            ["{{中央}}", "中央"],
            ["{{中央右}}", "中右翼"],
            ["{{左下}}", "左下角"],
            ["{{中央下}}", "中下级"],
            ["{{右下}}", "右下"],
            ["{{中心点のX座標}}", "中心点的X坐标"],
            ["{{中心点のY座標}}", "中心点的Y坐标"],
            ["{{MovieClipに変換}}", "转换为MovieClip"],
            ["{{変換}}", "蜕变"],
            ["{{ループ回数}}", "循环次数"],
            ["{{カーブポインターの削除}}", "删除曲线指针"],
            ["{{ステージ基準}}", "阶段性标准"],
            ["{{閉じる}}", "贴近"],
            ["{{保存}}", "储存"],
            ["{{リセット}}", "重置"],
            ["{{スクリーン}}", "筛选"],
            ["{{ショートカット設定}}", "捷径设置"],
            ["{{レイヤーカラー}}", "分层色"],
            ["{{Next2Dを支援する}}", "支持Next2D"],
            ["{{サポート}}", "支持"],
            ["{{未使用のアイテムを削除}}", "删除未使用的项目"],
            ["{{レイヤーをペースト}}", "粘贴层"],
            ["{{レイヤーをコピー}}", "复制层"],
            ["{{フレームをペースト}}", "粘贴框架"],
            ["{{フレームをコピー}}", "复制框架"],
            ["{{キーフレームを削除}}", "删除关键帧"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "不能向关键帧添加空关键帧"],
            ["{{ズームツール}}", "缩放工具"],
            ["{{タイムライン幅の拡大・縮小}}", "时间线宽度 扩大/缩小"],
            ["{{ガイドレイヤー}}", "指导层"],
            ["{{音量設定}}", "音量设置"],
            ["{{サウンドを削除}}", "移除声音"],
            ["{{カスタムループ}}", "定制的循环"],
            ["{{読込のみ}}", "只读"],
            ["{{書込を許可}}", "职位许可"],
            ["{{単一行}}", "单线"],
            ["{{複数行}}", "多线"],
            ["{{自動で折り返し}}", "自动绕行"],
            ["{{左寄せ}}", "左对齐"],
            ["{{中央揃え}}", "定心"],
            ["{{右寄せ}}", "右对齐"],
            ["{{放射状グラデーション}}", "径向梯度"],
            ["{{線形グラデーション}}", "线性梯度"],
            ["{{画像}}", "图片"],
            ["{{画像選択}}", "图像选择"],
            ["{{種別}}", "分类"],
            ["{{Shapeの色設定}}", "形状颜色设置"],
            ["{{変形}}", "变形"],
            ["{{カラー効果}}", "颜色转换"],
            ["{{フィルター}}", "滤镜"],
            ["{{Shapeを複製}}", "复制的形状"],
            ["{{読み込み}}", "读在"],
            ["{{新規フォルダー}}", "新文件夹"],
            ["{{新規MovieClip}}", "新的电影剪辑"],
            ["{{枠に合わせてテキストをリサイズ}}", "调整文字大小以适应框架"],
            ["{{テキストに合わせて枠をリサイズ}}", "调整框架的大小以适应文本"],
            ["{{リサイズしない}}", "不调整大小"],
            ["{{フォント}}", "字体"],
            ["{{テキスト}}", "文本"],
            ["{{ループ}}", "循环"],
            ["{{音量}}", "音量"],
            ["{{ビデオ}}", "视频"],
            ["{{イージング}}", "缓和"],
            ["{{サウンド}}", "声音"],
            ["{{シンボル}}", "符号"],
            ["{{名前}}", "命名"],
            ["{{オブジェクト}}", "对象"],
            ["{{ステージ設定}}", "舞台设置"],
            ["{{プレビュー}}", "预览"],
            ["{{削除}}", "删除"],
            ["{{ペースト}}", "粘贴"],
            ["{{コピー}}", "拷贝"],
            ["{{プラグインメニュー}}", "插件菜单"],
            ["{{トゥイーン}}", "嫩枝"],
            ["{{カーブポインターの追加}}", "额外的曲线指示器"],
            ["{{パスの結合}}", "路径合并"],
            ["{{シェイプ}}", "形状"],
            ["{{キーフレームに配分}}", "分配给关键帧"],
            ["{{レイヤーに配分}}", "分配到各层"],
            ["{{タイムライン}}", "时间线"],
            ["{{整列}}", "对齐"],
            ["{{最背面}}", "最 后"],
            ["{{ひとつ背面へ}}", "一个背影"],
            ["{{ひとつ前面へ}}", "一个正面"],
            ["{{最前面}}", "最前线"],
            ["{{重ね順}}", "继承顺序"],
            ["{{プラグイン}}", "插件"],
            ["{{ライブラリ}}", "图书馆"],
            ["{{プロパティ}}", "财产"],
            ["{{マスクレイヤー}}", "掩膜层"],
            ["{{通常レイヤー}}", "普通层"],
            ["{{モーショントゥイーンの削除}}", "删去了运动推理的内容"],
            ["{{モーショントゥイーンの追加}}", "额外的议案推理"],
            ["{{モーダル表示}}", "模态指示"],
            ["{{言語}}", "语言"],
            ["{{フォーマット}}", "格式"],
            ["{{含める}}", "包括"],
            ["{{含めない}}", "不包括"],
            ["{{使い方、リファレンス}}", "用法，参考"],
            ["{{非表示レイヤー}}", "隐藏层"],
            ["{{設定}}", "设置"],
            ["{{デフォルトのループを利用する}}", "使用默认的循环"],
            ["{{フレームピッカー}}", "选框机"],
            ["{{左揃え}}", "左对齐"],
            ["{{中央揃え(水平方向)}}", "居中（水平方向）"],
            ["{{右揃え}}", "右对齐"],
            ["{{上揃え}}", "上对齐"],
            ["{{中央揃え(垂直方向)}}", "居中（垂直方向）"],
            ["{{下揃え}}", "下对齐"],
            ["{{開始フレーム}}", "起始框架"],
            ["{{終了フレーム}}", "终端框架"],
            ["{{ループで再生}}", "循环播放"],
            ["{{1回再生}}", "1次播放"],
            ["{{指定したフレームで固定}}", "固定在指定的框架内"],
            ["{{1回逆再生}}", "1 反向播放"],
            ["{{逆ループで再生}}", "反向循环播放"],
            ["{{画面の拡大・縮小}}", "画面的放大和缩小"],
            ["{{カスタムイージングデータを保存}}", "保存自定义缓和数据"],
            ["{{カスタムイージングデータの読込}}", "读取自定义宽松数据"],
            ["{{プレビューのON/OFF}}", "预览开/关"],
            ["{{フォント枠サイズ}}", "字体帧大小"],
            ["{{フォント枠カラー}}", "字体帧颜色"],
            ["{{オニオンスキン}}", "洋葱皮"],
            ["{{バケツツール}}", "整体填充工具"],
            ["{{ペンツール}}", "钢笔工具"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "双击来添加一个曲线点"],
            ["{{選択ツール}}", "选择工具"],
            ["{{Shape変形ツール}}", "形状变换工具"],
            ["{{テキストツール}}", "文本工具"],
            ["{{矩形ツール}}", "矩形工具"],
            ["{{楕円ツール}}", "椭圆工具"],
            ["{{角丸矩形ツール}}", "圆角矩形工具"],
            ["{{塗りのカラー}}", "填充颜色"],
            ["{{線のカラー}}", "画笔颜色"],
            ["{{線の太さ}}", "画笔宽度"],
            ["{{プロジェクトデータの読込}}", "载入工程文件"],
            ["{{プロジェクトデータを保存}}", "保存工程文件"],
            ["{{書き出し}}", "导出"],
            ["{{Discordへ移動}}", "前往discord"],
            ["{{バグ報告}}", "错误报告"],
            ["{{設定}}", "设置"],
            ["{{タブを追加}}", "添加标签页"],
            ["{{タブの一覧を表示・移動}}", "标签页列表"],
            ["{{スクリプトを追加}}", "添加一个脚本"],
            ["{{キーフレームを追加}}", "添加一个关键帧"],
            ["{{空のキーフレームを追加}}", "添加一个空的关键帧"],
            ["{{フレームを追加}}", "添加帧"],
            ["{{フレームを削除}}", "删除帧"],
            ["{{再生}}", "播放"],
            ["{{停止}}", "停止"],
            ["{{ループ設定}}", "循环设置"],
            ["{{レイヤーを追加}}", "添加图层"],
            ["{{レイヤーを削除}}", "删除图层"],
            ["{{全てのレイヤーをハイライト}}", "高亮所有图层"],
            ["{{全てのレイヤーを非表示}}", "隐藏所有图层"],
            ["{{全てのレイヤーをロック}}", "锁定所有图层"],
            ["{{比率を固定}}", "锁定比例"],
            ["{{ステージの幅}}", "画面宽度"],
            ["{{背景色}}", "背景颜色"],
            ["{{ステージの高さ}}", "画面高度"],
            ["{{フレームレート}}", "帧速率"],
            ["{{シンボル名}}", "符号名称"],
            ["{{イージング設定}}", "过渡设置"],
            ["{{ビデオの音量設定}}", "视频音量设置"],
            ["{{自動再生}}", "自动播放"],
            ["{{テキストエリアのボーダー設定}}", "文本框边框设置"],
            ["{{テキスト入力設定}}", "文本输入设置"],
            ["{{フォント選択}}", "字体选择"],
            ["{{自動サイズ調整}}", "自动调整尺寸"],
            ["{{フォントスタイルタイプ}}", "字体风格类型"],
            ["{{行揃え}}", "对齐"],
            ["{{改行設定}}", "换行设置"],
            ["{{スクロール設定}}", "滚动设置"],
            ["{{フォントサイズ}}", "字体大小"],
            ["{{フォントカラー}}", "字体颜色"],
            ["{{行間}}", "行间距"],
            ["{{文字幅}}", "字符宽度"],
            ["{{左マージン}}", "左边距"],
            ["{{右マージン}}", "右边距"],
            ["{{カラー種別の選択}}", "选择颜色类型"],
            ["{{背景画像の選択}}", "选择背景图片"],
            ["{{カラーポインターを追加}}", "添加颜色指针"],
            ["{{カラー値}}", "颜色"],
            ["{{アルファ(0%-100%)}}", "透明度（0%-100%）"],
            ["{{アルファ値}}", "透明度"],
            ["{{選択対象の幅}}", "选择对象的宽度"],
            ["{{選択対象のX座標}}", "选择对象的X轴坐标"],
            ["{{選択対象の高さ}}", "选择对象的高度"],
            ["{{選択対象のY座標}}", "选择对象的Y轴坐标"],
            ["{{選択対象の幅の伸縮}}", "选定对象的X轴缩放"],
            ["{{選択対象を回転}}", "旋转物体"],
            ["{{選択対象の高さの伸縮}}", "所选对象的比例Y"],
            ["{{アルファオフセット(-255〜255)}}", "透明度偏移（-255~255）"],
            ["{{赤(0%-100%)}}", "红色（0%-100%）"],
            ["{{赤オフセット(-255〜255)}}", "红色偏移（-255~255）"],
            ["{{緑(0%-100%)}}", "绿色（0%-100%）"],
            ["{{緑オフセット(-255〜255)}}", "绿色偏移（-255~255）"],
            ["{{青(0%-100%)}}", "蓝色（0%-100%）"],
            ["{{青オフセット(-255〜255)}}", "蓝色偏移（-255~255）"],
            ["{{ブレンドモード}}", "混合模式"],
            ["{{フィルターを選択}}", "选择滤镜"],
            ["{{フィルターを追加}}", "添加滤镜"],
            ["{{サウンドを追加}}", "添加声音"],
            ["{{フィルターを表示・非表示する}}", "显示和隐藏滤镜"],
            ["{{フィルターを削除}}", "删除滤镜"],
            ["{{水平方向にぼかす}}", "横向模糊"],
            ["{{垂直方向にぼかす}}", "纵向模糊"],
            ["{{フィルター強度}}", "滤镜强度"],
            ["{{フィルター角度}}", "滤镜角度"],
            ["{{シャドウのアルファ}}", "阴影透明度"],
            ["{{シャドウのカラー}}", "阴影颜色"],
            ["{{フィルター距離}}", "滤镜距离"],
            ["{{ハイライトのカラー}}", "高光色"],
            ["{{ハイライトのアルファ}}", "高光透明度"],
            ["{{グラデーションカラー}}", "渐变色"],
            ["{{グラデーションのアルファ}}", "渐变透明度"],
            ["{{タブの移動・名前を変更}}", "移动/重命名标签"],
            ["{{プロジェクトを閉じる}}", "关闭工程"],
            ["{{上下に移動}}", "上下移动"],
            ["{{レイヤー変更(ダブルクリック)}}", "改变图层（双击）"],
            ["{{レイヤーをハイライト}}", "高亮图层"],
            ["{{レイヤーを非表示}}", "隐藏图层"],
            ["{{レイヤーをロック}}", "锁定图层"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "曲线指针（双击打开/关闭）"],
            ["{{インスタンス名}}", "实例名称"],
            ["{{ライブラリ内の検索}}", "在库中搜索"],
            ["{{フレームラベル}}", "帧标签"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "如果工程没有保存，将无法恢复此标签页数据。 你想删除这个标签页吗？"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class English extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{自由変形ツール}}", "Free Transform Tool"],
            ["{{キーフレームに変換}}", "Convert to keyframes"],
            ["{{空のキーフレームに変換}}", "Convert to empty keyframes"],
            ["{{最初のフレームに移動}}", "Go to First Frame"],
            ["{{最後のフレームに移動}}", "Go to Last Frame"],
            ["{{SWFを解析中}}", "SWF Being Parsed"],
            ["{{JSONを生成}}", "Generate JSON"],
            ["{{ファイルを生成}}", "Generate File"],
            ["{{N2Dファイルの読み込み}}", "Loading N2D File"],
            ["{{JSONの読み込み}}", "Loading JSON"],
            ["{{データを解凍中}}", "Decompressing Data"],
            ["{{データを圧縮中}}", "Compressing Data"],
            ["{{エンコード}}", "Encoding"],
            ["{{外部ファイルの読み込み}}", "Reading External Files"],
            ["{{バイナリデータを生成}}", "Generating Binary Data"],
            ["{{データベースを起動}}", "Starting the Database"],
            ["{{データを保存中}}", "Storing Data"],
            ["{{完了}}", "Completed"],
            ["{{ステージ左揃え}}", "Align Stage Left"],
            ["{{ステージ中央揃え(水平方向)}}", "Align Stage Center (Horizontal)"],
            ["{{ステージ右揃え}}", "Align Stage Right"],
            ["{{ステージ上揃え}}", "Align Stage Top"],
            ["{{ステージ中央揃え(垂直方向)}}", "Center Stage (Vertical)"],
            ["{{ステージ下揃え}}", "Align Bottom of Stage"],
            ["{{定規}}", "Ruler"],
            ["{{表示}}", "Display"],
            ["{{ショートカット}}", "Shortcut"],
            ["{{レイヤーを複製}}", "Duplicate Layer"],
            ["{{未使用のフォルダを削除}}", "Delete unused folders"],
            ["{{同名のアイテムが存在します}}", "An item of the same name exists"],
            ["{{追加ファイル}}", "Additional File"],
            ["{{既存のコンテンツ}}", "Existing Content"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "You can choose to overwrite, rename and add files, or skip"],
            ["{{全て上書き}}", "Overwrite All"],
            ["{{全てスキップ}}", "Skip All"],
            ["{{追加・上書き}}", "Add or Overwrite"],
            ["{{スキップ}}", "Skip"],
            ["{{表示確認したいフレームを指定}}", "Specify the frame you want to check the display"],
            ["{{ファイル名を指定}}", "Specify File Name"],
            ["{{ファイル名}}", "File Name"],
            ["{{終了フレームを指定}}", "Specify End Frame"],
            ["{{開始フレームを指定}}", "Specify Start Frame"],
            ["{{フレーム設定}}", "Frame Setting"],
            ["{{書き出し設定}}", "Export Settings"],
            ["{{ファイル形式の選択}}", "Select File Format"],
            ["{{ファイル形式}}", "File Formats"],
            ["{{サイズ設定}}", "Size Setting"],
            ["{{左上}}", "Top Left"],
            ["{{中央上}}", "Top Center"],
            ["{{右上}}", "Top Right"],
            ["{{中央左}}", "Center Left"],
            ["{{中央}}", "Center"],
            ["{{中央右}}", "Center Right"],
            ["{{左下}}", "Bottom Left"],
            ["{{中央下}}", "Bottom Center"],
            ["{{右下}}", "Bottom Right"],
            ["{{中心点のX座標}}", "X coordinate of the center point"],
            ["{{中心点のY座標}}", "Y coordinate of the center point"],
            ["{{MovieClipに変換}}", "Convert to MovieClip"],
            ["{{変換}}", "Conversion"],
            ["{{ループ回数}}", "Loop Count"],
            ["{{カーブポインターの削除}}", "Delete curve pointer"],
            ["{{ステージ基準}}", "Stage Criteria"],
            ["{{閉じる}}", "Close"],
            ["{{保存}}", "Save"],
            ["{{リセット}}", "Reset"],
            ["{{スクリーン}}", "Screen"],
            ["{{ショートカット設定}}", "Shortcut Settings"],
            ["{{レイヤーカラー}}", "Layer Color"],
            ["{{Next2Dを支援する}}", "Support Next2D"],
            ["{{サポート}}", "Support"],
            ["{{未使用のアイテムを削除}}", "Delete unused items"],
            ["{{レイヤーをペースト}}", "Paste Layer"],
            ["{{レイヤーをコピー}}", "Copy Layer"],
            ["{{フレームをペースト}}", "Paste Frame"],
            ["{{フレームをコピー}}", "Copy Frame"],
            ["{{キーフレームを削除}}", "Delete keyframe"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "Cannot add an empty keyframe to a keyframe"],
            ["{{ズームツール}}", "Zoom Tool"],
            ["{{タイムライン幅の拡大・縮小}}", "Timeline Width Expand/Reduce"],
            ["{{ガイドレイヤー}}", "Guide Layer"],
            ["{{音量設定}}", "Volume Setting"],
            ["{{サウンドを削除}}", "Remove Sound"],
            ["{{カスタムループ}}", "Custom Loop"],
            ["{{読込のみ}}", "ReadOnly"],
            ["{{書込を許可}}", "Writeable"],
            ["{{単一行}}", "Single line"],
            ["{{複数行}}", "Multiline"],
            ["{{自動で折り返し}}", "Auto Wrap"],
            ["{{左寄せ}}", "Left"],
            ["{{中央揃え}}", "Center"],
            ["{{右寄せ}}", "Right"],
            ["{{放射状グラデーション}}", "Radial Gradient"],
            ["{{線形グラデーション}}", "Linear Gradient"],
            ["{{画像}}", "Image"],
            ["{{画像選択}}", "Image Selection"],
            ["{{種別}}", "Type"],
            ["{{Shapeの色設定}}", "Shape color settings"],
            ["{{変形}}", "Transform"],
            ["{{カラー効果}}", "Color Transform"],
            ["{{フィルター}}", "Filter"],
            ["{{Shapeを複製}}", "Duplicate Shape"],
            ["{{読み込み}}", "Read in"],
            ["{{新規フォルダー}}", "Added Folder"],
            ["{{新規MovieClip}}", "Added MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "Resize text to fit the frame"],
            ["{{テキストに合わせて枠をリサイズ}}", "Resize the frame to fit the text"],
            ["{{リサイズしない}}", "No Resize"],
            ["{{フォント}}", "Font"],
            ["{{テキスト}}", "Text"],
            ["{{ループ}}", "Loop"],
            ["{{音量}}", "Volume"],
            ["{{ビデオ}}", "Video"],
            ["{{イージング}}", "Easing"],
            ["{{サウンド}}", "Sound"],
            ["{{シンボル}}", "Symbol"],
            ["{{名前}}", "Name"],
            ["{{オブジェクト}}", "Object"],
            ["{{ステージ設定}}", "Stage Setting"],
            ["{{プレビュー}}", "Preview"],
            ["{{削除}}", "Delete"],
            ["{{ペースト}}", "Paste"],
            ["{{コピー}}", "Copy"],
            ["{{プラグインメニュー}}", "Plugin Menu"],
            ["{{トゥイーン}}", "Tween"],
            ["{{カーブポインターの追加}}", "Added Curve Pointer"],
            ["{{パスの結合}}", "Integrating paths"],
            ["{{シェイプ}}", "Shape"],
            ["{{キーフレームに配分}}", "Distribute to Keyframes"],
            ["{{レイヤーに配分}}", "Distribute to Layers"],
            ["{{タイムライン}}", "Timeline"],
            ["{{整列}}", "Align"],
            ["{{最背面}}", "Send to Back"],
            ["{{ひとつ背面へ}}", "Send to Backward"],
            ["{{ひとつ前面へ}}", "Bring to Forward"],
            ["{{最前面}}", "Bring to Front"],
            ["{{重ね順}}", "Arrange"],
            ["{{プラグイン}}", "Plugin"],
            ["{{ライブラリ}}", "Library"],
            ["{{プロパティ}}", "Property"],
            ["{{マスクレイヤー}}", "Mask Layer"],
            ["{{通常レイヤー}}", "Normal Layer"],
            ["{{モーショントゥイーンの削除}}", "Deleted Motion Tweening"],
            ["{{モーショントゥイーンの追加}}", "Added Motion Tweening"],
            ["{{モーダル表示}}", "Modal Indication"],
            ["{{言語}}", "Language"],
            ["{{フォーマット}}", "Format"],
            ["{{含める}}", "Include"],
            ["{{含めない}}", "Not Including"],
            ["{{使い方、リファレンス}}", "Usage, Reference"],
            ["{{非表示レイヤー}}", "Hidden Layers"],
            ["{{設定}}", "Setting"],
            ["{{デフォルトのループを利用する}}", "Use the default loop"],
            ["{{フレームピッカー}}", "Frame Picker"],
            ["{{左揃え}}", "Left"],
            ["{{中央揃え(水平方向)}}", "Center (Horizontal)"],
            ["{{右揃え}}", "Right"],
            ["{{上揃え}}", "Top"],
            ["{{中央揃え(垂直方向)}}", "Center (Vertical)"],
            ["{{下揃え}}", "Bottom"],
            ["{{開始フレーム}}", "Start Frame"],
            ["{{終了フレーム}}", "End Frame"],
            ["{{ループで再生}}", "Play in loop"],
            ["{{1回再生}}", "1 playback"],
            ["{{指定したフレームで固定}}", "Fixed at the specified frame"],
            ["{{1回逆再生}}", "1 reverse playback"],
            ["{{逆ループで再生}}", "Playback in reverse loop"],
            ["{{画面の拡大・縮小}}", "Zoom in/out of screen"],
            ["{{カスタムイージングデータを保存}}", "Save custom easing data"],
            ["{{カスタムイージングデータの読込}}", "Reading custom easing data"],
            ["{{プレビューのON/OFF}}", "Preview on/off"],
            ["{{フォント枠サイズ}}", "Font Frame Size"],
            ["{{フォント枠カラー}}", "Font Frame Color"],
            ["{{オニオンスキン}}", "Onion Skin"],
            ["{{バケツツール}}", "Bucket Tools"],
            ["{{ペンツール}}", "Pen Tool"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Double-click to add a curve point"],
            ["{{選択ツール}}", "Selection Tool"],
            ["{{Shape変形ツール}}", "Shape Transform Tool"],
            ["{{テキストツール}}", "Text Tool"],
            ["{{矩形ツール}}", "Rectangle Tool"],
            ["{{楕円ツール}}", "Ellipse Tool"],
            ["{{角丸矩形ツール}}", "Rounded Rectangle Tool"],
            ["{{塗りのカラー}}", "Fill Color"],
            ["{{線のカラー}}", "Stroke Color"],
            ["{{線の太さ}}", "Stroke Width"],
            ["{{プロジェクトデータの読込}}", "Loading project data"],
            ["{{プロジェクトデータを保存}}", "Save project data"],
            ["{{書き出し}}", "Export"],
            ["{{Discordへ移動}}", "Go to discord"],
            ["{{バグ報告}}", "Bug reports"],
            ["{{設定}}", "Setting"],
            ["{{タブを追加}}", "Add a tab"],
            ["{{タブの一覧を表示・移動}}", "View and move through the list of tabs"],
            ["{{スクリプトを追加}}", "Add a script"],
            ["{{キーフレームを追加}}", "Add a keyframe"],
            ["{{空のキーフレームを追加}}", "Add an empty keyframe"],
            ["{{フレームを追加}}", "Add a frame"],
            ["{{フレームを削除}}", "Delete frame"],
            ["{{再生}}", "Play"],
            ["{{停止}}", "Stop"],
            ["{{ループ設定}}", "Loop Setting"],
            ["{{レイヤーを追加}}", "Add a layer"],
            ["{{レイヤーを削除}}", "Delete layer"],
            ["{{全てのレイヤーをハイライト}}", "Highlight all layers"],
            ["{{全てのレイヤーを非表示}}", "Hide all layers"],
            ["{{全てのレイヤーをロック}}", "Lock all layers"],
            ["{{比率を固定}}", "Fixed ratio"],
            ["{{ステージの幅}}", "Stage Width"],
            ["{{背景色}}", "Background Color"],
            ["{{ステージの高さ}}", "Stage Height"],
            ["{{フレームレート}}", "Frame Rate"],
            ["{{シンボル名}}", "Symbol Name"],
            ["{{イージング設定}}", "Easing Setting"],
            ["{{ビデオの音量設定}}", "Video Volume Setting"],
            ["{{自動再生}}", "Auto Play"],
            ["{{テキストエリアのボーダー設定}}", "Text Area Border Setting"],
            ["{{テキスト入力設定}}", "Text Input Setting"],
            ["{{フォント選択}}", "Font Select"],
            ["{{自動サイズ調整}}", "Automatic size adjustment"],
            ["{{フォントスタイルタイプ}}", "Font Style Type"],
            ["{{行揃え}}", "Align"],
            ["{{改行設定}}", "Newline Setting"],
            ["{{スクロール設定}}", "Scroll Setting"],
            ["{{フォントサイズ}}", "Font Size"],
            ["{{フォントカラー}}", "Font Color"],
            ["{{行間}}", "Line Space"],
            ["{{文字幅}}", "Character Width"],
            ["{{左マージン}}", "Left Margin"],
            ["{{右マージン}}", "Right Margin"],
            ["{{カラー種別の選択}}", "Select a color type"],
            ["{{背景画像の選択}}", "Selecting a background image"],
            ["{{カラーポインターを追加}}", "Add color pointers"],
            ["{{カラー値}}", "Color"],
            ["{{アルファ(0%-100%)}}", "Alpha(0%-100%)"],
            ["{{アルファ値}}", "Alpha"],
            ["{{選択対象の幅}}", "Width of the selection object"],
            ["{{選択対象のX座標}}", "X coordinate of the selection object"],
            ["{{選択対象の高さ}}", "Height  of the selection object"],
            ["{{選択対象のY座標}}", "Y coordinate of the selection object"],
            ["{{選択対象の幅の伸縮}}", "scaleX of the selected object"],
            ["{{選択対象を回転}}", "Rotate the object"],
            ["{{選択対象の高さの伸縮}}", "scaleY of the selected object"],
            ["{{アルファオフセット(-255〜255)}}", "Alpha Offset(-255〜255)"],
            ["{{赤(0%-100%)}}", "Red(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Red Offset(-255〜255)"],
            ["{{緑(0%-100%)}}", "Green(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Green Offset(-255〜255)"],
            ["{{青(0%-100%)}}", "Blue(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Blue Offset(-255〜255)"],
            ["{{ブレンドモード}}", "Blend Mode"],
            ["{{フィルターを選択}}", "Select a filter"],
            ["{{フィルターを追加}}", "Add a filter"],
            ["{{サウンドを追加}}", "Add a sound"],
            ["{{フィルターを表示・非表示する}}", "Show and Hide filters"],
            ["{{フィルターを削除}}", "Delete Filter"],
            ["{{水平方向にぼかす}}", "Blur Horizontally"],
            ["{{垂直方向にぼかす}}", "Blur Vertically"],
            ["{{フィルター強度}}", "Filter Strength"],
            ["{{フィルター角度}}", "Filter Angle"],
            ["{{シャドウのアルファ}}", "Shadow Alpha"],
            ["{{シャドウのカラー}}", "Shadow Color"],
            ["{{フィルター距離}}", "Filter Distance"],
            ["{{ハイライトのカラー}}", "Highlight Color"],
            ["{{ハイライトのアルファ}}", "Highlight Alpha"],
            ["{{グラデーションカラー}}", "Gradient Color"],
            ["{{グラデーションのアルファ}}", "Gradient Alpha"],
            ["{{タブの移動・名前を変更}}", "Move/Rename tabs"],
            ["{{プロジェクトを閉じる}}", "Close the project"],
            ["{{上下に移動}}", "Move up and down"],
            ["{{レイヤー変更(ダブルクリック)}}", "Layer Change(double-click)"],
            ["{{レイヤーをハイライト}}", "Highlight Layer"],
            ["{{レイヤーを非表示}}", "Hide Layer"],
            ["{{レイヤーをロック}}", "Lock the Layer"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Curve Pointer (double click to turn on/off)"],
            ["{{インスタンス名}}", "Instance Name"],
            ["{{ライブラリ内の検索}}", "Search in the library"],
            ["{{フレームラベル}}", "Frame Label"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "If the project is not saved, the project data in this tab cannot be recovered. Do you want to delete the tab?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class French extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{自由変形ツール}}", "Outil de transformation gratuit"],
            ["{{キーフレームに変換}}", "Convertir en image clé"],
            ["{{空のキーフレームに変換}}", "Convertir en images clés vides"],
            ["{{最初のフレームに移動}}", "Aller au premier cadre"],
            ["{{最後のフレームに移動}}", "Aller à la dernière image"],
            ["{{SWFを解析中}}", "SWF en cours d'analyse"],
            ["{{JSONを生成}}", "Générer JSON"],
            ["{{ファイルを生成}}", "Générer un fichier"],
            ["{{N2Dファイルの読み込み}}", "Chargement des fichiers N2D"],
            ["{{JSONの読み込み}}", "Chargement de JSON"],
            ["{{データを解凍中}}", "Décompression des données"],
            ["{{データを圧縮中}}", "Compression des données"],
            ["{{エンコード}}", "Encodage"],
            ["{{外部ファイルの読み込み}}", "Lecture de fichiers externes"],
            ["{{バイナリデータを生成}}", "Génération de données binaires"],
            ["{{データベースを起動}}", "Démarrage de la base de données"],
            ["{{データを保存中}}", "Stockage des données en cours"],
            ["{{完了}}", "Complété"],
            ["{{ステージ左揃え}}", "Aligner la scène à gauche"],
            ["{{ステージ中央揃え(水平方向)}}", "Aligner le centre de la scène (horizontal)"],
            ["{{ステージ右揃え}}", "Aligner la scène à droite"],
            ["{{ステージ上揃え}}", "Aligner la scène vers le haut"],
            ["{{ステージ中央揃え(垂直方向)}}", "Aligner le centre de la scène (vertical)"],
            ["{{ステージ下揃え}}", "Aligner le fond de la scène"],
            ["{{定規}}", "Règle"],
            ["{{表示}}", "Afficher"],
            ["{{ショートカット}}", "Raccourci"],
            ["{{レイヤーを複製}}", "Dupliquer la couche"],
            ["{{未使用のフォルダを削除}}", "Supprimez les dossiers inutilisés"],
            ["{{同名のアイテムが存在します}}", "Un ou plusieurs articles du même nom existent"],
            ["{{追加ファイル}}", "Fichier supplémentaire"],
            ["{{既存のコンテンツ}}", "Contenu existant"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "Vous pouvez choisir d'écraser, de renommer et d'ajouter des fichiers, ou de ne pas le faire"],
            ["{{全て上書き}}", "Ecraser tout"],
            ["{{全てスキップ}}", "Ignorer tout"],
            ["{{追加・上書き}}", "Ajouter ou Écraser"],
            ["{{スキップ}}", "Ignorer"],
            ["{{表示確認したいフレームを指定}}", "Specify the frame you want to check the display"],
            ["{{ファイル名を指定}}", "Spécifier le nom du fichier"],
            ["{{ファイル名}}", "nom du fichier"],
            ["{{終了フレームを指定}}", "Spécifier le cadre de fin"],
            ["{{開始フレームを指定}}", "Spécifier le cadre de départ"],
            ["{{フレーム設定}}", "Réglage du cadre"],
            ["{{書き出し設定}}", "Paramètres d'exportation"],
            ["{{ファイル形式の選択}}", "Sélectionner le format du fichier"],
            ["{{ファイル形式}}", "Formats de fichiers"],
            ["{{サイズ設定}}", "Réglage de la taille"],
            ["{{左上}}", "En haut à gauche"],
            ["{{中央上}}", "Centre supérieur"],
            ["{{右上}}", "Haut Droite"],
            ["{{中央左}}", "Centre gauche"],
            ["{{中央}}", "Centre"],
            ["{{中央右}}", "Centre droit"],
            ["{{左下}}", "Bas gauche"],
            ["{{中央下}}", "Bas Centre"],
            ["{{右下}}", "Bas droit"],
            ["{{中心点のX座標}}", "Coordonnée X du point central"],
            ["{{中心点のY座標}}", "Coordonnée Y du point central"],
            ["{{MovieClipに変換}}", "Convertir en MovieClip"],
            ["{{変換}}", "transformation"],
            ["{{ループ回数}}", "Nombre de boucles"],
            ["{{カーブポインターの削除}}", "Supprimer le pointeur de courbe"],
            ["{{ステージ基準}}", "Critères d'étape"],
            ["{{閉じる}}", "Fermer"],
            ["{{保存}}", "Sauvez"],
            ["{{リセット}}", "réinitialiser"],
            ["{{スクリーン}}", "Écran"],
            ["{{ショートカット設定}}", "Paramètres des raccourcis"],
            ["{{レイヤーカラー}}", "couleur superposée"],
            ["{{Next2Dを支援する}}", "Soutenez Next2D"],
            ["{{サポート}}", "soutien"],
            ["{{未使用のアイテムを削除}}", "Retirer les articles non utilisés"],
            ["{{レイヤーをペースト}}", "Couche de pâte"],
            ["{{レイヤーをコピー}}", "Copie de la couche"],
            ["{{フレームをペースト}}", "Coller le cadre"],
            ["{{フレームをコピー}}", "Cadre de copie"],
            ["{{キーフレームを削除}}", "Supprimez les images clés"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "Impossible d'ajouter des images clés vides à des images clés"],
            ["{{ズームツール}}", "Outil de zoom"],
            ["{{タイムライン幅の拡大・縮小}}", "Largeur de la ligne de temps Développer/réduire"],
            ["{{ガイドレイヤー}}", "couche de guidage"],
            ["{{音量設定}}", "Réglage du volume"],
            ["{{サウンドを削除}}", "Supprimer le son"],
            ["{{カスタムループ}}", "boucle personnalisée"],
            ["{{読込のみ}}", "Lecture seulement"],
            ["{{書込を許可}}", "autorisation de poste"],
            ["{{単一行}}", "Ligne unique"],
            ["{{複数行}}", "Multiline"],
            ["{{自動で折り返し}}", "Enveloppe automatique"],
            ["{{左寄せ}}", "Gauche"],
            ["{{中央揃え}}", "Centre"],
            ["{{右寄せ}}", "Droite"],
            ["{{放射状グラデーション}}", "gradation radiale"],
            ["{{線形グラデーション}}", "gradient linéaire"],
            ["{{画像}}", "Image"],
            ["{{画像選択}}", "Sélection d'images"],
            ["{{種別}}", "Type"],
            ["{{Shapeの色設定}}", "Paramètres de couleur de la forme"],
            ["{{変形}}", "déformation"],
            ["{{カラー効果}}", "Transformation des couleurs"],
            ["{{フィルター}}", "filtre"],
            ["{{Shapeを複製}}", "Dupliquer la forme"],
            ["{{読み込み}}", "lire dans"],
            ["{{新規フォルダー}}", "Nouveau dossier"],
            ["{{新規MovieClip}}", "Nouveau MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "Redimensionnez le texte pour l'adapter au cadre"],
            ["{{テキストに合わせて枠をリサイズ}}", "Redimensionnez le cadre pour l'adapter au texte"],
            ["{{リサイズしない}}", "Pas de redimensionnement"],
            ["{{フォント}}", "police"],
            ["{{テキスト}}", "Texte"],
            ["{{ループ}}", "boucle"],
            ["{{音量}}", "volume"],
            ["{{ビデオ}}", "Vidéo"],
            ["{{イージング}}", "facilitant"],
            ["{{サウンド}}", "son"],
            ["{{シンボル}}", "Symbole"],
            ["{{名前}}", "Nom"],
            ["{{オブジェクト}}", "objet"],
            ["{{ステージ設定}}", "Mise en scène"],
            ["{{プレビュー}}", "Prévisualisation"],
            ["{{削除}}", "Supprimer"],
            ["{{ペースト}}", "Pâte"],
            ["{{コピー}}", "Copie"],
            ["{{プラグインメニュー}}", "Menu plug-in"],
            ["{{トゥイーン}}", "entre"],
            ["{{カーブポインターの追加}}", "Pointeur de courbe supplémentaire"],
            ["{{パスの結合}}", "Fusion de chemins"],
            ["{{シェイプ}}", "forme"],
            ["{{キーフレームに配分}}", "Attribution aux images clés"],
            ["{{レイヤーに配分}}", "Affectation aux couches"],
            ["{{タイムライン}}", "chronologie"],
            ["{{整列}}", "Aligner"],
            ["{{最背面}}", "La plupart des dos"],
            ["{{ひとつ背面へ}}", "Un à l'arrière"],
            ["{{ひとつ前面へ}}", "Un front"],
            ["{{最前面}}", "Frontmost"],
            ["{{重ね順}}", "Organiser"],
            ["{{プラグイン}}", "plug-in"],
            ["{{ライブラリ}}", "bibliothèque"],
            ["{{プロパティ}}", "propriété"],
            ["{{マスクレイヤー}}", "couche de masque"],
            ["{{通常レイヤー}}", "Couche normale"],
            ["{{モーショントゥイーンの削除}}", "Suppression des tweens de mouvement"],
            ["{{モーショントゥイーンの追加}}", "Des tweens de mouvement supplémentaires"],
            ["{{モーダル表示}}", "indication modale"],
            ["{{言語}}", "Langue"],
            ["{{フォーマット}}", "format"],
            ["{{含める}}", "inclure"],
            ["{{含めない}}", "à ne pas inclure"],
            ["{{使い方、リファレンス}}", "Utilisation, référence"],
            ["{{非表示レイヤー}}", "couche cachée"],
            ["{{設定}}", "configuration"],
            ["{{デフォルトのループを利用する}}", "Utilisez la boucle par défaut"],
            ["{{フレームピッカー}}", "ramasseur de cadres"],
            ["{{左揃え}}", "Gauche"],
            ["{{中央揃え(水平方向)}}", "Centre(sens horizontal)"],
            ["{{右揃え}}", "Droit"],
            ["{{上揃え}}", "Top"],
            ["{{中央揃え(垂直方向)}}", "Centre(Vertical)"],
            ["{{下揃え}}", "Fond"],
            ["{{開始フレーム}}", "cadre de départ"],
            ["{{終了フレーム}}", "cadre terminal"],
            ["{{ループで再生}}", "Lecture en boucle"],
            ["{{1回再生}}", "1 lecture"],
            ["{{指定したフレームで固定}}", "Fixé dans le cadre spécifié"],
            ["{{1回逆再生}}", "1 lecture en sens inverse"],
            ["{{逆ループで再生}}", "Lecture en boucle inversée"],
            ["{{画面の拡大・縮小}}", "Zoom avant et arrière sur l'écran"],
            ["{{カスタムイージングデータを保存}}", "Enregistrez les données d'assouplissement personnalisées"],
            ["{{カスタムイージングデータの読込}}", "Lecture des données de l'assouplissement personnalisé"],
            ["{{プレビューのON/OFF}}", "Activation/désactivation de la prévisualisation"],
            ["{{フォント枠サイズ}}", "Taille du cadre de la police"],
            ["{{フォント枠カラー}}", "Couleur du cadre de la police"],
            ["{{オニオンスキン}}", "Peau d'oignon"],
            ["{{バケツツール}}", "Outils à godets"],
            ["{{ペンツール}}", "Outil stylo"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Double-cliquez pour ajouter un point de courbe"],
            ["{{選択ツール}}", "Outils de sélection"],
            ["{{Shape変形ツール}}", "Outil de transformation des formes"],
            ["{{テキストツール}}", "Outil texte"],
            ["{{矩形ツール}}", "Outil Rectangle"],
            ["{{楕円ツール}}", "Outil Ellipse"],
            ["{{角丸矩形ツール}}", "Outil Rectangle arrondi"],
            ["{{塗りのカラー}}", "Couleur de remplissage"],
            ["{{線のカラー}}", "Couleur du trait"],
            ["{{線の太さ}}", "Largeur de course"],
            ["{{プロジェクトデータの読込}}", "Chargement des données du projet"],
            ["{{プロジェクトデータを保存}}", "Sauvegarder les données du projet"],
            ["{{書き出し}}", "Exportation"],
            ["{{Discordへ移動}}", "Aller sur le discord"],
            ["{{バグ報告}}", "Rapports de bogue"],
            ["{{設定}}", "Réglage de"],
            ["{{タブを追加}}", "Ajouter un onglet"],
            ["{{タブの一覧を表示・移動}}", "Visualiser et se déplacer dans la liste des onglets"],
            ["{{スクリプトを追加}}", "Ajouter un script"],
            ["{{キーフレームを追加}}", "Ajouter une image clé"],
            ["{{空のキーフレームを追加}}", "Ajouter une image clé vide"],
            ["{{フレームを追加}}", "Ajouter un cadre"],
            ["{{フレームを削除}}", "Supprimer le cadre"],
            ["{{再生}}", "Jouer"],
            ["{{停止}}", "Stop"],
            ["{{ループ設定}}", "Réglage de la boucle"],
            ["{{レイヤーを追加}}", "Ajouter une couche"],
            ["{{レイヤーを削除}}", "Supprimer la couche"],
            ["{{全てのレイヤーをハイライト}}", "Mettez en évidence toutes les couches"],
            ["{{全てのレイヤーを非表示}}", "Cacher toutes les couches"],
            ["{{全てのレイヤーをロック}}", "Verrouiller toutes les couches"],
            ["{{比率を固定}}", "Ratio fixe"],
            ["{{ステージの幅}}", "Largeur de la scène"],
            ["{{背景色}}", "Couleur de fond"],
            ["{{ステージの高さ}}", "Hauteur de la scène"],
            ["{{フレームレート}}", "Fréquence d'images"],
            ["{{シンボル名}}", "Nom du symbole"],
            ["{{イージング設定}}", "Réglage de l'assouplissement"],
            ["{{ビデオの音量設定}}", "Réglage du volume vidéo"],
            ["{{自動再生}}", "Lecture automatique"],
            ["{{テキストエリアのボーダー設定}}", "Réglage de la bordure de la zone de texte"],
            ["{{テキスト入力設定}}", "Réglage de la saisie du texte"],
            ["{{フォント選択}}", "Sélection de la police"],
            ["{{自動サイズ調整}}", "Ajustement automatique de la taille"],
            ["{{フォントスタイルタイプ}}", "Type de police"],
            ["{{行揃え}}", "Aligner"],
            ["{{改行設定}}", "Réglage des nouvelles lignes"],
            ["{{スクロール設定}}", "Réglage du défilement"],
            ["{{フォントサイズ}}", "Taille de la police"],
            ["{{フォントカラー}}", "Couleur de la police"],
            ["{{行間}}", "Espace linéaire"],
            ["{{文字幅}}", "Largeur des caractères"],
            ["{{左マージン}}", "Marge gauche"],
            ["{{右マージン}}", "Marge droite"],
            ["{{カラー種別の選択}}", "Sélectionnez un type de couleur"],
            ["{{背景画像の選択}}", "Sélection d'une image de fond"],
            ["{{カラーポインターを追加}}", "Ajouter des pointeurs de couleur"],
            ["{{カラー値}}", "Couleur"],
            ["{{アルファ(0%-100%)}}", "Alpha(0%-100%)"],
            ["{{アルファ値}}", "Alpha"],
            ["{{選択対象の幅}}", "Largeur de l'objet de sélection"],
            ["{{選択対象のX座標}}", "Coordonnée X de l'objet de sélection"],
            ["{{選択対象の高さ}}", "Hauteur de l'objet de sélection"],
            ["{{選択対象のY座標}}", "Coordonnée Y de l'objet de sélection"],
            ["{{選択対象の幅の伸縮}}", "scaleX de l'objet sélectionné"],
            ["{{選択対象を回転}}", "Faire pivoter l'objet"],
            ["{{選択対象の高さの伸縮}}", "scaleY de l'objet sélectionné"],
            ["{{アルファオフセット(-255〜255)}}", "Décalage alpha(-255〜255)"],
            ["{{赤(0%-100%)}}", "Rouge(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Décalage rouge(-255〜255)"],
            ["{{緑(0%-100%)}}", "Vert(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Compensation verte(-255〜255)"],
            ["{{青(0%-100%)}}", "Bleu(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Décalage bleu(-255〜255)"],
            ["{{ブレンドモード}}", "Mode de mélange"],
            ["{{フィルターを選択}}", "Sélectionnez un filtre"],
            ["{{フィルターを追加}}", "Ajouter un filtre"],
            ["{{サウンドを追加}}", "Ajouter un son"],
            ["{{フィルターを表示・非表示する}}", "Afficher et masquer les filtres"],
            ["{{フィルターを削除}}", "Supprimer le filtre"],
            ["{{水平方向にぼかす}}", "Flou horizontal"],
            ["{{垂直方向にぼかす}}", "Flou vertical"],
            ["{{フィルター強度}}", "Résistance du filtre"],
            ["{{フィルター角度}}", "Angle du filtre"],
            ["{{シャドウのアルファ}}", "Shadow Alpha"],
            ["{{シャドウのカラー}}", "Couleur de l'ombre"],
            ["{{フィルター距離}}", "Distance du filtre"],
            ["{{ハイライトのカラー}}", "Couleur de mise en évidence"],
            ["{{ハイライトのアルファ}}", "Highlight Alpha"],
            ["{{グラデーションカラー}}", "Couleur dégradée"],
            ["{{グラデーションのアルファ}}", "Gradient Alpha"],
            ["{{タブの移動・名前を変更}}", "Déplacer/Renommer les onglets"],
            ["{{プロジェクトを閉じる}}", "Fermer le projet"],
            ["{{上下に移動}}", "Déplacement vers le haut et le bas"],
            ["{{レイヤー変更(ダブルクリック)}}", "Changement de couche (double-clic)"],
            ["{{レイヤーをハイライト}}", "Couche de mise en évidence"],
            ["{{レイヤーを非表示}}", "Masquer la couche"],
            ["{{レイヤーをロック}}", "Verrouiller le calque"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Pointeur de courbe (double-cliquez pour l'activer ou le désactiver)"],
            ["{{インスタンス名}}", "Nom de l'instance"],
            ["{{ライブラリ内の検索}}", "Recherche dans la bibliothèque"],
            ["{{フレームラベル}}", "Étiquette du cadre"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "Si le projet n'est pas sauvegardé, les données du projet dans cet onglet ne peuvent pas être récupérées. Voulez-vous supprimer l'onglet ?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Italiano extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{自由変形ツール}}", "Strumento di trasformazione gratuito"],
            ["{{キーフレームに変換}}", "Convertire in keyframe"],
            ["{{空のキーフレームに変換}}", "Convertire in fotogrammi chiave vuoti"],
            ["{{最初のフレームに移動}}", "Vai al primo fotogramma"],
            ["{{最後のフレームに移動}}", "Vai all'ultimo fotogramma"],
            ["{{SWFを解析中}}", "SWF in analisi"],
            ["{{JSONを生成}}", "Generare JSON"],
            ["{{ファイルを生成}}", "Generare il file"],
            ["{{N2Dファイルの読み込み}}", "Caricamento dei file N2D"],
            ["{{JSONの読み込み}}", "Caricamento di JSON"],
            ["{{データを解凍中}}", "Decomprimere i dati"],
            ["{{データを圧縮中}}", "Comprimere i dati"],
            ["{{エンコード}}", "Codifica"],
            ["{{外部ファイルの読み込み}}", "Lettura di file esterni"],
            ["{{バイナリデータを生成}}", "Generazione di dati binari"],
            ["{{データベースを起動}}", "Avvio del database"],
            ["{{データを保存中}}", "Memorizzazione dei dati in corso"],
            ["{{完了}}", "Completato"],
            ["{{ステージ左揃え}}", "Allineare il palco a sinistra"],
            ["{{ステージ中央揃え(水平方向)}}", "Allineare il centro del palco (orizzontale)"],
            ["{{ステージ右揃え}}", "Allineare il palco a destra"],
            ["{{ステージ上揃え}}", "Allineare il palco in alto"],
            ["{{ステージ中央揃え(垂直方向)}}", "Allineare il centro del palco (verticale)"],
            ["{{ステージ下揃え}}", "Allineare il fondo del palco"],
            ["{{定規}}", "Righello"],
            ["{{表示}}", "Display"],
            ["{{ショートカット}}", "scorciatoia"],
            ["{{レイヤーを複製}}", "Duplicare il livello"],
            ["{{未使用のフォルダを削除}}", "Eliminare le cartelle inutilizzate"],
            ["{{同名のアイテムが存在します}}", "Esistono voci con lo stesso nome"],
            ["{{追加ファイル}}", "File aggiuntivo"],
            ["{{既存のコンテンツ}}", "Contenuto esistente"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "È possibile scegliere di sovrascrivere, rinominare e aggiungere i file, o di saltare"],
            ["{{全て上書き}}", "Sovrascrivi tutto"],
            ["{{全てスキップ}}", "Salta tutto"],
            ["{{追加・上書き}}", "Aggiungi o sovrascrivi"],
            ["{{スキップ}}", "Salta"],
            ["{{表示確認したいフレームを指定}}", "Specificare la cornice di cui si desidera controllare la visualizzazione"],
            ["{{ファイル名を指定}}", "Specificare il nome del file"],
            ["{{ファイル名}}", "nome del file"],
            ["{{終了フレームを指定}}", "Specificare la cornice finale"],
            ["{{開始フレームを指定}}", "Specificare il fotogramma iniziale"],
            ["{{フレーム設定}}", "Impostazione del telaio"],
            ["{{書き出し設定}}", "Impostazioni di esportazione"],
            ["{{ファイル形式の選択}}", "Selezionare il formato del file"],
            ["{{ファイル形式}}", "Formati dei file"],
            ["{{サイズ設定}}", "Impostazione delle dimensioni"],
            ["{{左上}}", "In alto a sinistra"],
            ["{{中央上}}", "In alto al centro"],
            ["{{右上}}", "In alto a destra"],
            ["{{中央左}}", "Centro Sinistra"],
            ["{{中央}}", "Centro"],
            ["{{中央右}}", "Centro Destra"],
            ["{{左下}}", "In basso a sinistra"],
            ["{{中央下}}", "In basso al centro"],
            ["{{右下}}", "In basso a destra"],
            ["{{中心点のX座標}}", "Coordinata X del punto centrale"],
            ["{{中心点のY座標}}", "Coordinata Y del punto centrale"],
            ["{{MovieClipに変換}}", "Convertire in MovieClip"],
            ["{{変換}}", "trasformazione"],
            ["{{ループ回数}}", "Conteggio dei cicli"],
            ["{{カーブポインターの削除}}", "Elimina il puntatore di curva"],
            ["{{ステージ基準}}", "Criteri di fase"],
            ["{{閉じる}}", "Chiudere"],
            ["{{保存}}", "Risparmiare"],
            ["{{リセット}}", "azzeramento"],
            ["{{スクリーン}}", "Schermo"],
            ["{{ショートカット設定}}", "Impostazioni delle scorciatoie"],
            ["{{レイヤーカラー}}", "colore stratificato"],
            ["{{Next2Dを支援する}}", "Supporto Next2D"],
            ["{{サポート}}", "supporto"],
            ["{{未使用のアイテムを削除}}", "Rimuovere gli articoli inutilizzati"],
            ["{{レイヤーをペースト}}", "Strato di pasta"],
            ["{{レイヤーをコピー}}", "Copiare il livello"],
            ["{{フレームをペースト}}", "Incolla la cornice"],
            ["{{フレームをコピー}}", "Cornice di copia"],
            ["{{キーフレームを削除}}", "Elimina i fotogrammi chiave"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "Impossibile aggiungere keyframes vuoti ai keyframes"],
            ["{{ズームツール}}", "Strumento zoom"],
            ["{{タイムライン幅の拡大・縮小}}", "Larghezza della timeline Espandere/ridurre"],
            ["{{ガイドレイヤー}}", "strato guida"],
            ["{{音量設定}}", "Regolazione del volume"],
            ["{{サウンドを削除}}", "Rimuovere il suono"],
            ["{{カスタムループ}}", "anello personalizzato"],
            ["{{読込のみ}}", "Leggere solo"],
            ["{{書込を許可}}", "autorizzazione del post"],
            ["{{単一行}}", "Linea singola"],
            ["{{複数行}}", "Multiline"],
            ["{{自動で折り返し}}", "Avvolgimento automatico"],
            ["{{左寄せ}}", "Sinistra"],
            ["{{中央揃え}}", "Centro"],
            ["{{右寄せ}}", "Destra"],
            ["{{放射状グラデーション}}", "gradazione radiale"],
            ["{{線形グラデーション}}", "gradiente lineare"],
            ["{{画像}}", "Immagine"],
            ["{{画像選択}}", "Selezione dell'immagine"],
            ["{{種別}}", "Tipo"],
            ["{{Shapeの色設定}}", "Impostazioni del colore della forma"],
            ["{{変形}}", "deformazione"],
            ["{{カラー効果}}", "Trasformazione del colore"],
            ["{{フィルター}}", "filtro"],
            ["{{Shapeを複製}}", "Forma duplicata"],
            ["{{読み込み}}", "leggere in"],
            ["{{新規フォルダー}}", "Nuova cartella"],
            ["{{新規MovieClip}}", "Nuovo MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "Ridimensiona il testo per adattarlo alla cornice"],
            ["{{テキストに合わせて枠をリサイズ}}", "Ridimensiona la cornice per adattarla al testo"],
            ["{{リサイズしない}}", "Nessun ridimensionamento"],
            ["{{フォント}}", "font"],
            ["{{テキスト}}", "Testo"],
            ["{{ループ}}", "loop"],
            ["{{音量}}", "volume"],
            ["{{ビデオ}}", "Video"],
            ["{{イージング}}", "facilitando"],
            ["{{サウンド}}", "suono"],
            ["{{シンボル}}", "Simbolo"],
            ["{{名前}}", "Nome"],
            ["{{オブジェクト}}", "oggetto"],
            ["{{ステージ設定}}", "Scenario"],
            ["{{プレビュー}}", "Anteprima"],
            ["{{削除}}", "Cancellare"],
            ["{{ペースト}}", "Incolla"],
            ["{{コピー}}", "Copia"],
            ["{{プラグインメニュー}}", "Menu del plug-in"],
            ["{{トゥイーン}}", "tween"],
            ["{{カーブポインターの追加}}", "Puntatore di curva supplementare"],
            ["{{パスの結合}}", "Fusione di percorsi"],
            ["{{シェイプ}}", "forma"],
            ["{{キーフレームに配分}}", "Assegnazione ai fotogrammi chiave"],
            ["{{レイヤーに配分}}", "Assegnazione ai livelli"],
            ["{{タイムライン}}", "Timeline"],
            ["{{整列}}", "Allineare"],
            ["{{最背面}}", "La maggior parte della schiena"],
            ["{{ひとつ背面へ}}", "Uno sul retro"],
            ["{{ひとつ前面へ}}", "Una parte anteriore"],
            ["{{最前面}}", "In prima linea"],
            ["{{重ね順}}", "Organizzare"],
            ["{{プラグイン}}", "plug-in"],
            ["{{ライブラリ}}", "biblioteca"],
            ["{{プロパティ}}", "proprietà"],
            ["{{マスクレイヤー}}", "strato di maschera"],
            ["{{通常レイヤー}}", "Strato normale"],
            ["{{モーショントゥイーンの削除}}", "Soppressione dei tweens di movimento"],
            ["{{モーショントゥイーンの追加}}", "Ulteriori tween di movimento"],
            ["{{モーダル表示}}", "indicazione modale"],
            ["{{言語}}", "Lingua"],
            ["{{フォーマット}}", "formato"],
            ["{{含める}}", "includere"],
            ["{{含めない}}", "non includere"],
            ["{{使い方、リファレンス}}", "Uso, riferimento"],
            ["{{非表示レイヤー}}", "strato nascosto"],
            ["{{設定}}", "setup"],
            ["{{デフォルトのループを利用する}}", "Utilizzare il ciclo predefinito"],
            ["{{フレームピッカー}}", "raccoglitore di cornici"],
            ["{{左揃え}}", "Sinistra"],
            ["{{中央揃え(水平方向)}}", "Centro (Orizzontalità)"],
            ["{{右揃え}}", "Destra"],
            ["{{上揃え}}", "Top"],
            ["{{中央揃え(垂直方向)}}", "Centro (Verticale)"],
            ["{{下揃え}}", "Fondo"],
            ["{{開始フレーム}}", "telaio di partenza"],
            ["{{終了フレーム}}", "telaio finale"],
            ["{{ループで再生}}", "Gioca in loop"],
            ["{{1回再生}}", "1 riproduzione"],
            ["{{指定したフレームで固定}}", "Fissato nella cornice specificata"],
            ["{{1回逆再生}}", "1 riproduzione inversa"],
            ["{{逆ループで再生}}", "Riproduzione in loop inverso"],
            ["{{画面の拡大・縮小}}", "Ingrandire e rimpicciolire lo schermo"],
            ["{{カスタムイージングデータを保存}}", "Salva i dati di easing personalizzati"],
            ["{{カスタムイージングデータの読込}}", "Lettura dei dati di easing personalizzati"],
            ["{{プレビューのON/OFF}}", "Anteprima on/off"],
            ["{{フォント枠サイズ}}", "Dimensione della cornice del carattere"],
            ["{{フォント枠カラー}}", "Colore della cornice del carattere"],
            ["{{オニオンスキン}}", "Pelle di cipolla"],
            ["{{バケツツール}}", "Strumenti a secchiello"],
            ["{{ペンツール}}", "Strumento penna"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Doppio clic per aggiungere un punto di curva"],
            ["{{選択ツール}}", "Strumenti di selezione"],
            ["{{Shape変形ツール}}", "Strumento di trasformazione della forma"],
            ["{{テキストツール}}", "Text Tool"],
            ["{{矩形ツール}}", "Strumento di testo"],
            ["{{楕円ツール}}", "Strumento Ellisse"],
            ["{{角丸矩形ツール}}", "Strumento Rettangolo arrotondato"],
            ["{{塗りのカラー}}", "Colore di riempimento"],
            ["{{線のカラー}}", "Colore del tratto"],
            ["{{線の太さ}}", "Larghezza della corsa"],
            ["{{プロジェクトデータの読込}}", "Caricamento dei dati del progetto"],
            ["{{プロジェクトデータを保存}}", "Salvare i dati del progetto"],
            ["{{書き出し}}", "Esportazione"],
            ["{{Discordへ移動}}", "Vai su discordia"],
            ["{{バグ報告}}", "Segnalazioni di bug"],
            ["{{設定}}", "Impostazione"],
            ["{{タブを追加}}", "Aggiungere una scheda"],
            ["{{タブの一覧を表示・移動}}", "Visualizzare e spostarsi attraverso l'elenco delle schede"],
            ["{{スクリプトを追加}}", "Aggiungere uno script"],
            ["{{キーフレームを追加}}", "Aggiungere un keyframe"],
            ["{{空のキーフレームを追加}}", "Aggiungere un keyframe vuoto"],
            ["{{フレームを追加}}", "Aggiungere una cornice"],
            ["{{フレームを削除}}", "Cancellare la cornice"],
            ["{{再生}}", "Gioca"],
            ["{{停止}}", "Fermare"],
            ["{{ループ設定}}", "Impostazione del loop"],
            ["{{レイヤーを追加}}", "Aggiungere uno strato"],
            ["{{レイヤーを削除}}", "Cancellare il livello"],
            ["{{全てのレイヤーをハイライト}}", "Evidenzia tutti i livelli"],
            ["{{全てのレイヤーを非表示}}", "Nascondi tutti i livelli"],
            ["{{全てのレイヤーをロック}}", "Blocca tutti i livelli"],
            ["{{比率を固定}}", "Rapporto fisso"],
            ["{{ステージの幅}}", "Larghezza del palco"],
            ["{{背景色}}", "Colore di sfondo"],
            ["{{ステージの高さ}}", "Altezza del palco"],
            ["{{フレームレート}}", "Frame Rate"],
            ["{{シンボル名}}", "Nome del simbolo"],
            ["{{イージング設定}}", "Impostazione di rilassamento"],
            ["{{ビデオの音量設定}}", "Impostazione del volume video"],
            ["{{自動再生}}", "Riproduzione automatica"],
            ["{{テキストエリアのボーダー設定}}", "Impostazione del bordo dell'area di testo"],
            ["{{テキスト入力設定}}", "Impostazione dell'inserimento del testo"],
            ["{{フォント選択}}", "Seleziona il carattere"],
            ["{{自動サイズ調整}}", "Regolazione automatica delle dimensioni"],
            ["{{フォントスタイルタイプ}}", "Tipo di stile di carattere"],
            ["{{行揃え}}", "Allineare"],
            ["{{改行設定}}", "Impostazione Newline"],
            ["{{スクロール設定}}", "Impostazione dello scorrimento"],
            ["{{フォントサイズ}}", "Dimensione del carattere"],
            ["{{フォントカラー}}", "Colore del carattere"],
            ["{{行間}}", "Spazio di linea"],
            ["{{文字幅}}", "Larghezza del carattere"],
            ["{{左マージン}}", "Margine sinistro"],
            ["{{右マージン}}", "Margine destro"],
            ["{{カラー種別の選択}}", "Seleziona un tipo di colore"],
            ["{{背景画像の選択}}", "Selezionare un'immagine di sfondo"],
            ["{{カラーポインターを追加}}", "Aggiungere i puntatori di colore"],
            ["{{カラー値}}", "Colore"],
            ["{{アルファ(0%-100%)}}", "Alpha(0%-100%)"],
            ["{{アルファ値}}", "Alpha"],
            ["{{選択対象の幅}}", "Larghezza dell'oggetto di selezione"],
            ["{{選択対象のX座標}}", "Coordinata X dell'oggetto di selezione"],
            ["{{選択対象の高さ}}", "Altezza dell'oggetto di selezione"],
            ["{{選択対象のY座標}}", "Coordinata Y dell'oggetto di selezione"],
            ["{{選択対象の幅の伸縮}}", "scaleX dell'oggetto selezionato"],
            ["{{選択対象を回転}}", "Ruotare l'oggetto"],
            ["{{選択対象の高さの伸縮}}", "scalaY dell'oggetto selezionato"],
            ["{{アルファオフセット(-255〜255)}}", "Offset alfa(-255〜255)"],
            ["{{赤(0%-100%)}}", "Rosso(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Offset rosso(-255〜255)"],
            ["{{緑(0%-100%)}}", "Verde(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Offset Verde(-255〜255)"],
            ["{{青(0%-100%)}}", "Blu(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Offset Blu(-255〜255)"],
            ["{{ブレンドモード}}", "Modalità di fusione"],
            ["{{フィルターを選択}}", "Seleziona un filtro"],
            ["{{フィルターを追加}}", "Aggiungere un filtro"],
            ["{{サウンドを追加}}", "Aggiungere un suono"],
            ["{{フィルターを表示・非表示する}}", "Mostrare e nascondere i filtri"],
            ["{{フィルターを削除}}", "Cancellare il filtro"],
            ["{{水平方向にぼかす}}", "Sfocatura orizzontale"],
            ["{{垂直方向にぼかす}}", "Sfocatura verticale"],
            ["{{フィルター強度}}", "Forza del filtro"],
            ["{{フィルター角度}}", "Angolo del filtro"],
            ["{{シャドウのアルファ}}", "Ombra alfa"],
            ["{{シャドウのカラー}}", "Colore dell'ombra"],
            ["{{フィルター距離}}", "Distanza del filtro"],
            ["{{ハイライトのカラー}}", "Colore in evidenza"],
            ["{{ハイライトのアルファ}}", "Evidenziare l'alfa"],
            ["{{グラデーションカラー}}", "Colore sfumato"],
            ["{{グラデーションのアルファ}}", "Gradiente alfa"],
            ["{{タブの移動・名前を変更}}", "Spostare/rinominare le schede"],
            ["{{プロジェクトを閉じる}}", "Chiudere il progetto"],
            ["{{上下に移動}}", "Sposta su e giù"],
            ["{{レイヤー変更(ダブルクリック)}}", "Cambio di livello (doppio clic)"],
            ["{{レイヤーをハイライト}}", "Strato di evidenziazione"],
            ["{{レイヤーを非表示}}", "Nascondere lo strato"],
            ["{{レイヤーをロック}}", "Bloccare il livello"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Curve Pointer (doppio clic per attivare/disattivare)"],
            ["{{インスタンス名}}", "Nome dell'istanza"],
            ["{{ライブラリ内の検索}}", "Cerca nella biblioteca"],
            ["{{フレームラベル}}", "Etichetta del telaio"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "Se il progetto non viene salvato, i dati del progetto in questa scheda non possono essere recuperati. Vuoi cancellare la scheda?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Japanese extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{自由変形ツール}}", "自由変形ツール"],
            ["{{キーフレームに変換}}", "キーフレームに変換"],
            ["{{空のキーフレームに変換}}", "空のキーフレームに変換"],
            ["{{最初のフレームに移動}}", "最初のフレームに移動"],
            ["{{最後のフレームに移動}}", "最後のフレームに移動"],
            ["{{SWFを解析中}}", "SWFを解析中"],
            ["{{JSONを生成}}", "JSONを生成"],
            ["{{ファイルを生成}}", "ファイルを生成"],
            ["{{N2Dファイルの読み込み}}", "N2Dファイルの読み込み"],
            ["{{JSONの読み込み}}", "JSONの読み込み"],
            ["{{データを解凍中}}", "データを解凍中"],
            ["{{データを圧縮中}}", "データを圧縮中"],
            ["{{エンコード}}", "エンコード"],
            ["{{外部ファイルの読み込み}}", "外部ファイルの読み込み"],
            ["{{バイナリデータを生成}}", "バイナリデータを生成"],
            ["{{データベースを起動}}", "データベースを起動"],
            ["{{データを保存中}}", "データを保存中"],
            ["{{完了}}", "完了"],
            ["{{ステージ左揃え}}", "ステージ左揃え"],
            ["{{ステージ中央揃え(水平方向)}}", "ステージ中央揃え(水平方向)"],
            ["{{ステージ右揃え}}", "ステージ右揃え"],
            ["{{ステージ上揃え}}", "ステージ上揃え"],
            ["{{ステージ中央揃え(垂直方向)}}", "ステージ中央揃え(垂直方向)"],
            ["{{ステージ下揃え}}", "ステージ下揃え"],
            ["{{定規}}", "定規"],
            ["{{表示}}", "表示"],
            ["{{ショートカット}}", "ショートカット"],
            ["{{レイヤーを複製}}", "レイヤーを複製"],
            ["{{未使用のフォルダを削除}}", "未使用のフォルダを削除"],
            ["{{同名のアイテムが存在します}}", "同名のアイテムが存在します"],
            ["{{追加ファイル}}", "追加ファイル"],
            ["{{既存のコンテンツ}}", "既存のコンテンツ"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます"],
            ["{{全て上書き}}", "全て上書き"],
            ["{{全てスキップ}}", "全てスキップ"],
            ["{{追加・上書き}}", "追加・上書き"],
            ["{{スキップ}}", "スキップ"],
            ["{{表示確認したいフレームを指定}}", "表示確認したいフレームを指定"],
            ["{{ファイル名を指定}}", "ファイル名を指定"],
            ["{{ファイル名}}", "ファイル名"],
            ["{{終了フレームを指定}}", "終了フレームを指定"],
            ["{{開始フレームを指定}}", "開始フレームを指定"],
            ["{{フレーム設定}}", "フレーム設定"],
            ["{{書き出し設定}}", "書き出し設定"],
            ["{{ファイル形式の選択}}", "ファイル形式の選択"],
            ["{{ファイル形式}}", "ファイル形式"],
            ["{{サイズ設定}}", "サイズ設定"],
            ["{{左上}}", "左上"],
            ["{{中央上}}", "中央上"],
            ["{{右上}}", "右上"],
            ["{{中央左}}", "中央左"],
            ["{{中央}}", "中央"],
            ["{{中央右}}", "中央右"],
            ["{{左下}}", "左下"],
            ["{{中央下}}", "中央下"],
            ["{{右下}}", "右下"],
            ["{{中心点のX座標}}", "中心点のX座標"],
            ["{{中心点のY座標}}", "中心点のY座標"],
            ["{{MovieClipに変換}}", "MovieClipに変換"],
            ["{{変換}}", "変換"],
            ["{{ループ回数}}", "ループ回数"],
            ["{{カーブポインターの削除}}", "カーブポインターの削除"],
            ["{{ステージ基準}}", "ステージ基準"],
            ["{{閉じる}}", "閉じる"],
            ["{{保存}}", "保存"],
            ["{{リセット}}", "リセット"],
            ["{{スクリーン}}", "スクリーン"],
            ["{{ショートカット設定}}", "ショートカット設定"],
            ["{{レイヤーカラー}}", "レイヤーカラー"],
            ["{{Next2Dを支援する}}", "Next2Dを支援する"],
            ["{{サポート}}", "サポート"],
            ["{{未使用のアイテムを削除}}", "未使用のアイテムを削除"],
            ["{{レイヤーをペースト}}", "レイヤーをペースト"],
            ["{{レイヤーをコピー}}", "レイヤーをコピー"],
            ["{{フレームをペースト}}", "フレームをペースト"],
            ["{{フレームをコピー}}", "フレームをコピー"],
            ["{{キーフレームを削除}}", "キーフレームを削除"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "キーフレームに空のキーフレームを追加できません"],
            ["{{ズームツール}}", "ズームツール"],
            ["{{タイムライン幅の拡大・縮小}}", "タイムライン幅の拡大・縮小"],
            ["{{ガイドレイヤー}}", "ガイドレイヤー"],
            ["{{音量設定}}", "音量設定"],
            ["{{サウンドを削除}}", "サウンドを削除"],
            ["{{カスタムループ}}", "カスタムループ"],
            ["{{読込のみ}}", "読込のみ"],
            ["{{書込を許可}}", "書込を許可"],
            ["{{単一行}}", "単一行"],
            ["{{複数行}}", "複数行"],
            ["{{自動で折り返し}}", "自動で折り返し"],
            ["{{左寄せ}}", "左寄せ"],
            ["{{中央揃え}}", "中央揃え"],
            ["{{右寄せ}}", "右寄せ"],
            ["{{放射状グラデーション}}", "放射状グラデーション"],
            ["{{線形グラデーション}}", "線形グラデーション"],
            ["{{画像}}", "画像"],
            ["{{画像選択}}", "画像選択"],
            ["{{種別}}", "種別"],
            ["{{Shapeの色設定}}", "Shapeの色設定"],
            ["{{変形}}", "変形"],
            ["{{カラー効果}}", "カラー効果"],
            ["{{フィルター}}", "フィルター"],
            ["{{Shapeを複製}}", "Shapeを複製"],
            ["{{読み込み}}", "読み込み"],
            ["{{新規フォルダー}}", "新規フォルダー"],
            ["{{新規MovieClip}}", "新規MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "枠に合わせてテキストをリサイズ"],
            ["{{テキストに合わせて枠をリサイズ}}", "テキストに合わせて枠をリサイズ"],
            ["{{リサイズしない}}", "リサイズしない"],
            ["{{フォント}}", "フォント"],
            ["{{テキスト}}", "テキスト"],
            ["{{ループ}}", "ループ"],
            ["{{音量}}", "音量"],
            ["{{ビデオ}}", "ビデオ"],
            ["{{イージング}}", "イージング"],
            ["{{サウンド}}", "サウンド"],
            ["{{シンボル}}", "シンボル"],
            ["{{名前}}", "名前"],
            ["{{オブジェクト}}", "オブジェクト"],
            ["{{ステージ設定}}", "ステージ設定"],
            ["{{プレビュー}}", "プレビュー"],
            ["{{削除}}", "削除"],
            ["{{ペースト}}", "ペースト"],
            ["{{コピー}}", "コピー"],
            ["{{プラグインメニュー}}", "プラグインメニュー"],
            ["{{トゥイーン}}", "トゥイーン"],
            ["{{カーブポインターの追加}}", "カーブポインターの追加"],
            ["{{パスの結合}}", "パスの結合"],
            ["{{シェイプ}}", "シェイプ"],
            ["{{キーフレームに配分}}", "キーフレームに配分"],
            ["{{レイヤーに配分}}", "レイヤーに配分"],
            ["{{タイムライン}}", "タイムライン"],
            ["{{整列}}", "整列"],
            ["{{最背面}}", "最背面"],
            ["{{ひとつ背面へ}}", "ひとつ背面へ"],
            ["{{ひとつ前面へ}}", "ひとつ前面へ"],
            ["{{最前面}}", "最前面"],
            ["{{重ね順}}", "重ね順"],
            ["{{プラグイン}}", "プラグイン"],
            ["{{ライブラリ}}", "ライブラリ"],
            ["{{プロパティ}}", "プロパティ"],
            ["{{マスクレイヤー}}", "マスクレイヤー"],
            ["{{通常レイヤー}}", "通常レイヤー"],
            ["{{モーショントゥイーンの削除}}", "モーショントゥイーンの削除"],
            ["{{モーショントゥイーンの追加}}", "モーショントゥイーンの追加"],
            ["{{モーダル表示}}", "モーダル表示"],
            ["{{言語}}", "言語"],
            ["{{フォーマット}}", "フォーマット"],
            ["{{含める}}", "含める"],
            ["{{含めない}}", "含めない"],
            ["{{使い方、リファレンス}}", "使い方、リファレンス"],
            ["{{非表示レイヤー}}", "非表示レイヤー"],
            ["{{設定}}", "設定"],
            ["{{デフォルトのループを利用する}}", "デフォルトのループを利用する"],
            ["{{フレームピッカー}}", "フレームピッカー"],
            ["{{左揃え}}", "左揃え"],
            ["{{中央揃え(水平方向)}}", "中央揃え(水平方向)"],
            ["{{右揃え}}", "右揃え"],
            ["{{上揃え}}", "上揃え"],
            ["{{中央揃え(垂直方向)}}", "中央揃え(垂直方向)"],
            ["{{下揃え}}", "下揃え"],
            ["{{開始フレーム}}", "開始フレーム"],
            ["{{終了フレーム}}", "終了フレーム"],
            ["{{ループで再生}}", "ループで再生"],
            ["{{1回再生}}", "1回再生"],
            ["{{指定したフレームで固定}}", "指定したフレームで固定"],
            ["{{1回逆再生}}", "1回逆再生"],
            ["{{逆ループで再生}}", "逆ループで再生"],
            ["{{画面の拡大・縮小}}", "画面の拡大・縮小"],
            ["{{カスタムイージングデータを保存}}", "カスタムイージングデータを保存"],
            ["{{カスタムイージングデータの読込}}", "カスタムイージングデータの読込"],
            ["{{プレビューのON/OFF}}", "プレビューのON/OFF"],
            ["{{フォント枠サイズ}}", "フォント枠サイズ"],
            ["{{フォント枠カラー}}", "フォント枠カラー"],
            ["{{オニオンスキン}}", "オニオンスキン"],
            ["{{バケツツール}}", "バケツツール"],
            ["{{ペンツール}}", "ペンツール"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "ダブルクリックでカーブポイントが追加されます"],
            ["{{選択ツール}}", "選択ツール"],
            ["{{Shape変形ツール}}", "Shape変形ツール"],
            ["{{テキストツール}}", "テキストツール"],
            ["{{矩形ツール}}", "矩形ツール"],
            ["{{楕円ツール}}", "楕円ツール"],
            ["{{角丸矩形ツール}}", "角丸矩形ツール"],
            ["{{塗りのカラー}}", "塗りのカラー"],
            ["{{線のカラー}}", "線のカラー"],
            ["{{線の太さ}}", "線の太さ"],
            ["{{プロジェクトデータの読込}}", "プロジェクトデータの読込"],
            ["{{プロジェクトデータを保存}}", "プロジェクトデータを保存"],
            ["{{書き出し}}", "書き出し"],
            ["{{Discordへ移動}}", "Discordへ移動"],
            ["{{バグ報告}}", "バグ報告"],
            ["{{設定}}", "設定"],
            ["{{タブを追加}}", "タブを追加"],
            ["{{タブの一覧を表示・移動}}", "タブの一覧を表示・移動"],
            ["{{スクリプトを追加}}", "スクリプトを追加"],
            ["{{キーフレームを追加}}", "キーフレームを追加"],
            ["{{空のキーフレームを追加}}", "空のキーフレームを追加"],
            ["{{フレームを追加}}", "フレームを追加"],
            ["{{フレームを削除}}", "フレームを削除"],
            ["{{再生}}", "再生"],
            ["{{停止}}", "停止"],
            ["{{ループ設定}}", "ループ設定"],
            ["{{レイヤーを追加}}", "レイヤーを追加"],
            ["{{レイヤーを削除}}", "レイヤーを削除"],
            ["{{全てのレイヤーをハイライト}}", "全てのレイヤーをハイライト"],
            ["{{全てのレイヤーを非表示}}", "全てのレイヤーを非表示"],
            ["{{全てのレイヤーをロック}}", "全てのレイヤーをロック"],
            ["{{比率を固定}}", "比率を固定"],
            ["{{ステージの幅}}", "ステージの幅"],
            ["{{背景色}}", "背景色"],
            ["{{ステージの高さ}}", "ステージの高さ"],
            ["{{フレームレート}}", "フレームレート"],
            ["{{シンボル名}}", "シンボル名"],
            ["{{イージング設定}}", "イージング設定"],
            ["{{ビデオの音量設定}}", "ビデオの音量設定"],
            ["{{自動再生}}", "自動再生"],
            ["{{テキストエリアのボーダー設定}}", "テキストエリアのボーダー設定"],
            ["{{テキスト入力設定}}", "テキスト入力設定"],
            ["{{フォント選択}}", "フォント選択"],
            ["{{自動サイズ調整}}", "自動サイズ調整"],
            ["{{フォントスタイルタイプ}}", "フォントスタイルタイプ"],
            ["{{行揃え}}", "行揃え"],
            ["{{改行設定}}", "改行設定"],
            ["{{スクロール設定}}", "スクロール設定"],
            ["{{フォントサイズ}}", "フォントサイズ"],
            ["{{フォントカラー}}", "フォントカラー"],
            ["{{行間}}", "行間"],
            ["{{文字幅}}", "文字幅"],
            ["{{左マージン}}", "左マージン"],
            ["{{右マージン}}", "右マージン"],
            ["{{カラー種別の選択}}", "カラー種別の選択"],
            ["{{背景画像の選択}}", "背景画像の選択"],
            ["{{カラーポインターを追加}}", "カラーポインターを追加"],
            ["{{カラー値}}", "カラー値"],
            ["{{アルファ(0%-100%)}}", "アルファ(0%-100%)"],
            ["{{アルファ値}}", "アルファ値"],
            ["{{選択対象の幅}}", "選択対象の幅"],
            ["{{選択対象のX座標}}", "選択対象のX座標"],
            ["{{選択対象の高さ}}", "選択対象の高さ"],
            ["{{選択対象のY座標}}", "選択対象のY座標"],
            ["{{選択対象の幅の伸縮}}", "選択対象の幅の伸縮"],
            ["{{選択対象を回転}}", "選択対象を回転"],
            ["{{選択対象の高さの伸縮}}", "選択対象の高さの伸縮"],
            ["{{アルファオフセット(-255〜255)}}", "アルファオフセット(-255〜255)"],
            ["{{赤(0%-100%)}}", "赤(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "赤オフセット(-255〜255)"],
            ["{{緑(0%-100%)}}", "緑(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "緑オフセット(-255〜255)"],
            ["{{青(0%-100%)}}", "青(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "青オフセット(-255〜255)"],
            ["{{ブレンドモード}}", "ブレンドモード"],
            ["{{フィルターを選択}}", "フィルターを選択"],
            ["{{フィルターを追加}}", "フィルターを追加"],
            ["{{サウンドを追加}}", "サウンドを追加"],
            ["{{フィルターを表示・非表示する}}", "フィルターを表示・非表示する"],
            ["{{フィルターを削除}}", "フィルターを削除"],
            ["{{水平方向にぼかす}}", "水平方向にぼかす"],
            ["{{垂直方向にぼかす}}", "垂直方向にぼかす"],
            ["{{フィルター強度}}", "フィルター強度"],
            ["{{フィルター角度}}", "フィルター角度"],
            ["{{シャドウのアルファ}}", "シャドウのアルファ"],
            ["{{シャドウのカラー}}", "シャドウのカラー"],
            ["{{フィルター距離}}", "フィルター距離"],
            ["{{ハイライトのカラー}}", "ハイライトのカラー"],
            ["{{ハイライトのアルファ}}", "ハイライトのアルファ"],
            ["{{グラデーションカラー}}", "グラデーションカラー"],
            ["{{グラデーションのアルファ}}", "グラデーションのアルファ"],
            ["{{タブの移動・名前を変更}}", "タブの移動・名前を変更"],
            ["{{プロジェクトを閉じる}}", "プロジェクトを閉じる"],
            ["{{上下に移動}}", "上下に移動"],
            ["{{レイヤー変更(ダブルクリック)}}", "レイヤー変更(ダブルクリック)"],
            ["{{レイヤーをハイライト}}", "レイヤーをハイライト"],
            ["{{レイヤーを非表示}}", "レイヤーを非表示"],
            ["{{レイヤーをロック}}", "レイヤーをロック"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "カーブポインター(ダブルクリックでON/OFF)"],
            ["{{インスタンス名}}", "インスタンス名"],
            ["{{ライブラリ内の検索}}", "ライブラリ内の検索"],
            ["{{フレームラベル}}", "フレームラベル"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Korean extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{自由変形ツール}}", "자유 변형 도구"],
            ["{{キーフレームに変換}}", "키프레임으로 변환"],
            ["{{空のキーフレームに変換}}", "빈 키프레임으로 변환"],
            ["{{最初のフレームに移動}}", "첫 번째 프레임으로 이동"],
            ["{{最後のフレームに移動}}", "마지막 프레임으로 이동"],
            ["{{SWFを解析中}}", "SWF 분석 중"],
            ["{{JSONを生成}}", "JSON 생성"],
            ["{{ファイルを生成}}", "파일 생성"],
            ["{{N2Dファイルの読み込み}}", "N2D 파일 불러오기"],
            ["{{JSONの読み込み}}", "JSON 로드"],
            ["{{データを解凍中}}", "데이터 압축 해제 중"],
            ["{{データを圧縮中}}", "데이터 압축 중"],
            ["{{エンコード}}", "인코딩"],
            ["{{外部ファイルの読み込み}}", "외부 파일 로드"],
            ["{{バイナリデータを生成}}", "바이너리 데이터 생성"],
            ["{{データベースを起動}}", "데이터베이스 시작"],
            ["{{データを保存中}}", "데이터 저장 중"],
            ["{{完了}}", "완료"],
            ["{{ステージ左揃え}}", "스테이지 왼쪽 정렬"],
            ["{{ステージ中央揃え(水平方向)}}", "스테이지 중앙 정렬(수평 방향)"],
            ["{{ステージ右揃え}}", "스테이지 오른쪽 정렬"],
            ["{{ステージ上揃え}}", "무대에서 정렬"],
            ["{{ステージ中央揃え(垂直方向)}}", "스테이지 중앙 정렬(수직 방향)"],
            ["{{ステージ下揃え}}", "무대 아래 정렬"],
            ["{{定規}}", "눈금자"],
            ["{{表示}}", "표시"],
            ["{{ショートカット}}", "단축키"],
            ["{{レイヤーを複製}}", "중복 레이어"],
            ["{{未使用のフォルダを削除}}", "사용하지 않는 폴더 삭제"],
            ["{{同名のアイテムが存在します}}", "같은 이름의 항목이 존재합니다"],
            ["{{追加ファイル}}", "추가 파일"],
            ["{{既存のコンテンツ}}", "기존 콘텐츠"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "파일을 덮어쓰거나 이름을 변경하고 추가하거나 건너뛰도록 선택할 수 있습니다"],
            ["{{全て上書き}}", "모두 덮어쓰기"],
            ["{{全てスキップ}}", "모두 건너뛰기"],
            ["{{追加・上書き}}", "추가 또는 덮어쓰기"],
            ["{{スキップ}}", "건너뛰다"],
            ["{{表示確認したいフレームを指定}}", "표시 확인할 프레임 지정"],
            ["{{ファイル名を指定}}", "파일 이름 지정"],
            ["{{ファイル名}}", "파일 이름"],
            ["{{終了フレームを指定}}", "끝 프레임 지정"],
            ["{{開始フレームを指定}}", "시작 프레임 지정"],
            ["{{フレーム設定}}", "프레임 설정"],
            ["{{書き出し設定}}", "내보내기 설정"],
            ["{{ファイル形式の選択}}", "파일 형식 선택"],
            ["{{ファイル形式}}", "파일 형식"],
            ["{{サイズ設定}}", "사이즈 설정"],
            ["{{左上}}", "왼쪽 상단"],
            ["{{中央上}}", "상단 중앙"],
            ["{{右上}}", "오른쪽 상단"],
            ["{{中央左}}", "중앙 왼쪽"],
            ["{{中央}}", "센터"],
            ["{{中央右}}", "중앙 오른쪽"],
            ["{{左下}}", "왼쪽 하단"],
            ["{{中央下}}", "하단 중앙"],
            ["{{右下}}", "오른쪽 하단"],
            ["{{中心点のX座標}}", "중심점의 X 좌표"],
            ["{{中心点のY座標}}", "중심점의 Y 좌표"],
            ["{{MovieClipに変換}}", "MovieClip로 변환"],
            ["{{変換}}", "변환"],
            ["{{ループ回数}}", "루프 횟수"],
            ["{{カーブポインターの削除}}", "곡선 테이블의"],
            ["{{ステージ基準}}", "스테이지 기준"],
            ["{{閉じる}}", "닫다"],
            ["{{保存}}", "저장"],
            ["{{リセット}}", "리셋"],
            ["{{スクリーン}}", "스크린"],
            ["{{ショートカット設定}}", "바로 가기 설정"],
            ["{{レイヤーカラー}}", "레이어 색상"],
            ["{{Next2Dを支援する}}", "Next2D 지원"],
            ["{{サポート}}", "지원"],
            ["{{未使用のアイテムを削除}}", "사용하지 않는 항목 삭제"],
            ["{{レイヤーをペースト}}", "레이어 붙여넣기"],
            ["{{レイヤーをコピー}}", "레이어 복사"],
            ["{{フレームをペースト}}", "프레임을 붙여넣기"],
            ["{{フレームをコピー}}", "프레임 복사"],
            ["{{キーフレームを削除}}", "키프레임 삭제"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "키프레임에 빈 키프레임을 추가할 수 없음"],
            ["{{ズームツール}}", "줌 도구"],
            ["{{タイムライン幅の拡大・縮小}}", "타임라인 폭 확대·축소"],
            ["{{ガイドレイヤー}}", "가이드레이야"],
            ["{{音量設定}}", "볼륨 설정"],
            ["{{サウンドを削除}}", "사운드 삭제"],
            ["{{カスタムループ}}", "맞춤형 루프"],
            ["{{読込のみ}}", "로드 전용"],
            ["{{書込を許可}}", "쓰기 허용"],
            ["{{単一行}}", "단일 행"],
            ["{{複数行}}", "여러 줄"],
            ["{{自動で折り返し}}", "자동으로 되감기"],
            ["{{左寄せ}}", "왼쪽"],
            ["{{中央揃え}}", "센터"],
            ["{{右寄せ}}", "권리"],
            ["{{放射状グラデーション}}", "방사형 그라데이션"],
            ["{{線形グラデーション}}", "선형 그라데이션"],
            ["{{画像}}", "이미지"],
            ["{{画像選択}}", "이미지 선택"],
            ["{{種別}}", "종별"],
            ["{{Shapeの色設定}}", "Shape 색상 설정"],
            ["{{変形}}", "변형"],
            ["{{カラー効果}}", "색상 변환"],
            ["{{フィルター}}", "필터"],
            ["{{Shapeを複製}}", "Shape 복제"],
            ["{{読み込み}}", "로딩"],
            ["{{新規フォルダー}}", "새 폴더"],
            ["{{新規MovieClip}}", "새로운 MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "프레임에 맞게 텍스트를 크기 조정"],
            ["{{テキストに合わせて枠をリサイズ}}", "텍스트에 맞게 프레임을 크기 조정"],
            ["{{リサイズしない}}", "크기 조정하지 않음"],
            ["{{フォント}}", "글꼴"],
            ["{{テキスト}}", "텍스트"],
            ["{{ループ}}", "루프"],
            ["{{音量}}", "볼륨"],
            ["{{ビデオ}}", "동영상"],
            ["{{イージング}}", "부드럽게"],
            ["{{サウンド}}", "소리"],
            ["{{シンボル}}", "상징"],
            ["{{名前}}", "이름"],
            ["{{オブジェクト}}", "개체"],
            ["{{ステージ設定}}", "스테이지 설정"],
            ["{{プレビュー}}", "미리보기"],
            ["{{削除}}", "삭제"],
            ["{{ペースト}}", "붙여넣기"],
            ["{{コピー}}", "복사"],
            ["{{プラグインメニュー}}", "플러그인 메뉴"],
            ["{{トゥイーン}}", "트윈"],
            ["{{カーブポインターの追加}}", "커브 포인터 추가"],
            ["{{パスの結合}}", "경로 결합"],
            ["{{シェイプ}}", "모양"],
            ["{{キーフレームに配分}}", "키프레임에 할당"],
            ["{{レイヤーに配分}}", "레이어에 배포"],
            ["{{タイムライン}}", "타임라인"],
            ["{{整列}}", "맞추다"],
            ["{{最背面}}", "최후면"],
            ["{{ひとつ背面へ}}", "하나의 뒷면으로"],
            ["{{ひとつ前面へ}}", "하나 앞으로"],
            ["{{最前面}}", "최전면"],
            ["{{重ね順}}", "겹침 순서"],
            ["{{プラグイン}}", "플러그인"],
            ["{{ライブラリ}}", "도서관"],
            ["{{プロパティ}}", "속성"],
            ["{{マスクレイヤー}}", "마스크 레이어"],
            ["{{通常レイヤー}}", "일반 레이어"],
            ["{{モーショントゥイーンの削除}}", "모션 트윈 삭제"],
            ["{{モーショントゥイーンの追加}}", "모션 트윈 추가"],
            ["{{モーダル表示}}", "모달 표시"],
            ["{{言語}}", "언어"],
            ["{{フォーマット}}", "형식"],
            ["{{含める}}", "포함"],
            ["{{含めない}}", "포함하지 않음"],
            ["{{使い方、リファレンス}}", "사용법, 참조"],
            ["{{非表示レイヤー}}", "숨겨진 레이어"],
            ["{{設定}}", "설정"],
            ["{{デフォルトのループを利用する}}", "기본 루프 사용"],
            ["{{フレームピッカー}}", "프레임 선택기"],
            ["{{左揃え}}", "왼쪽 정렬"],
            ["{{中央揃え(水平方向)}}", "중앙 정렬(수평 방향)"],
            ["{{右揃え}}", "오른쪽 정렬"],
            ["{{上揃え}}", "상단 정렬"],
            ["{{中央揃え(垂直方向)}}", "중앙 정렬(수직 방향)"],
            ["{{下揃え}}", "아래 정렬"],
            ["{{開始フレーム}}", "시작 프레임"],
            ["{{終了フレーム}}", "종료 프레임"],
            ["{{ループで再生}}", "루프로 재생"],
            ["{{1回再生}}", "한 번 재생"],
            ["{{指定したフレームで固定}}", "지정된 프레임으로 고정"],
            ["{{1回逆再生}}", "1회 역재생"],
            ["{{逆ループで再生}}", "역 루프로 재생"],
            ["{{画面の拡大・縮小}}", "화면 확대/축소"],
            ["{{カスタムイージングデータを保存}}", "맞춤형 여유 데이터 저장"],
            ["{{カスタムイージングデータの読込}}", "사용자 정의 여유 데이터 읽기"],
            ["{{プレビューのON/OFF}}", "프레뷰의 ON/OFF"],
            ["{{フォント枠サイズ}}", "글꼴 프레임 크기"],
            ["{{フォント枠カラー}}", "글꼴 프레임 색상"],
            ["{{オニオンスキン}}", "양파 껍질"],
            ["{{バケツツール}}", "버킷 도구"],
            ["{{ペンツール}}", "펜 도구"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "곡선 점을 추가하려면 두 번 클릭"],
            ["{{選択ツール}}", "선택 도구"],
            ["{{Shape変形ツール}}", "모양 변형 도구"],
            ["{{テキストツール}}", "텍스트 도구"],
            ["{{矩形ツール}}", "너무 직사각형"],
            ["{{楕円ツール}}", "타원 도구"],
            ["{{角丸矩形ツール}}", "둥근 사각형 도구"],
            ["{{塗りのカラー}}", "채우기 색상"],
            ["{{線のカラー}}", "획 색상"],
            ["{{線の太さ}}", "획 폭"],
            ["{{プロジェクトデータの読込}}", "프로젝트 데이터 로드"],
            ["{{プロジェクトデータを保存}}", "프로젝트 데이터 저장"],
            ["{{書き出し}}", "내 보내다"],
            ["{{Discordへ移動}}", "불화로 이동"],
            ["{{バグ報告}}", "버그 보고서"],
            ["{{設定}}", "환경"],
            ["{{タブを追加}}", "탭 추가"],
            ["{{タブの一覧を表示・移動}}", "탭 목록 보기 및 이동"],
            ["{{スクリプトを追加}}", "스크립트 추가"],
            ["{{キーフレームを追加}}", "키프레임 추가"],
            ["{{空のキーフレームを追加}}", "빈 키프레임 추가"],
            ["{{フレームを追加}}", "프레임 추가"],
            ["{{フレームを削除}}", "프레임 삭제"],
            ["{{再生}}", "놀다"],
            ["{{停止}}", "중지"],
            ["{{ループ設定}}", "루프 설정"],
            ["{{レイヤーを追加}}", "레이어 추가"],
            ["{{レイヤーを削除}}", "레이어 삭제"],
            ["{{全てのレイヤーをハイライト}}", "모든 레이어 강조 표시"],
            ["{{全てのレイヤーを非表示}}", "모든 레이어 숨기기"],
            ["{{全てのレイヤーをロック}}", "모든 레이어 잠금"],
            ["{{比率を固定}}", "고정 비율"],
            ["{{ステージの幅}}", "무대 폭"],
            ["{{背景色}}", "배경색"],
            ["{{ステージの高さ}}", "무대 높이"],
            ["{{フレームレート}}", "프레임 속도"],
            ["{{シンボル名}}", "기호 이름"],
            ["{{イージング設定}}", "이징 설정"],
            ["{{ビデオの音量設定}}", "비디오 볼륨 설정"],
            ["{{自動再生}}", "자동 재생"],
            ["{{テキストエリアのボーダー設定}}", "텍스트 영역 테두리 설정"],
            ["{{テキスト入力設定}}", "텍스트 입력 설정"],
            ["{{フォント選択}}", "글꼴 선택"],
            ["{{自動サイズ調整}}", "자동 크기 조정"],
            ["{{フォントスタイルタイプ}}", "글꼴 스타일 유형"],
            ["{{行揃え}}", "맞추다"],
            ["{{改行設定}}", "개행 설정"],
            ["{{スクロール設定}}", "스크롤 설정"],
            ["{{フォントサイズ}}", "글꼴 크기"],
            ["{{フォントカラー}}", "글꼴 색상"],
            ["{{行間}}", "줄 간격"],
            ["{{文字幅}}", "문자 너비"],
            ["{{左マージン}}", "왼쪽 여백"],
            ["{{右マージン}}", "오른쪽 여백"],
            ["{{カラー種別の選択}}", "색상 유형 선택"],
            ["{{背景画像の選択}}", "배경 이미지 선택"],
            ["{{カラーポインターを追加}}", "색상 포인터 추가"],
            ["{{カラー値}}", "색상"],
            ["{{アルファ(0%-100%)}}", "알파(0%-100%)"],
            ["{{アルファ値}}", "알파"],
            ["{{選択対象の幅}}", "선택 개체의 너비"],
            ["{{選択対象のX座標}}", "선택 객체의 X 좌표"],
            ["{{選択対象の高さ}}", "선택 개체의 높이"],
            ["{{選択対象のY座標}}", "선택 객체의 Y 좌표"],
            ["{{選択対象の幅の伸縮}}", "선택한 객체의 scaleX"],
            ["{{選択対象を回転}}", "개체 회전"],
            ["{{選択対象の高さの伸縮}}", "선택한 객체의 scaleY"],
            ["{{アルファオフセット(-255〜255)}}", "알파 오프셋(-255〜255)"],
            ["{{赤(0%-100%)}}", "빨간색(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "레드 오프셋(-255〜255)"],
            ["{{緑(0%-100%)}}", "녹색(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "그린 오프셋(-255〜255)"],
            ["{{青(0%-100%)}}", "파란색(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "블루 오프셋(-255〜255)"],
            ["{{ブレンドモード}}", "혼합 모드"],
            ["{{フィルターを選択}}", "필터 선택"],
            ["{{フィルターを追加}}", "필터 추가"],
            ["{{サウンドを追加}}", "소리 추가"],
            ["{{フィルターを表示・非表示する}}", "필터 표시 및 숨기기"],
            ["{{フィルターを削除}}", "필터 삭제"],
            ["{{水平方向にぼかす}}", "수평으로 흐림"],
            ["{{垂直方向にぼかす}}", "수직으로 흐림"],
            ["{{フィルター強度}}", "필터 강도"],
            ["{{フィルター角度}}", "필터 각도"],
            ["{{シャドウのアルファ}}", "섀도우 알파"],
            ["{{シャドウのカラー}}", "그림자 색상"],
            ["{{フィルター距離}}", "필터 거리"],
            ["{{ハイライトのカラー}}", "하이라이트 색상"],
            ["{{ハイライトのアルファ}}", "하이라이트 알파"],
            ["{{グラデーションカラー}}", "그라데이션 색상"],
            ["{{グラデーションのアルファ}}", "그라디언트 알파"],
            ["{{タブの移動・名前を変更}}", "탭 이동/이름 바꾸기"],
            ["{{プロジェクトを閉じる}}", "프로젝트 닫기"],
            ["{{上下に移動}}", "위아래로 이동"],
            ["{{レイヤー変更(ダブルクリック)}}", "레이어 변경(더블 클릭)"],
            ["{{レイヤーをハイライト}}", "하이라이트 레이어"],
            ["{{レイヤーを非表示}}", "레이어 숨기기"],
            ["{{レイヤーをロック}}", "레이어 잠금"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "곡선 포인터(켜기/끄려면 두 번 클릭)"],
            ["{{インスタンス名}}", "인스턴스 이름"],
            ["{{ライブラリ内の検索}}", "도서관에서 검색"],
            ["{{フレームラベル}}", "프레임 라벨"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "프로젝트를 저장하지 않으면 이 탭의 프로젝트 데이터를 복구할 수 없습니다. 탭을 삭제하시겠습니까?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Russia extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{自由変形ツール}}", "Бесплатный инструмент трансформации"],
            ["{{キーフレームに変換}}", "Преобразование в ключевые кадры"],
            ["{{空のキーフレームに変換}}", "Преобразование в пустые ключевые кадры"],
            ["{{最初のフレームに移動}}", "Переход к первому кадру"],
            ["{{最後のフレームに移動}}", "Переход к последнему кадру"],
            ["{{SWFを解析中}}", "Анализируемые SWF"],
            ["{{JSONを生成}}", "Сгенерировать JSON"],
            ["{{ファイルを生成}}", "Создать файл"],
            ["{{N2Dファイルの読み込み}}", "Загрузка файлов N2D"],
            ["{{JSONの読み込み}}", "Загрузка JSON"],
            ["{{データを解凍中}}", "Декомпрессия данных"],
            ["{{データを圧縮中}}", "Сжатие данных"],
            ["{{エンコード}}", "Кодирование"],
            ["{{外部ファイルの読み込み}}", "Чтение внешних файлов"],
            ["{{バイナリデータを生成}}", "Генерация двоичных данных"],
            ["{{データベースを起動}}", "Запуск базы данных"],
            ["{{データを保存中}}", "Хранение данных в процессе работы"],
            ["{{完了}}", "Завершено"],
            ["{{ステージ左揃え}}", "Выровнять сцену слева"],
            ["{{ステージ中央揃え(水平方向)}}", "Выровняйте центр сцены (горизонтально)"],
            ["{{ステージ右揃え}}", "Выровнять сцену вправо"],
            ["{{ステージ上揃え}}", "Выровнять сцену вверх"],
            ["{{ステージ中央揃え(垂直方向)}}", "Выровняйте центр сцены (вертикально)"],
            ["{{ステージ下揃え}}", "Выровнять дно сцены"],
            ["{{定規}}", "Линейка"],
            ["{{表示}}", "Дисплей"],
            ["{{ショートカット}}", "ярлык"],
            ["{{レイヤーを複製}}", "Дублирование слоя"],
            ["{{未使用のフォルダを削除}}", "Удалите неиспользуемые папки"],
            ["{{同名のアイテムが存在します}}", "Существуют предметы с таким же названием"],
            ["{{追加ファイル}}", "Дополнительный файл"],
            ["{{既存のコンテンツ}}", "Существующее содержание"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "Вы можете выбрать перезапись, переименование и добавление файлов или пропуск"],
            ["{{全て上書き}}", "Переписать все"],
            ["{{全てスキップ}}", "Пропустить все"],
            ["{{追加・上書き}}", "Добавить или перезаписать"],
            ["{{スキップ}}", "Пропустить"],
            ["{{表示確認したいフレームを指定}}", "Укажите кадр, отображение которого вы хотите проверить"],
            ["{{ファイル名を指定}}", "Укажите имя файла"],
            ["{{ファイル名}}", "имя файла"],
            ["{{終了フレームを指定}}", "Укажите конечную рамку"],
            ["{{開始フレームを指定}}", "Укажите начальный кадр"],
            ["{{フレーム設定}}", "Установка рамы"],
            ["{{書き出し設定}}", "Настройки экспорта"],
            ["{{ファイル形式の選択}}", "Выберите формат файла"],
            ["{{ファイル形式}}", "Форматы файлов"],
            ["{{サイズ設定}}", "Установка размера"],
            ["{{左上}}", "Вверху слева"],
            ["{{中央上}}", "Вверху по центру"],
            ["{{右上}}", "Верхний правый"],
            ["{{中央左}}", "Центр Левый"],
            ["{{中央}}", "Центр"],
            ["{{中央右}}", "Центр Правый"],
            ["{{左下}}", "Низ Левый"],
            ["{{中央下}}", "Нижняя часть Центр"],
            ["{{右下}}", "Дно справа"],
            ["{{中心点のX座標}}", "X-координата центральной точки"],
            ["{{中心点のY座標}}", "Y-координата центральной точки"],
            ["{{MovieClipに変換}}", "Конвертировать в MovieClip"],
            ["{{変換}}", "трансформация"],
            ["{{ループ回数}}", "Количество циклов"],
            ["{{カーブポインターの削除}}", "Удалить указатель кривой"],
            ["{{ステージ基準}}", "Критерии этапа"],
            ["{{閉じる}}", "Закрыть"],
            ["{{保存}}", "Сохранить"],
            ["{{リセット}}", "сброс"],
            ["{{スクリーン}}", "Экран"],
            ["{{ショートカット設定}}", "Настройки ярлыков"],
            ["{{レイヤーカラー}}", "слоистый цвет"],
            ["{{Next2Dを支援する}}", "Поддержите Next2D"],
            ["{{サポート}}", "поддержка"],
            ["{{未使用のアイテムを削除}}", "Удалите неиспользуемые предметы"],
            ["{{レイヤーをペースト}}", "Слой пасты"],
            ["{{レイヤーをコピー}}", "Копирование слоя"],
            ["{{フレームをペースト}}", "Вставить рамку"],
            ["{{フレームをコピー}}", "Копировальная рама"],
            ["{{キーフレームを削除}}", "Удалить ключевые кадры"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "Невозможно добавить пустые ключевые кадры в ключевые кадры"],
            ["{{ズームツール}}", "Инструмент масштабирования"],
            ["{{タイムライン幅の拡大・縮小}}", "Ширина временной шкалы Расширение/сокращение"],
            ["{{ガイドレイヤー}}", "направляющий слой"],
            ["{{音量設定}}", "Настройка громкости"],
            ["{{サウンドを削除}}", "Удалить звук"],
            ["{{カスタムループ}}", "индивидуальная петля"],
            ["{{読込のみ}}", "Только чтение"],
            ["{{書込を許可}}", "разрешение на публикацию"],
            ["{{単一行}}", "Одиночная линия"],
            ["{{複数行}}", "Многолинейный"],
            ["{{自動で折り返し}}", "Автоматический обхват"],
            ["{{左寄せ}}", "Слева"],
            ["{{中央揃え}}", "Центр"],
            ["{{右寄せ}}", "Правый"],
            ["{{放射状グラデーション}}", "радиальная градация"],
            ["{{線形グラデーション}}", "линейный градиент"],
            ["{{画像}}", "Изображение"],
            ["{{画像選択}}", "Выбор изображения"],
            ["{{種別}}", "Тип"],
            ["{{Shapeの色設定}}", "Настройки цвета формы"],
            ["{{変形}}", "деформация"],
            ["{{カラー効果}}", "Трансформация цвета"],
            ["{{フィルター}}", "фильтр"],
            ["{{Shapeを複製}}", "Дублировать форму"],
            ["{{読み込み}}", "читать в"],
            ["{{新規フォルダー}}", "Новая папка"],
            ["{{新規MovieClip}}", "Новый MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "Измените размер текста, чтобы он поместился в рамку"],
            ["{{テキストに合わせて枠をリサイズ}}", "Измените размер рамки, чтобы вместить текст"],
            ["{{リサイズしない}}", "Отсутствие изменения размера"],
            ["{{フォント}}", "шрифт"],
            ["{{テキスト}}", "Текст"],
            ["{{ループ}}", "петля"],
            ["{{音量}}", "громкость"],
            ["{{ビデオ}}", "Видео"],
            ["{{イージング}}", "облегчение"],
            ["{{サウンド}}", "звук"],
            ["{{シンボル}}", "Символ"],
            ["{{名前}}", "Имя"],
            ["{{オブジェクト}}", "объект"],
            ["{{ステージ設定}}", "Постановка сцены"],
            ["{{プレビュー}}", "Предварительный просмотр"],
            ["{{削除}}", "Удалить"],
            ["{{ペースト}}", "Паста"],
            ["{{コピー}}", "Копировать"],
            ["{{プラグインメニュー}}", "Меню подключаемых модулей"],
            ["{{トゥイーン}}", "между"],
            ["{{カーブポインターの追加}}", "Дополнительный указатель кривой"],
            ["{{パスの結合}}", "Объединение путей"],
            ["{{シェイプ}}", "форма"],
            ["{{キーフレームに配分}}", "Распределение по ключевым кадрам"],
            ["{{レイヤーに配分}}", "Распределение по слоям"],
            ["{{タイムライン}}", "временная шкала"],
            ["{{整列}}", "Выровнять"],
            ["{{最背面}}", "Большая часть спины"],
            ["{{ひとつ背面へ}}", "Один в задней части"],
            ["{{ひとつ前面へ}}", "Один фронт"],
            ["{{最前面}}", "На переднем крае"],
            ["{{重ね順}}", "Организуйте"],
            ["{{プラグイン}}", "плагин"],
            ["{{ライブラリ}}", "библиотека"],
            ["{{プロパティ}}", "собственность"],
            ["{{マスクレイヤー}}", "слой маски"],
            ["{{通常レイヤー}}", "Нормальный слой"],
            ["{{モーショントゥイーンの削除}}", "Удаление твинов движения"],
            ["{{モーショントゥイーンの追加}}", "Дополнительные твины движения"],
            ["{{モーダル表示}}", "модальная индикация"],
            ["{{言語}}", "Язык"],
            ["{{フォーマット}}", "формат"],
            ["{{含める}}", "включать"],
            ["{{含めない}}", "не включать"],
            ["{{使い方、リファレンス}}", "Использование, ссылка"],
            ["{{非表示レイヤー}}", "скрытый слой"],
            ["{{設定}}", "настройка"],
            ["{{デフォルトのループを利用する}}", "Используйте цикл по умолчанию"],
            ["{{フレームピッカー}}", "подборщик рам"],
            ["{{左揃え}}", "Слева"],
            ["{{中央揃え(水平方向)}}", "Центр (горизонтальность)"],
            ["{{右揃え}}", "Справа"],
            ["{{上揃え}}", "Топ"],
            ["{{中央揃え(垂直方向)}}", "Центр (вертикальный)"],
            ["{{下揃え}}", "Дно"],
            ["{{開始フレーム}}", "начальная рамка"],
            ["{{終了フレーム}}", "торцевая рама"],
            ["{{ループで再生}}", "Воспроизведение по кругу"],
            ["{{1回再生}}", "1 воспроизведение"],
            ["{{指定したフレームで固定}}", "Фиксируется в указанном кадре"],
            ["{{1回逆再生}}", "1 воспроизведение в обратном направлении"],
            ["{{逆ループで再生}}", "Воспроизведение в обратном цикле"],
            ["{{画面の拡大・縮小}}", "Увеличение и уменьшение масштаба экрана"],
            ["{{カスタムイージングデータを保存}}", "Сохраните данные пользовательского смягчения"],
            ["{{カスタムイージングデータの読込}}", "Чтение пользовательских данных о смягчении"],
            ["{{プレビューのON/OFF}}", "Включение/выключение предварительного просмотра"],
            ["{{フォント枠サイズ}}", "Размер рамки шрифта"],
            ["{{フォント枠カラー}}", "Цвет шрифтовой рамки"],
            ["{{オニオンスキン}}", "Луковая шкурка"],
            ["{{バケツツール}}", "Ведерные инструменты"],
            ["{{ペンツール}}", "Инструмент \"Перо"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Дважды щелкните, чтобы добавить точку кривой"],
            ["{{選択ツール}}", "Инструменты выбора"],
            ["{{Shape変形ツール}}", "Инструмент преобразования формы"],
            ["{{テキストツール}}", "Текстовый инструмент"],
            ["{{矩形ツール}}", "Инструмент \"Прямоугольник"],
            ["{{楕円ツール}}", "Инструмент \"Эллипс"],
            ["{{角丸矩形ツール}}", "Инструмент \"Скругленный прямоугольник"],
            ["{{塗りのカラー}}", "Цвет заливки"],
            ["{{線のカラー}}", "Цвет штриха"],
            ["{{線の太さ}}", "Ширина штриха"],
            ["{{プロジェクトデータの読込}}", "Загрузка данных проекта"],
            ["{{プロジェクトデータを保存}}", "Сохранить данные проекта"],
            ["{{書き出し}}", "Экспорт"],
            ["{{Discordへ移動}}", "Зайдите в дискорд"],
            ["{{バグ報告}}", "Сообщения об ошибках"],
            ["{{設定}}", "Настройка"],
            ["{{タブを追加}}", "Добавить вкладку"],
            ["{{タブの一覧を表示・移動}}", "Просмотр и перемещение по списку вкладок"],
            ["{{スクリプトを追加}}", "Добавить сценарий"],
            ["{{キーフレームを追加}}", "Добавить ключевой кадр"],
            ["{{空のキーフレームを追加}}", "Добавьте пустой ключевой кадр"],
            ["{{フレームを追加}}", "Добавить рамку"],
            ["{{フレームを削除}}", "Удалить рамку"],
            ["{{再生}}", "Играть"],
            ["{{停止}}", "Остановить"],
            ["{{ループ設定}}", "Настройка контура"],
            ["{{レイヤーを追加}}", "Добавить слой"],
            ["{{レイヤーを削除}}", "Удалить слой"],
            ["{{全てのレイヤーをハイライト}}", "Выделите все слои"],
            ["{{全てのレイヤーを非表示}}", "Скрыть все слои"],
            ["{{全てのレイヤーをロック}}", "Заблокируйте все слои"],
            ["{{比率を固定}}", "Фиксированный коэффициент"],
            ["{{ステージの幅}}", "Ширина сцены"],
            ["{{背景色}}", "Цвет фона"],
            ["{{ステージの高さ}}", "Высота сцены"],
            ["{{フレームレート}}", "Частота кадров"],
            ["{{シンボル名}}", "Название символа"],
            ["{{イージング設定}}", "Установка облегчения"],
            ["{{ビデオの音量設定}}", "Настройка громкости видео"],
            ["{{自動再生}}", "Автоматическое воспроизведение"],
            ["{{テキストエリアのボーダー設定}}", "Настройка границ текстовой области"],
            ["{{テキスト入力設定}}", "Настройка ввода текста"],
            ["{{フォント選択}}", "Выбор шрифта"],
            ["{{自動サイズ調整}}", "Автоматическая регулировка размера"],
            ["{{フォントスタイルタイプ}}", "Тип стиля шрифта"],
            ["{{行揃え}}", "Выровнять"],
            ["{{改行設定}}", "Установка новой строки"],
            ["{{スクロール設定}}", "Настройка прокрутки"],
            ["{{フォントサイズ}}", "Размер шрифта"],
            ["{{フォントカラー}}", "Цвет шрифта"],
            ["{{行間}}", "Пространство линии"],
            ["{{文字幅}}", "Ширина символа"],
            ["{{左マージン}}", "Левое поле"],
            ["{{右マージン}}", "Правая граница"],
            ["{{カラー種別の選択}}", "Выберите тип цвета"],
            ["{{背景画像の選択}}", "Выбор фонового изображения"],
            ["{{カラーポインターを追加}}", "Добавьте указатели цвета"],
            ["{{カラー値}}", "Цвет"],
            ["{{アルファ(0%-100%)}}", "Альфа(0%-100%)"],
            ["{{アルファ値}}", "Альфа"],
            ["{{選択対象の幅}}", "Ширина объекта выделения"],
            ["{{選択対象のX座標}}", "X координата объекта выделения"],
            ["{{選択対象の高さ}}", "Высота объекта выделения"],
            ["{{選択対象のY座標}}", "Y координата объекта выделения"],
            ["{{選択対象の幅の伸縮}}", "масштабX выбранного объекта"],
            ["{{選択対象を回転}}", "Повернуть объект"],
            ["{{選択対象の高さの伸縮}}", "scaleY выбранного объекта"],
            ["{{アルファオフセット(-255〜255)}}", "Альфа-смещение(-255〜255)"],
            ["{{赤(0%-100%)}}", "Красный(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Красное смещение(-255〜255)"],
            ["{{緑(0%-100%)}}", "Зеленый(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Зеленый зачет(-255〜255)"],
            ["{{青(0%-100%)}}", "Голубой(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Синее смещение(-255〜255)"],
            ["{{ブレンドモード}}", "Режим наложения"],
            ["{{フィルターを選択}}", "Выберите фильтр"],
            ["{{フィルターを追加}}", "Добавить фильтр"],
            ["{{サウンドを追加}}", "Добавить звук"],
            ["{{フィルターを表示・非表示する}}", "Показать и скрыть фильтры"],
            ["{{フィルターを削除}}", "Удалить фильтр"],
            ["{{水平方向にぼかす}}", "Размытие по горизонтали"],
            ["{{垂直方向にぼかす}}", "Размытие по вертикали"],
            ["{{フィルター強度}}", "Прочность фильтра"],
            ["{{フィルター角度}}", "Угол фильтрации"],
            ["{{シャドウのアルファ}}", "Тень Альфа"],
            ["{{シャドウのカラー}}", "Цвет теней"],
            ["{{フィルター距離}}", "Расстояние между фильтрами"],
            ["{{ハイライトのカラー}}", "Цвет подсветки"],
            ["{{ハイライトのアルファ}}", "Выделение Альфа"],
            ["{{グラデーションカラー}}", "Цвет градиента"],
            ["{{グラデーションのアルファ}}", "Градиент Альфа"],
            ["{{タブの移動・名前を変更}}", "Переместить/именовать вкладки"],
            ["{{プロジェクトを閉じる}}", "Закрыть проект"],
            ["{{上下に移動}}", "Двигайтесь вверх и вниз"],
            ["{{レイヤー変更(ダブルクリック)}}", "Смена слоя (двойной щелчок)"],
            ["{{レイヤーをハイライト}}", "Выделительный слой"],
            ["{{レイヤーを非表示}}", "Скрыть слой"],
            ["{{レイヤーをロック}}", "Заблокировать слой"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Указатель кривой (двойной щелчок для включения/выключения)"],
            ["{{インスタンス名}}", "Имя экземпляра"],
            ["{{ライブラリ内の検索}}", "Поиск в библиотеке"],
            ["{{フレームラベル}}", "Рамочная этикетка"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "Если проект не сохранен, данные проекта на этой вкладке не могут быть восстановлены. Вы хотите удалить вкладку?"]
        ]);
    }
}

/**
 * @class
 * @extends Language
 */
class Spanish extends Language
{
    /**
     * @return {Map}
     * @method
     * @public
     */
    createMapping ()
    {
        return new Map([
            ["{{自由変形ツール}}", "Herramienta de transformación gratuita"],
            ["{{キーフレームに変換}}", "Convertir en fotogramas clave"],
            ["{{空のキーフレームに変換}}", "Convertir en fotogramas clave vacíos"],
            ["{{最初のフレームに移動}}", "Ir al primer cuadro"],
            ["{{最後のフレームに移動}}", "Ir al último cuadro"],
            ["{{SWFを解析中}}", "SWF que se está analizando"],
            ["{{JSONを生成}}", "Generar JSON"],
            ["{{ファイルを生成}}", "Generar archivo"],
            ["{{N2Dファイルの読み込み}}", "Carga de archivos N2D"],
            ["{{JSONの読み込み}}", "Carga de JSON"],
            ["{{データを解凍中}}", "Descompresión de datos"],
            ["{{データを圧縮中}}", "Compresión de datos"],
            ["{{エンコード}}", "Codificación"],
            ["{{外部ファイルの読み込み}}", "Lectura de archivos externos"],
            ["{{バイナリデータを生成}}", "Generación de datos binarios"],
            ["{{データベースを起動}}", "Iniciar la base de datos"],
            ["{{データを保存中}}", "Almacenamiento de datos en curso"],
            ["{{完了}}", "Completado"],
            ["{{ステージ左揃え}}", "Alinear el escenario a la izquierda"],
            ["{{ステージ中央揃え(水平方向)}}", "Alinear el centro del escenario (horizontal)"],
            ["{{ステージ右揃え}}", "Alinear el escenario a la derecha"],
            ["{{ステージ上揃え}}", "Alinear el escenario hacia arriba"],
            ["{{ステージ中央揃え(垂直方向)}}", "Alinear el centro del escenario (vertical)"],
            ["{{ステージ下揃え}}", "Alinear el fondo del escenario"],
            ["{{定規}}", "Regla"],
            ["{{表示}}", "Mostrar"],
            ["{{ショートカット}}", "acceso directo"],
            ["{{レイヤーを複製}}", "Duplicar capa"],
            ["{{未使用のフォルダを削除}}", "Eliminar las carpetas no utilizadas"],
            ["{{同名のアイテムが存在します}}", "Existen artículos con el mismo nombre"],
            ["{{追加ファイル}}", "Archivo adicional"],
            ["{{既存のコンテンツ}}", "Contenido existente"],
            ["{{上書きするか、ファイル名を変更して追加するか、スキップを選択する事ができます}}", "Puede elegir entre sobrescribir, renombrar y añadir archivos, u omitir"],
            ["{{全て上書き}}", "Sobrescribir todo"],
            ["{{全てスキップ}}", "Omitir todo"],
            ["{{追加・上書き}}", "Añadir o sobrescribir"],
            ["{{スキップ}}", "Omitir"],
            ["{{表示確認したいフレームを指定}}", "Especifique el marco del que desea comprobar la visualización"],
            ["{{ファイル名を指定}}", "Especifique el nombre del archivo"],
            ["{{ファイル名}}", "nombre del archivo"],
            ["{{終了フレームを指定}}", "Especifique el marco final"],
            ["{{開始フレームを指定}}", "Especifique el marco de inicio"],
            ["{{フレーム設定}}", "Ajuste del marco"],
            ["{{書き出し設定}}", "Configuración de la exportación"],
            ["{{ファイル形式の選択}}", "Seleccione el formato de archivo"],
            ["{{ファイル形式}}", "Formatos de archivo"],
            ["{{サイズ設定}}", "Ajuste del tamaño"],
            ["{{左上}}", "Arriba a la izquierda"],
            ["{{中央上}}", "Centro superior"],
            ["{{右上}}", "Arriba Derecha"],
            ["{{中央左}}", "Centro Izquierda"],
            ["{{中央}}", "Centro"],
            ["{{中央右}}", "Centro derecha"],
            ["{{左下}}", "Abajo a la izquierda"],
            ["{{中央下}}", "Abajo Centro"],
            ["{{右下}}", "Abajo a la derecha"],
            ["{{中心点のX座標}}", "Coordenada X del punto central"],
            ["{{中心点のY座標}}", "Coordenada Y del punto central"],
            ["{{MovieClipに変換}}", "Convertir a MovieClip"],
            ["{{変換}}", "transformación"],
            ["{{ループ回数}}", "Recuento de bucles"],
            ["{{カーブポインターの削除}}", "Borrar el puntero de la curva"],
            ["{{ステージ基準}}", "Criterios de la etapa"],
            ["{{閉じる}}", "Cerrar"],
            ["{{保存}}", "Guardar"],
            ["{{リセット}}", "restablecer"],
            ["{{スクリーン}}", "Pantalla"],
            ["{{ショートカット設定}}", "Configuración de los accesos directos"],
            ["{{レイヤーカラー}}", "color en capas"],
            ["{{Next2Dを支援する}}", "Apoya a Next2D"],
            ["{{サポート}}", "soporte"],
            ["{{未使用のアイテムを削除}}", "Eliminar los elementos no utilizados"],
            ["{{レイヤーをペースト}}", "Capa de pasta"],
            ["{{レイヤーをコピー}}", "Copiar capa"],
            ["{{フレームをペースト}}", "Pegar el marco"],
            ["{{フレームをコピー}}", "Copiar marco"],
            ["{{キーフレームを削除}}", "Eliminar fotogramas clave"],
            ["{{キーフレームに空のキーフレームを追加できません}}", "No se pueden añadir fotogramas clave vacíos a los fotogramas clave"],
            ["{{ズームツール}}", "Herramienta de zoom"],
            ["{{タイムライン幅の拡大・縮小}}", "Anchura de la línea de tiempo Ampliar/reducir"],
            ["{{ガイドレイヤー}}", "capa de guía"],
            ["{{音量設定}}", "Ajuste del volumen"],
            ["{{サウンドを削除}}", "Eliminar el sonido"],
            ["{{カスタムループ}}", "bucle personalizado"],
            ["{{読込のみ}}", "Sólo para leer"],
            ["{{書込を許可}}", "permiso de correos"],
            ["{{単一行}}", "Línea única"],
            ["{{複数行}}", "Multilínea"],
            ["{{自動で折り返し}}", "Envoltura automática"],
            ["{{左寄せ}}", "Izquierda"],
            ["{{中央揃え}}", "Centro"],
            ["{{右寄せ}}", "Derecha"],
            ["{{放射状グラデーション}}", "gradación radial"],
            ["{{線形グラデーション}}", "gradiente lineal"],
            ["{{画像}}", "Imagen"],
            ["{{画像選択}}", "Selección de imágenes"],
            ["{{種別}}", "Tipo"],
            ["{{Shapeの色設定}}", "Configuración del color de la forma"],
            ["{{変形}}", "deformación"],
            ["{{カラー効果}}", "Transformación del color"],
            ["{{フィルター}}", "filtro"],
            ["{{Shapeを複製}}", "Duplicar la forma"],
            ["{{読み込み}}", "leer en"],
            ["{{新規フォルダー}}", "Carpeta nueva"],
            ["{{新規MovieClip}}", "Nuevo MovieClip"],
            ["{{枠に合わせてテキストをリサイズ}}", "Cambia el tamaño del texto para que se ajuste al marco"],
            ["{{テキストに合わせて枠をリサイズ}}", "Cambia el tamaño del marco para que se ajuste al texto"],
            ["{{リサイズしない}}", "No hay cambio de tamaño"],
            ["{{フォント}}", "fuente"],
            ["{{テキスト}}", "Texto"],
            ["{{ループ}}", "bucle"],
            ["{{音量}}", "volumen"],
            ["{{ビデオ}}", "Vídeo"],
            ["{{イージング}}", "facilitando"],
            ["{{サウンド}}", "sonido"],
            ["{{シンボル}}", "Símbolo"],
            ["{{名前}}", "Nombre"],
            ["{{オブジェクト}}", "objeto"],
            ["{{ステージ設定}}", "Puesta en escena"],
            ["{{プレビュー}}", "Previsualización"],
            ["{{削除}}", "Borrar"],
            ["{{ペースト}}", "Pegar"],
            ["{{コピー}}", "Copiar"],
            ["{{プラグインメニュー}}", "Menú de complementos"],
            ["{{トゥイーン}}", "tween"],
            ["{{カーブポインターの追加}}", "Puntero de curva adicional"],
            ["{{パスの結合}}", "Fusión de caminos"],
            ["{{シェイプ}}", "forma"],
            ["{{キーフレームに配分}}", "Asignación a los fotogramas clave"],
            ["{{レイヤーに配分}}", "Asignación a las capas"],
            ["{{タイムライン}}", "línea de tiempo"],
            ["{{整列}}", "Alinear"],
            ["{{最背面}}", "La mayor parte de la espalda"],
            ["{{ひとつ背面へ}}", "Uno en la parte trasera"],
            ["{{ひとつ前面へ}}", "Un frente"],
            ["{{最前面}}", "Frontmost"],
            ["{{重ね順}}", "Organice"],
            ["{{プラグイン}}", "plug-in"],
            ["{{ライブラリ}}", "biblioteca"],
            ["{{プロパティ}}", "propiedad"],
            ["{{マスクレイヤー}}", "capa de máscara"],
            ["{{通常レイヤー}}", "Capa normal"],
            ["{{モーショントゥイーンの削除}}", "Supresión de los tweens de movimiento"],
            ["{{モーショントゥイーンの追加}}", "Tweens de movimiento adicionales"],
            ["{{モーダル表示}}", "indicación modal"],
            ["{{言語}}", "El idioma"],
            ["{{フォーマット}}", "formato"],
            ["{{含める}}", "incluir"],
            ["{{含めない}}", "no incluir"],
            ["{{使い方、リファレンス}}", "Uso, referencia"],
            ["{{非表示レイヤー}}", "capa oculta"],
            ["{{設定}}", "configuración"],
            ["{{デフォルトのループを利用する}}", "Utiliza el bucle por defecto"],
            ["{{フレームピッカー}}", "Recogedor de marcos"],
            ["{{左揃え}}", "Izquierda"],
            ["{{中央揃え(水平方向)}}", "Centro (Horizontal)"],
            ["{{右揃え}}", "Derecho"],
            ["{{上揃え}}", "Arriba"],
            ["{{中央揃え(垂直方向)}}", "Centro (Vertical)"],
            ["{{下揃え}}", "Fondo"],
            ["{{開始フレーム}}", "marco de inicio"],
            ["{{終了フレーム}}", "marco final"],
            ["{{ループで再生}}", "Reproducir en bucle"],
            ["{{1回再生}}", "1 reproducción"],
            ["{{指定したフレームで固定}}", "Fijado en el marco especificado"],
            ["{{1回逆再生}}", "1 reproducción inversa"],
            ["{{逆ループで再生}}", "Reproducción en bucle invertido"],
            ["{{画面の拡大・縮小}}", "Acercar y alejar la pantalla"],
            ["{{カスタムイージングデータを保存}}", "Guarda los datos de la flexión personalizada"],
            ["{{カスタムイージングデータの読込}}", "Lectura de datos de flexibilización personalizados"],
            ["{{プレビューのON/OFF}}", "Activación/desactivación de la vista previa"],
            ["{{フォント枠サイズ}}", "Tamaño del marco de la fuente"],
            ["{{フォント枠カラー}}", "Color del marco de la fuente"],
            ["{{オニオンスキン}}", "Piel de cebolla"],
            ["{{バケツツール}}", "Herramientas para cubos"],
            ["{{ペンツール}}", "Herramienta de la pluma"],
            ["{{ダブルクリックでカーブポイントが追加されます}}", "Haga doble clic para añadir un punto de curva"],
            ["{{選択ツール}}", "Herramientas de selección"],
            ["{{Shape変形ツール}}", "Herramienta de transformación de formas"],
            ["{{テキストツール}}", "Herramienta de texto"],
            ["{{矩形ツール}}", "Herramienta Rectángulo"],
            ["{{楕円ツール}}", "Herramienta Elipse"],
            ["{{角丸矩形ツール}}", "Herramienta Rectángulo Redondeado"],
            ["{{塗りのカラー}}", "Color de relleno"],
            ["{{線のカラー}}", "Color del trazo"],
            ["{{線の太さ}}", "Anchura de la carrera"],
            ["{{プロジェクトデータの読込}}", "Carga de los datos del proyecto"],
            ["{{プロジェクトデータを保存}}", "Guardar los datos del proyecto"],
            ["{{書き出し}}", "Exportar"],
            ["{{Discordへ移動}}", "Ir a la discordia"],
            ["{{バグ報告}}", "Informes de errores"],
            ["{{設定}}", "Configuración"],
            ["{{タブを追加}}", "Añadir una pestaña"],
            ["{{タブの一覧を表示・移動}}", "Ver y desplazarse por la lista de pestañas"],
            ["{{スクリプトを追加}}", "Añadir una secuencia de comandos"],
            ["{{キーフレームを追加}}", "Añadir un fotograma clave"],
            ["{{空のキーフレームを追加}}", "Añadir un fotograma clave vacío"],
            ["{{フレームを追加}}", "Añadir un marco"],
            ["{{フレームを削除}}", "Borrar el marco"],
            ["{{再生}}", "Juega a"],
            ["{{停止}}", "Detener"],
            ["{{ループ設定}}", "Ajuste del bucle"],
            ["{{レイヤーを追加}}", "Añadir una capa"],
            ["{{レイヤーを削除}}", "Eliminar la capa"],
            ["{{全てのレイヤーをハイライト}}", "Resaltar todas las capas"],
            ["{{全てのレイヤーを非表示}}", "Ocultar todas las capas"],
            ["{{全てのレイヤーをロック}}", "Bloquear todas las capas"],
            ["{{比率を固定}}", "Relación fija"],
            ["{{ステージの幅}}", "Anchura del escenario"],
            ["{{背景色}}", "Color de fondo"],
            ["{{ステージの高さ}}", "Altura del escenario"],
            ["{{フレームレート}}", "Velocidad de fotogramas"],
            ["{{シンボル名}}", "Nombre del símbolo"],
            ["{{イージング設定}}", "Ajuste de la flexibilización"],
            ["{{ビデオの音量設定}}", "Ajuste del volumen de vídeo"],
            ["{{自動再生}}", "Reproducción automática"],
            ["{{テキストエリアのボーダー設定}}", "Configuración del borde del área de texto"],
            ["{{テキスト入力設定}}", "Ajuste de la entrada de texto"],
            ["{{フォント選択}}", "Selección de fuentes"],
            ["{{自動サイズ調整}}", "Ajuste automático del tamaño"],
            ["{{フォントスタイルタイプ}}", "Tipo de letra"],
            ["{{行揃え}}", "Alinear"],
            ["{{改行設定}}", "Ajuste de la nueva línea"],
            ["{{スクロール設定}}", "Ajuste de desplazamiento"],
            ["{{フォントサイズ}}", "Tamaño de la fuente"],
            ["{{フォントカラー}}", "Color de la fuente"],
            ["{{行間}}", "Espacio de la línea"],
            ["{{文字幅}}", "Anchura de los caracteres"],
            ["{{左マージン}}", "Margen izquierdo"],
            ["{{右マージン}}", "Margen derecho"],
            ["{{カラー種別の選択}}", "Seleccione un tipo de color"],
            ["{{背景画像の選択}}", "Seleccionar una imagen de fondo"],
            ["{{カラーポインターを追加}}", "Añadir punteros de color"],
            ["{{カラー値}}", "Color"],
            ["{{アルファ(0%-100%)}}", "Alpha(0%-100%)"],
            ["{{アルファ値}}", "Alpha"],
            ["{{選択対象の幅}}", "Anchura del objeto de selección"],
            ["{{選択対象のX座標}}", "Coordenada X del objeto de selección"],
            ["{{選択対象の高さ}}", "Altura del objeto de selección"],
            ["{{選択対象のY座標}}", "Coordenada Y del objeto de selección"],
            ["{{選択対象の幅の伸縮}}", "scaleX del objeto seleccionado"],
            ["{{選択対象を回転}}", "Girar el objeto"],
            ["{{選択対象の高さの伸縮}}", "escalaY del objeto seleccionado"],
            ["{{アルファオフセット(-255〜255)}}", "Desplazamiento alfa(-255〜255)"],
            ["{{赤(0%-100%)}}", "Rojo(0%-100%)"],
            ["{{赤オフセット(-255〜255)}}", "Compensación roja(-255〜255)"],
            ["{{緑(0%-100%)}}", "Verde(0%-100%)"],
            ["{{緑オフセット(-255〜255)}}", "Compensación verde(-255〜255)"],
            ["{{青(0%-100%)}}", "Azul(0%-100%)"],
            ["{{青オフセット(-255〜255)}}", "Offset azul(-255〜255)"],
            ["{{ブレンドモード}}", "Modo de fusión"],
            ["{{フィルターを選択}}", "Seleccione un filtro"],
            ["{{フィルターを追加}}", "Añadir un filtro"],
            ["{{サウンドを追加}}", "Añadir un sonido"],
            ["{{フィルターを表示・非表示する}}", "Mostrar y ocultar filtros"],
            ["{{フィルターを削除}}", "Eliminar el filtro"],
            ["{{水平方向にぼかす}}", "Desenfoque horizontal"],
            ["{{垂直方向にぼかす}}", "Desenfoque vertical"],
            ["{{フィルター強度}}", "Fuerza del filtro"],
            ["{{フィルター角度}}", "Ángulo del filtro"],
            ["{{シャドウのアルファ}}", "Sombra Alfa"],
            ["{{シャドウのカラー}}", "Color de la sombra"],
            ["{{フィルター距離}}", "Distancia del filtro"],
            ["{{ハイライトのカラー}}", "Color de realce"],
            ["{{ハイライトのアルファ}}", "Resaltar Alpha"],
            ["{{グラデーションカラー}}", "Color degradado"],
            ["{{グラデーションのアルファ}}", "Gradiente Alfa"],
            ["{{タブの移動・名前を変更}}", "Mover/Renombrar pestañas"],
            ["{{プロジェクトを閉じる}}", "Cerrar el proyecto"],
            ["{{上下に移動}}", "Subir y bajar"],
            ["{{レイヤー変更(ダブルクリック)}}", "Cambio de capa (doble clic)"],
            ["{{レイヤーをハイライト}}", "Capa de resaltado"],
            ["{{レイヤーを非表示}}", "Ocultar capa"],
            ["{{レイヤーをロック}}", "Bloquear la capa"],
            ["{{カーブポインター(ダブルクリックでON/OFF)}}", "Puntero de curva (doble clic para activar/desactivar)"],
            ["{{インスタンス名}}", "Nombre de la instancia"],
            ["{{ライブラリ内の検索}}", "Buscar en la biblioteca"],
            ["{{フレームラベル}}", "Etiqueta del marco"],
            ["{{プロジェクトが保存されていない場合、このタブのプロジェクトデータを復旧する事はできません。タブを削除しますか？}}", "Si el proyecto no se guarda, los datos del proyecto en esta pestaña no se pueden recuperar. ¿Desea eliminar la pestaña?"]
        ]);
    }
}

let characterId = 0;

const Util = {};

Util.VERSION                  = 1;
Util.PREFIX                   = "__next2d-tools__";
Util.DATABASE_NAME            = "save-data";
Util.STORE_KEY                = "local";
Util.REVISION_LIMIT           = 100;
Util.$activeWorkSpaceId       = 0;
Util.$activeCharacterIds      = [];
Util.$workSpaces              = [];
Util.$readStatus              = 0;
Util.$readEnd                 = 1;
Util.$shiftKey                = false;
Util.$ctrlKey                 = false;
Util.$altKey                  = false;
Util.$zoomScale               = 1.0;
Util.$currentFrame            = 1;
Util.$root                    = null;
Util.$Rad2Deg                 = 180 / Math.PI;
Util.$Deg2Rad                 = Math.PI / 180;
Util.$keyLock                 = false;
Util.$activeScript            = false;
Util.$previewMode             = false;
Util.$offsetLeft              = 0;
Util.$offsetTop               = 0;
Util.$currentCursor           = "auto";
Util.$useIds                  = new Map();
Util.$symbols                 = new Map();
Util.$copyWorkSpaceId         = -1;
Util.$copyLibrary             = null;
Util.$copyLayer               = null;
Util.$copyCharacter           = null;
Util.$canCopyLayer            = false;
Util.$canCopyCharacter        = false;
Util.$hitColor                = null;
Util.$updated                 = false;
Util.$languages               = new Map();
Util.$currentLanguage         = null;
Util.$shapePointerColor       = "#009900";
Util.$shapeLinkedPointerColor = "#ffa500";
Util.$shortcut                = new Map();
Util.$useShortcutSetting      = false;
Util.$changeLibraryId         = 0;
Util.$canvases                = [];

const userAgentData = window.navigator.userAgentData;
if (userAgentData) {
    userAgentData
        .getHighEntropyValues(["platform"])
        .then((object) =>
        {
            Util.$isMac = object.platform.indexOf("mac") > -1;
        });
} else {
    Util.$isMac = window.navigator.userAgent.indexOf("Mac") > -1;
}

const canvas     = document.createElement("canvas");
canvas.width     = 1;
canvas.height    = 1;
Util.$hitContext = canvas.getContext("2d");

/**
 * @return {HTMLCanvasElement}
 * @static
 */
Util.$getCanvas = () =>
{
    return Util.$canvases.length
        ? Util.$canvases.pop()
        : document.createElement("canvas");
};

/**
 * @param {CanvasRenderingContext2D} context
 * @static
 */
Util.$poolCanvas = (context) =>
{
    if (!(context instanceof CanvasRenderingContext2D)) {
        return ;
    }

    const canvas = context.canvas;
    const width  = canvas.width;
    const height = canvas.height;

    context.clearRect(0, 0, width + 1, height + 1);

    // canvas reset
    canvas.width = canvas.height = 1;

    // pool
    Util.$canvases.push(canvas);
};

Util.$cloneMovieClip = (from_work_space_id, movie_clip) =>
{
    const fromWorkSpace = Util.$workSpaces[from_work_space_id];
    const toWorkSpace   = Util.$currentWorkSpace();

    const activeWorkSpaceId = Util.$activeWorkSpaceId;
    Util.$activeWorkSpaceId = this._$copyWorkSpaceId;

    const movieClip = movie_clip.clone();
    Util.$activeWorkSpaceId = activeWorkSpaceId;

    for (const layer of movieClip._$layers.values()) {

        // 設置されたレイヤーを複製
        const newLayer = new Layer();
        for (let idx = 0; idx < layer._$characters.length; ++idx) {

            // 複製先でIDを発番するのでtoObjectを利用する
            Util.$activeWorkSpaceId = from_work_space_id;
            const character = new Character(
                JSON.parse(JSON.stringify(layer._$characters[idx].toObject()))
            );

            // 初期化
            character._$id = toWorkSpace._$characterId++;

            Util.$activeWorkSpaceId = activeWorkSpaceId;

            const instance = fromWorkSpace
                .getLibrary(character.libraryId);

            if (this._$copyMapping.has(instance.id)) {
                character.libraryId = this._$copyMapping.get(instance.id);
                newLayer.addCharacter(character);
                continue;
            }

            if (instance.folderId) {

                const folders = [];

                let parent = instance;
                while (parent._$folderId) {
                    parent = fromWorkSpace.getLibrary(
                        parent._$folderId
                    );
                    folders.unshift(parent);
                }

                for (let idx = 0; folders.length > idx; ++idx) {

                    const folder = folders[idx];

                    const path = folder
                        .getPathWithWorkSpace(fromWorkSpace);

                    if (toWorkSpace._$nameMap.has(path)) {

                        if (!this._$instanceMap.has(folder.id)) {
                            this._$instanceMap.set(folder.id, []);
                        }

                        this._$instanceMap
                            .get(folder.id)
                            .push({
                                "layer": null,
                                "path": path,
                                "character": folder
                            });

                        continue;
                    }

                    const clone = folder.clone();

                    const id = toWorkSpace.nextLibraryId;
                    this._$copyMapping.set(clone.id, id);

                    clone._$id = id;
                    if (clone.folderId
                        && this._$copyMapping.has(clone.folderId)
                    ) {
                        clone.folderId = this
                            ._$copyMapping
                            .get(clone.folderId);
                    }

                    toWorkSpace._$libraries.set(clone.id, clone);

                    Util
                        .$libraryController
                        .createInstance(
                            clone.type,
                            clone.name,
                            clone.id,
                            clone.symbol
                        );

                }
            }

            // コピー元のワークスペースからpathを算出
            const path = instance
                .getPathWithWorkSpace(fromWorkSpace);

            if (toWorkSpace._$nameMap.has(path)) {

                if (!this._$instanceMap.has(instance.id)) {
                    this._$instanceMap.set(instance.id, []);
                }

                this._$instanceMap
                    .get(instance.id)
                    .push({
                        "layer": newLayer,
                        "path": path,
                        "character": character
                    });

                continue;
            }

            // fixed logic 複製を生成
            const clone = instance.type === InstanceType.MOVIE_CLIP
                ? this.cloneMovieClip(instance)
                : instance.clone();

            // ライブラリにアイテムを追加
            const id = toWorkSpace.nextLibraryId;
            this._$copyMapping.set(instance.id, id);

            character.libraryId = id;
            clone._$id = id;
            toWorkSpace._$libraries.set(clone.id, clone);

            if (clone.folderId
                && this._$copyMapping.has(clone.folderId)
            ) {
                clone.folderId = this
                    ._$copyMapping
                    .get(clone.folderId);
            }

            Util
                .$libraryController
                .createInstance(
                    clone.type,
                    clone.name,
                    clone.id,
                    clone.symbol
                );

            toWorkSpace
                ._$nameMap
                .set(path, clone.id);

            newLayer.addCharacter(character);
        }

        // 空のキーフレームをコピー
        for (let idx = 0; idx < layer._$emptys.length; ++idx) {
            newLayer.addEmptyCharacter(
                layer._$emptys[idx].clone()
            );
        }

        newLayer.id = layer.id;
        movieClip.setLayer(newLayer.id, newLayer);
    }

    return movieClip;
};

/**
 * @param  {*}   value
 * @param  {int} min
 * @param  {int} max
 * @return {number}
 * @static
 */
Util.$clamp = (value, min, max) =>
{
    const number = +value;
    return Math.min(Math.max(min, isNaN(number) || !isFinite(number) ? 0 : number), max);
};

/**
 * @param  {string} key
 * @param  {object} [options=null]
 * @return {string}
 * @static
 */
Util.$generateShortcutKey = (key, options = null) =>
{
    let value = key.length === 1 ? key.toLowerCase() : key;
    if (options) {
        if (options.shift) {
            value += "Shift";
        }
        if (options.alt) {
            value += "Alt";
        }
        if (options.ctrl) {
            value += "Ctrl";
        }
    }
    return value;
};

/**
 * @param  {*} source
 * @return {boolean}
 * @static
 */
Util.$isArray = (source) =>
{
    return Array.isArray(source);
};

/**
 * @param  {string} [value="auto"]
 * @return {void}
 * @static
 */
Util.$setCursor = (value = "auto") =>
{
    if (Util.$currentCursor !== value) {
        Util.$currentCursor = value;
        document
            .documentElement
            .style
            .setProperty("--tool-cursor", value);
    }
};

/**
 * @description モーダルのアニメーションイベントを登録
 *
 * @param  {HTMLElement} element
 * @return {void}
 * @method
 * @static
 */
Util.$addModalEvent = (element) =>
{
    const elements = element
        .querySelectorAll("[data-detail]");

    for (let idx = 0; idx < elements.length; ++idx) {

        const element = elements[idx];

        element.addEventListener("mouseover", Util.$fadeIn);
        element.addEventListener("mouseout",  Util.$fadeOut);
    }
};

/**
 * @description モーダルのフェードアウト関数
 *
 * @param  {MouseEvent} event
 * @method
 * @static
 */
Util.$fadeIn = (event) =>
{
    const object = Util.$userSetting.getPublishSetting();
    if ("modal" in object && !object.modal) {
        return ;
    }

    const target = event.currentTarget;

    let value = Util.$currentLanguage.replace(
        target.dataset.detail
    );

    let shortcutKey = target.dataset.shortcutKey;
    if (shortcutKey) {

        const mapping = Util.$shortcutSetting.viewMapping.get(
            target.dataset.area
        );

        const shortcutText = mapping.has(shortcutKey)
            ? mapping.get(shortcutKey).text
            : target.dataset.shortcutText;

        value += ` (${shortcutText})`;
    }

    const element = document.getElementById("detail-modal");
    if (element.textContent !== value) {
        element.textContent = value;
    }

    // 表示領域に収まるようx座標を調整
    switch (true) {

        case element.clientWidth + event.pageX - 20 > window.innerWidth:
            element.style.left = `${event.pageX - (element.clientWidth + event.pageX + 10 - window.innerWidth)}px`;
            break;

        case 0 > event.pageX - 20:
            element.style.left = "10px";
            break;

        default:
            element.style.left  = `${event.pageX - 20}px`;
            break;

    }

    // 表示領域に収まるようy座標を調整
    switch (true) {

        case element.clientHeight + event.pageY + 20 > window.innerHeight:
            element.style.top = `${event.pageY - element.clientHeight - 20}px`;
            break;

        default:
            element.style.top = `${event.pageY + 20}px`;
            break;

    }

    element.setAttribute("class", "fadeIn");

    // 1.5秒で自動的に消えるようタイマーをセット
    element.dataset.timerId = setTimeout(() =>
    {
        if (!element.classList.contains("fadeOut")) {
            element.setAttribute("class", "fadeOut");
        }
    }, 1500);
};

/**
 * @description モーダルのフェードアウト関数
 *
 * @method
 * @static
 */
Util.$fadeOut = () =>
{
    const object = Util.$userSetting.getPublishSetting();
    if ("modal" in object && !object.modal) {
        return ;
    }

    const element = document.getElementById("detail-modal");
    clearTimeout(element.dataset.timerId | 0);
    element.setAttribute("class", "fadeOut");
};

/**
 * @param  {string} ignore
 * @return {void}
 * @static
 */
Util.$endMenu = (ignore) =>
{
    const names = [
        "timeline-menu",
        "library-menu",
        "tab-name-menu",
        "timeline-layer-menu",
        "scene-name-menu",
        "user-setting",
        "screen-menu",
        "editor-modal",
        "plugin-modal",
        "shortcut-setting-menu",
        "library-export-modal",
        "screen-order-menu",
        "screen-align-menu",
        "change-movie-clip"
    ];

    for (let idx = 0; idx < names.length; ++idx) {

        const name = names[idx];
        if (name === ignore) {
            continue;
        }

        if (name === "editor-modal"
            && Util.$javaScriptEditor.active
        ) {
            Util.$javaScriptEditor.hide();
        }

        const menu = document.getElementById(name);
        if (!menu.classList.contains("fadeIn")) {
            continue;
        }
        menu.setAttribute("class", "fadeOut");
    }
};

/**
 * @return {void}
 * @static
 */
Util.$loadSaveData = () =>
{
    Util.$saveProgress.start();

    const binary = localStorage
        .getItem(`${Util.PREFIX}@${Util.DATABASE_NAME}`);

    if (binary) {

        localStorage
            .removeItem(`${Util.PREFIX}@${Util.DATABASE_NAME}`);

        const length = binary.length;
        const buffer = new Uint8Array(length);
        for (let idx = 0; idx < length; ++idx) {
            buffer[idx] = binary.charCodeAt(idx) & 0xff;
        }

        Util.$saveProgress.zlibInflate();

        Util.$unZlibWorker.postMessage({
            "buffer": buffer,
            "type": "local"
        }, [buffer.buffer]);

    } else {

        Util.$saveProgress.launchDatabase(10);

        const request = Util.$launchDB();
        request.onsuccess = (event) =>
        {
            const db = event.target.result;
            const transaction = db.transaction(
                `${Util.DATABASE_NAME}`, "readonly"
            );

            const store = transaction
                .objectStore(`${Util.DATABASE_NAME}`);

            const request = store.get(Util.STORE_KEY);
            request.onsuccess = (event) =>
            {
                const binary = event.target.result;
                if (binary) {

                    const length = binary.length;
                    const buffer = new Uint8Array(length);
                    for (let idx = 0; idx < length; ++idx) {
                        buffer[idx] = binary.charCodeAt(idx) & 0xff;
                    }

                    Util.$saveProgress.zlibInflate();

                    Util.$unZlibWorker.postMessage({
                        "buffer": buffer,
                        "type": "local"
                    }, [buffer.buffer]);

                } else {

                    Util.$workSpaces.push(new WorkSpace());

                    Util.$screenTab.run();

                    Util.$initializeEnd();

                }

                db.close();
            };
        };
    }
};

/**
 * @param   {Float32Array} a
 * @param   {Float32Array} b
 * @returns {Float32Array}
 * @static
 */
Util.$multiplicationMatrix = (a, b) =>
{
    return new Float32Array([
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        a[0] * b[4] + a[2] * b[5] + a[4],
        a[1] * b[4] + a[3] * b[5] + a[5]
    ]);
};

/**
 * @description 画面全体のショートカットを登録
 *
 * @param  {string} code
 * @param  {function} callback
 * @return {void}
 * @method
 * @static
 */
Util.$setShortcut = (code, callback) =>
{
    Util.$shortcut.set(code, callback);
};

/**
 * @description ショートカットを削除
 *
 * @param  {string} code
 * @return {void}
 * @method
 * @static
 */
Util.$deleteShortcut = (code) =>
{
    if (!Util.$shortcut.has(code)) {
        return ;
    }
    Util.$shortcut.delete(code);
};

/**
 * @param  {KeyboardEvent} event
 * @return {void}
 * @method
 * @static
 */
Util.$executeKeyCommand = (event) =>
{
    Util.$shiftKey = event.shiftKey;
    Util.$ctrlKey  = event.ctrlKey || event.metaKey; // command
    Util.$altKey   = event.altKey;

    if (Util.$ctrlKey) {

        switch (event.key) {

            case "-":
            case "+":
            case ";":
                event.stopPropagation();
                event.preventDefault();
                break;

            default:
                break;

        }

    }

    if (Util.$keyLock) {
        return ;
    }

    if (Util.$useShortcutSetting) {
        event.stopPropagation();
        event.preventDefault();
        return ;
    }

    const code = Util.$generateShortcutKey(event.key, {
        "alt": Util.$altKey,
        "shift": Util.$shiftKey,
        "ctrl": Util.$ctrlKey
    });

    if (!Util.$shortcut.has(code)) {
        return ;
    }

    event.stopPropagation();
    event.preventDefault();
    Util.$shortcut.get(code)(event);
};

/**
 * @description AudioContextを起動
 */
Util.$loadAudioContext = () =>
{
    window.removeEventListener("click", Util.$loadAudioContext);
    Util.$audioContext = new AudioContext();
};

/**
 * @return {void}
 * @static
 */
Util.$initialize = () =>
{
    // end event
    window.removeEventListener("DOMContentLoaded", Util.$initialize);

    // clickでAudioContextを起動
    window.addEventListener("mousedown", Util.$loadAudioContext);

    Util.$filterClasses = {
        "BevelFilter": BevelFilter,
        "BlurFilter": BlurFilter,
        "DropShadowFilter": DropShadowFilter,
        "GlowFilter": GlowFilter,
        "GradientBevelFilter": GradientBevelFilter,
        "GradientGlowFilter": GradientGlowFilter
    };

    Util.$languages.set("Japanese", Japanese);
    Util.$languages.set("English", English);
    Util.$languages.set("Chinese", Chinese);
    Util.$languages.set("Korean", Korean);
    Util.$languages.set("French", French);
    Util.$languages.set("Russia", Russia);
    Util.$languages.set("Italiano", Italiano);
    Util.$languages.set("Spanish", Spanish);

    let language = localStorage
        .getItem(`${Util.PREFIX}@language-setting`);

    if (!language) {

        switch (navigator.language) {

            case "ja":
                language = "Japanese";
                break;

            case "ko":
                language = "Korean";
                break;

            case "zh":
                language = "Chinese";
                break;

            case "fr":
                language = "French";
                break;

            case "ru":
                language = "Russia";
                break;

            case "it":
                language = "Italiano";
                break;

            case "es":
                language = "Spanish";
                break;

            default:
                language = "English";
                break;

        }

    }

    const LanguageClass = Util.$languages.get(language);
    Util.$currentLanguage = new LanguageClass();

    // load local data
    Util.$loadSaveData();

    // added event
    window.addEventListener("keydown", Util.$executeKeyCommand);

    // key reset
    window.addEventListener("keyup", () =>
    {
        Util.$shiftKey = false;
        Util.$ctrlKey  = false;
        Util.$altKey   = false;
    });

    window.addEventListener("beforeunload", (event) =>
    {
        if (Util.$updated) {

            event.preventDefault();
            event.stopPropagation();

            event.returnValue = "データ保存中...";

            // 保存を実行
            Util.$autoSave();

            return false;
        }
    });

    // フレームのデフォルト幅をセット
    document
        .documentElement
        .style
        .setProperty(
            "--timeline-frame-width",
            `${TimelineTool.DEFAULT_TIMELINE_WIDTH}px`
        );

    document
        .documentElement
        .style
        .setProperty(
            "--timeline-frame-height",
            `${TimelineTool.DEFAULT_TIMELINE_HEIGHT - 1}px`
        );

    document
        .documentElement
        .style
        .setProperty("--screen-height", `${window.innerHeight - 50}px`);

    const width  = Stage.STAGE_DEFAULT_WIDTH;
    const height = Stage.STAGE_DEFAULT_HEIGHT;
    const fps    = Stage.STAGE_DEFAULT_FPS;

    const previewDisplay = document.getElementById("preview-display");
    if (previewDisplay) {
        previewDisplay.style.width  = `${width}px`;
        previewDisplay.style.height = `${height}px`;
    }

    if ("next2d" in window) {
        Util.$root = window
            .next2d
            .createRootMovieClip(width, height, fps, {
                "tagId": "preview-display"
            });

        Util.$root.stage._$player.stop();
    }

    const previewStop = document.getElementById("preview-stop");
    if (previewStop) {
        previewStop.addEventListener("click", Util.$hidePreview);
    }

    document
        .documentElement
        .style
        .setProperty("--ad", "260px");

    // clear
    Util.$initialize = null;
};
window.addEventListener("DOMContentLoaded", Util.$initialize);
window.addEventListener("resize", () =>
{
    if (Util.$saveProgress.active) {
        return ;
    }

    Util.$rebuildTimeline();
    Util.$rebuildRuler();
});

/**
 * @description 定規を現在のスケールで再構成
 *
 * @method
 * @static
 */
Util.$rebuildRuler = () =>
{
    if (Util.$currentWorkSpace()._$ruler) {
        Util.$screenRuler.rebuild();
    }
};

/**
 * @description タイムラインを現在の幅で再構成
 *
 * @method
 * @static
 */
Util.$rebuildTimeline = () =>
{
    // ヘッダーを再構成
    Util.$timelineHeader._$currentFrame = -1;
    Util.$timelineHeader.setWidth();
    Util.$timelineHeader.rebuild();

    // タイムラインを再構成
    Util.$timelineLayer.moveTimeLine();
    Util.$timelineLayer.updateClientSize();
};

/**
 * @return {void}
 * @static
 */
Util.$showPreview = () =>
{
    // タイムライン側を停止
    Util
        .$timelinePlayer
        .executeTimelineStop();

    Util.$javaScriptEditor.save();

    Util.$previewMode = true;
    Util.$keyLock     = true;

    const element = document.getElementById("player-preview");
    element.style.display = "";
    element.style.zIndex  = "9999";

    const workSpace = Util.$currentWorkSpace();

    const preview = document.getElementById("preview-display");
    preview.style.width  = `${workSpace.stage.width}px`;
    preview.style.height = `${workSpace.stage.height}px`;

    const stopElement = document.getElementById("preview-stop");
    stopElement.style.top  = `${preview.offsetTop - 20}px`;
    stopElement.style.left = `${preview.offsetLeft + workSpace.stage.width}px`;
    stopElement.addEventListener("click", Util.$hidePreview);

    const stage = Util.$root.stage;
    stage.frameRate = document.getElementById("stage-fps").value | 0;

    const player  = stage._$player;
    player.width  = workSpace.stage.width;
    player.height = workSpace.stage.height;

    // fixed logic
    player._$resize();
    stage.clearGlobalVariable();
    stage._$events = new Map();
    player._$broadcastEvents = new Map();

    const json = Publish.toJSON();
    Util.$useIds.clear();

    const { Loader } = window.next2d.display;
    const { URLRequest } = window.next2d.net;
    const { Event } = window.next2d.events;

    const loader = new Loader();

    loader
        .contentLoaderInfo
        .addEventListener(Event.COMPLETE, (event) =>
        {
            const loaderInfo = event.currentTarget;

            const stage  = Util.$root.stage;
            const player = stage._$player;
            const data   = loaderInfo._$data;

            player.width  = data.stage.width;
            player.height = data.stage.height;
            player.stage.frameRate = data.stage.fps;

            const color = Util.$intToRGB(
                `0x${data.stage.bgColor.slice(1)}` | 0
            );

            player._$context._$setColor(
                color.R / 255,
                color.G / 255,
                color.B / 255,
                1
            );

            player._$backgroundColor = [
                color.R / 255,
                color.G / 255,
                color.B / 255,
                1
            ];

            Util.$root = null;
            Util.$root = loaderInfo.content;
            while (stage.numChildren) {
                stage.removeChildAt(0);
            }

            stage.addChild(Util.$root);

            player._$cacheStore.reset();

            const { BlendMode } = window.next2d.display;

            const context = player._$context;
            context._$globalAlpha              = 1;
            context._$globalCompositeOperation = BlendMode.NORMAL;
            context._$imageSmoothingEnabled    = false;

            context.frameBuffer.unbind();
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.clearRect(0, 0, context.canvas.width, context.canvas.height);
            context._$bind(player._$buffer);

            player.play();
        });

    loader.load(new URLRequest(
        URL.createObjectURL(new Blob([json], { "type": "application/json" }))
    ));

    // setup clear
    player._$broadcastEvents.clear();
    window.next2d.media.SoundMixer.volume = 1;

    player._$loadStatus = 1;
    player._$updateLoadStatus();
};

/**
 * @return {void}
 * @static
 */
Util.$hidePreview = () =>
{
    const stopElement = document.getElementById("preview-stop");
    stopElement.removeEventListener("click", Util.$hidePreview);

    const element = document.getElementById("player-preview");
    element.style.display = "none";
    element.style.zIndex  = "0";

    Util.$previewMode = false;
    if (!Util.$activeScript) {
        Util.$keyLock = false;
    }

    while (Util.$root.numChildren) {
        Util.$root.removeChild(Util.$root.getChildAt(0));
    }
    Util.$root.stage._$player.stop();
};

/**
 * @return {string}
 * @static
 */
Util.$toJSON = () =>
{
    // cache WorkSpaceId
    const activeWorkSpaceId = Util.$activeWorkSpaceId;

    const children = document
        .getElementById("view-tab-area")
        .children;

    const data = [];
    for (let idx = 0; idx < children.length; ++idx) {

        const node = children[idx];

        const workSpace = Util.$workSpaces[node.dataset.tabId | 0];
        if (!workSpace) {
            continue;
        }

        Util.$activeWorkSpaceId = node.dataset.tabId | 0;

        data.push(workSpace.toJSON());

    }

    // reset
    Util.$activeWorkSpaceId = activeWorkSpaceId;

    return JSON.stringify(data);
};

/**
 * @return {Promise}
 * @static
 */
Util.$autoSave = () =>
{
    if (Util.$saveProgress.active) {
        return Promise.resolve();
    }

    Util.$javaScriptEditor.save();
    Util.$saveProgress.start();

    return new Promise((resolve) =>
    {
        Util.$saveProgress.createJson();

        setTimeout(() =>
        {
            resolve({
                "object": Util.$toJSON(),
                "type": "local"
            });
        }, 200);

    })
        .then((data) =>
        {
            Util.$saveProgress.zlibDeflate();

            if (Util.$zlibWorkerActive) {

                Util.$zlibQueues.push(data);

            } else {

                Util.$zlibWorkerActive = true;
                Util.$zlibWorker.postMessage(data);

            }
        });

};

/**
 * @param   {array} matrix
 * @returns {array}
 * @method
 * @static
 */
Util.$inverseMatrix = (matrix) =>
{
    const tx = matrix[2] * matrix[5] - matrix[3] * matrix[4];
    const ty = matrix[1] * matrix[4] - matrix[0] * matrix[5];

    let det = matrix[0] * matrix[3] - matrix[2] * matrix[1];
    if (!det || !isFinite(det)) {
        return [
            matrix[3],
            -matrix[1],
            -matrix[2],
            matrix[0] ,
            tx,
            ty
        ];
    }

    const rdet = 1 / det;
    return [
        matrix[3] * rdet,
        -matrix[1] * rdet,
        -matrix[2] * rdet,
        matrix[0] * rdet,
        tx * rdet,
        ty * rdet
    ];
};

/**
 * @param  {number} num
 * @return {number}
 */
Util.$toFixed4 = (num) =>
{
    const value = num.toString();
    const index = value.indexOf("e");
    if (index > -1) {
        num = +value.slice(0, index);
    }
    return +num.toFixed(4);
};

/**
 * @return {WorkSpace}
 * @static
 */
Util.$currentWorkSpace = () =>
{
    return Util.$workSpaces[Util.$activeWorkSpaceId];
};

/**
 * @return {void}
 * @static
 */
Util.$initializeEnd = () =>
{
    Util.$readStatus++;
    if (Util.$readStatus === Util.$readEnd) {

        Util.$saveProgress.end();

        // HTML内に設定されたdata-detailの値を、モーダル出力するのに登録
        Util.$addModalEvent(document);

        // WorkSpaceを起動
        Util.$currentWorkSpace().run();
    }
};

/**
 * @param {number} id
 * @static
 */
Util.$changeWorkSpace = (id) =>
{
    // reset
    Util.$useIds.clear();
    Util.$symbols.clear();

    Util.$currentWorkSpace().stop();

    Util.$activeWorkSpaceId = id | 0;

    Util.$currentWorkSpace().run();
};

// ZLIB Inflate Worker
Util.$unZlibWorker = new Worker(URL.createObjectURL(
    new Blob(["var zlibes=function(e){\"use strict\";const t=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),n=131072,r=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],i=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],s=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],o=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],a=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function f(e){const t=Object.keys(e);let n=0,r=0,i=Number.MAX_SAFE_INTEGER;t.forEach((e=>{n=Number(e),r<n&&(r=n),i>n&&(i=n)}));let s,o=0;const a={};for(let t=i;t<=r;t++){void 0===(s=e[t])&&(s=[]),s.sort(((e,t)=>e<t?-1:e>t?1:0));const n={};s.forEach((e=>{n[o]=e,o++})),a[t]=n,o<<=1}return a}function h(e,t=15){const n={};for(const t of e)n[t]?n[t]++:n[t]=1;const r=Object.keys(n);let i=[],s=0,o=[];if(1===r.length)o.push({count:n[0],simbles:[Number(r[0])]});else for(let e=0;e<t;e++){for(o=[],r.forEach((e=>{const t={count:n[Number(e)],simbles:[Number(e)]};o.push(t)})),s=0;s+2<=i.length;){const e={count:i[s].count+i[s+1].count,simbles:i[s].simbles.concat(i[s+1].simbles)};o.push(e),s+=2}(o=o.sort(((e,t)=>e.count<t.count?-1:e.count>t.count?1:0))).length%2!=0&&o.pop(),i=o}const a={};let f;o.forEach((e=>{e.simbles.forEach((e=>{a[e]?a[e]++:a[e]=1}))}));const h=Object.keys(a),d={};let u=0,c=3,l=Number.MAX_SAFE_INTEGER,w=0;h.forEach((e=>{c=a[Number(e)],d[c]||(d[c]=[],l>c&&(l=c),w<c&&(w=c)),d[c].push(Number(e))})),u=0;const g=new Map;for(let e=l;e<=w;e++)(f=d[e])&&(f=f.sort(((e,t)=>e<t?-1:e>t?1:0))).forEach((t=>{g.set(t,{code:u,bitlen:e}),u++})),u<<=1;return g}function d(e,t,n){let r=t;const o=t+n-3;let a=0,f=0,h=0,d=0,u=0,c=0,l=0;const w=[],g={},b={},R=function(e,t,n){const r=t+n-3,i={};for(let n=t;n<=r;n++){const t=e[n]<<16|e[n+1]<<8|e[n+2];void 0===i[t]&&(i[t]=[]),i[t].push(n)}return i}(e,t,n);for(;r<=o;){const t=e[r]<<16|e[r+1]<<8|e[r+2],n=R[t];if(void 0===n||n.length<=1){w.push([e[r]]),r++;continue}a=r>32768?r-32768:0,h=0,d=0;let E=g[t]||0;for(;n[E]<a;)E=E+1|0;for(g[t]=E,E=b[t]||0;n[E]<r;)E=E+1|0;b[t]=E;let p=0;e:for(let i=b[t]-1,s=g[t];s<=i&&!(p>=128||h>=8&&p>=16);i--){p++;const t=n[i];for(let n=h-1;0<n;n--)if(e[t+n]!==e[r+n])continue e;f=258;for(let n=h;n<=258;n++)if(e[t+n]!==e[r+n]){f=n;break}if(h<f&&(h=f,d=t,258<=f))break}if(h>=3&&r+h<=o){u=r-d;for(let e=0;e<i.length&&!(i[e]>h);e++)c=e;for(let e=0;e<s.length&&!(s[e]>u);e++)l=e;w.push([c,l,h,u]),r+=h}else w.push([e[r]]),r++}return w.push([e[r]]),w.push([e[r+1]]),w}class u{constructor(e,t=0,n=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsIndex=n}write(e){if(this.isEnd)throw new Error(\"Lack of data length\");e<<=this.nowBitsIndex,this.nowBits+=e,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(e,t){let n=1,r=0;for(let i=0;i<t;i++)r=e&n?1:0,this.write(r),n<<=1}writeRangeCoded(e,t){let n=1<<t-1,r=0;for(let i=0;i<t;i++)r=e&n?1:0,this.write(r),n>>>=1}}function c(e,t,n,f){const u=d(t,n,f),c=[256],l=[];let w=256,g=0;for(let e=0,t=u.length;e<t;e++){const t=u[e];let n=t[0];const r=t[1];void 0!==r&&(n+=257,l.push(r),g<r&&(g=r)),c.push(n),w<n&&(w=n)}const b=h(c),R=h(l),E=[];for(let e=0;e<=w;e++)b.has(e)?E.push(b.get(e).bitlen):E.push(0);const p=E.length;for(let e=0;e<=g;e++)R.has(e)?E.push(R.get(e).bitlen):E.push(0);const B=E.length-p,I=[],N=[];let m=0,x=0;for(let e=0;e<E.length;e++){for(m=E[e],x=1;m===E[e+1];)if(x++,e++,0===m){if(138<=x)break}else if(6<=x)break;if(4<=x)0===m?11<=x?I.push(18):I.push(17):(I.push(m),N.push(1),x--,I.push(16)),N.push(x);else for(let e=0;e<x;e++)I.push(m),N.push(1)}const A=h(I,7);let v,y=0;a.forEach(((e,t)=>{A.has(e)&&(y=t+1)})),e.writeRange(p-257,5),e.writeRange(B-1,5),e.writeRange(y-4,4);for(let t=0;t<y;t++)void 0!==(v=A.get(a[t]))?e.writeRange(v.bitlen,3):e.writeRange(0,3);I.forEach(((t,n)=>{if(void 0===(v=A.get(t)))throw new Error(\"Data is corrupted\");e.writeRangeCoded(v.code,v.bitlen),18===t?e.writeRange(N[n]-11,7):17===t?e.writeRange(N[n]-3,3):16===t&&e.writeRange(N[n]-3,2)}));for(let t=0,n=u.length;t<n;t++){const n=u[t],a=n[0],f=n[1];if(void 0!==f){if(void 0===(v=b.get(a+257)))throw new Error(\"Data is corrupted\");e.writeRangeCoded(v.code,v.bitlen),0<r[a]&&(x=n[2],e.writeRange(x-i[a],r[a]));const t=R.get(f);if(void 0===t)throw new Error(\"Data is corrupted\");if(e.writeRangeCoded(t.code,t.bitlen),0<o[f]){const t=n[3];e.writeRange(t-s[f],o[f])}}else{if(void 0===(v=b.get(a)))throw new Error(\"Data is corrupted\");e.writeRangeCoded(v.code,v.bitlen)}}if(void 0===(v=b.get(256)))throw new Error(\"Data is corrupted\");e.writeRangeCoded(v.code,v.bitlen)}class l{constructor(e,t=0){this.nowBitsLength=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsLength=8}read(){if(this.isEnd)throw new Error(\"Lack of data length\");const e=1&this.nowBits;return this.nowBitsLength>1?(this.nowBitsLength--,this.nowBits>>=1):(this.bufferIndex++,this.bufferIndex<this.buffer.length?(this.nowBits=this.buffer[this.bufferIndex],this.nowBitsLength=8):(this.nowBitsLength=0,this.isEnd=!0)),e}readRange(e){for(;this.nowBitsLength<=e;)this.nowBits|=this.buffer[++this.bufferIndex]<<this.nowBitsLength,this.nowBitsLength+=8;const t=this.nowBits&(1<<e)-1;return this.nowBits>>>=e,this.nowBitsLength-=e,t}readRangeCoded(e){let t=0;for(let n=0;n<e;n++)t<<=1,t|=this.read();return t}}class w{constructor(e){this.index=0,this.buffer=new Uint8Array(e),this.length=e,this._extendedSize=e}write(e){if(this.length<=this.index){this.length+=this._extendedSize;const e=new Uint8Array(this.length),t=this.buffer.length;for(let n=0;n<t;n++)e[n]=this.buffer[n];this.buffer=e}this.buffer[this.index]=e,this.index++}}const g=f(function(){const e={7:[],8:[],9:[]};for(let t=0;t<=287;t++)t<=143?e[8].push(t):t<=255?e[9].push(t):t<=279?e[7].push(t):e[8].push(t);return e}());function b(e,t){e.nowBitsLength<8&&e.readRange(e.nowBitsLength);const n=e.readRange(8)|e.readRange(8)<<8;if(n+(e.readRange(8)|e.readRange(8)<<8)!==65535)throw new Error(\"Data is corrupted\");for(let r=0;r<n;r++)t.write(e.readRange(8))}function R(e,t){const n=g,a=Object.keys(n);let f=0,h=0,d=Number.MAX_SAFE_INTEGER;a.forEach((e=>{f=Number(e),h<f&&(h=f),d>f&&(d=f)}));let u,c,l,w,b,R,E,p,B=0;for(;!e.isEnd;){for(u=void 0,f=d,B=e.readRangeCoded(d);void 0===(u=n[f][B]);){if(h<=f)throw new Error(\"Data is corrupted\");f++,B<<=1,B|=e.read()}if(u<256)t.write(u);else{if(256===u)break;l=i[c=u-257],0<(w=r[c])&&(l+=e.readRange(w)),b=e.readRangeCoded(5),R=s[b],0<(E=o[b])&&(R+=e.readRange(E)),p=t.index-R;for(let e=0;e<l;e++)t.write(t.buffer[p+e])}}}function E(e,t){const n=e.readRange(5)+257,h=e.readRange(5)+1,d=e.readRange(4)+4;let u=0;const c={};for(let t=0;t<d;t++)0!==(u=e.readRange(3))&&(c[u]||(c[u]=[]),c[u].push(a[t]));const l=f(c),w=Object.keys(l);let g=0,b=Number.MAX_SAFE_INTEGER;w.forEach((e=>{u=Number(e),g<u&&(g=u),b>u&&(b=u)}));const R={},E={};let p,B=0,I=0,N=0;const m=n+h;for(let t=0;t<m;){for(p=void 0,u=b,B=e.readRangeCoded(b);void 0===(p=l[u][B]);){if(g<=u)throw new Error(\"Data is corrupted\");u++,B<<=1,B|=e.read()}if(16===p?I=3+e.readRange(2):17===p?(I=3+e.readRange(3),N=0):18===p?(I=11+e.readRange(7),N=0):(I=1,N=p),N<=0)t+=I;else for(;I;)t<n?(R[N]||(R[N]=[]),R[N].push(t++)):(E[N]||(E[N]=[]),E[N].push(t++-n)),I--}const x=f(R),A=f(E),v=Object.keys(x);let y=0,C=0,D=Number.MAX_SAFE_INTEGER;v.forEach((e=>{y=Number(e),C<y&&(C=y),D>y&&(D=y)}));const k=Object.keys(A);let L=0,_=0,M=Number.MAX_SAFE_INTEGER;k.forEach((e=>{L=Number(e),_<L&&(_=L),M>L&&(M=L)}));let S,O,j,U,F,X,T,G,z,Y,P=0;for(;!e.isEnd;){for(S=void 0,y=D,P=e.readRangeCoded(D);void 0===(S=x[y][P]);){if(C<=y)throw new Error(\"Data is corrupted\");y++,P<<=1,P|=e.read()}if(S<256)t.write(S);else{if(256===S)break;for(j=i[O=S-257],0<(U=r[O])&&(j+=e.readRange(U)),F=void 0,G=M,z=e.readRangeCoded(M);void 0===(F=A[G][z]);){if(_<=G)throw new Error(\"Data is corrupted\");G++,z<<=1,z|=e.read()}X=s[F],0<(T=o[F])&&(X+=e.readRange(T)),Y=t.index-X;for(let e=0;e<j;e++)t.write(t.buffer[Y+e])}}}/**     * @license Copyright (c) 2018 zprodev     */return e.inflate=function(e){const n=new l(e);if(8!==n.readRange(4))throw new Error(\"Not compressed by deflate\");return n.readRange(4),n.readRange(5),n.readRange(1),n.readRange(2),function(e,n=0){const r=new w(10*e.length),i=new l(e,n);let s=0,o=0;for(;1!==s;){if(s=i.readRange(1),(o=i.readRange(2))===t.UNCOMPRESSED)b(i,r);else if(o===t.FIXED)R(i,r);else{if(o!==t.DYNAMIC)throw new Error(\"Not supported BTYPE : \"+o);E(i,r)}if(0===s&&i.isEnd)throw new Error(\"Data length is insufficient\")}return r.buffer.subarray(0,r.index)}(e,2)},e.deflate=function(e){const r=function(e){const r=e.length,i=new u(new Uint8Array(r<n/2?n:2*r));let s=0,o=0;for(;s+n>=r?(o=r-s,i.writeRange(1,1)):(o=n,i.writeRange(0,1)),i.writeRange(t.DYNAMIC,2),c(i,e,s,o),!((s+=n)>=r););return 0!==i.nowBitsIndex&&i.writeRange(0,8-i.nowBitsIndex),i.buffer.subarray(0,i.bufferIndex)}(e),i=new u(new Uint8Array(1));i.writeRange(8,4),i.writeRange(7,4);const s=new u(new Uint8Array(1));s.writeRange(28,5),s.writeRange(0,1),s.writeRange(2,2);const o=new u(new Uint8Array(4)),a=function(e){let t=1,n=0;const r=e.length;for(let i=0;i<r;i++)n=((t=(t+e[i])%65521)+n)%65521;return(n<<16)+t}(e);o.writeRange(a>>>24,8),o.writeRange(a>>>16&255,8),o.writeRange(a>>>8&255,8),o.writeRange(255&a,8);const f=new Uint8Array(r.length+6);return f.set(i.buffer),f.set(s.buffer,1),f.set(r,2),f.set(o.buffer,f.length-4),f},e}({});this.addEventListener(\"message\",(function(e){const t=zlibes.inflate(e.data.buffer);let n=\"\";for(let e=0;e<t.length;e+=4096)n+=String.fromCharCode.apply(null,t.slice(e,e+4096));this.postMessage({json:n,name:e.data.name,type:e.data.type})}));"], { "type": "text/javascript" })
));

/**
 * @param {MessageEvent} event
 * @public
 */
Util.$unZlibWorker.onmessage = (event) =>
{
    if (event.data.type === "n2d") {

        Util.$saveProgress.loadN2D();

        const workSpaces = new WorkSpace(
            decodeURIComponent(event.data.json)
        );

        workSpaces.name = event.data.name;

        Util
            .$workSpaces
            .push(workSpaces);

        Util
            .$screenTab
            .createElement(workSpaces, Util.$workSpaces.length - 1);

        Util.$saveProgress.end();

    } else {

        Util.$saveProgress.loadJson();

        const values = JSON.parse(decodeURIComponent(event.data.json));

        for (let idx = 0; idx < values.length; ++idx) {
            Util.$workSpaces.push(new WorkSpace(values[idx]));
        }

        if (!Util.$workSpaces.length) {
            Util.$workSpaces.push(new WorkSpace());
        }

        // タブセット
        Util.$screenTab.run();

        // end
        Util.$initializeEnd();

    }
};

// ZLIB Deflate Worker
Util.$zlibWorker = new Worker(URL.createObjectURL(
    new Blob(["var zlibes=function(e){\"use strict\";const t=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),n=131072,r=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],s=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],i=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],o=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],f=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function a(e){const t=Object.keys(e);let n=0,r=0,s=Number.MAX_SAFE_INTEGER;t.forEach((e=>{n=Number(e),r<n&&(r=n),s>n&&(s=n)}));let i,o=0;const f={};for(let t=s;t<=r;t++){void 0===(i=e[t])&&(i=[]),i.sort(((e,t)=>e<t?-1:e>t?1:0));const n={};i.forEach((e=>{n[o]=e,o++})),f[t]=n,o<<=1}return f}function h(e,t=15){const n={};for(const t of e)n[t]?n[t]++:n[t]=1;const r=Object.keys(n);let s=[],i=0,o=[];if(1===r.length)o.push({count:n[0],simbles:[Number(r[0])]});else for(let e=0;e<t;e++){for(o=[],r.forEach((e=>{const t={count:n[Number(e)],simbles:[Number(e)]};o.push(t)})),i=0;i+2<=s.length;){const e={count:s[i].count+s[i+1].count,simbles:s[i].simbles.concat(s[i+1].simbles)};o.push(e),i+=2}(o=o.sort(((e,t)=>e.count<t.count?-1:e.count>t.count?1:0))).length%2!=0&&o.pop(),s=o}const f={};let a;o.forEach((e=>{e.simbles.forEach((e=>{f[e]?f[e]++:f[e]=1}))}));const h=Object.keys(f),d={};let u=0,c=3,l=Number.MAX_SAFE_INTEGER,w=0;h.forEach((e=>{c=f[Number(e)],d[c]||(d[c]=[],l>c&&(l=c),w<c&&(w=c)),d[c].push(Number(e))})),u=0;const g=new Map;for(let e=l;e<=w;e++)(a=d[e])&&(a=a.sort(((e,t)=>e<t?-1:e>t?1:0))).forEach((t=>{g.set(t,{code:u,bitlen:e}),u++})),u<<=1;return g}function d(e,t,n){let r=t;const o=t+n-3;let f=0,a=0,h=0,d=0,u=0,c=0,l=0;const w=[],g={},b={},R=function(e,t,n){const r=t+n-3,s={};for(let n=t;n<=r;n++){const t=e[n]<<16|e[n+1]<<8|e[n+2];void 0===s[t]&&(s[t]=[]),s[t].push(n)}return s}(e,t,n);for(;r<=o;){const t=e[r]<<16|e[r+1]<<8|e[r+2],n=R[t];if(void 0===n||n.length<=1){w.push([e[r]]),r++;continue}f=r>32768?r-32768:0,h=0,d=0;let E=g[t]||0;for(;n[E]<f;)E=E+1|0;for(g[t]=E,E=b[t]||0;n[E]<r;)E=E+1|0;b[t]=E;let p=0;e:for(let s=b[t]-1,i=g[t];i<=s&&!(p>=128||h>=8&&p>=16);s--){p++;const t=n[s];for(let n=h-1;0<n;n--)if(e[t+n]!==e[r+n])continue e;a=258;for(let n=h;n<=258;n++)if(e[t+n]!==e[r+n]){a=n;break}if(h<a&&(h=a,d=t,258<=a))break}if(h>=3&&r+h<=o){u=r-d;for(let e=0;e<s.length&&!(s[e]>h);e++)c=e;for(let e=0;e<i.length&&!(i[e]>u);e++)l=e;w.push([c,l,h,u]),r+=h}else w.push([e[r]]),r++}return w.push([e[r]]),w.push([e[r+1]]),w}class u{constructor(e,t=0,n=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsIndex=n}write(e){if(this.isEnd)throw new Error(\"Lack of data length\");e<<=this.nowBitsIndex,this.nowBits+=e,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(e,t){let n=1,r=0;for(let s=0;s<t;s++)r=e&n?1:0,this.write(r),n<<=1}writeRangeCoded(e,t){let n=1<<t-1,r=0;for(let s=0;s<t;s++)r=e&n?1:0,this.write(r),n>>>=1}}function c(e,t,n,a){const u=d(t,n,a),c=[256],l=[];let w=256,g=0;for(let e=0,t=u.length;e<t;e++){const t=u[e];let n=t[0];const r=t[1];void 0!==r&&(n+=257,l.push(r),g<r&&(g=r)),c.push(n),w<n&&(w=n)}const b=h(c),R=h(l),E=[];for(let e=0;e<=w;e++)b.has(e)?E.push(b.get(e).bitlen):E.push(0);const p=E.length;for(let e=0;e<=g;e++)R.has(e)?E.push(R.get(e).bitlen):E.push(0);const B=E.length-p,I=[],N=[];let x=0,m=0;for(let e=0;e<E.length;e++){for(x=E[e],m=1;x===E[e+1];)if(m++,e++,0===x){if(138<=m)break}else if(6<=m)break;if(4<=m)0===x?11<=m?I.push(18):I.push(17):(I.push(x),N.push(1),m--,I.push(16)),N.push(m);else for(let e=0;e<m;e++)I.push(x),N.push(1)}const A=h(I,7);let y,v=0;f.forEach(((e,t)=>{A.has(e)&&(v=t+1)})),e.writeRange(p-257,5),e.writeRange(B-1,5),e.writeRange(v-4,4);for(let t=0;t<v;t++)void 0!==(y=A.get(f[t]))?e.writeRange(y.bitlen,3):e.writeRange(0,3);I.forEach(((t,n)=>{if(void 0===(y=A.get(t)))throw new Error(\"Data is corrupted\");e.writeRangeCoded(y.code,y.bitlen),18===t?e.writeRange(N[n]-11,7):17===t?e.writeRange(N[n]-3,3):16===t&&e.writeRange(N[n]-3,2)}));for(let t=0,n=u.length;t<n;t++){const n=u[t],f=n[0],a=n[1];if(void 0!==a){if(void 0===(y=b.get(f+257)))throw new Error(\"Data is corrupted\");e.writeRangeCoded(y.code,y.bitlen),0<r[f]&&(m=n[2],e.writeRange(m-s[f],r[f]));const t=R.get(a);if(void 0===t)throw new Error(\"Data is corrupted\");if(e.writeRangeCoded(t.code,t.bitlen),0<o[a]){const t=n[3];e.writeRange(t-i[a],o[a])}}else{if(void 0===(y=b.get(f)))throw new Error(\"Data is corrupted\");e.writeRangeCoded(y.code,y.bitlen)}}if(void 0===(y=b.get(256)))throw new Error(\"Data is corrupted\");e.writeRangeCoded(y.code,y.bitlen)}class l{constructor(e,t=0){this.nowBitsLength=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsLength=8}read(){if(this.isEnd)throw new Error(\"Lack of data length\");const e=1&this.nowBits;return this.nowBitsLength>1?(this.nowBitsLength--,this.nowBits>>=1):(this.bufferIndex++,this.bufferIndex<this.buffer.length?(this.nowBits=this.buffer[this.bufferIndex],this.nowBitsLength=8):(this.nowBitsLength=0,this.isEnd=!0)),e}readRange(e){for(;this.nowBitsLength<=e;)this.nowBits|=this.buffer[++this.bufferIndex]<<this.nowBitsLength,this.nowBitsLength+=8;const t=this.nowBits&(1<<e)-1;return this.nowBits>>>=e,this.nowBitsLength-=e,t}readRangeCoded(e){let t=0;for(let n=0;n<e;n++)t<<=1,t|=this.read();return t}}class w{constructor(e){this.index=0,this.buffer=new Uint8Array(e),this.length=e,this._extendedSize=e}write(e){if(this.length<=this.index){this.length+=this._extendedSize;const e=new Uint8Array(this.length),t=this.buffer.length;for(let n=0;n<t;n++)e[n]=this.buffer[n];this.buffer=e}this.buffer[this.index]=e,this.index++}}const g=a(function(){const e={7:[],8:[],9:[]};for(let t=0;t<=287;t++)t<=143?e[8].push(t):t<=255?e[9].push(t):t<=279?e[7].push(t):e[8].push(t);return e}());function b(e,t){e.nowBitsLength<8&&e.readRange(e.nowBitsLength);const n=e.readRange(8)|e.readRange(8)<<8;if(n+(e.readRange(8)|e.readRange(8)<<8)!==65535)throw new Error(\"Data is corrupted\");for(let r=0;r<n;r++)t.write(e.readRange(8))}function R(e,t){const n=g,f=Object.keys(n);let a=0,h=0,d=Number.MAX_SAFE_INTEGER;f.forEach((e=>{a=Number(e),h<a&&(h=a),d>a&&(d=a)}));let u,c,l,w,b,R,E,p,B=0;for(;!e.isEnd;){for(u=void 0,a=d,B=e.readRangeCoded(d);void 0===(u=n[a][B]);){if(h<=a)throw new Error(\"Data is corrupted\");a++,B<<=1,B|=e.read()}if(u<256)t.write(u);else{if(256===u)break;l=s[c=u-257],0<(w=r[c])&&(l+=e.readRange(w)),b=e.readRangeCoded(5),R=i[b],0<(E=o[b])&&(R+=e.readRange(E)),p=t.index-R;for(let e=0;e<l;e++)t.write(t.buffer[p+e])}}}function E(e,t){const n=e.readRange(5)+257,h=e.readRange(5)+1,d=e.readRange(4)+4;let u=0;const c={};for(let t=0;t<d;t++)0!==(u=e.readRange(3))&&(c[u]||(c[u]=[]),c[u].push(f[t]));const l=a(c),w=Object.keys(l);let g=0,b=Number.MAX_SAFE_INTEGER;w.forEach((e=>{u=Number(e),g<u&&(g=u),b>u&&(b=u)}));const R={},E={};let p,B=0,I=0,N=0;const x=n+h;for(let t=0;t<x;){for(p=void 0,u=b,B=e.readRangeCoded(b);void 0===(p=l[u][B]);){if(g<=u)throw new Error(\"Data is corrupted\");u++,B<<=1,B|=e.read()}if(16===p?I=3+e.readRange(2):17===p?(I=3+e.readRange(3),N=0):18===p?(I=11+e.readRange(7),N=0):(I=1,N=p),N<=0)t+=I;else for(;I;)t<n?(R[N]||(R[N]=[]),R[N].push(t++)):(E[N]||(E[N]=[]),E[N].push(t++-n)),I--}const m=a(R),A=a(E),y=Object.keys(m);let v=0,C=0,D=Number.MAX_SAFE_INTEGER;y.forEach((e=>{v=Number(e),C<v&&(C=v),D>v&&(D=v)}));const k=Object.keys(A);let L=0,M=0,_=Number.MAX_SAFE_INTEGER;k.forEach((e=>{L=Number(e),M<L&&(M=L),_>L&&(_=L)}));let S,j,O,U,F,X,z,T,G,Y,P=0;for(;!e.isEnd;){for(S=void 0,v=D,P=e.readRangeCoded(D);void 0===(S=m[v][P]);){if(C<=v)throw new Error(\"Data is corrupted\");v++,P<<=1,P|=e.read()}if(S<256)t.write(S);else{if(256===S)break;for(O=s[j=S-257],0<(U=r[j])&&(O+=e.readRange(U)),F=void 0,T=_,G=e.readRangeCoded(_);void 0===(F=A[T][G]);){if(M<=T)throw new Error(\"Data is corrupted\");T++,G<<=1,G|=e.read()}X=i[F],0<(z=o[F])&&(X+=e.readRange(z)),Y=t.index-X;for(let e=0;e<O;e++)t.write(t.buffer[Y+e])}}}/**     * @license Copyright (c) 2018 zprodev     */return e.inflate=function(e){const n=new l(e);if(8!==n.readRange(4))throw new Error(\"Not compressed by deflate\");return n.readRange(4),n.readRange(5),n.readRange(1),n.readRange(2),function(e,n=0){const r=new w(10*e.length),s=new l(e,n);let i=0,o=0;for(;1!==i;){if(i=s.readRange(1),(o=s.readRange(2))===t.UNCOMPRESSED)b(s,r);else if(o===t.FIXED)R(s,r);else{if(o!==t.DYNAMIC)throw new Error(\"Not supported BTYPE : \"+o);E(s,r)}if(0===i&&s.isEnd)throw new Error(\"Data length is insufficient\")}return r.buffer.subarray(0,r.index)}(e,2)},e.deflate=function(e){const r=function(e){const r=e.length,s=new u(new Uint8Array(r<n/2?n:2*r));let i=0,o=0;for(;i+n>=r?(o=r-i,s.writeRange(1,1)):(o=n,s.writeRange(0,1)),s.writeRange(t.DYNAMIC,2),c(s,e,i,o),!((i+=n)>=r););return 0!==s.nowBitsIndex&&s.writeRange(0,8-s.nowBitsIndex),s.buffer.subarray(0,s.bufferIndex)}(e),s=new u(new Uint8Array(1));s.writeRange(8,4),s.writeRange(7,4);const i=new u(new Uint8Array(1));i.writeRange(28,5),i.writeRange(0,1),i.writeRange(2,2);const o=new u(new Uint8Array(4)),f=function(e){let t=1,n=0;const r=e.length;for(let s=0;s<r;s++)n=((t=(t+e[s])%65521)+n)%65521;return(n<<16)+t}(e);o.writeRange(f>>>24,8),o.writeRange(f>>>16&255,8),o.writeRange(f>>>8&255,8),o.writeRange(255&f,8);const a=new Uint8Array(r.length+6);return a.set(s.buffer),a.set(i.buffer,1),a.set(r,2),a.set(o.buffer,a.length-4),a},e}({});this.addEventListener(\"message\",(function(e){const t=encodeURIComponent(e.data.object),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n[e]=t[e].charCodeAt(0);const r=e.data.type;if(\"json\"===r)this.postMessage({json:JSON.stringify({buffer:Array.from(zlibes.deflate(n)),type:\"zlib\"}),type:r});else{const e=zlibes.deflate(n);this.postMessage({buffer:e,type:r},[e.buffer])}}));"], { "type": "text/javascript" })
));

/**
 * @param {MessageEvent} event
 * @public
 */
Util.$zlibWorker.onmessage = (event) =>
{
    const type = event.data.type;
    switch (type) {

        case "json":
        case "n2d":
            Util.$saveProgress.createFile();

            setTimeout(() =>
            {
                const anchor = document.getElementById("save-anchor");
                if (anchor.href) {
                    URL.revokeObjectURL(anchor.href);
                }

                anchor.download = `${Util.$currentWorkSpace().name}.${type}`;

                anchor.href = type === "json"
                    ? URL.createObjectURL(new Blob([event.data.json],   { "type" : "application/json" }))
                    : URL.createObjectURL(new Blob([event.data.buffer], { "type" : "text/plain" }));

                anchor.click();

                Util.$saveProgress.end();

            }, 200);
            break;

        case "local":
            {
                const buffer = event.data.buffer;

                new Promise((resolve) =>
                {
                    window.requestAnimationFrame(() =>
                    {
                        Util.$saveProgress.createBinary();

                        let binary = "";
                        for (let idx = 0; idx < buffer.length; idx += 4096) {
                            binary += String.fromCharCode.apply(
                                null, buffer.slice(idx, idx + 4096)
                            );
                        }

                        resolve(binary);
                    });
                })
                    .then((data) =>
                    {

                        Util.$saveProgress.launchDatabase(90);

                        const request = Util.$launchDB();

                        request.onsuccess = (event) =>
                        {
                            const db = event.target.result;
                            const transaction = db.transaction(
                                `${Util.DATABASE_NAME}`, "readwrite"
                            );

                            const store = transaction
                                .objectStore(`${Util.DATABASE_NAME}`);

                            store.put(data, Util.STORE_KEY);

                            transaction.oncomplete = (event) =>
                            {
                                event.target.db.close();
                                Util.$updated = false;
                                Util.$saveProgress.end();
                            };

                            Util.$saveProgress.commit();
                            transaction.commit();
                        };
                    });
            }

            break;

    }

    if (Util.$zlibQueues.length) {

        Util.$zlibWorker.postMessage(Util.$zlibQueues.pop());

    } else {

        Util.$zlibWorkerActive = false;

    }
};

Util.$zlibQueues       = [];
Util.$zlibWorkerActive = false;

// Unzip Worker
Util.$unzipURL = URL.createObjectURL(
    new Blob(["const Util={};Util.$Uint8Array=Uint8Array,Util.$Uint16Array=Uint16Array,Util.$Int16Array=Int16Array,Util.$ArrayBuffer=ArrayBuffer,Util.$max=Math.max,Util.$min=Math.min,Util.$potArrayBuffers=new Map,Util.$codeTables=[],Util.$getCodeTable=function(t,e){const i=Util.$codeTables.pop()||{key:null,value:null};return i.key=t,i.value=e,i},Util.$poolCodeTable=function(t){Util.$codeTables.push(t)},Util.$poolTypedArrayBuffer=function(t){const e=t.buffer,i=e.byteLength;if(!i||i!==Util.$upperPowerOfTwo(i))return;let r=Util.$potArrayBuffers.get(i);r||(r=[],Util.$potArrayBuffers.set(i,r)),r.push(e)},Util.$upperPowerOfTwo=function(t){return t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t},Util.$getUint8Array=function(t){let e;const i=Util.$upperPowerOfTwo(t),r=Util.$potArrayBuffers.get(i),l=r&&r.pop();return l?(e=new Util.$Uint8Array(l,0,t),e.fill(0)):e=new Util.$Uint8Array(new Util.$ArrayBuffer(i),0,t),e},Util.$getUint16Array=function(t){let e;const i=Util.$upperPowerOfTwo(2*t),r=Util.$potArrayBuffers.get(i),l=r&&r.pop();return l?(e=new Util.$Uint16Array(l,0,t),e.fill(0)):e=new Util.$Uint16Array(new Util.$ArrayBuffer(i),0,t),e},Util.$fixedDistTable={key:new Util.$Uint16Array([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]),value:new Util.$Uint16Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31])},Util.$fixedLitTable={key:new Util.$Uint16Array([7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9]),value:new Util.$Uint16Array([256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,280,281,282,283,284,285,286,287,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255])},Util.$ORDER=new Util.$Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Util.$LEXT=new Util.$Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,99,99]),Util.$LENS=new Util.$Int16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Util.$DEXT=new Util.$Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),Util.$DISTS=new Util.$Int16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577]);class ByteStream{constructor(){this.initialization()}initialization(){this.data=null,this.bit_offset=0,this.byte_offset=0,this.bit_buffer=null}byteAlign(){this.bit_offset&&(this.byte_offset=this.byte_offset+(this.bit_offset+7)/8|0,this.bit_offset=0)}getData(t){this.byteAlign();const e=this.byte_offset+t,i=this.data.slice(this.byte_offset,e);return this.byte_offset=e,i}setOffset(t,e){this.byte_offset=t,this.bit_offset=e}unzip(t,e=0){let i=e;const r=Util.$getUint8Array(19);let l=null,a=null;for(;;){const e=this.readUB(1),s=this.readUB(2);if(l&&(Util.$poolCodeTable(l),Util.$poolCodeTable(a)),l=null,a=null,s){if(1===s)l=Util.$fixedDistTable,a=Util.$fixedLitTable;else{const t=this.readUB(5)+257,e=this.readUB(5)+1,i=this.readUB(4)+4;for(let t=0;t<i;++t)r[Util.$ORDER[t]]=this.readUB(3);const s=this.buildHuffTable(r);r.fill(0);const f=t+e|0,o=Util.$getUint8Array(f);let n=0;for(let t=0;t<f;){const e=this.decodeSymbol(s.key,s.value);switch(e){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:o[t++]=e,n=e;break;case 16:{let e=this.readUB(2)+3|0;for(;e;)--e,o[t++]=n}break;case 17:{let e=this.readUB(3)+3|0;for(;e;)--e,o[t++]=0}break;case 18:{let e=this.readUB(7)+11|0;for(;e;)--e,o[t++]=0}}}Util.$poolCodeTable(s),l=this.buildHuffTable(o.subarray(t)),a=this.buildHuffTable(o.subarray(0,t)),Util.$poolTypedArrayBuffer(o),Util.$poolTypedArrayBuffer(s.key),Util.$poolTypedArrayBuffer(s.value)}for(;;){const e=0|this.decodeSymbol(a.key,a.value);if(256===e)break;if(e<256)t[i++]=e;else{const r=e-257|0;let a=Util.$LENS[r]+this.readUB(Util.$LEXT[r])|0;const s=this.decodeSymbol(l.key,l.value);let f=i-(Util.$DISTS[s]+this.readUB(Util.$DEXT[s])|0)|0;for(;a;)--a,t[i++]=t[f++]}}}else{this.bit_offset=8,this.bit_buffer=null;const e=0|this.readNumber(2);this.byte_offset+=2;for(let r=0;r<e;++r)t[i++]=this.readNumber(1)}if(e)break}Util.$poolTypedArrayBuffer(r)}buildHuffTable(t){const e=t.length,i=Util.$max.apply(null,t),r=Util.$getUint8Array(i),l=Util.$getUint16Array(i+1);let a=0,s=0,f=e;for(;f;)s=t[--f],s&&++r[s];let o=0;for(let t=0;t<i;)a=a+r[t++]<<1,l[t]=a,o=Util.$max(o,a);const n=o+e,U=Util.$getUint16Array(n),u=Util.$getUint16Array(n);for(let i=0;i<e;++i)if(s=t[i],s){const t=l[s];U[t]=s,u[t]=i,l[s]=t+1|0}return Util.$poolTypedArrayBuffer(r),Util.$poolTypedArrayBuffer(l),Util.$getCodeTable(U,u)}decodeSymbol(t,e){let i=0,r=0;for(;;)if(i=i<<1|this.readUB(1),++r,t[i]===r)return e[i]}readUB(t){let e=0;for(let i=0;i<t;++i)8===this.bit_offset&&(this.bit_buffer=this.readNumber(1),this.bit_offset=0),e|=(this.bit_buffer&1<<this.bit_offset++?1:0)<<i;return e}readNumber(t){let e=0;const i=this.byte_offset;let r=i+t|0;for(;r>i;)e=e<<8|this.data[--r];return this.byte_offset+=t,e}}Util.$byteStream=new ByteStream,Util.$lossless=function(t,e,i,r,l,a){const s=new Util.$Uint8Array(e*i*4);if(3===r){const r=(e+3&-4)-e;let f=0;if(a){let a=4*l;for(let l=0;l<i;++l){for(let i=0;i<e;++i){const e=4*t[a++],i=t[e+3];if(0===i){s[f++]=0,s[f++]=0,s[f++]=0,s[f++]=0;continue}const r=t[e],l=t[e+1],o=t[e+2];255!==i?(s[f++]=255&Util.$min(r/i*255,255),s[f++]=255&Util.$min(l/i*255,255),s[f++]=255&Util.$min(o/i*255,255),s[f++]=i):(s[f++]=r,s[f++]=l,s[f++]=o,s[f++]=i)}a+=r}return s}let o=3*l;for(let l=0;l<i;++l){for(let i=0;i<e;++i){const e=3*t[o++];s[f++]=t[e],s[f++]=t[e+1],s[f++]=t[e+2],s[f++]=255}o+=r}return s}const f=e*i;if(a){for(let e=0;e<f;++e){const i=4*e,r=i,l=i+1,a=i+2,f=i+3,o=t[r];0!==o?255!==o?(s[r]=255&Util.$min(t[l]/o*255,255),s[l]=255&Util.$min(t[a]/o*255,255),s[a]=255&Util.$min(t[f]/o*255,255),s[f]=o):(s[r]=t[l],s[l]=t[a],s[a]=t[f],s[f]=o):(s[r]=0,s[l]=0,s[a]=0,s[f]=0)}return s}for(let e=0;e<f;++e){const i=4*e,r=i+1,l=i+2,a=i+3;s[i]=t[r],s[r]=t[l],s[l]=t[a],s[a]=255}return s},this.addEventListener(\"message\",(function(t){const e=Util.$byteStream;switch(t.data.mode){case\"swf\":{e.data=t.data.buffer;const i=t.data.fileSize,r=new Util.$Uint8Array(i),l=e.getData(8);e.setOffset(10,8),r.set(l,0),e.unzip(r,8),this.postMessage({buffer:r,mode:t.data.mode},[r.buffer])}break;case\"lossless\":{const i=t.data,r=new Util.$Uint8Array(i.fileSize);e.data=t.data.buffer,e.setOffset(2,8),e.unzip(r,0);const l=Util.$lossless(r,i.width,i.height,i.format,i.tableSize,i.isAlpha);this.postMessage({buffer:l,mode:t.data.mode},[l.buffer])}break;case\"jpegAlpha\":{const i=t.data.width*t.data.height,r=new Util.$Uint8Array(i);e.data=t.data.alphaData,e.setOffset(2,8),e.unzip(r,0),t.data.alphaData=r,this.postMessage(t.data,[t.data.buffer.buffer,t.data.alphaData.buffer])}}Util.$byteStream.initialization()}));"], { "type": "text/javascript" }
    ));
Util.$unzipWorker       = null;
Util.$unzipQueues       = [];
Util.$unzipWorkerActive = false;

/**
 * @return {IDBOpenDBRequest}
 * @static
 */
Util.$launchDB = () =>
{
    const request = indexedDB.open(
        `${Util.PREFIX}@${Util.DATABASE_NAME}`
    );

    request.onupgradeneeded = (event) =>
    {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(`${Util.DATABASE_NAME}`)) {
            db.createObjectStore(`${Util.DATABASE_NAME}`);
        }
    };

    return request;
};

/**
 * @param  {object} event
 * @return void
 * @static
 */
Util.$unzipHandler = function (event)
{
    const worker = event.target;

    // event end
    worker.onmessage = null;

    // setup
    switch (event.data.mode) {

        case "swf":
            this._$byteStream._$buffer = event.data.buffer;
            this.parseAndBuild();
            break;

        case "lossless":
            {
                const workSpace    = Util.$currentWorkSpace();
                const instance     = workSpace.getLibrary(this.libraryId);
                instance._$buffer  = event.data.buffer;
                instance._$command = null;
            }
            break;

        case "jpegAlpha":
            {
                const buffer    = event.data.buffer;
                const alphaData = event.data.alphaData;

                let index = 0;
                for (let idx = 0; idx < buffer.length; idx += 4) {
                    buffer[idx + 3] = alphaData[index++];
                }

                const workSpace    = Util.$currentWorkSpace();
                const instance     = workSpace.getLibrary(this.libraryId);
                instance._$buffer  = buffer;
                instance._$command = null;
            }
            break;

    }

    // next
    if (Util.$unzipQueues.length) {
        const object = Util.$unzipQueues.shift();
        worker.onmessage = Util.$unzipHandler.bind(object);
        switch (object.mode) {

            case "swf":
                {
                    const buffer = object._$byteStream._$buffer;
                    worker.postMessage({
                        "fileSize": object.fileSize,
                        "mode":     object.mode,
                        "buffer":   buffer
                    }, [buffer.buffer]);
                }
                break;

            case "lossless":
                worker.postMessage(object, [object.buffer.buffer]);
                break;

            case "jpegAlpha":
                worker.postMessage(object, [
                    object.buffer.buffer,
                    object.alphaData.buffer
                ]);
                break;

        }

    } else {

        Util.$unzipWorkerActive = false;

    }

};

Util.$unlzmaWorkerURL = URL.createObjectURL(
    new Blob(["const LZMA={init:function(e){const t=[];t.push(e[12],e[13],e[14],e[15],e[16],e[4],e[5],e[6],e[7]);let s=8;for(let e=5;e<9;++e){if(t[e]>=s){t[e]=t[e]-s|0;break}t[e]=256+t[e]-s|0,s=1}return t.push(0,0,0,0),e.set(t,4),e.subarray(4)},reverseDecode2:function(e,t,s,i){let r=1,o=0,d=0;for(;d<i;++d){const i=s.decodeBit(e,t+r);r=r<<1|i,o|=i<<d}return o},decompress:function(e,t){const s=new Decoder,i=s.decodeHeader(e),r=i.uncompressedSize;if(s.setProperties(i),!s.decodeBody(e,t,r))throw new Error(\"Error in lzma data stream\");return t}};class OutWindow{constructor(){this._buffer=null,this._stream=null,this._pos=0,this._streamPos=0,this._windowSize=0}create(e){this._buffer&&this._windowSize===e||(this._buffer=new Uint8Array(e)),this._windowSize=e}flush(){const e=this._pos-this._streamPos;e&&(this._stream.writeBytes(this._buffer,e),this._pos>=this._windowSize&&(this._pos=0),this._streamPos=this._pos)}releaseStream(){this.flush(),this._stream=null}setStream(e){this._stream=e}init(e=!1){e||(this._streamPos=0,this._pos=0)}copyBlock(e,t){let s=this._pos-e-1;for(s<0&&(s+=this._windowSize);t--;)s>=this._windowSize&&(s=0),this._buffer[this._pos++]=this._buffer[s++],this._pos>=this._windowSize&&this.flush()}putByte(e){this._buffer[this._pos++]=e,this._pos>=this._windowSize&&this.flush()}getByte(e){let t=this._pos-e-1;return t<0&&(t+=this._windowSize),this._buffer[t]}}class RangeDecoder{constructor(){this._stream=null,this._code=0,this._range=-1}setStream(e){this._stream=e}releaseStream(){this._stream=null}init(){let e=5;for(this._code=0,this._range=-1;e--;)this._code=this._code<<8|this._stream.readByte()}decodeDirectBits(e){let t=0,s=e;for(;s--;){this._range>>>=1;const e=this._code-this._range>>>31;this._code-=this._range&e-1,t=t<<1|1-e,0==(4278190080&this._range)&&(this._code=this._code<<8|this._stream.readByte(),this._range<<=8)}return t}decodeBit(e,t){const s=e[t],i=(this._range>>>11)*s;return(2147483648^this._code)<(2147483648^i)?(this._range=i,e[t]+=2048-s>>>5,0==(4278190080&this._range)&&(this._code=this._code<<8|this._stream.readByte(),this._range<<=8),0):(this._range-=i,this._code-=i,e[t]-=s>>>5,0==(4278190080&this._range)&&(this._code=this._code<<8|this._stream.readByte(),this._range<<=8),1)}}class BitTreeDecoder{constructor(e){this._models=Array(1<<e).fill(1024),this._numBitLevels=e}decode(e){let t=1,s=this._numBitLevels;for(;s--;)t=t<<1|e.decodeBit(this._models,t);return t-(1<<this._numBitLevels)}reverseDecode(e){let t=1,s=0,i=0;for(;i<this._numBitLevels;++i){const r=e.decodeBit(this._models,t);t=t<<1|r,s|=r<<i}return s}}class LenDecoder{constructor(){this._choice=[1024,1024],this._lowCoder=[],this._midCoder=[],this._highCoder=new BitTreeDecoder(8),this._numPosStates=0}create(e){for(;this._numPosStates<e;++this._numPosStates)this._lowCoder[this._numPosStates]=new BitTreeDecoder(3),this._midCoder[this._numPosStates]=new BitTreeDecoder(3)}decode(e,t){return 0===e.decodeBit(this._choice,0)?this._lowCoder[t].decode(e):0===e.decodeBit(this._choice,1)?8+this._midCoder[t].decode(e):16+this._highCoder.decode(e)}}class Decoder2{constructor(){this._decoders=Array(768).fill(1024)}decodeNormal(e){let t=1;do{t=t<<1|e.decodeBit(this._decoders,t)}while(t<256);return 255&t}decodeWithMatchByte(e,t){let s=1;do{const i=t>>7&1;t<<=1;const r=e.decodeBit(this._decoders,(1+i<<8)+s);if(s=s<<1|r,i!==r){for(;s<256;)s=s<<1|e.decodeBit(this._decoders,s);break}}while(s<256);return 255&s}}class LiteralDecoder{create(e,t){if(this._coders&&this._numPrevBits===t&&this._numPosBits===e)return;this._numPosBits=e,this._posMask=(1<<e)-1,this._numPrevBits=t,this._coders=[];let s=1<<this._numPrevBits+this._numPosBits;for(;s--;)this._coders[s]=new Decoder2}getDecoder(e,t){return this._coders[((e&this._posMask)<<this._numPrevBits)+((255&t)>>>8-this._numPrevBits)]}}class Decoder{constructor(){this._outWindow=new OutWindow,this._rangeDecoder=new RangeDecoder,this._isMatchDecoders=Array(192).fill(1024),this._isRepDecoders=Array(12).fill(1024),this._isRepG0Decoders=Array(12).fill(1024),this._isRepG1Decoders=Array(12).fill(1024),this._isRepG2Decoders=Array(12).fill(1024),this._isRep0LongDecoders=Array(192).fill(1024),this._posDecoders=Array(114).fill(1024),this._posAlignDecoder=new BitTreeDecoder(4),this._lenDecoder=new LenDecoder,this._repLenDecoder=new LenDecoder,this._literalDecoder=new LiteralDecoder,this._dictionarySize=-1,this._dictionarySizeCheck=-1,this._posSlotDecoder=[new BitTreeDecoder(6),new BitTreeDecoder(6),new BitTreeDecoder(6),new BitTreeDecoder(6)]}setDictionarySize(e){return!(e<0)&&(this._dictionarySize!==e&&(this._dictionarySize=e,this._dictionarySizeCheck=Math.max(this._dictionarySize,1),this._outWindow.create(Math.max(this._dictionarySizeCheck,4096))),!0)}setLcLpPb(e,t,s){if(e>8||t>4||s>4)return!1;const i=1<<s;return this._literalDecoder.create(t,e),this._lenDecoder.create(i),this._repLenDecoder.create(i),this._posStateMask=i-1,!0}setProperties(e){if(!this.setLcLpPb(e.lc,e.lp,e.pb))throw Error(\"Incorrect stream properties\");if(!this.setDictionarySize(e.dictionarySize))throw Error(\"Invalid dictionary size\")}decodeHeader(e){if(e._$size<13)return!1;let t=e.readByte();const s=t%9;t=~~(t/9);const i=t%5,r=~~(t/5);let o=e.readByte();o|=e.readByte()<<8,o|=e.readByte()<<16,o+=16777216*e.readByte();let d=e.readByte();return d|=e.readByte()<<8,d|=e.readByte()<<16,d+=16777216*e.readByte(),e.readByte(),e.readByte(),e.readByte(),e.readByte(),{lc:s,lp:i,pb:r,dictionarySize:o,uncompressedSize:d}}decodeBody(e,t,s){let i,r,o=0,d=0,h=0,c=0,n=0,_=0,a=0;for(this._rangeDecoder.setStream(e),this._rangeDecoder.init(),this._outWindow.setStream(t),this._outWindow.init(!1);_<s;){const e=_&this._posStateMask;if(0===this._rangeDecoder.decodeBit(this._isMatchDecoders,(o<<4)+e)){const e=this._literalDecoder.getDecoder(_++,a);a=o>=7?e.decodeWithMatchByte(this._rangeDecoder,this._outWindow.getByte(d)):e.decodeNormal(this._rangeDecoder),this._outWindow.putByte(a),o=o<4?0:o-(o<10?3:6)}else{if(1===this._rangeDecoder.decodeBit(this._isRepDecoders,o))i=0,0===this._rangeDecoder.decodeBit(this._isRepG0Decoders,o)?0===this._rangeDecoder.decodeBit(this._isRep0LongDecoders,(o<<4)+e)&&(o=o<7?9:11,i=1):(0===this._rangeDecoder.decodeBit(this._isRepG1Decoders,o)?r=h:(0===this._rangeDecoder.decodeBit(this._isRepG2Decoders,o)?r=c:(r=n,n=c),c=h),h=d,d=r),0===i&&(i=2+this._repLenDecoder.decode(this._rangeDecoder,e),o=o<7?8:11);else{n=c,c=h,h=d,i=2+this._lenDecoder.decode(this._rangeDecoder,e),o=o<7?7:10;const t=this._posSlotDecoder[i<=5?i-2:3].decode(this._rangeDecoder);if(t>=4){const e=(t>>1)-1;if(d=(2|1&t)<<e,t<14)d+=LZMA.reverseDecode2(this._posDecoders,d-t-1,this._rangeDecoder,e);else if(d+=this._rangeDecoder.decodeDirectBits(e-4)<<4,d+=this._posAlignDecoder.reverseDecode(this._rangeDecoder),d<0){if(-1===d)break;return!1}}else d=t}if(d>=_||d>=this._dictionarySizeCheck)return!1;this._outWindow.copyBlock(d,i),_+=i,a=this._outWindow.getByte(0)}}return this._outWindow.releaseStream(),this._rangeDecoder.releaseStream(),!0}}class InStream{constructor(e){this._$data=e,this._$size=e.length,this._$offset=0}readByte(){return this._$data[this._$offset++]}}class OutStream{constructor(e){this.size=8,this.buffers=e}writeBytes(e,t){e.length===t?this.buffers.set(e,this.size):this.buffers.set(e.subarray(0,t),this.size),this.size+=t}}this.addEventListener(\"message\",(function(e){const t=e.data.fileSize,s=e.data.buffer,i=new Uint8Array(t+8);i.set(s.slice(0,8),0),LZMA.decompress(new InStream(LZMA.init(s)),new OutStream(i)),this.postMessage(i,[i.buffer]),this.close()}));"], { "type": "text/javascript" })
);
Util.$unlzmaQueues       = [];
Util.$unlzmaWorkerActive = false;

Util.$parserURL = URL.createObjectURL(
    new Blob(["const Util={$tagObjects:[]};Util.$installed=new Map,Util.$swfParser=null,Util.$Rad2Deg=180/Math.PI,Util.$JCT11280=Function('var a=\"zKV33~jZ4zN=~ji36XazM93y!{~k2y!o~k0ZlW6zN?3Wz3W?{EKzK[33[`y|;-~j^YOTz$!~kNy|L1$353~jV3zKk3~k-4P4zK_2+~jY4y!xYHR~jlz$_~jk4z$e3X5He<0y!wy|X3[:~l|VU[F3VZ056Hy!nz/m1XD61+1XY1E1=1y|bzKiz!H034zKj~mEz#c5ZA3-3X$1~mBz$$3~lyz#,4YN5~mEz#{ZKZ3V%7Y}!J3X-YEX_J(3~mAz =V;kE0/y|F3y!}~m>z/U~mI~j_2+~mA~jp2;~m@~k32;~m>V}2u~mEX#2x~mBy+x2242(~mBy,;2242(~may->2&XkG2;~mIy-_2&NXd2;~mGz,{4<6:.:B*B:XC4>6:.>B*BBXSA+A:X]E&E<~r#z+625z s2+zN=`HXI@YMXIAXZYUM8X4K/:Q!Z&33 3YWX[~mB`{zKt4z (zV/z 3zRw2%Wd39]S11z$PAXH5Xb;ZQWU1ZgWP%3~o@{Dgl#gd}T){Uo{y5_d{e@}C(} WU9|cB{w}bzvV|)[} H|zT}d||0~{]Q|(l{|x{iv{dw}(5}[Z|kuZ }cq{{y|ij}.I{idbof%cu^d}Rj^y|-M{ESYGYfYsZslS`?ZdYO__gLYRZ&fvb4oKfhSf^d<Yeasc1f&a=hnYG{QY{D`Bsa|u,}Dl|_Q{C%xK|Aq}C>|c#ryW=}eY{L+`)][YF_Ub^h4}[X|?r|u_ex}TL@YR]j{SrXgo*|Gv|rK}B#mu{R1}hs|dP{C7|^Qt3|@P{YVV |8&}#D}ef{e/{Rl|>Hni}R1{Z#{D[}CQlQ||E}[s{SG_+i8eplY[=[|ec[$YXn#`hcm}YR|{Ci(_[ql|?8p3]-}^t{wy}4la&pc|3e{Rp{LqiJ],] `kc(]@chYnrM`O^,ZLYhZB]ywyfGY~aex!_Qww{a!|)*lHrM{N+n&YYj~Z b c#e_[hZSon|rOt`}hBXa^i{lh|<0||r{KJ{kni)|x,|0auY{D!^Sce{w;|@S|cA}Xn{C1h${E]Z-XgZ*XPbp]^_qbH^e[`YM|a||+=]!Lc}]vdBc=j-YSZD]YmyYLYKZ9Z>Xcczc2{Yh}9Fc#Z.l{}(D{G{{mRhC|L3b#|xK[Bepj#ut`H[,{E9Yr}1b{[e]{ZFk7[ZYbZ0XL]}Ye[(`d}c!|*y`Dg=b;gR]Hm=hJho}R-[n}9;{N![7k_{UbmN]rf#pTe[x8}!Qcs_rs[m`|>N}^V})7{^r|/E}),}HH{OYe2{Skx)e<_.cj.cjoMhc^d}0uYZd!^J_@g,[[[?{i@][|3S}Yl3|!1|eZ|5IYw|1D}e7|Cv{OHbnx-`wvb[6[4} =g+k:{C:}ed{S]|2M]-}WZ|/q{LF|dYu^}Gs^c{Z=}h>|/i|{W]:|ip{N:|zt|S<{DH[p_tvD{N<[8Axo{X4a.^o^X>Yfa59`#ZBYgY~_t^9`jZHZn`>G[oajZ;X,i)Z.^~YJe ZiZF^{][[#Zt^|]Fjx]&_5dddW]P0C[-]}]d|y {C_jUql] |OpaA[Z{lp|rz}:Mu#]_Yf6{Ep?f5`$[6^D][^u[$[6^.Z8]]ePc2U/=]K^_+^M{q*|9tYuZ,s(dS{i=|bNbB{uG}0jZOa:[-]dYtu3]:]<{DJ_SZIqr_`l=Yt`gkTnXb3d@kiq0a`Z{|!B|}e}Ww{Sp,^Z|0>_Z}36|]A|-t}lt{R6pi|v8hPu#{C>YOZHYmg/Z4nicK[}hF_Bg|YRZ7c|crkzYZY}_iXcZ.|)U|L5{R~qi^Uga@Y[xb}&qdbd6h5|Btw[}c<{Ds53[Y7]?Z<|e0{L[ZK]mXKZ#Z2^tavf0`PE[OSOaP`4gi`qjdYMgys/?[nc,}EEb,eL]g[n{E_b/vcvgb.{kcwi`~v%|0:|iK{Jh_vf5lb}KL|(oi=LrzhhY_^@`zgf[~g)[J_0fk_V{T)}I_{D&_/d9W/|MU[)f$xW}?$xr4<{Lb{y4}&u{XJ|cm{Iu{jQ}CMkD{CX|7A}G~{kt)nB|d5|<-}WJ}@||d@|Iy}Ts|iL|/^|no|0;}L6{Pm]7}$zf:|r2}?C_k{R(}-w|`G{Gy[g]bVje=_0|PT{^Y^yjtT[[[l!Ye_`ZN]@[n_)j3nEgMa]YtYpZy].d-Y_cjb~Y~[nc~sCi3|zg}B0}do{O^{|$`_|D{}U&|0+{J3|8*]iayx{a{xJ_9|,c{Ee]QXlYb]$[%YMc*]w[aafe]aVYi[fZEii[xq2YQZHg]Y~h#|Y:thre^@^|_F^CbTbG_1^qf7{L-`VFx Zr|@EZ;gkZ@slgko`[e}T:{Cu^pddZ_`yav^Ea+[#ZBbSbO`elQfLui}.F|txYcbQ`XehcGe~fc^RlV{D_0ZAej[l&jShxG[ipB_=u:eU}3e8[=j|{D(}dO{Do[BYUZ0/]AYE]ALYhZcYlYP/^-^{Yt_1_-;YT`P4BZG=IOZ&]H[e]YYd[9^F[1YdZxZ?Z{Z<]Ba2[5Yb[0Z4l?]d_;_)a?YGEYiYv`_XmZs4ZjY^Zb]6gqGaX^9Y}dXZr[g|]Y}K aFZp^k^F]M`^{O1Ys]ZCgCv4|E>}8eb7}l`{L5[Z_faQ|c2}Fj}hw^#|Ng|B||w2|Sh{v+[G}aB|MY}A{|8o}X~{E8paZ:]i^Njq]new)`-Z>haounWhN}c#{DfZ|fK]KqGZ=:u|fqoqcv}2ssm}.r{]{nIfV{JW)[K|,Z{Uxc|]l_KdCb%]cfobya3`p}G^|LZiSC]U|(X|kBlVg[kNo({O:g:|-N|qT}9?{MBiL}Sq{`P|3a|u.{Uaq:{_o|^S}jX{Fob0`;|#y_@[V[K|cw[<_ }KU|0F}d3|et{Q7{LuZttsmf^kYZ`Af`}$x}U`|Ww}d]| >}K,r&|XI|*e{C/a-bmr1fId4[;b>tQ_:]hk{b-pMge]gfpo.|(w[jgV{EC1Z,YhaY^q,_G[c_g[J0YX]`[h^hYK^_Yib,` {i6vf@YM^hdOKZZn(jgZ>bzSDc^Z%[[o9[2=/YHZ(_/Gu_`*|8z{DUZxYt^vuvZjhi^lc&gUd4|<UiA`z]$b/Z?l}YI^jaHxe|;F}l${sQ}5g}hA|e4}?o{ih}Uz{C)jPe4]H^J[Eg[|AMZMlc}:,{iz}#*|gc{Iq|/:|zK{l&}#u|myd{{M&v~nV};L|(g|I]ogddb0xsd7^V})$uQ{HzazsgxtsO^l}F>ZB]r|{7{j@cU^{{CbiYoHlng]f+nQ[bkTn/}<-d9q {KXadZYo+n|l[|lc}V2{[a{S4Zam~Za^`{HH{xx_SvF|ak=c^[v^7_rYT`ld@]:_ub%[$[m](Shu}G2{E.ZU_L_R{tz`vj(f?^}hswz}GdZ}{S:h`aD|?W|`dgG|if{a8|J1{N,}-Ao3{H#{mfsP|[ bzn+}_Q{MT{u4kHcj_q`eZj[8o0jy{p7}C|[}l){MuYY{|Ff!Ykn3{rT|m,^R|,R}$~Ykgx{P!]>iXh6[l[/}Jgcg{JYZ.^qYfYIZl[gZ#Xj[Pc7YyZD^+Yt;4;`e8YyZVbQ7YzZxXja.7SYl[s]2^/Ha$[6ZGYrb%XiYdf2]H]kZkZ*ZQ[ZYS^HZXcCc%Z|[(bVZ]]:OJQ_DZCg<[,]%Zaa [g{C00HY[c%[ChyZ,Z_`PbXa+eh`^&jPi0a[ggvhlekL]w{Yp^v}[e{~;k%a&k^|nR_z_Qng}[E}*Wq:{k^{FJZpXRhmh3^p>de^=_7`|ZbaAZtdhZ?n4ZL]u`9ZNc3g%[6b=e.ZVfC[ZZ^^^hD{E(9c(kyZ=bb|Sq{k`|vmr>izlH[u|e`}49}Y%}FT{[z{Rk}Bz{TCc/lMiAqkf(m$hDc;qooi[}^o:c^|Qm}a_{mrZ(pA`,}<2sY| adf_%|}`}Y5U;}/4|D>|$X{jw{C<|F.hK|*A{MRZ8Zsm?imZm_?brYWZrYx`yVZc3a@f?aK^ojEd {bN}/3ZH]/$YZhm^&j 9|(S|b]mF}UI{q&aM]LcrZ5^.|[j`T_V_Gak}9J[ ZCZD|^h{N9{~&[6Zd{}B}2O|cv]K}3s}Uy|l,fihW{EG`j_QOp~Z$F^zexS`dcISfhZBXP|.vn|_HYQ|)9|cr]<`&Z6]m_(ZhPcSg>`Z]5`~1`0Xcb4k1{O!bz|CN_T{LR|a/gFcD|j<{Z._[f)mPc:1`WtIaT1cgYkZOaVZOYFrEe[}T$}Ch}mk{K-^@]fH{Hdi`c*Z&|Kt{if[C{Q;{xYB`dYIX:ZB[}]*[{{p9|4GYRh2ao{DS|V+[zd$`F[ZXKadb*A] Ys]Maif~a/Z2bmclb8{Jro_rz|x9cHojbZ{GzZx_)]:{wAayeDlx}<=`g{H1{l#}9i|)=|lP{Qq}.({La|!Y{i2EZfp=c*}Cc{EDvVB|;g}2t{W4av^Bn=]ri,|y?|3+}T*ckZ*{Ffr5e%|sB{lx^0]eZb]9[SgAjS_D|uHZx]dive[c.YPkcq/}db{EQh&hQ|eg}G!ljil|BO]X{Qr_GkGl~YiYWu=c3eb}29v3|D|}4i||.{Mv})V{SP1{FX}CZW6{cm|vO{pS|e#}A~|1i}81|Mw}es|5[}3w{C`h9aL]o{}p[G`>i%a1Z@`Ln2bD[$_h`}ZOjhdTrH{[j_:k~kv[Sdu]CtL}41{I |[[{]Zp$]XjxjHt_eThoa#h>sSt8|gK|TVi[Y{t=}Bs|b7Zpr%{gt|Yo{CS[/{iteva|cf^hgn}($_c^wmb^Wm+|55jrbF|{9^ q6{C&c+ZKdJkq_xOYqZYSYXYl`8]-cxZAq/b%b*_Vsa[/Ybjac/OaGZ4fza|a)gY{P?| I|Y |,pi1n7}9bm9ad|=d{aV|2@[(}B`d&|Uz}B}{`q|/H|!JkM{FU|CB|.{}Az}#P|lk}K{|2rk7{^8^?`/|k>|Ka{Sq}Gz}io{DxZh[yK_#}9<{TRdgc]`~Z>JYmYJ]|`!ZKZ]gUcx|^E[rZCd`f9oQ[NcD_$ZlZ;Zr}mX|=!|$6ZPZYtIo%fj}CpcN|B,{VDw~gb}@hZg`Q{LcmA[(bo`<|@$|o1|Ss}9Z_}tC|G`{F/|9nd}i=}V-{L8aaeST]daRbujh^xlpq8|}zs4bj[S`J|]?G{P#{rD{]I`OlH{Hm]VYuSYUbRc*6[j`8]pZ[bt_/^Jc*[<Z?YE|Xb|?_Z^Vcas]h{t9|Uwd)_(=0^6Zb{Nc} E[qZAeX[a]P^|_J>e8`W^j_Y}R{{Jp__]Ee#e:iWb9q_wKbujrbR}CY`,{mJ}gz{Q^{t~N|? gSga`V_||:#mi}3t|/I`X{N*|ct|2g{km}gi|{={jC}F;|E}{ZZjYf*frmu}8Tdroi{T[|+~}HG{cJ}DM{Lp{Ctd&}$hi3|FZ| m}Kr|38}^c|m_|Tr{Qv|36}?Up>|;S{DV{k_as}BK{P}}9p|t`jR{sAm4{D=b4pWa[}Xi{EjwEkI}3S|E?u=X0{jf} S|NM|JC{qo^3cm]-|JUx/{Cj{s>{Crt[UXuv|D~|j|d{YXZR}Aq}0r}(_{pJfi_z}0b|-vi)Z mFe,{f4|q`b{}^Z{HM{rbeHZ|^x_o|XM|L%|uFXm}@C_{{Hhp%a7|0p[Xp+^K}9U{bP}: tT}B|}+$|b2|[^|~h{FAby[`{}xgygrt~h1[li`c4vz|,7p~b(|mviN}^pg[{N/|g3|^0c,gE|f%|7N{q[|tc|TKA{LU}I@|AZp(}G-sz{F |qZ{}F|f-}RGn6{Z]_5})B}UJ{FFb2]4ZI@v=k,]t_Dg5Bj]Z-]L]vrpdvdGlk|gF}G]|IW}Y0[G| /bo|Te^,_B}#n^^{QHYI[?hxg{[`]D^IYRYTb&kJ[cri[g_9]Ud~^_]<p@_e_XdNm-^/|5)|h_{J;{kacVopf!q;asqd}n)|.m|bf{QW|U)}b+{tL|w``N|to{t ZO|T]jF}CB|0Q{e5Zw|k |We}5:{HO{tPwf_uajjBfX}-V_C_{{r~gg|Ude;s+}KNXH}! `K}eW{Upwbk%ogaW}9EYN}YY|&v|SL{C3[5s.]Y]I]u{M6{pYZ`^,`ZbCYR[1mNg>rsk0Ym[jrE]RYiZTr*YJ{Ge|%-lf|y(`=[t}E6{k!|3)}Zk} ][G{E~cF{u3U.rJ|a9p#o#ZE|?|{sYc#vv{E=|LC}cu{N8`/`3`9rt[4|He{cq|iSYxY`}V |(Q|t4{C?]k_Vlvk)BZ^r<{CL}#h}R+[<|i=}X|{KAo]|W<`K{NW|Zx}#;|fe{IMr<|K~tJ_x}AyLZ?{GvbLnRgN}X&{H7|x~}Jm{]-| GpNu0}.ok>|c4{PYisrDZ|fwh9|hfo@{H~XSbO]Odv]%`N]b1Y]]|eIZ}_-ZA]aj,>eFn+j[aQ_+]h[J_m_g]%_wf.`%k1e#Z?{CvYu_B^|gk`Xfh^M3`afGZ-Z|[m{L}|k3cp[it ^>YUi~d>{T*}YJ{Q5{Jxa$hg|%4`}|LAgvb }G}{P=|<;Ux{_skR{cV|-*|s-{Mp|XP|$G|_J}c6cM{_=_D|*9^$ec{V;|4S{qO|w_|.7}d0|/D}e}|0G{Dq]Kdp{}dfDi>}B%{Gd|nl}lf{C-{y}|ANZr}#={T~|-(}c&{pI|ft{lsVP}){|@u}!W|bcmB{d?|iW|:dxj{PSkO|Hl]Li:}VYk@|2={fnWt{M3`cZ6|)}|Xj}BYa?vo{e4|L7|B7{L7|1W|lvYO}W8nJ|$Vih|{T{d*_1|:-n2dblk``fT{Ky|-%}m!|Xy|-a{Pz}[l{kFjz|iH}9N{WE{x,|jz}R {P|{D)c=nX|Kq|si}Ge{sh|[X{RF{t`|jsr*fYf,rK|/9}$}}Nf{y!1|<Std}4Wez{W${Fd_/^O[ooqaw_z[L`Nbv[;l7V[ii3_PeM}.h^viqYjZ*j1}+3{bt{DR[;UG}3Og,rS{JO{qw{d<_zbAh<R[1_r`iZTbv^^a}c{iEgQZ<exZFg.^Rb+`Uj{a+{z<[~r!]`[[|rZYR|?F|qppp]L|-d|}K}YZUM|=Y|ktm*}F]{D;g{uI|7kg^}%?Z%ca{N[_<q4xC]i|PqZC]n}.bDrnh0Wq{tr|OMn6tM|!6|T`{O`|>!]ji+]_bTeU}Tq|ds}n|{Gm{z,f)}&s{DPYJ`%{CGd5v4tvb*hUh~bf]z`jajiFqAii]bfy^U{Or|m+{I)cS|.9k:e3`^|xN}@Dnlis`B|Qo{`W|>||kA}Y}{ERYuYx`%[exd`]|OyiHtb}HofUYbFo![5|+]gD{NIZR|Go}.T{rh^4]S|C9_}xO^i`vfQ}C)bK{TL}cQ|79iu}9a];sj{P.o!f[Y]pM``Jda^Wc9ZarteBZClxtM{LW}l9|a.mU}KX}4@{I+f1}37|8u}9c|v${xGlz}jP{Dd1}e:}31}%3X$|22i<v+r@~mf{sN{C67G97855F4YL5}8f{DT|xy{sO{DXB334@55J1)4.G9A#JDYtXTYM4, YQD9;XbXm9SX]IB^4UN=Xn<5(;(F3YW@XkH-X_VM[DYM:5XP!T&Y`6|,^{IS-*D.H>:LXjYQ0I3XhAF:9:(==.F*3F1189K/7163D,:@|e2{LS36D4hq{Lw/84443@4.933:0307::6D7}&l{Mx657;89;,K5678H&93D(H<&<>0B90X^I;}Ag1{P%3A+>><975}[S{PZE453?4|T2{Q+5187;>447:81{C=hL6{Me^:=7ii{R=.=F<81;48?|h8}Uh{SE|,VxL{ST,7?9Y_5Xk3A#:$%YSYdXeKXOD8+TXh7(@>(YdXYHXl9J6X_5IXaL0N?3YK7Xh!1?XgYz9YEXhXaYPXhC3X`-YLY_XfVf[EGXZ5L8BXL9YHX]SYTXjLXdJ: YcXbQXg1PX]Yx4|Jr{Ys4.8YU+XIY`0N,<H%-H;:0@,74/:8546I=9177154870UC]d<C3HXl7ALYzXFXWP<<?E!88E5@03YYXJ?YJ@6YxX-YdXhYG|9o{`iXjY_>YVXe>AYFX[/(I@0841?):-B=14337:8=|14{c&93788|di{cW-0>0<097/A;N{FqYpugAFT%X/Yo3Yn,#=XlCYHYNX[Xk3YN:YRT4?)-YH%A5XlYF3C1=NWyY}>:74-C673<69545v {iT85YED=64=.F4..9878/D4378?48B3:7:7/1VX[f4{D,{l<5E75{dAbRB-8-@+;DBF/$ZfW8S<4YhXA.(5@*11YV8./S95C/0R-A4AXQYI7?68167B95HA1*<M3?1/@;/=54XbYP36}lc{qzSS38:19?,/39193574/66878Yw1X-87E6=;964X`T734:>86>1/=0;(I-1::7ALYGXhF+Xk[@W%TYbX7)KXdYEXi,H-XhYMRXfYK?XgXj.9HX_SX]YL1XmYJ>Y}WwIXiI-3-GXcYyXUYJ$X`Vs[7;XnYEZ;XF! 3;%8;PXX(N3Y[)Xi1YE&/ :;74YQ6X`33C;-(>Xm0(TYF/!YGXg8 9L5P01YPXO-5%C|qd{{/K/E6,=0144:361:955;6443@?B7*7:F89&F35YaX-CYf,XiFYRXE_e{}sF 0*7XRYPYfXa5YXXY8Xf8Y~XmA[9VjYj*#YMXIYOXk,HHX40YxYMXU8OXe;YFXLYuPXP?EB[QV0CXfY{:9XV[FWE0D6X^YVP*$4%OXiYQ(|xp|%c3{}V`1>Y`XH00:8/M6XhQ1:;3414|TE|&o@1*=81G8<3}6<|(f6>>>5-5:8;093B^3U*+*^*UT30XgYU&7*O1953)5@E78--F7YF*B&0:%P68W9Zn5974J9::3}Vk|-,C)=)1AJ4+<3YGXfY[XQXmT1M-XcYTYZXCYZXEYXXMYN,17>XIG*SaS|/eYJXbI?XdNZ+WRYP<F:R PXf;0Xg`$|1GX9YdXjLYxWX!ZIXGYaXNYm6X9YMX?9EXmZ&XZ#XQ>YeXRXfAY[4 ;0X!Zz0XdN$XhYL XIY^XGNXUYS/1YFXhYk.TXn4DXjB{jg|4DEX]:XcZMW=A.+QYL<LKXc[vV$+&PX*Z3XMYIXUQ:ZvW< YSXFZ,XBYeXMM)?Xa XiZ4/EXcP3%}&-|6~:1(-+YT$@XIYRBC<}&,|7aJ6}bp|8)K1|Xg|8C}[T|8Q.89;-964I38361<=/;883651467<7:>?1:.}le|:Z=39;1Y^)?:J=?XfLXbXi=Q0YVYOXaXiLXmJXO5?.SFXiCYW}-;|=u&D-X`N0X^,YzYRXO(QX_YW9`I|>hZ:N&X)DQXP@YH#XmNXi$YWX^=!G6YbYdX>XjY|XlX^XdYkX>YnXUXPYF)FXT[EVTMYmYJXmYSXmNXi#GXmT3X8HOX[ZiXN]IU2>8YdX1YbX<YfWuZ8XSXcZU%0;1XnXkZ_WTG,XZYX5YSX Yp 05G?XcYW(IXg6K/XlYP4XnI @XnO1W4Zp-9C@%QDYX+OYeX9>--YSXkD.YR%Q/Yo YUX].Xi<HYEZ2WdCE6YMXa7F)=,D>-@9/8@5=?7164;35387?N<618=6>7D+C50<6B03J0{Hj|N9$D,9I-,.KB3}m |NzE0::/81YqXjMXl7YG; [.W=Z0X4XQY]:MXiR,XgM?9$9>:?E;YE77VS[Y564760391?14941:0=:8B:;/1DXjFA-564=0B3XlH1+D85:0Q!B#:-6&N/:9<-R3/7Xn<*3J4.H:+334B.=>30H.;3833/76464665755:/83H6633:=;.>5645}&E|Y)?1/YG-,93&N3AE@5 <L1-G/8A0D858/30>8<549=@B8] V0[uVQYlXeD(P#ID&7T&7;Xi0;7T-$YE)E=1:E1GR):--0YI7=E<}n9|aT6783A>D7&4YG7=391W;Zx<5+>F#J39}o/|cc;6=A050EQXg8A1-}D-|d^5548083563695D?-.YOXd37I$@LYLWeYlX<Yd+YR A$;3-4YQ-9XmA0!9/XLY_YT(=5XdDI>YJ5XP1ZAW{9>X_6R(XhYO65&J%DA)C-!B:97#A9;@?F;&;(9=11/=657/H,<8}bz|j^5446>.L+&Y^8Xb6?(CYOXb*YF(8X`FYR(XPYVXmPQ%&DD(XmZXW??YOXZXfCYJ79,O)XnYF7K0!QXmXi4IYFRXS,6<%-:YO(+:-3Q!1E1:W,Zo}Am|n~;3580534*?3Zc4=9334361693:30C<6/717:<1/;>59&:4}6!|rS36=1?75<8}[B|s809983579I.A.>84758=108564741H*9E{L{|u%YQ<%6XfH.YUXe4YL@,>N}Tv|ve*G0X)Z;/)3@A74(4P&A1X:YVH97;,754*A66:1 D739E3553545558E4?-?K17/770843XAYf838A7K%N!YW4.$T19Z`WJ*0XdYJXTYOXNZ 1XaN1A+I&Xi.Xk3Z3GB&5%WhZ1+5#Y[X<4YMXhQYoQXVXbYQ8XSYUX4YXBXWDMG0WxZA[8V+Z8X;D],Va$%YeX?FXfX[XeYf<X:Z[WsYz8X_Y]%XmQ(!7BXIZFX]&YE3F$(1XgYgYE& +[+W!<YMYFXc;+PXCYI9YrWxGXY9DY[!GXiI7::)OC;*$.>N*HA@{C|}&k=:<TB83X`3YL+G4XiK]i}(fYK<=5$.FYE%4*5*H*6XkCYL=*6Xi6!Yi1KXR4YHXbC8Xj,B9ZbWx/XbYON#5B}Ue}+QKXnF1&YV5XmYQ0!*3IXBYb71?1B75XmF;0B976;H/RXU:YZX;BG-NXj;XjI>A#D3B636N;,*%<D:0;YRXY973H5)-4FXOYf0:0;/7759774;7;:/855:543L43<?6=E,.A4:C=L)%4YV!1(YE/4YF+ F3%;S;&JC:%/?YEXJ4GXf/YS-EXEYW,9;E}X$}547EXiK=51-?71C%?57;5>463553Zg90;6447?<>4:9.7538XgN{|!}9K/E&3-:D+YE1)YE/3;37/:05}n<}:UX8Yj4Yt864@JYK..G=.(A Q3%6K>3(P3#AYE$-6H/456*C=.XHY[#S.<780191;057C)=6HXj?955B:K1 E>-B/9,;5.!L?:0>/.@//:;7833YZ56<4:YE=/:7Z_WGC%3I6>XkC*&NA16X=Yz2$X:Y^&J48<99k8}CyB-61<18K946YO4{|N}E)YIB9K0L>4=46<1K0+R;6-=1883:478;4,S+3YJX`GJXh.Yp+Xm6MXcYpX(>7Yo,/:X=Z;Xi0YTYHXjYmXiXj;*;I-8S6N#XgY}.3XfYGO3C/$XjL$*NYX,1 6;YH&<XkK9C#I74.>}Hd`A748X[T450[n75<4439:18A107>|ET}Rf<1;14876/Yb983E<5.YNXd4149>,S=/4E/<306443G/06}0&}UkYSXFYF=44=-5095=88;63844,9E6644{PL}WA8:>)7+>763>>0/B3A545CCnT}Xm|dv}Xq1L/YNXk/H8;;.R63351YY747@15YE4J8;46;.38.>4A369.=-83,;Ye3?:3@YE.4-+N353;/;@(X[YYD>@/05-I*@.:551741Yf5>6A443<3535;.58/86=D4753442$635D1>0359NQ @73:3:>><Xn?;43C14 ?Y|X611YG1&<+,4<*,YLXl<1/AIXjF*N89A4Z576K1XbJ5YF.ZOWN.YGXO/YQ01:4G38Xl1;KI0YFXB=R<7;D/,/4>;$I,YGXm94@O35Yz66695385.>:6A#5}W7n^4336:4157597434433<3|XA}m`>=D>:4A.337370?-6Q96{`E|4A}C`|Qs{Mk|J+~r>|o,wHv>Vw}!c{H!|Gb|*Ca5}J||,U{t+{CN[!M65YXOY_*B,Y[Z9XaX[QYJYLXPYuZ%XcZ8LY[SYPYKZM<LMYG9OYqSQYM~[e{UJXmQYyZM_)>YjN1~[f3{aXFY|Yk:48YdH^NZ0|T){jVFYTZNFY^YTYN~[h{nPYMYn3I]`EYUYsYIZEYJ7Yw)YnXPQYH+Z.ZAZY]^Z1Y`YSZFZyGYHXLYG 8Yd#4~[i|+)YH9D?Y^F~Y7|-eYxZ^WHYdYfZQ~[j|3>~[k|3oYmYqY^XYYO=Z*4[]Z/OYLXhZ1YLZIXgYIHYEYK,<Y`YEXIGZI[3YOYcB4SZ!YHZ*&Y{Xi3~[l|JSY`Zz?Z,~[m|O=Yi>??XnYWXmYS617YVYIHZ(Z4[~L4/=~[n|Yu{P)|];YOHHZ}~[o33|a>~[r|aE]DH~[s|e$Zz~[t|kZFY~XhYXZB[`Y}~[u|{SZ&OYkYQYuZ2Zf8D~[v}% ~[w3},Q[X]+YGYeYPIS~[y}4aZ!YN^!6PZ*~[z}?E~[{3}CnZ=~[}}EdDZz/9A3(3S<,YR8.D=*XgYPYcXN3Z5 4)~[~}JW=$Yu.XX~] }KDX`PXdZ4XfYpTJLY[F5]X~[2Yp}U+DZJ::<446[m@~]#3}]1~]%}^LZwZQ5Z`/OT<Yh^ -~]&}jx[ ~m<z!%2+~ly4VY-~o>}p62yz!%2+Xf2+~ly4VY-zQ`z (=] 2z~o2\",C={\" \":0,\"!\":1},c=34,i=2,p,s=\"\",u=String.fromCharCode,t=u(12539);for(;++c<127;)C[u(c)]=c^39&&c^92?i++:0;i=0;for(;0<=(c=C[a.charAt(i++)]);)if(16===c)if((c=C[a.charAt(i++)])<87){if(86===c)c=1879;for(;c--;)s+=u(++p)}else s+=s.substr(8272,360);else if(c<86)s+=u(p+=c<51?c-16:(c-55)*92+C[a.charAt(i++)]);else if((c=((c-86)*92+C[a.charAt(i++)])*92+C[a.charAt(i++)])<49152)s+=u(p=c<40960?c:c|57344);else{c&=511;for(;c--;)s+=t;p=12539}return s')(),Util.$decodeToShiftJis=function(t){return t.replace(/%(8[1-9A-F]|[9E][0-9A-F]|F[0-9A-C])(%[4-689A-F][0-9A-F]|%7[0-9A-E]|[@-~])|%([0-7][0-9A-F]|A[1-9A-F]|[B-D][0-9A-F])/gi,(function(t){let e=parseInt(t.substring(1,3),16);const s=t.length;return 3===s?String.fromCharCode(e<160?e:e+65216):Util.$JCT11280.charAt(188*(e<160?e-129:e-193)+(4===s?t.charCodeAt(3)-64:(e=parseInt(t.substring(4),16))<127?e-64:e-65))}))},Util.$getTagObject=function(){return Util.$tagObjects.pop()||{placeObjects:[],sounds:[],removeObjects:[],frameLabel:[]}},Util.$poolTagObject=function(t){t.placeObjects.length=0,t.sounds.length=0,t.removeObjects.length=0,t.frameLabel.length=0,Util.$tagObjects.push(t)},Util.$createMovieClip=function(){const t={_$characterId:0,_$name:\"MovieClip\",_$controller:[],_$placeObjects:[],_$placeMap:[],_$labels:[],_$dictionary:[],_$sounds:[]};return t},Util.$getControllerAt=function(t,e,s){return s in t._$controller[e]?t._$controller[e][s]:null},Util.$addDictionary=function(t,e){const s=t._$dictionary.length,a={CharacterId:e.CharacterId,Depth:e.Depth,Name:null,ClipDepth:0,PlaceFlagHasImage:0|e.PlaceFlagHasImage,StartFrame:0|e.StartFrame,EndFrame:0|e.EndFrame};return e.PlaceFlagHasName&&(a.Name=e.Name),e.PlaceFlagHasClipDepth&&(a.ClipDepth=e.ClipDepth),t._$dictionary[s]=a,s},Util.$getBlendName=function(t){switch(t){case 1:case\"normal\":default:return\"normal\";case 2:case\"layer\":return\"layer\";case 3:case\"multiply\":return\"multiply\";case 4:case\"screen\":return\"screen\";case 5:case\"lighten\":return\"lighten\";case 6:case\"darken\":return\"darken\";case 7:case\"difference\":return\"difference\";case 8:case\"add\":return\"add\";case 9:case\"subtract\":return\"subtract\";case 10:case\"invert\":return\"invert\";case 11:case\"alpha\":return\"alpha\";case 12:case\"erase\":return\"erase\";case 13:case\"overlay\":return\"overlay\";case 14:case\"hardlight\":return\"hardlight\"}};class ByteStream{constructor(){this.clear()}clear(){this.data=null,this.bit_offset=0,this.byte_offset=0,this.bit_buffer=null}setData(t){this.data=t}getData(t){this.byteAlign();const e=this.byte_offset+t,s=this.data.subarray(this.byte_offset,e);return this.byte_offset=e,s}byteAlign(){this.bit_offset&&(this.byte_offset=this.byte_offset+(this.bit_offset+7)/8|0,this.bit_offset=0)}getDataUntil(t=0){this.byteAlign();let e=\"\";for(;;){const t=this.data[this.byte_offset++];if(!t)break;if(10===t||13===t){e+=\"\\n\";continue}let s=t.toString(16);1===s.length&&(s=\"0\"+s),e+=\"%\"+s}if(!e.length)return\"\";if(e.length>5&&\"\\n\"===e.substr(-5)&&(e=e.slice(0,-5)),t)return Util.$decodeToShiftJis(e);try{return decodeURIComponent(e)}catch(t){return Util.$decodeToShiftJis(e)}}byteCarry(){if(this.bit_offset>7)this.byte_offset=this.byte_offset+(0|(this.bit_offset+7)/8),this.bit_offset&=7;else for(;this.bit_offset<0;)--this.byte_offset,this.bit_offset+=8}getUIBits(t){let e=0;for(;t;)e<<=1,e|=this.getUIBit(),--t;return e}getUIBit(){return this.byteCarry(),this.data[this.byte_offset]>>7-this.bit_offset++&1}getSIBits(t){const e=this.getUIBits(t),s=e&1<<t-1;return s?-(e^2*s-1)-1:e}getUI8(){return this.byteAlign(),this.data[this.byte_offset++]}getUI16(){return this.byteAlign(),this.getUI8()|this.getUI8()<<8}getUI32(){return this.byteAlign(),this.getUI8()|(this.getUI8()|(this.getUI8()|this.getUI8()<<8)<<8)<<8}getFloat16(){const t=this.data[this.byte_offset++];let e=0;return e|=this.data[this.byte_offset++]<<8,e|=t<<0,e}getFloat32(){const t=this.data[this.byte_offset++],e=this.data[this.byte_offset++],s=this.data[this.byte_offset++];let a=0;a|=this.data[this.byte_offset++]<<24,a|=s<<16,a|=e<<8,a|=t<<0;const i=a>>23&255;return a&&2147483648!==a?(2147483648&a?-1:1)*(8388608|8388607&a)*Math.pow(2,i-127-23):0}incrementOffset(t,e){this.byte_offset+=t,this.bit_offset+=e,this.byteCarry()}setOffset(t,e){this.byte_offset=t,this.bit_offset=e}}class SwfParser{constructor(){this.byteStream=new ByteStream,this.currentPosition={x:0,y:0},this.jpegTables=null,this.characters=[],this.frameInfo=[],this.fonts=new Map,this.textSettings=new Map,this.grids=new Map,this.version=0}clear(){this.byteStream.clear(),this.currentPosition.x=0,this.currentPosition.y=0,this.jpegTables=null,this.characters.length=0,this.frameInfo.length=0,this.version=0}getCharacter(t){return this.characters[t]}setCharacter(t,e,s){this.characters[t]=e,globalThis.postMessage({infoKey:\"character\",characterId:t,piece:e},s)}getFont(t){return this.fonts.get(t)}setFont(t,e){this.fonts.set(t,e)}setTextSetting(t,e){this.textSettings.set(t,e)}setGrid(t,e){this.grids.set(t,e)}showFrame(t,e,s,a){let i,r;const h=s-1|0,o=e.frameLabel;i=o.length;for(let e=0;e<i;++e){const a=o[e];a.name in this.frameInfo&&(a.frame=this.frameInfo[\"@\"+a.name]),t._$labels.push({label:a.name,frame:a.frame||s})}const n=e.sounds;i=0|n.length,i&&t._$sounds.push({frame:s,data:n.slice(0)});const l=e.removeObjects;i=l.length;for(let e=0;e<i;++e){const a=l[e],i=Util.$getControllerAt(t,h,a.Depth);t._$dictionary[i].EndFrame=s,Util.$installed.set(a.Depth,1)}s in a||(a[s]=[]),s in t._$controller||(t._$controller[s]=[]),s in t._$placeMap||(t._$placeMap[s]=[]);const c=e.placeObjects,b=h?a[h]:null;i=c.length;for(let e=0;e<i;++e){let i=null;const r=c[e];let o=null;h&&r.Depth in b&&(o=b[r.Depth]),0===r.PlaceFlagHasCharacter&&o&&(r.CharacterId=o.CharacterId);let n=!1;if((0===r.PlaceFlagMove||1===r.PlaceFlagMove&&1===r.PlaceFlagHasCharacter)&&(n=!0),h&&!n&&(i=Util.$getControllerAt(t,h,r.Depth),null===i&&(n=!0)),1===r.PlaceFlagMove&&o&&(1!==o.PlaceFlagHasMatrix||r.PlaceFlagHasMatrix||(r.PlaceFlagHasMatrix=1,r.Matrix=o.Matrix),1!==o.PlaceFlagHasColorTransform||r.PlaceFlagHasColorTransform||(r.PlaceFlagHasColorTransform=1,r.ColorTransform=o.ColorTransform),1!==o.PlaceFlagHasClipDepth||r.PlaceFlagHasClipDepth||(r.PlaceFlagHasClipDepth=1,r.ClipDepth=o.ClipDepth),1!==o.PlaceFlagHasRatio||r.PlaceFlagHasRatio||(r.PlaceFlagHasRatio=1,r.Ratio=o.Ratio),1!==o.PlaceFlagHasFilterList||r.PlaceFlagHasFilterList||(r.PlaceFlagHasFilterList=1,r.SurfaceFilterList=o.SurfaceFilterList),1!==o.PlaceFlagHasBlendMode||r.PlaceFlagHasBlendMode||(r.PlaceFlagHasBlendMode=1,r.BlendMode=o.BlendMode)),h&&!Util.$installed.has(r.Depth)){const e=Util.$getControllerAt(t,h,r.Depth);if(null!==e){const a=t._$dictionary[e];!a||0!==r.PlaceFlagMove&&1!==r.PlaceFlagHasCharacter||(a.EndFrame=0|s,t._$dictionary[e]=a,n=!0)}}if(n){if(r.StartFrame=0|s,r.EndFrame=0,1===r.PlaceFlagHasCharacter&&1===r.PlaceFlagMove){const e=Util.$getControllerAt(t,h,r.Depth),a=t._$dictionary[e];a.EndFrame=0|s,t._$dictionary[e]=a}i=Util.$addDictionary(t,r)}t._$controller[s][r.Depth]=i;const l=t._$placeObjects.length;t._$placeObjects[l]=this.buildPlaceObject(r),t._$placeMap[s][r.Depth]=l,Util.$installed.set(r.Depth,1),a[s][r.Depth]=r}if(h){let e;const o=t._$controller[h];r=Object.keys(o),i=r.length;for(let n=0;n<i;++n)e=0|r[n],Util.$installed.has(e)||(a[s][e]=a[h][e],t._$controller[s][e]=o[e]);const n=t._$placeMap[h];r=Object.keys(n),i=r.length;for(let a=0;a<i;++a)e=r[a],e in t._$placeMap[s]||(t._$placeMap[s][e]=n[e])}Util.$installed.clear()}buildPlaceObject(t){const e={matrix:[1,0,0,1,0,0],colorTransform:[1,1,1,1,0,0,0,0],filters:null,blendMode:\"normal\"};return t.PlaceFlagHasMatrix&&(e.matrix=t.Matrix),t.PlaceFlagHasColorTransform&&(e.colorTransform=t.ColorTransform),t.PlaceFlagHasFilterList&&(e.surfaceFilterList=t.SurfaceFilterList),t.PlaceFlagHasBlendMode&&(e.blendMode=Util.$getBlendName(t.BlendMode)),t.PlaceFlagHasRatio&&(e.ratio=t.Ratio||0),e}postData(t){if(this.textSettings.size){for(let[t,e]of this.textSettings){const s=this.characters[t];s&&(s._$textSetting=e,globalThis.postMessage({infoKey:\"character\",characterId:t,piece:s}))}this.textSettings.clear()}if(this.grids.size){for(let[t,e]of this.grids){const s=this.characters[t];s&&(s._$grid=e,globalThis.postMessage({infoKey:\"character\",characterId:t,piece:s}))}this.grids.clear()}if(this.fonts.size){for(let[t,e]of this.fonts){if(!e._$hasLayout){globalThis.postMessage({infoKey:\"font\",index:t,piece:e});continue}const s=e._$glyphShapeTable,a=e._$zoneTable;e._$glyphShapeTable=[],e._$zoneTable=a?[]:null,globalThis.postMessage({infoKey:\"font\",index:t,piece:e},[e._$advanceTable.buffer,e._$codeTable.buffer]);const i=s.length;if(i){const e=[],a=[];for(let r=0;r<i;++r){const i=s[r];e.push(i),a.push(i.records.buffer),e.length>256&&(globalThis.postMessage({infoKey:\"font_shape\",index:t,pieces:e},a),a.length=0,e.length=0)}e.length&&globalThis.postMessage({infoKey:\"font_shape\",index:t,pieces:e},a)}if(a)for(;a.length;){const e=Math.min(256,a.length);globalThis.postMessage({infoKey:\"font_zone\",index:t,pieces:a.splice(0,e)})}}this.fonts.clear()}for(let e=1;e<t._$controller.length;++e){const s=t._$controller[e];t._$controller[e]=s.filter((()=>!0))}this.setCharacter(0,t)}parseTags(t,e){const s=Util.$getTagObject();let a=1;const i=[],r=this.byteStream;for(;r.byte_offset<t;){const h=r.byte_offset;if(h+2>t)break;const o=r.getUI16(),n=o>>6;let l=63&o;if(63===l){if(h+6>t){r.byte_offset=h,r.bit_offset=0;break}l=r.getUI32()}const c=r.byte_offset;this.parseTag(n,l,e,a,s,i),1===n&&(++a,s.placeObjects.length=0,s.sounds.length=0,s.removeObjects.length=0,s.frameLabel.length=0);const b=r.byte_offset-c|0;b!==l&&b<l&&(r.byte_offset=r.byte_offset+(l-b)),r.bit_offset=0}Util.$poolTagObject(s)}parseTag(t,e,s,a,i,r){switch(t){case 28:i.removeObjects.push({Frame:a,Depth:this.byteStream.getUI16()});break;case 4:case 26:case 70:i.placeObjects.push(this.parsePlaceObject(t,e));break;case 39:{const t=this.byteStream.byte_offset+e,s=this.byteStream.getUI16();this.byteStream.getUI16();const a=Util.$createMovieClip();a._$characterId=s,this.parseTags(t,a);for(let t=1;t<a._$controller.length;++t){const e=a._$controller[t];a._$controller[t]=e.filter((()=>!0))}this.setCharacter(s,a)}break;case 1:this.showFrame(s,i,a,r);break;case 2:case 22:case 32:case 83:e<10?this.byteStream.byte_offset+=e:this.parseDefineShape(t);break;case 20:case 36:this.parseDefineBitsLossLess(t,e);break;case 6:case 21:case 35:case 90:this.parseDefineBits(t,e,this.jpegTables);break;case 15:case 89:i.sounds.push(this.parseStartSound(t));break;case 10:case 48:case 75:this.parseDefineFont(t,e);break;case 14:this.parseDefineSound(e);break;case 13:case 62:this.parseDefineFontInfo(t,e);break;case 43:i.frameLabel.push(this.parseFrameLabel());break;case 11:case 33:this.parseDefineText(t);break;case 37:this.parseDefineEditText(t);break;case 7:case 34:this.parseDefineButton(t,e);break;case 88:this.parseDefineFontName();break;case 8:e&&(this.jpegTables=this.parseJPEGTables(e));break;case 46:case 84:this.parseDefineMorphShape(t);break;case 18:case 45:this.parseSoundStreamHead(t);break;case 17:this.parseDefineButtonSound();break;case 73:this.parseDefineFontAlignZones();break;case 74:this.parseCSMTextSettings(t);break;case 19:this.parseSoundStreamBlock(t,e);break;case 78:this.parseDefineScalingGrid();break;case 5:console.log(\"TODO RemoveObject type 5.\"),i.removeObjects.push({CharacterId:this.byteStream.getUI16(),Depth:this.byteStream.getUI16()});break;case 76:this.parseSymbolClass();break;case 0:case 27:case 30:case 67:case 68:case 79:case 80:case 81:case 85:case 92:default:break;case 86:case 56:case 9:case 40:case 24:case 63:case 64:case 69:case 65:case 77:case 60:case 61:case 41:case 87:case 59:case 12:case 72:case 82:this.byteStream.byte_offset+=e;break;case 3:case 16:case 23:case 25:case 29:case 31:case 38:case 42:case 44:case 47:case 49:case 52:case 53:case 54:case 55:case 57:case 58:case 66:case 71:case 91:case 93:console.log(\"[TODO] tagType -> \"+t)}}parseSymbolClass(){const t=this.byteStream.getUI16();if(t){const e=[];for(let s=0;s<t;++s){const t=this.byteStream.getUI16(),s=this.byteStream.getDataUntil();e[e.length]={tagId:t,ns:s},128===e.length&&(globalThis.postMessage({infoKey:\"_$symbols\",pieces:e}),e.length=0)}e.length&&globalThis.postMessage({infoKey:\"_$symbols\",pieces:e})}}parseDefineShape(t){const e=0|this.byteStream.getUI16(),s=this.rect();if(83===t){const t={};this.rect(),this.byteStream.getUIBits(5),t.UsesFillWindingRule=this.byteStream.getUIBits(1),t.UsesNonScalingStrokes=this.byteStream.getUIBits(1),t.UsesScalingStrokes=this.byteStream.getUIBits(1)}const a=this.shapeWithStyle(t);this.setCharacter(e,{_$records:a,_$name:\"Shape\",_$bounds:s,_$characterId:e},[a.ShapeData.records.buffer])}rect(){this.byteStream.byteAlign();const t=this.byteStream.getUIBits(5);return{xMin:this.byteStream.getSIBits(t)/20,xMax:this.byteStream.getSIBits(t)/20,yMin:this.byteStream.getSIBits(t)/20,yMax:this.byteStream.getSIBits(t)/20}}shapeWithStyle(t){const e={};switch(t){case 46:case 84:break;default:e.fillStyles=this.fillStyleArray(t),e.lineStyles=this.lineStyleArray(t)}const s=this.byteStream.getUI8(),a=s>>4,i=15&s;return e.ShapeData=this.shapeRecords(t,{FillBits:a,LineBits:i}),e}fillStyleArray(t){let e=0|this.byteStream.getUI8();t>2&&255===e&&(e=this.byteStream.getUI16());const s=[];for(let a=0;a<e;++a)s[s.length]=this.fillStyle(t);return s}fillStyle(t){const e=this.byteStream.getUI8(),s={};switch(s.fillStyleType=e,e){case 0:switch(t){case 32:case 83:s.Color=this.rgba();break;case 46:case 84:s.StartColor=this.rgba(),s.EndColor=this.rgba();break;default:s.Color=this.rgb()}break;case 16:case 18:switch(t){case 46:case 84:s.startGradientMatrix=this.matrix(),s.endGradientMatrix=this.matrix(),s.gradient=this.gradient(t);break;default:s.gradientMatrix=this.matrix(),s.gradient=this.gradient(t)}break;case 19:s.gradientMatrix=this.matrix(),s.gradient=this.focalGradient(t);break;case 64:case 65:case 66:case 67:switch(s.bitmapId=this.byteStream.getUI16(),t){case 46:case 84:s.startBitmapMatrix=this.matrix(),s.endBitmapMatrix=this.matrix();break;default:s.bitmapMatrix=this.matrix()}}return s}rgb(){return{R:0|this.byteStream.getUI8(),G:0|this.byteStream.getUI8(),B:0|this.byteStream.getUI8(),A:1}}rgba(){return{R:this.byteStream.getUI8(),G:this.byteStream.getUI8(),B:this.byteStream.getUI8(),A:this.byteStream.getUI8()/255}}matrix(){this.byteStream.byteAlign();const t=[1,0,0,1,0,0];if(this.byteStream.getUIBit()){const e=this.byteStream.getUIBits(5);t[0]=this.byteStream.getSIBits(e)/65536,t[3]=this.byteStream.getSIBits(e)/65536}if(this.byteStream.getUIBit()){const e=this.byteStream.getUIBits(5);t[1]=this.byteStream.getSIBits(e)/65536,t[2]=this.byteStream.getSIBits(e)/65536}const e=this.byteStream.getUIBits(5);return t[4]=this.byteStream.getSIBits(e)/20,t[5]=this.byteStream.getSIBits(e)/20,t}gradient(t){let e,s=0,a=0;switch(this.byteStream.byteAlign(),t){case 46:case 84:e=this.byteStream.getUI8();break;default:s=this.byteStream.getUIBits(2),a=this.byteStream.getUIBits(2),e=this.byteStream.getUIBits(4)}const i=[];for(let s=0;s<e;++s)i[i.length]=this.gradientRecord(t);return{SpreadMode:s,InterpolationMode:a,GradientRecords:i,FocalPoint:0}}gradientRecord(t){switch(t){case 46:case 84:return{StartRatio:this.byteStream.getUI8()/255,StartColor:this.rgba(),EndRatio:this.byteStream.getUI8()/255,EndColor:this.rgba()};default:return{Ratio:this.byteStream.getUI8()/255,Color:t<32?this.rgb():this.rgba()}}}focalGradient(t){this.byteStream.byteAlign();const e=this.byteStream.getUIBits(2),s=this.byteStream.getUIBits(2),a=this.byteStream.getUIBits(4),i=[];for(let e=0;e<a;++e)i[i.length]=this.gradientRecord(t);return{SpreadMode:e,InterpolationMode:s,GradientRecords:i,FocalPoint:this.byteStream.getFloat16()}}lineStyleArray(t){let e=this.byteStream.getUI8();t>2&&255===e&&(e=this.byteStream.getUI16());const s=[];for(let a=0;a<e;++a)s[s.length]=this.lineStyles(t);return s}lineStyles(t){const e={fillStyleType:0};switch(t){case 46:e.StartWidth=this.byteStream.getUI16()/20,e.EndWidth=this.byteStream.getUI16()/20,e.StartColor=this.rgba(),e.EndColor=this.rgba();break;case 84:e.StartWidth=this.byteStream.getUI16()/20,e.EndWidth=this.byteStream.getUI16()/20,e.StartCapStyle=this.byteStream.getUIBits(2),e.JoinStyle=this.byteStream.getUIBits(2),e.HasFillFlag=this.byteStream.getUIBit(),e.NoHScaleFlag=this.byteStream.getUIBit(),e.NoVScaleFlag=this.byteStream.getUIBit(),e.PixelHintingFlag=this.byteStream.getUIBit(),this.byteStream.getUIBits(5),e.NoClose=this.byteStream.getUIBit(),e.EndCapStyle=this.byteStream.getUIBits(2),2===e.JoinStyle&&(e.MiterLimitFactor=this.byteStream.getUI16()/20),e.HasFillFlag?e.FillType=this.fillStyle(t):(e.StartColor=this.rgba(),e.EndColor=this.rgba());break;case 83:e.Width=this.byteStream.getUI16()/20,e.StartCapStyle=this.byteStream.getUIBits(2),e.JoinStyle=this.byteStream.getUIBits(2),e.HasFillFlag=this.byteStream.getUIBit(),e.NoHScaleFlag=this.byteStream.getUIBit(),e.NoVScaleFlag=this.byteStream.getUIBit(),e.PixelHintingFlag=this.byteStream.getUIBit(),this.byteStream.getUIBits(5),e.NoClose=this.byteStream.getUIBit(),e.EndCapStyle=this.byteStream.getUIBits(2),2===e.JoinStyle&&(e.MiterLimitFactor=this.byteStream.getUI16()),e.HasFillFlag?e.FillType=this.fillStyle(t):e.Color=this.rgba();break;case 32:e.Width=this.byteStream.getUI16()/20,e.Color=this.rgba(),e.JoinStyle=0,e.StartCapStyle=0,e.EndCapStyle=0;break;default:e.Width=this.byteStream.getUI16()/20,e.Color=this.rgb(),e.JoinStyle=0,e.StartCapStyle=0,e.EndCapStyle=0}return e}shapeRecords(t,e){this.currentPosition.x=0,this.currentPosition.y=0;const s=[],a=[];for(;;){const i=this.byteStream.getUIBits(6);if(32&i){const e=15&i;if(16&i){this.straightEdgeRecord(t,e,s);continue}this.curvedEdgeRecord(t,e,s)}else{if(!i){s.push(-1),this.byteStream.byteAlign();break}this.styleChangeRecord(t,i,e,s,a)}}const i={records:new Int32Array(s)};return a.length&&(i.styles=a),i}straightEdgeRecord(t,e,s){let a=0,i=0;this.byteStream.getUIBit()?(a=this.byteStream.getSIBits(e+2),i=this.byteStream.getSIBits(e+2)):this.byteStream.getUIBit()?i=this.byteStream.getSIBits(e+2):a=this.byteStream.getSIBits(e+2);let r=a,h=i;switch(t){case 46:case 84:break;default:r=this.currentPosition.x+a,h=this.currentPosition.y+i,this.currentPosition.x=r,this.currentPosition.y=h}s.push(0,0,r,h)}curvedEdgeRecord(t,e,s){const a=this.byteStream.getSIBits(e+2),i=this.byteStream.getSIBits(e+2),r=this.byteStream.getSIBits(e+2),h=this.byteStream.getSIBits(e+2);let o=a,n=i,l=r,c=h;switch(t){case 46:case 84:break;default:o=this.currentPosition.x+a,n=this.currentPosition.y+i,l=o+r,c=n+h,this.currentPosition.x=l,this.currentPosition.y=c}s.push(0,1,o,n,l,c)}styleChangeRecord(t,e,s,a,i){const r=e>>4&1,h=e>>3&1,o=e>>2&1,n=e>>1&1,l=1&e;let c=0,b=0;if(l){const t=this.byteStream.getUIBits(5);c=this.byteStream.getSIBits(t),b=this.byteStream.getSIBits(t),this.currentPosition.x=c,this.currentPosition.y=b}const g=n?this.byteStream.getUIBits(s.FillBits):0,y=o?this.byteStream.getUIBits(s.FillBits):0,S=h?this.byteStream.getUIBits(s.LineBits):0;let m=null,f=null,d=0,Y=0;if(r){m=this.fillStyleArray(t),f=this.lineStyleArray(t);const e=this.byteStream.getUI8();s.FillBits=d=e>>4,s.LineBits=Y=15&e}a.push(1,r),r&&(a.push(d,Y),i.push({FillStyles:m,LineStyles:f})),a.push(l),l&&a.push(c,b),a.push(n),n&&a.push(g),a.push(o),o&&a.push(y),a.push(h),h&&a.push(S)}parseDefineBitsLossLess(t,e){const s=this.byteStream.byte_offset,a=this.byteStream.getUI16(),i=this.byteStream.getUI8(),r=this.byteStream.getUI16(),h=this.byteStream.getUI16(),o=36===t,n=3===i?this.byteStream.getUI8()+1:0;let l=r*h*4;if(3===i){l=(r+((r+3&-4)-r|0))*h+n*(o?4:3)}const c=e-(this.byteStream.byte_offset-s),b=this.byteStream.byte_offset;this.byteStream.byte_offset+=c;const g=this.byteStream.data.slice(b,this.byteStream.byte_offset),y={width:r,height:h,format:i,fileSize:l,tableSize:n,isAlpha:o,color:o?4278190080:0,_$name:\"lossless\",_$characterId:a,buffer:g};this.setCharacter(a,y,[g.buffer])}parseJPEGTables(t){const e=this.byteStream.byte_offset;return this.byteStream.byte_offset+=t,{offset:e,length:this.byteStream.byte_offset}}parseDefineBits(t,e,s=null){const a=this.byteStream.byte_offset,i=this.byteStream.getUI16(),r=this.byteStream.byte_offset-a,h=35===t||90===t?this.byteStream.getUI32():e-r;if(90===t){const t=this.byteStream.getUI16();console.log(\"TODO DeblockParam\",t)}const o=this.byteStream.byte_offset;this.byteStream.byte_offset+=h;let n=this.byteStream.data.slice(o,this.byteStream.byte_offset);if(s){const t=this.byteStream.data.subarray(s.offset,s.length);if(t.length>4&&255===n[0]&&216===n[1]){const e=t.length-2,s=n.length,a=new Uint8Array(e+s);a.set(t.subarray(0,e),0),a.set(n.subarray(2,s),e),n=a}}const l={infoKey:\"character\",_$name:\"imageData\",_$characterId:i,jpegData:n,alphaData:null},c=[];c.push(n.buffer);let b=!1;const g=a+e-this.byteStream.byte_offset;if(g){b=!0;const t=this.byteStream.byte_offset;this.byteStream.byte_offset+=g;const e=this.byteStream.data.slice(t,this.byteStream.byte_offset);l.alphaData=e,c.push(e.buffer)}l.isAlpha=b,l.color=b?4278190080:0,this.setCharacter(i,l,c)}parseDefineFont(t,e){const s=this.byteStream.byte_offset+e|0,a=this.byteStream.getUI16(),i=this.getFont(a)||{};let r=0,h=0,o=0;if(48===t||75===t){const t=this.byteStream.getUI8();i._$hasLayout=t>>>7&1,i._$shiftJIS=t>>>6&1,i._$smallText=t>>>5&1,i._$ANSI=t>>>4&1,h=t>>>3&1,o=t>>>2&1,i._$italic=t>>>1&1,i._$bold=1&t,this.byteStream.byteAlign(),i._$languageCode=this.byteStream.getUI8();const e=this.byteStream.getUI8();if(e){const t=0|this.byteStream.byte_offset;i._$fontName=this.getFontName(this.byteStream.getDataUntil()),this.byteStream.byte_offset=t+e|0}r=this.byteStream.getUI16(),i._$numGlyphs=r}const n=0|this.byteStream.byte_offset;if(10===t&&(r=this.byteStream.getUI16()),r){const e=[];10===t&&(e[0]=r,r/=2,r-=1);let s=0;if(1===h){for(let t=0;t<r;++t)e[e.length]=this.byteStream.getUI32();10!==t&&(s=this.byteStream.getUI32())}else{for(let t=0;t<r;++t)e[e.length]=this.byteStream.getUI16();10!==t&&(s=this.byteStream.getUI16())}const a=[];10===t&&(r+=1);for(let s=0;s<r;++s){this.byteStream.setOffset(e[s]+n,0);const i=this.byteStream.getUI8(),r={FillBits:i>>4,LineBits:15&i};a[a.length]=this.shapeRecords(t,r)}switch(i._$glyphShapeTable=a,t){case 48:case 75:if(this.byteStream.setOffset(s+n,0),1===o){const t=new Uint16Array(r);for(let e=0;e<r;++e)t[e]=this.byteStream.getUI16();i._$codeTable=t}else{const t=new Uint8Array(r);for(let e=0;e<r;++e)t[e]=this.byteStream.getUI8();i._$codeTable=t}if(i._$hasLayout){i._$ascent=this.byteStream.getUI16(),i._$descent=this.byteStream.getUI16(),i._$leading=this.byteStream.getUI16();const e=new Uint16Array(r);for(let t=0;t<r;++t)e[t]=this.byteStream.getUI16();i._$advanceTable=e;const s=[];for(let t=0;t<r;++t)s[s.length]=this.rect();if(75===t){const t=this.byteStream.getUI16(),e=[];for(let s=0;s<t;++s){const t=o?this.byteStream.getUI16():this.byteStream.getUI8(),s=o?this.byteStream.getUI16():this.byteStream.getUI8(),a=this.byteStream.getSIBits(16);e[e.length]={FontKerningCode1:t,FontKerningCode2:s,FontKerningAdjustment:a}}i._$kerningRecords=e}}}}this.byteStream.byte_offset=0|s,this.setFont(a,i)}parseDefineFontInfo(t,e){const s=this.byteStream.byte_offset+e|0,a=this.byteStream.getUI16();let i=this.getFont(a);i||(i={});const r=this.byteStream.getUI8(),h=this.byteStream.getData(r);let o=\"\";for(let t=0;t<r;++t)h[t]>127||(o+=String.fromCharCode(h[t]));this.byteStream.getUIBits(2),i._$smallText=this.byteStream.getUIBits(1),i._$shiftJIS=this.byteStream.getUIBits(1),i._$ANSI=this.byteStream.getUIBits(1),i._$italic=this.byteStream.getUIBits(1),i._$bold=this.byteStream.getUIBits(1);const n=this.byteStream.getUIBits(1);62===t&&(i._$languageCode=this.byteStream.getUI8());const l=i._$shiftJIS||2===i._$languageCode?Util.$decodeToShiftJis(o):decodeURIComponent(o);i._$fontName=this.getFontName(l),this.byteStream.byteAlign();const c=[];let b=null;if(!0==(1===n||62===t)){for(;this.byteStream.byte_offset<s;)c[c.length]=this.byteStream.getUI16();b=new Uint16Array(c)}else{for(;this.byteStream.byte_offset<s;)c[c.length]=this.byteStream.getUI8();b=new Uint8Array(c)}i._$codeTable=b,this.setFont(a,i)}getFontName(t){const e=0|t.length;switch(0===t.substr(e-1).charCodeAt(0)&&(t=t.slice(0,-1)),t){case\"_sans\":return\"_sans\";case\"_serif\":return\"_serif\";case\"_typewriter\":return\"_typewriter\";case\"_等幅\":return\"Osaka\";default:return\"_\"===t.substr(0,1)?\"sans-serif\":t}}parseDefineFontName(){this.byteStream.getUI16(),this.byteStream.getDataUntil(),this.byteStream.getDataUntil()}parseDefineText(t){const e={_$name:\"StaticText\"};e._$characterId=0|this.byteStream.getUI16(),e._$bounds=this.rect(),e._$baseMatrix=this.matrix(),e._$shapeRecords=null;const s=this.byteStream.getUI8(),a=this.byteStream.getUI8();e._$textRecords=this.getTextRecords(t,s,a),this.setCharacter(e._$characterId,e)}getTextRecords(t,e,s){const a=[];for(;0!==this.byteStream.getUI8();){this.byteStream.incrementOffset(-1,0);const i={};i.TextRecordType=this.byteStream.getUIBits(1),i.StyleFlagsReserved=this.byteStream.getUIBits(3),i.StyleFlagsHasFont=this.byteStream.getUIBits(1),i.StyleFlagsHasColor=this.byteStream.getUIBits(1),i.StyleFlagsHasYOffset=this.byteStream.getUIBits(1),i.StyleFlagsHasXOffset=this.byteStream.getUIBits(1),i.StyleFlagsHasFont&&(i.FontId=this.byteStream.getUI16()),i.StyleFlagsHasColor&&(i.TextColor=11===t?this.rgb():this.rgba()),i.StyleFlagsHasXOffset&&(i.XOffset=this.byteStream.getUI16()/20),i.StyleFlagsHasYOffset&&(i.YOffset=this.byteStream.getUI16()/20),i.StyleFlagsHasFont&&(i.TextHeight=this.byteStream.getUI16()),i.GlyphCount=this.byteStream.getUI8(),i.GlyphEntries=this.getGlyphEntries(i.GlyphCount,e,s),a[a.length]=i}return a}getGlyphEntries(t,e,s){const a=[];for(let i=0;i<t;++i)a[a.length]={GlyphIndex:this.byteStream.getUIBits(e),GlyphAdvance:this.byteStream.getSIBits(s)/20};return a}parseDefineEditText(){const t={_$ns:[\"flash\",\"text\"],_$name:\"TextField\"},e={},s=this.byteStream.getUI16();t._$characterId=s,t._$bounds=this.rect();const a=this.byteStream.getUI8(),i=a>>>7&1;t._$wordWrap=a>>>6&1,t._$multiline=a>>>5&1,t._$displayAsPassword=a>>>4&1;const r=a>>>3&1;t._$type=\"dynamic\",r||(t._$type=\"input\");const h=a>>>2&1,o=a>>>1&1,n=1&a,l=this.byteStream.getUI8(),c=l>>>7&1,b=l>>>5&1;t._$selectable=l>>>4&1,t._$border=l>>>3&1;const g=l>>>1&1,y=1&l;t._$border&&(t._$background=!0);let S=0;if(n){const s=this.byteStream.getUI16(),a=this.getFont(s);if(a){if(S=a._$shiftJIS,c){const t=this.byteStream.getDataUntil();console.log(\"TODO HasFontClass: \",t)}e._$font=a._$fontName,e._$size=this.byteStream.getUI16()/20,t._$fontId=0|s,t._$embedFonts=!(!y&&\"embedded\"!==a.fontType||t.displayAsPassword)}}if(h){const e=this.rgba();t._$textColor=(e.R<<16)+(e.G<<8)+e.B+255*e.A*16777216}if(o&&(t._$maxChars=this.byteStream.getUI16()),b){switch(this.byteStream.getUI8()){case 0:e._$align=\"left\";break;case 1:e._$align=\"right\";break;case 2:e._$align=\"center\";break;case 3:e._$align=\"justify\"}e._$leftMargin=this.byteStream.getUI16()/20,e._$rightMargin=this.byteStream.getUI16()/20,e._$indent=this.byteStream.getUI16(),e._$indent>=32768&&(e._$indent-=65536),e._$leading=this.byteStream.getUI16(),e._$leading>=32768&&(e._$leading-=65536),e._$indent/=20,e._$leading/=20}const m=this.byteStream.getDataUntil(S)+\"\";if(t._$text=\"\",i){const e=this.byteStream.getDataUntil(S);if(!0==(1===g))t._$htmlText=e,t._$initText=!0;else t._$text=e}\"\"!==m&&console.log(\"VariableName: \",m),t._$defaultTextFormat=[null,e._$font,e._$size,e._$color,e._$bold,e._$italic,e._$underline,e._$url,e._$target,e._$align,e._$leftMargin,e._$rightMargin,0,e._$leading,e._$indent],this.setCharacter(s,t)}parseDefineMorphShape(t){const e={};e.CharacterId=this.byteStream.getUI16(),e.StartBounds=this.rect(),e.EndBounds=this.rect(),84===t&&(e.StartEdgeBounds=this.rect(),e.EndEdgeBounds=this.rect(),this.byteStream.getUIBits(6),e.UsesNonScalingStrokes=this.byteStream.getUIBits(1),e.UsesScalingStrokes=this.byteStream.getUIBits(1));const s=this.byteStream.getUI32(),a=this.byteStream.byte_offset+s;e.MorphFillStyles=this.fillStyleArray(t),e.MorphLineStyles=this.lineStyleArray(t),e.StartEdges=this.shapeWithStyle(t),this.byteStream.byte_offset!==a&&(this.byteStream.byte_offset=a),e.EndEdges=this.shapeWithStyle(t);const i={x:0,y:0},r={x:0,y:0},h=e.StartEdges.ShapeData.records,o=e.EndEdges.ShapeData.records,n=h.length,l=o.length;let c=Math.max(n,l);const b=[],g=[];let y=0,S=0;for(;c>y||c>S;){const t=h[y++],e=o[S++];if(-1===t&&-1===e)break;switch(!0){case-1===t:case void 0===t:if(e){const t=o[S++];if(g.push(1,t),b.push(1,t),t){const t=o[S++],e=o[S++];g.push(t,e),b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const e=o[S++];if(g.push(e),b.push(e),e){const t=o[S++],e=o[S++];r.x=t,r.y=e,g.push(t,e),b.push(t,e)}const s=o[S++];if(g.push(s),b.push(s),s){const t=o[S++];g.push(t),b.push(t)}const a=o[S++];if(g.push(a),b.push(a),a){const t=o[S++];g.push(t),b.push(t)}const i=o[S++];if(g.push(i),b.push(i),i){const t=o[S++];g.push(t),b.push(t)}break}if(o[S++]){const t=o[S++],e=o[S++],s=o[S++],a=o[S++];r.x+=t+s,r.y+=e+a,g.push(0,1,t,e,s,a),b.push(0,1,t,e,s,a)}else{const t=o[S++],e=o[S++];r.x+=t,r.y+=e,g.push(0,0,t,e),b.push(0,0,t,e)}break;case-1===e:case void 0===e:if(t){const t=h[y++];if(g.push(1,t),b.push(1,t),t){const t=h[y++],e=h[y++];g.push(t,e),b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const e=h[y++];if(g.push(e),b.push(e),e){const t=h[y++],e=h[y++];i.x=t,i.y=e,g.push(t,e),b.push(t,e)}const s=h[y++];if(g.push(s),b.push(s),s){const t=h[y++];g.push(t),b.push(t)}const a=h[y++];if(g.push(a),b.push(a),a){const t=h[y++];g.push(t),b.push(t)}const r=h[y++];if(g.push(r),b.push(r),r){const t=h[y++];g.push(t),b.push(t)}break}if(h[y++]){const t=h[y++],e=h[y++],s=h[y++],a=h[y++];i.x+=t+s,i.y+=e+a,g.push(0,1,t,e,s,a),b.push(0,1,t,e,s,a)}else{const t=h[S++],e=h[S++];i.x+=t,i.y+=e,g.push(0,0,t,e),b.push(0,0,t,e)}break;case 1===t&&1===e:const s=h[y++];if(b.push(1,s),s){const t=h[y++],e=h[y++];b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const a=h[y++];if(b.push(a),a){const t=h[y++],e=h[y++];i.x=t,i.y=e,b.push(t,e)}const n=h[y++];if(b.push(n),n){const t=h[y++];b.push(t)}const l=h[y++];if(b.push(l),l){const t=h[y++];b.push(t)}const c=h[y++];if(b.push(c),c){const t=h[y++];b.push(t)}const m=o[S++];if(g.push(1,m),m){const t=o[S++],e=o[S++];g.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const f=o[S++];if(g.push(f),f){const t=o[S++],e=o[S++];i.x=t,i.y=e,g.push(t,e)}const d=o[S++];if(g.push(d),d){const t=o[S++];g.push(t)}const Y=o[S++];if(g.push(Y),Y){const t=o[S++];g.push(t)}const I=o[S++];if(g.push(I),I){const t=o[S++];g.push(t)}break;case 0===t&&0===e:if(h[y++]){const t=h[y++],e=h[y++],s=h[y++],a=h[y++];i.x=s,i.y=a,b.push(0,1,t,e,s,a)}else{const t=h[y++],e=h[y++];i.x=t,i.y=e,b.push(0,0,t,e)}if(o[S++]){const t=o[S++],e=o[S++],s=o[S++],a=o[S++];r.x=s,r.y=a,g.push(0,1,t,e,s,a)}else{const t=o[S++],e=o[S++];r.x=t,r.y=e,g.push(0,0,t,e)}break;case 1===t&&0===e:{const t=h[y++];if(g.push(1,t),b.push(1,t),t){const t=h[y++],e=h[y++];g.push(t,e),b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const e=h[y++];if(g.push(e),b.push(e),e){const t=h[y++],e=h[y++];i.x=t,i.y=e,g.push(t,e),b.push(t,e)}const s=h[y++];if(g.push(s),b.push(s),s){const t=h[y++];g.push(t),b.push(t)}const a=h[y++];if(g.push(a),b.push(a),a){const t=h[y++];g.push(t),b.push(t)}const r=h[y++];if(g.push(r),b.push(r),r){const t=h[y++];g.push(t),b.push(t)}--S}break;case 0===t&&1===e:{const t=o[S++];if(g.push(1,t),b.push(1,t),t){const t=o[S++],e=o[S++];g.push(t,e),b.push(t,e),console.log(\"TODO Parse Morph NewStyles\")}const e=o[S++];if(g.push(e),b.push(e),e){const t=o[S++],e=o[S++];r.x=t,r.y=e,g.push(t,e),b.push(t,e)}const s=o[S++];if(g.push(s),b.push(s),s){const t=o[S++];g.push(t),b.push(t)}const a=o[S++];if(g.push(a),b.push(a),a){const t=o[S++];g.push(t),b.push(t)}const i=o[S++];if(g.push(i),b.push(i),i){const t=o[S++];g.push(t),b.push(t)}--y}}}b.push(-1),g.push(-1),e.StartEdges.ShapeData.records=new Int32Array(b),e.EndEdges.ShapeData.records=new Int32Array(g),this.setCharacter(e.CharacterId,{_$ns:[\"flash\",\"display\"],_$name:\"MorphShape\",_$characterId:e.CharacterId,_$endBounds:e.EndBounds,_$endEdges:e.EndEdges,_$fillStyles:e.MorphFillStyles,_$lineStyles:e.MorphLineStyles,_$startBounds:e.StartBounds,_$startEdges:e.StartEdges,_$shapes:null,_$frameData:[],_$frameCreated:!1},[e.StartEdges.ShapeData.records.buffer,e.EndEdges.ShapeData.records.buffer])}parseFrameLabel(){return{name:this.byteStream.getDataUntil(),frame:0}}parseDefineButton(t,e){const s=this.byteStream.byte_offset+e|0,a={_$ns:[\"flash\",\"display\"],_$name:\"SimpleButton\"};a._$characterId=0|this.byteStream.getUI16();let i=0;7!==t&&(this.byteStream.getUIBits(7),a._$trackAsMenu=!!this.byteStream.getUIBits(1),i=0|this.byteStream.getUI16()),a._$characters=this.buttonCharacters(s),7===t?(i=s-this.byteStream.byte_offset|0,this.byteStream.byte_offset+=i):i>0&&(a._$actions=this.buttonActions(s)),this.setCharacter(a._$characterId,a),this.byteStream.byte_offset!==s&&(this.byteStream.byte_offset=0|s)}buttonCharacters(t){const e=[];for(;0!==this.byteStream.getUI8();){this.byteStream.incrementOffset(-1,0);const s=0|this.byteStream.byte_offset,a=this.buttonRecord();if(this.byteStream.byte_offset>t){this.byteStream.byte_offset=0|s;break}e[e.length]=a}return e}buttonRecord(){this.byteStream.getUIBits(2);const t={};return t.PlaceFlagHasBlendMode=this.byteStream.getUIBits(1),t.PlaceFlagHasFilterList=this.byteStream.getUIBits(1),t.ButtonStateHitTest=this.byteStream.getUIBits(1),t.ButtonStateDown=this.byteStream.getUIBits(1),t.ButtonStateOver=this.byteStream.getUIBits(1),t.ButtonStateUp=this.byteStream.getUIBits(1),t.CharacterId=this.byteStream.getUI16(),t.Depth=this.byteStream.getUI16(),t.PlaceFlagHasMatrix=1,t.Matrix=this.matrix(),t.ColorTransform=this.colorTransform(),t.PlaceFlagHasColorTransform=void 0===t.ColorTransform?0:1,t.PlaceFlagHasBlendMode&&(t.BlendMode=this.byteStream.getUI8()),t.PlaceFlagHasFilterList&&(t.SurfaceFilterList=this.getFilterList()),t.PlaceFlagHasRatio=0,t.PlaceFlagHasClipDepth=0,t.Sound=null,t}buttonActions(t){for(;;){const e={},s=0|this.byteStream.byte_offset,a=this.byteStream.getUI16();e.CondIdleToOverDown=this.byteStream.getUIBits(1),e.CondOutDownToIdle=this.byteStream.getUIBits(1),e.CondOutDownToOverDown=this.byteStream.getUIBits(1),e.CondOverDownToOutDown=this.byteStream.getUIBits(1),e.CondOverDownToOverUp=this.byteStream.getUIBits(1),e.CondOverUpToOverDown=this.byteStream.getUIBits(1),e.CondOverUpToIdle=this.byteStream.getUIBits(1),e.CondIdleToOverUp=this.byteStream.getUIBits(1),e.CondKeyPress=this.byteStream.getUIBits(7),e.CondOverDownToIdle=this.byteStream.getUIBits(1);const i=t-this.byteStream.byte_offset+1|0;if(this.byteStream.byte_offset+=i,!a)break;this.byteStream.byte_offset=s+a|0}return[]}parsePlaceObject(t,e){const s=this.byteStream.byte_offset,a={};if(a.tagType=t,4===t)return a.CharacterId=this.byteStream.getUI16(),a.Depth=this.byteStream.getUI16(),a.Matrix=this.matrix(),a.PlaceFlagHasMatrix=1,this.byteStream.byteAlign(),this.byteStream.byte_offset-s<e&&(a.ColorTransform=this.colorTransform(),a.PlaceFlagHasColorTransform=1),this.byteStream.byteAlign(),this.byteStream.byte_offset=s+e,a;const i=this.swfVersion;if(a.PlaceFlagHasClipActions=this.byteStream.getUIBits(1),a.PlaceFlagHasClipDepth=this.byteStream.getUIBits(1),a.PlaceFlagHasName=this.byteStream.getUIBits(1),a.PlaceFlagHasRatio=this.byteStream.getUIBits(1),a.PlaceFlagHasColorTransform=this.byteStream.getUIBits(1),a.PlaceFlagHasMatrix=this.byteStream.getUIBits(1),a.PlaceFlagHasCharacter=this.byteStream.getUIBits(1),a.PlaceFlagMove=this.byteStream.getUIBits(1),70===t&&(this.byteStream.getUIBits(1),a.PlaceFlagOpaqueBackground=this.byteStream.getUIBits(1),a.PlaceFlagHasVisible=this.byteStream.getUIBits(1),a.PlaceFlagHasImage=this.byteStream.getUIBits(1),a.PlaceFlagHasClassName=this.byteStream.getUIBits(1),a.PlaceFlagHasCacheAsBitmap=this.byteStream.getUIBits(1),a.PlaceFlagHasBlendMode=this.byteStream.getUIBits(1),a.PlaceFlagHasFilterList=this.byteStream.getUIBits(1)),a.Depth=this.byteStream.getUI16(),a.PlaceFlagHasClassName&&(a.ClassName=this.byteStream.getDataUntil(),console.log(\"TODO \",a.ClassName)),a.PlaceFlagHasCharacter&&(a.CharacterId=this.byteStream.getUI16()),a.PlaceFlagHasMatrix&&(a.Matrix=this.matrix()),a.PlaceFlagHasColorTransform&&(a.ColorTransform=this.colorTransform()),a.PlaceFlagHasRatio&&(a.Ratio=this.byteStream.getUI16()),a.PlaceFlagHasName&&(a.Name=this.byteStream.getDataUntil()),a.PlaceFlagHasClipDepth&&(a.ClipDepth=this.byteStream.getUI16()),70===t&&(a.PlaceFlagHasFilterList&&(a.SurfaceFilterList=this.getFilterList()),a.PlaceFlagHasBlendMode&&(a.BlendMode=this.byteStream.getUI8()),a.PlaceFlagHasCacheAsBitmap&&(a.BitmapCache=this.byteStream.getUI8()),a.PlaceFlagHasVisible&&(a.Visible=this.byteStream.getUI8()),a.PlaceFlagOpaqueBackground&&(a.BackgroundColor=this.rgba())),a.PlaceFlagHasClipActions){this.byteStream.getUI16(),a.AllEventFlags=this.parseClipEventFlags();const t=s+e;for(;this.byteStream.byte_offset<t;){const e=this.parseClipActionRecord(t);if(t<=this.byteStream.byte_offset)break;if(!(i<=5?this.byteStream.getUI16():this.byteStream.getUI32()))break;this.byteStream.byte_offset-=i<=5?2:4,e.KeyCode&&(this.byteStream.byte_offset-=1)}}return this.byteStream.byteAlign(),this.byteStream.byte_offset=s+e,a}parseClipActionRecord(t){const e={},s=this.parseClipEventFlags();if(t>this.byteStream.byte_offset){const t=this.byteStream.getUI32();s.keyPress&&(e.KeyCode=this.byteStream.getUI8()),this.byteStream.byte_offset+=t}return e}parseClipEventFlags(){const t=this.swfVersion,e={};return e.keyUp=this.byteStream.getUIBits(1),e.keyDown=this.byteStream.getUIBits(1),e.mouseUp=this.byteStream.getUIBits(1),e.mouseDown=this.byteStream.getUIBits(1),e.mouseMove=this.byteStream.getUIBits(1),e.unload=this.byteStream.getUIBits(1),e.enterFrame=this.byteStream.getUIBits(1),e.load=this.byteStream.getUIBits(1),t>=6&&(e.dragOver=this.byteStream.getUIBits(1),e.rollOut=this.byteStream.getUIBits(1),e.rollOver=this.byteStream.getUIBits(1),e.releaseOutside=this.byteStream.getUIBits(1),e.release=this.byteStream.getUIBits(1),e.press=this.byteStream.getUIBits(1),e.initialize=this.byteStream.getUIBits(1)),e.data=this.byteStream.getUIBits(1),t>=6&&(this.byteStream.getUIBits(5),e.construct=this.byteStream.getUIBits(1),e.keyPress=this.byteStream.getUIBits(1),e.dragOut=this.byteStream.getUIBits(1),this.byteStream.getUIBits(8)),this.byteStream.byteAlign(),e}getFilterList(){const t=0|this.byteStream.getUI8(),e=[];for(let s=0;s<t;++s){const t=this.getFilter();t&&(e[e.length]=t)}return e.length?e:null}getFilter(){switch(0|this.byteStream.getUI8()){case 0:return this.dropShadowFilter();case 1:return this.blurFilter();case 2:return this.glowFilter();case 3:return this.bevelFilter();case 4:return this.gradientGlowFilter();case 5:return this.convolutionFilter();case 6:return this.colorMatrixFilter();case 7:return this.gradientBevelFilter()}}dropShadowFilter(){const t={},e=this.rgba(),s=e.A,a=e.R<<16|e.G<<8|e.B,i=this.byteStream.getUI32()/65536,r=this.byteStream.getUI32()/65536,h=this.byteStream.getUI32()/65536*Util.$Rad2Deg,o=this.byteStream.getUI32()/65536,n=this.byteStream.getFloat16()/256,l=!!this.byteStream.getUIBits(1),c=!!this.byteStream.getUIBits(1),b=!this.byteStream.getUIBits(1),g=this.byteStream.getUIBits(5);return t._$ns=[\"flash\",\"filters\"],t._$name=\"DropShadowFilter\",t.params=[null,o,h,a,s,i,r,n,g,l,c,b],t}blurFilter(){const t={},e=this.byteStream.getUI32()/65536,s=this.byteStream.getUI32()/65536,a=this.byteStream.getUIBits(5);return this.byteStream.getUIBits(3),t._$ns=[\"flash\",\"filters\"],t._$name=\"BlurFilter\",t.params=[null,e,s,a],t}glowFilter(){const t={},e=this.rgba(),s=e.A,a=e.R<<16|e.G<<8|e.B,i=this.byteStream.getUI32()/65536,r=this.byteStream.getUI32()/65536,h=this.byteStream.getFloat16()/256,o=!!this.byteStream.getUIBits(1),n=!!this.byteStream.getUIBits(1);this.byteStream.getUIBits(1);const l=this.byteStream.getUIBits(5);return t._$ns=[\"flash\",\"filters\"],t._$name=\"GlowFilter\",t.params=[null,a,s,i,r,h,l,o,n],t}bevelFilter(){const t={};let e=this.rgba();const s=e.A,a=e.R<<16|e.G<<8|e.B;e=this.rgba();const i=e.A,r=e.R<<16|e.G<<8|e.B,h=this.byteStream.getUI32()/65536,o=this.byteStream.getUI32()/65536,n=this.byteStream.getUI32()/65536*Util.$Rad2Deg,l=this.byteStream.getUI32()/65536,c=this.byteStream.getFloat16()/256,b=!!this.byteStream.getUIBits(1),g=!!this.byteStream.getUIBits(1);this.byteStream.getUIBits(1);const y=this.byteStream.getUIBits(1),S=this.byteStream.getUIBits(4);let m=\"inner\";return b||(m=y?\"full\":\"outer\"),t._$ns=[\"flash\",\"filters\"],t._$name=\"BevelFilter\",t.params=[null,l,n,a,s,r,i,h,o,c,S,m,g],t}gradientGlowFilter(){const t={},e=0|this.byteStream.getUI8(),s=[],a=[];for(let t=0;t<e;++t){const t=this.rgba();a[a.length]=t.A,s[s.length]=t.R<<16|t.G<<8|t.B|0}const i=[];for(let t=0;t<e;++t)i[i.length]=+this.byteStream.getUI8()/255;const r=this.byteStream.getUI32()/65536,h=this.byteStream.getUI32()/65536,o=this.byteStream.getUI32()/65536*Util.$Rad2Deg,n=this.byteStream.getUI32()/65536,l=this.byteStream.getFloat16()/256,c=!!this.byteStream.getUIBits(1),b=!!this.byteStream.getUIBits(1);this.byteStream.getUIBits(1);const g=this.byteStream.getUIBits(1),y=this.byteStream.getUIBits(4);let S=\"inner\";return c||(S=g?\"full\":\"outer\"),t._$ns=[\"flash\",\"filters\"],t._$name=\"GradientGlowFilter\",t.params=[null,n,o,s,a,i,r,h,l,y,S,b],t}convolutionFilter(){const t={},e=this.byteStream.getUI8(),s=this.byteStream.getUI8(),a=this.byteStream.getFloat32,i=this.byteStream.getFloat32,r=e*s,h=[];for(let t=0;t<r;++t)h[h.length]=this.byteStream.getFloat32();const o=this.rgba();this.byteStream.getUIBits(6);const n=!!this.byteStream.getUIBits(1),l=!!this.byteStream.getUIBits(1);return t._$ns=[\"flash\",\"filters\"],t._$name=\"ConvolutionFilter\",t.params=[null,e,s,h,a,i,l,n,o],t}gradientBevelFilter(){const t={},e=0|this.byteStream.getUI8(),s=[],a=[];for(let t=0;t<e;++t){const t=this.rgba();a[a.length]=t.A,s[s.length]=t.R<<16|t.G<<8|t.B|0}const i=[];for(let t=0;t<e;++t)i[i.length]=+this.byteStream.getUI8()/255;const r=this.byteStream.getUI32()/65536,h=this.byteStream.getUI32()/65536,o=this.byteStream.getUI32()/65536*Util.$Rad2Deg,n=this.byteStream.getUI32()/65536,l=this.byteStream.getFloat16()/256,c=!!this.byteStream.getUIBits(1),b=!!this.byteStream.getUIBits(1);this.byteStream.getUIBits(1);const g=this.byteStream.getUIBits(1),y=this.byteStream.getUIBits(4);let S=\"inner\";return c||(S=g?\"full\":\"outer\"),t._$ns=[\"flash\",\"filters\"],t._$name=\"GradientBevelFilter\",t.params=[null,n,o,s,a,i,r,h,l,y,S,b],t}colorMatrixFilter(){const t={},e=[];for(let t=0;t<20;t++)e[e.length]=this.byteStream.getFloat32();return t._$ns=[\"flash\",\"filters\"],t._$name=\"ColorMatrixFilter\",t.params=[null,e],t}colorTransform(){this.byteStream.byteAlign();const t=[1,1,1,1,0,0,0,0],e=this.byteStream.getUIBits(6),s=e>>5,a=15&e;return e>>4&1&&(t[0]=this.byteStream.getSIBits(a)/256,t[1]=this.byteStream.getSIBits(a)/256,t[2]=this.byteStream.getSIBits(a)/256,t[3]=this.byteStream.getSIBits(a)/256),s&&(t[4]=this.byteStream.getSIBits(a),t[5]=this.byteStream.getSIBits(a),t[6]=this.byteStream.getSIBits(a),t[7]=this.byteStream.getSIBits(a)),t}parseSoundStreamHead(t){const e={};e.tagType=t,this.byteStream.getUIBits(4),e.PlaybackSoundRate=this.byteStream.getUIBits(2),e.PlaybackSoundSize=this.byteStream.getUIBits(1),e.PlaybackSoundType=this.byteStream.getUIBits(1),e.StreamSoundCompression=this.byteStream.getUIBits(4),e.StreamSoundRate=this.byteStream.getUIBits(2),e.StreamSoundSize=this.byteStream.getUIBits(1),e.StreamSoundType=this.byteStream.getUIBits(1),e.StreamSoundSampleCount=this.byteStream.getUI16(),2===e.StreamSoundCompression&&(e.LatencySeek=this.byteStream.getSIBits(2))}parseDefineSound(t){const e=this.byteStream.byte_offset,s=this.byteStream.getUI16();this.byteStream.getUIBits(4),this.byteStream.getUIBits(2),this.byteStream.getUIBit(),this.byteStream.getUIBit(),this.byteStream.getUI32();const a=t-(this.byteStream.byte_offset-e),i={_$characterId:s,_$data:null,_$buffer:null};i._$length=this.byteStream.byte_offset+a,i._$offset=this.byteStream.byte_offset,this.byteStream.byte_offset=e+t,this.setCharacter(s,i)}parseStartSound(t){const e={};return e.SoundId=this.byteStream.getUI16(),89===t&&(e.SoundClassName=this.byteStream.getDataUntil()),e.SoundInfo=this.parseSoundInfo(),e}parseDefineButtonSound(){const t=this.byteStream.getUI16(),e=this.getCharacter(t);for(let t=0;t<4;t++){const s=this.byteStream.getUI16();if(s){const a=this.parseSoundInfo();switch(t){case 0:e.ButtonStateUpSoundInfo=a,e.ButtonStateUpSoundId=s;break;case 1:e.ButtonStateOverSoundInfo=a,e.ButtonStateOverSoundId=s;break;case 2:e.ButtonStateDownSoundInfo=a,e.ButtonStateDownSoundId=s;break;case 3:e.ButtonStateHitTestSoundInfo=a,e.ButtonStateHitTestSoundId=s}}}this.setCharacter(t,e)}parseSoundInfo(){this.byteStream.getUIBits(2);const t={};if(t.SyncStop=this.byteStream.getUIBit(),t.SyncNoMultiple=this.byteStream.getUIBit(),t.HasEnvelope=this.byteStream.getUIBit(),t.HasLoops=this.byteStream.getUIBit(),t.HasOutPoint=this.byteStream.getUIBit(),t.HasInPoint=this.byteStream.getUIBit(),t.HasInPoint&&(t.InPoint=this.byteStream.getUI32()),t.HasOutPoint&&(t.OutPoint=this.byteStream.getUI32()),t.HasLoops&&(t.LoopCount=this.byteStream.getUI16()),t.HasEnvelope){const e=this.byteStream.getUI8(),s=[];for(let t=0;t<e;++t)s[t]={Pos44:this.byteStream.getUI32(),LeftLevel:this.byteStream.getUI16(),RightLevel:this.byteStream.getUI16()};t.EnvPoints=e,t.EnvelopeRecords=s}return t}parseDefineFontAlignZones(){const t=this.byteStream.getUI16(),e=this.getFont(t)||{};e._$CSMTableHint=this.byteStream.getUIBits(2),this.byteStream.getUIBits(6);const s=0|e._$numGlyphs,a=[];for(let t=0;t<s;++t){const e=this.byteStream.getUI8(),s=[];for(let t=0;t<e;++t)s.push(this.byteStream.getFloat16()),s.push(this.byteStream.getFloat16());this.byteStream.getUIBits(6),this.byteStream.getUIBits(1),this.byteStream.getUIBits(1),a[t]=s}this.byteStream.byteAlign(),e._$zoneTable=a,this.setFont(t,e)}parseCSMTextSettings(t){const e=this.byteStream.getUI16(),s={};s.tagType=t,s.UseFlashType=this.byteStream.getUIBits(2),s.GridFit=this.byteStream.getUIBits(3),this.byteStream.getUIBits(3),s.Thickness=this.byteStream.getUI32(),s.Sharpness=this.byteStream.getUI32(),this.byteStream.getUI8(),this.setTextSetting(e,s)}parseSoundStreamBlock(t,e){const s={};s.tagType=t,s.compressed=this.byteStream.getData(e)}parseDefineScalingGrid(){const t=this.byteStream.getUI16(),e=this.rect();this.setGrid(t,e)}postCharacter(t,e){globalThis.postMessage({infoKey:\"_$characters\",characters:t},e),t.length=0,e&&(e.length=0)}}Util.$swfParser=new SwfParser,this.addEventListener(\"message\",(function(t){const e=Util.$swfParser;e.version=t.data.version,e.byteStream.setData(t.data.buffer),e.byteStream.byte_offset=t.data.offset;const s=Util.$createMovieClip();e.parseTags(t.data.buffer.length,s),e.postData(s),e.clear()}));"], { "type": "text/javascript" })
);
Util.$parserWorker     = null;
Util.$parserQueues     = [];
Util.$parserWorkerWait = false;

/**
 * @param  {object} event
 * @return void
 * @static
 */
Util.$unlzmaHandler = function (event)
{
    // event end
    event.target.onmessage = null;

    // next
    if (Util.$unlzmaQueues.length) {

        const object = Util.$unlzmaQueues.shift();

        const worker = new Worker(Util.$unlzmaWorkerURL);

        worker.onmessage = Util.$unlzmaHandler.bind(object);

        const data = object._$byteStream._$buffer;
        worker.postMessage({
            "fileSize": object.fileSize,
            "mode":     object.mode,
            "buffer":   data
        }, [data.buffer]);

    } else {

        Util.$unlzmaWorkerActive = false;

    }

    // setup
    this._$byteStream._$buffer = event.data;
    this.parseAndBuild();
};

/**
 * @description 全てのエリアのコピーを初期化
 * @return {void}
 * @static
 */
Util.$allClearCopy = () =>
{
    Util.$timelineMenu.clearCopy();
    Util.$screenMenu.clearCopy();
    Util.$libraryMenu.clearCopy();
};

/**
 * @param  {Uint8Array} data
 * @return {string|null}
 * @static
 */
Util.$getImageType = (data) =>
{
    switch (true) {

        // JPEG
        case data[0] === 0xff && data[1] === 0xd8:
            return "jpeg";

        // GIF
        case data[0] === 0x47 && data[1] === 0x49 && data[2] === 0x46:
            return "gif";

        // PNG
        case data[0] === 0x89 && data[1] === 0x50 &&
            data[2] === 0x4E && data[3] === 0x47 &&
            data[4] === 0x0D && data[5] === 0x0A &&
            data[6] === 0x1A && data[7] === 0x0A:
            return "png";

        // BMP
        case data[0] === 0x42 && data[1] === 0x4d:
            return "bmp";

        default:
            return null;

    }
};

/**
 * @return {void}
 * @static
 */
Util.$jpegDecodeHandler = () =>
{
    const image  = this.image;
    const width  = image.width;
    const height = image.height;

    const canvas  = document.createElement("canvas");
    canvas.width  = width;
    canvas.height = height;
    const context = canvas.getContext("2d");

    context.drawImage(image, 0, 0, width, height);
    const buffer = new Uint8Array(context
        .getImageData(0, 0, width, height)
        .data);

    // clear
    this.jpegData = null;
    this.image    = null;

    const workSpace = Util.$currentWorkSpace();
    const instance  = workSpace.getLibrary(this.libraryId);
    instance.width  = width;
    instance.height = height;

    if (this.isAlpha) {

        // set
        this.buffer = buffer;
        this.width  = width;
        this.height = height;

        if (Util.$unzipWorkerActive) {
            Util.$unzipQueues.push(this);
            return ;
        }

        Util.$unzipWorkerActive = true;

        if (!Util.$unzipWorker) {
            Util.$unzipWorker = new Worker(Util.$unzipURL);
        }

        const worker = Util.$unzipWorker;
        worker.onmessage = Util.$unzipHandler.bind(this);
        worker.postMessage(this, [
            this.buffer.buffer,
            this.alphaData.buffer
        ]);

    } else {

        instance._$buffer = buffer;

    }
};

/**
 * @type {Map}
 */
Util.$characters = new Map();
Util.$symbols    = new Map();
Util.$fonts      = new Map();
Util.$texts      = new Map();

/**
 * @param  {object} event
 * @return void
 * @static
 */
Util.$parserHandler = function (event)
{
    const worker = event.target;
    switch (event.data.infoKey) {

        case "character":
            {
                const character = event.data.piece;

                const workSpace = Util.$currentWorkSpace();
                const id = workSpace.nextLibraryId;
                character.libraryId = id;

                switch (character._$name) {

                    case "Shape":
                        {
                            const object = Util
                                .$libraryController
                                .createInstance(InstanceType.SHAPE, `Shape_${id}`, id);

                            object.recodes  = Util.$vtc.convert(character._$records);
                            object.inBitmap = object.recodes.pop();
                            object.bounds   = {
                                "xMin": character._$bounds.xMin,
                                "xMax": character._$bounds.xMax,
                                "yMin": character._$bounds.yMin,
                                "yMax": character._$bounds.yMax
                            };

                            const shape = workSpace.addLibrary(object);
                            if (this._$folderId) {
                                shape.folderId = this._$folderId;
                            }

                            Util.$characters.set(character._$characterId, id);
                        }
                        break;

                    case "MovieClip":
                        {
                            for (let idx = 0; idx < character._$dictionary.length; ++idx) {
                                const object = character._$dictionary[idx];
                                object.LibraryId = Util.$characters.get(object.CharacterId);
                            }

                            const name = character._$characterId
                                ? `MovieClip_${id}`
                                : this._$fileName;

                            let libraryId = !character._$characterId && this._$libraryId
                                ? this._$libraryId
                                : id;

                            const object = Util
                                .$libraryController
                                .createInstance(InstanceType.MOVIE_CLIP, name, libraryId);

                            // create MovieClip
                            const movieClip = workSpace.addLibrary(object);
                            if (this._$folderId) {
                                movieClip.folderId = this._$folderId;
                            }

                            // create layer
                            let clipMap = new Map();
                            let layerArray = [];
                            for (let idx = 0; idx < character._$dictionary.length; ++idx) {
                                const tag = character._$dictionary[idx];

                                if (layerArray.indexOf(tag.Depth) !== -1) {
                                    continue;
                                }
                                layerArray.push(tag.Depth);

                                if (tag.ClipDepth) {
                                    clipMap.set(tag.Depth, idx);
                                }

                            }

                            layerArray.sort((a, b) =>
                            {
                                switch (true) {

                                    case a > b:
                                        return 1;

                                    case a < b:
                                        return -1;

                                    default:
                                        return 0;

                                }
                            });

                            // adj clips
                            if (clipMap.size) {

                                for (const [depth, index] of clipMap) {

                                    const moveArray = [];

                                    const tag = character._$dictionary[index];
                                    for (let idx = 0; character._$dictionary.length > idx; ++idx) {

                                        const target = character._$dictionary[idx];
                                        if (target.Depth > tag.ClipDepth) {
                                            break;
                                        }

                                        if (target.Depth > depth) {
                                            moveArray.push(target);
                                        }
                                    }

                                    for (let idx = 0; idx < moveArray.length; ++idx) {

                                        const target = moveArray[idx];

                                        const index = layerArray.indexOf(target.Depth);
                                        const depth = layerArray.splice(index, 1)[0];
                                        const insertIndex = layerArray.indexOf(tag.Depth);

                                        layerArray.splice(insertIndex, 0, depth);
                                    }

                                }
                            }

                            let maskId     = -1;
                            let clipDepth  = -1;
                            const index    = layerArray.length - 1;
                            const layerMap = new Map();
                            const layers   = [];
                            for (let idx = index; idx > -1; --idx) {

                                const layer = new Layer();
                                layer.name  = `Layer_${index - idx}`;

                                const depth = layerArray[idx];
                                if (clipMap.size) {

                                    if (clipDepth > -1) {
                                        if (depth > clipDepth) {
                                            layer.mode   = LayerMode.MASK_IN;
                                            layer.maskId = maskId;
                                        } else {
                                            maskId    = -1;
                                            clipDepth = -1;
                                        }
                                    }

                                    if (clipMap.has(depth)) {
                                        clipDepth  = depth;
                                        maskId     = index - idx;
                                        layer.mode = LayerMode.MASK;
                                    }
                                }

                                layers.push(layer);
                                layerMap.set(depth, layer);
                            }

                            for (let idx = 0; idx < layerArray.length; ++idx) {
                                movieClip.setLayer(idx, layers[idx]);
                            }

                            // setup
                            const characters = [];
                            const totalFrame = character._$controller.length - 1;
                            for (let idx = 0; idx < character._$dictionary.length; ++idx) {

                                const tag = character._$dictionary[idx];

                                const instance = new Character();
                                instance.libraryId  = tag.LibraryId;
                                instance.startFrame = tag.StartFrame;
                                instance.endFrame   = tag.EndFrame || totalFrame + 1;
                                instance.name       = tag.Name || "";

                                characters.push(instance);
                            }

                            const dup = new Map();
                            for (let frame = 1; frame < character._$controller.length; ++frame) {

                                const controller = character._$controller[frame];
                                for (let idx = 0; idx < controller.length; ++idx) {

                                    const id  = controller[idx];
                                    const tag = character._$dictionary[id];

                                    const layer = layerMap.get(tag.Depth);

                                    const instance = characters[id];
                                    if (!dup.has(id)) {
                                        dup.set(id, -1);
                                        layer.addCharacter(instance);
                                    }

                                    const nextId    = character._$placeMap[frame][tag.Depth];
                                    const currentId = dup.get(id);
                                    if (currentId !== nextId) {
                                        const placeObject = character._$placeObjects[nextId];

                                        instance.setPlace(frame, {
                                            "frame": frame,
                                            "depth": 0,
                                            "matrix": placeObject.matrix,
                                            "colorTransform": placeObject.colorTransform,
                                            "blendMode": placeObject.blendMode,
                                            "filter": placeObject.filters ? placeObject.filters : [],
                                            "loop": Util.$getDefaultLoopConfig()
                                        });

                                        dup.set(id, nextId);
                                    }
                                }
                            }

                            for (let idx = 0; idx < layers.length; ++idx) {

                                const empty = {
                                    "startFrame": -1
                                };

                                const layer = layers[idx];
                                for (let frame = 1; frame <= totalFrame; ++frame) {

                                    const characters = layer.getActiveCharacter(frame);

                                    // 空白のフレーム処理
                                    if (!characters.length) {

                                        if (empty.startFrame === -1) {
                                            empty.startFrame = frame;
                                        }

                                    } else {

                                        // 空白のフレームがあれば登録して初期化
                                        if (empty.startFrame > 0) {
                                            layer.addEmptyCharacter(new EmptyCharacter({
                                                "startFrame": empty.startFrame,
                                                "endFrame": frame
                                            }));

                                            // 初期化
                                            empty.startFrame = -1;
                                        }

                                    }
                                }
                            }

                            // 連続するplace objectをtweenに変換する
                            for (let idx = 0; idx < layers.length; ++idx) {

                                const layer = layers[idx];

                                const totalFrame = layer.totalFrame;
                                for (let frame = 1; totalFrame > frame; ) {

                                    const characters = layer.getActiveCharacter(frame);
                                    if (!characters.length || characters.length > 2) {
                                        frame++;
                                        continue;
                                    }

                                    const character = characters[0];
                                    const range = character.getRange(frame);

                                    // 幅が1フレーム以上なら次のレンジに移動
                                    if (range.endFrame - range.startFrame !== 1) {
                                        frame = range.endFrame;
                                        continue;
                                    }

                                    // キーフレームが終了していれば次のレイヤーへ
                                    if (frame + 1 >= totalFrame) {
                                        break;
                                    }

                                    if (!character.hasPlace(frame + 1)) {
                                        frame++;
                                        continue;
                                    }

                                    const startFrame = frame;
                                    for (;;) {

                                        // 次のフレームにキーフレームがなければ終了
                                        if (!character.hasPlace(frame + 1)) {
                                            if (frame - startFrame > 2) {
                                                character.setTween(startFrame, {
                                                    "method": "linear",
                                                    "curve": [],
                                                    "custom": Util.$tweenController.createEasingObject(),
                                                    "startFrame": startFrame,
                                                    "endFrame": frame
                                                });

                                                // キーフレームにtweenの設定を追加
                                                for (let tweenFrame = startFrame; frame > tweenFrame; ++tweenFrame) {
                                                    character.getPlace(tweenFrame).tweenFrame = startFrame;
                                                }
                                            }
                                            break;
                                        }

                                        frame++;

                                        // フレームが終了したら次のレイヤーに
                                        if (frame >= totalFrame) {
                                            break;
                                        }
                                    }

                                }

                            }

                            Util.$characters.set(character._$characterId, id);
                        }
                        break;

                    case "lossless": // PNG
                        {

                            const object = Util
                                .$libraryController
                                .createInstance(InstanceType.BITMAP, `Bitmap_${id}`, id);

                            character.mode   = "lossless";
                            object.imageType = "image/png";
                            object.buffer    = null;
                            object.width     = character.width;
                            object.height    = character.height;

                            const bitmap = workSpace.addLibrary(object);
                            if (this._$folderId) {
                                bitmap.folderId = this._$folderId;
                            }

                            Util.$characters.set(character._$characterId, id);

                            if (Util.$unzipWorkerActive) {
                                Util.$unzipQueues.push(character);
                                return ;
                            }

                            Util.$unzipWorkerActive = true;

                            if (!Util.$unzipWorker) {
                                Util.$unzipWorker = new Worker(Util.$unzipURL);
                            }

                            const worker = Util.$unzipWorker;
                            worker.onmessage = Util.$unzipHandler.bind(character);
                            worker.postMessage(character, [character.buffer.buffer]);
                        }
                        break;

                    case "imageData": // JPEG,GIF,PNG,etc...
                        {
                            const object = Util
                                .$libraryController
                                .createInstance(InstanceType.BITMAP, `Bitmap_${id}`, id);

                            const imageType     = `image/${Util.$getImageType(character.jpegData)}`;
                            character.mode      = "jpegAlpha";
                            character.imageType = imageType;
                            object.imageType    = imageType;
                            object.buffer       = null;
                            object.width        = 0;
                            object.height       = 0;

                            const bitmap = workSpace.addLibrary(object);
                            if (this._$folderId) {
                                bitmap.folderId = this._$folderId;
                            }

                            Util.$characters.set(character._$characterId, id);

                            character.image = new Image();
                            character.image.decoding = "async";
                            character.image.src = URL.createObjectURL(
                                new Blob([character.jpegData], {
                                    "type": character.imageType
                                })
                            );

                            character.image.decode()
                                .then(Util.$jpegDecodeHandler.bind(character));

                        }
                        break;

                    case "StaticText":
                        {
                            const object = Util
                                .$libraryController
                                .createInstance(InstanceType.SHAPE, `ShapeText_${id}`, id);

                            object.bounds  = {
                                "xMin": character._$bounds.xMin,
                                "xMax": character._$bounds.xMax,
                                "yMin": character._$bounds.yMin,
                                "yMax": character._$bounds.yMax
                            };

                            const text = workSpace.addLibrary(object);
                            if (this._$folderId) {
                                text.folderId = this._$folderId;
                            }

                            Util.$characters.set(character._$characterId, id);

                            Util.$texts.set(Util.$texts.size, character);
                        }
                        break;

                    case "SimpleButton":
                        {
                            console.log("TODO SimpleButton: ", character);

                            const object = Util
                                .$libraryController
                                .createInstance(InstanceType.BUTTON, `Button_${id}`, id);

                            object.bounds  = {
                                "xMin": character._$bounds.xMin,
                                "xMax": character._$bounds.xMax,
                                "yMin": character._$bounds.yMin,
                                "yMax": character._$bounds.yMax
                            };

                            // workSpace.addLibrary(object);

                            Util.$characters.set(character._$characterId, id);
                        }
                        break;

                    case "TextField":
                        {
                            const object = Util
                                .$libraryController
                                .createInstance(InstanceType.TEXT, `Text_${id}`, id);

                            object.bounds  = {
                                "xMin": character._$bounds.xMin,
                                "xMax": character._$bounds.xMax,
                                "yMin": character._$bounds.yMin,
                                "yMax": character._$bounds.yMax
                            };

                            // attach
                            object.text          = character._$text;
                            object.inputType     = character._$type;
                            object.color         = character._$textColor;
                            object.font          = character._$defaultTextFormat[1];
                            object.size          = character._$defaultTextFormat[2];
                            object.align         = character._$defaultTextFormat[7];
                            object.leftMargin    = character._$defaultTextFormat[8];
                            object.rightMargin   = character._$defaultTextFormat[9];
                            object.leading       = character._$defaultTextFormat[10];
                            object.multiline     = character._$multiline === 1;
                            object.wordWrap      = character._$wordWrap === 1;
                            object.border        = character._$border === 1;

                            if (character._$defaultTextFormat[4]
                            && character._$defaultTextFormat[5]
                            ) {
                                object.fontType = 3;
                            } else if (character._$defaultTextFormat[4]) {
                                object.fontType = 2;
                            } else if (character._$defaultTextFormat[5]) {
                                object.fontType = 1;
                            }

                            // TODO
                            object.htmlText = character._$htmlText;

                            const text = workSpace.addLibrary(object);
                            if (this._$folderId) {
                                text.folderId = this._$folderId;
                            }

                            Util.$characters.set(character._$characterId, id);
                        }
                        break;

                    default:
                        console.log("TODO: ", character);
                        break;

                }

                if (character._$characterId) {
                    return ;
                }

                if (this._$libraryId) {

                    Util.$changeLibraryId = this._$libraryId;

                    workSpace
                        .scene
                        .changeFrame(
                            Util.$timelineFrame.currentFrame
                        );

                    Util.$changeLibraryId = 0;
                }
            }
            break;

        case "_$symbols":
            for (let idx = 0; idx < event.data.pieces.length; ++idx) {
                const piece = event.data.pieces[idx];
                Util.$symbols.set(piece.tagId, piece.ns);
            }
            return;

        case "font":
            Util.$fonts.set(event.data.index, event.data.piece);
            return;

        case "font_shape":
            {
                const font = Util.$fonts.get(event.data.index);
                font._$glyphShapeTable.push.apply(font._$glyphShapeTable, event.data.pieces);
                Util.$fonts.set(event.data.index, font);
            }
            return;

        case "font_zone":
            {
                const font = Util.$fonts.get(event.data.index);
                font._$zoneTable.push.apply(font._$zoneTable, event.data.pieces);
                Util.$fonts.set(event.data.index, font);
            }
            return;

        default:
            break;

    }

    // if (Util.$texts.size) {
    //
    //     const { Graphics } = window.next2d.display;
    //
    //     const workSpace = Util.$currentWorkSpace();
    //
    //     for (const character of Util.$texts.values()) {
    //
    //         const shape = workSpace.getLibrary(character.libraryId);
    //
    //         // build shape data
    //         let offsetX     = 0;
    //         let offsetY     = 0;
    //         let color       = null;
    //         let codeTables  = null;
    //         let shapeTables = null;
    //         let textHeight  = 0;
    //         let isZoneTable = false;
    //
    //         const baseMatrix = character._$baseMatrix;
    //
    //         // build shape data
    //         const records = character._$textRecords;
    //         for (let idx = 0; idx < records.length; ++idx) {
    //
    //             const record = records[idx];
    //
    //             if ("FontId" in record) {
    //                 const font  = Util.$fonts.get(record.FontId);
    //                 codeTables  = font._$codeTable;
    //                 shapeTables = font._$glyphShapeTable;
    //                 isZoneTable = font._$zoneTable !== null;
    //             }
    //
    //             if ("XOffset" in record) {
    //                 offsetX = record.XOffset;
    //             }
    //
    //             if ("YOffset" in record) {
    //                 offsetY = record.YOffset;
    //             }
    //
    //             if ("TextColor" in record) {
    //                 color = record.TextColor;
    //             }
    //
    //             if ("TextHeight" in record) {
    //                 textHeight = record.TextHeight;
    //                 if (isZoneTable) {
    //                     textHeight /= 20;
    //                 }
    //             }
    //
    //             const entries = record.GlyphEntries;
    //             const count   = record.GlyphCount;
    //             const scale   = textHeight / 1024;
    //             for (let idx = 0; idx < count; ++idx) {
    //
    //                 const entry = entries[idx];
    //                 const index = entry.GlyphIndex | 0;
    //
    //                 // add records
    //                 const shapeRecodes = Util.$vtc.convert({
    //                     "ShapeData": shapeTables[index],
    //                     "lineStyles": [],
    //                     "fillStyles": [{
    //                         "Color": color,
    //                         "fillStyleType": 0
    //                     }]
    //                 });
    //
    //                 const matrix = [
    //                     scale, baseMatrix[1], baseMatrix[2], scale,
    //                     baseMatrix[4] + offsetX,
    //                     baseMatrix[5] + offsetY
    //                 ];
    //
    //                 for (let idx = 0; idx < shapeRecodes.length;) {
    //
    //                     const code = shapeRecodes[idx++];
    //                     shape._$recodes.push(code);
    //                     switch (code) {
    //
    //                         case Graphics.MOVE_TO:
    //                         case Graphics.LINE_TO:
    //                             {
    //                                 const x  = shapeRecodes[idx++];
    //                                 const y  = shapeRecodes[idx++];
    //                                 const tx = x * matrix[0] + y * matrix[2] + matrix[4];
    //                                 const ty = x * matrix[1] + y * matrix[3] + matrix[5];
    //                                 shape._$recodes.push(tx, ty);
    //                             }
    //                             break;
    //
    //                         case Graphics.CURVE_TO:
    //                             {
    //                                 const cx  = shapeRecodes[idx++];
    //                                 const cy  = shapeRecodes[idx++];
    //                                 const ctx = cx * matrix[0] + cy * matrix[2] + matrix[4];
    //                                 const cty = cx * matrix[1] + cy * matrix[3] + matrix[5];
    //                                 shape._$recodes.push(ctx, cty);
    //
    //                                 const x  = shapeRecodes[idx++];
    //                                 const y  = shapeRecodes[idx++];
    //                                 const tx = x * matrix[0] + y * matrix[2] + matrix[4];
    //                                 const ty = x * matrix[1] + y * matrix[3] + matrix[5];
    //                                 shape._$recodes.push(tx, ty);
    //                             }
    //                             break;
    //
    //                         case Graphics.FILL_STYLE:
    //                             shape._$recodes.push(
    //                                 shapeRecodes[idx++], shapeRecodes[idx++],
    //                                 shapeRecodes[idx++], shapeRecodes[idx++]
    //                             );
    //                             break;
    //
    //                         case Graphics.BEGIN_PATH:
    //                         case Graphics.END_FILL:
    //                             break;
    //
    //                     }
    //                 }
    //
    //                 offsetX += entry.GlyphAdvance;
    //             }
    //         }
    //     }
    // }

    const workSpace = Util.$currentWorkSpace();
    for (const [id, name] of Util.$symbols) {
        const instance = workSpace.getLibrary(id);
        instance._$symbol = `${name}`;
    }

    // map clear
    Util.$characters.clear();
    Util.$symbols.clear();
    Util.$fonts.clear();
    Util.$texts.clear();

    Util.$libraryController.reload(
        Array.from(workSpace._$libraries.values())
    );

    // parser end
    worker.onmessage = null;

    if (this._$resolve) {
        this._$resolve();
    }

    // next
    if (Util.$parserQueues.length) {

        const object = Util.$parserQueues.shift();

        worker.onmessage = Util.$parserHandler.bind(object);

        const buffer = object._$byteStream._$buffer;
        worker.postMessage({
            "version": object._$swfVersion,
            "offset":  object._$offset,
            "buffer":  buffer
        }, [buffer.buffer]);

    } else {

        Util.$parserWorkerWait = false;

    }

};

/**
 * @param  {object} bounds
 * @param  {Float32Array} matrix
 * @return {object}
 * @method
 * @static
 */
Util.$boundsMatrix = (bounds, matrix) =>
{
    const x0 = bounds.xMax * matrix[0] + bounds.yMax * matrix[2] + matrix[4];
    const x1 = bounds.xMax * matrix[0] + bounds.yMin * matrix[2] + matrix[4];
    const x2 = bounds.xMin * matrix[0] + bounds.yMax * matrix[2] + matrix[4];
    const x3 = bounds.xMin * matrix[0] + bounds.yMin * matrix[2] + matrix[4];
    const y0 = bounds.xMax * matrix[1] + bounds.yMax * matrix[3] + matrix[5];
    const y1 = bounds.xMax * matrix[1] + bounds.yMin * matrix[3] + matrix[5];
    const y2 = bounds.xMin * matrix[1] + bounds.yMax * matrix[3] + matrix[5];
    const y3 = bounds.xMin * matrix[1] + bounds.yMin * matrix[3] + matrix[5];

    return {
        "xMin": Math.min( Number.MAX_VALUE, x0, x1, x2, x3),
        "xMax": Math.max(-Number.MAX_VALUE, x0, x1, x2, x3),
        "yMin": Math.min( Number.MAX_VALUE, y0, y1, y2, y3),
        "yMax": Math.max(-Number.MAX_VALUE, y0, y1, y2, y3)
    };
};

/**
 * @param   {number} color
 * @returns {object}
 * @method
 * @static
 */
Util.$intToRGB = (color) =>
{
    return {
        "R": (color & 0xff0000) >> 16,
        "G": (color & 0x00ff00) >> 8,
        "B": color & 0x0000ff
    };
};

/**
 * @param  {object} object
 * @param  {Map}    dup
 * @method
 * @static
 */
Util.$copyContainer = (object, dup) =>
{
    const workSpace       = Util.$currentWorkSpace();
    const targetWorkSpace = Util.$workSpaces[Util.$copyWorkSpaceId];

    if (!dup.has(object.id)) {
        dup.set(object.id, workSpace.nextLibraryId);
    }

    object.id = dup.get(object.id);
    workSpace.addLibrary(object);

    for (let idx = 0; idx < object.layers.length; ++idx) {

        const layer = object.layers[idx];
        for (let idx = 0; idx < layer.characters.length; ++idx) {

            const character = layer.characters[idx];
            if (!dup.has(character.libraryId)) {

                dup.set(character.libraryId, workSpace.nextLibraryId);

                const instance = targetWorkSpace
                    .getLibrary(character.libraryId);

                const object = instance.toObject();
                if (object.type === InstanceType.MOVIE_CLIP) {

                    Util.$copyContainer(object, dup);

                } else {

                    object.id = dup.get(character.libraryId);
                    workSpace.addLibrary(object);

                }
            }

            character.libraryId = dup.get(character.libraryId);
        }
    }

    workSpace.addLibrary(object);
};

/**
 * @return {void}
 * @static
 */
Util.$clearShapePointer = () =>
{
    const element  = document.getElementById("stage-area");
    if (!element) {
        return ;
    }

    const children = element.children;
    for (let idx = 0; children.length > idx; ++idx) {

        const node = children[idx];
        if (!node.dataset.shapePointer) {
            continue;
        }

        node.remove();
        --idx;
    }
};

/**
 * @return {object}
 * @static
 */
Util.$getDefaultLoopConfig = () =>
{
    return {
        "type": LoopController.DEFAULT,
        "start": 1,
        "end": 0
    };
};

/**
 * @param  {object} place
 * @param  {object} range
 * @param  {number} parent_frame
 * @param  {number} total_frame
 * @param  {number} static_frame
 * @return {number}
 * @static
 */
Util.$getFrame = (place, range, parent_frame, total_frame, static_frame = 0) =>
{
    // レンジ幅での移動数
    const length = parent_frame - range.startFrame;

    let frame = 1;
    switch (place.loop.type) {

        case LoopController.REPEAT:
            {
                const totalFrame = place.loop.end
                    ? place.loop.end
                    : total_frame;

                frame = place.loop.start;
                for (let idx = 0; idx < length; ++idx) {

                    ++frame;

                    if (frame > totalFrame) {
                        frame = place.loop.start;
                    }

                }
            }
            break;

        case LoopController.NO_REPEAT:
            {
                const totalFrame = place.loop.end
                    ? place.loop.end
                    : total_frame;

                frame = place.loop.start;
                for (let idx = 0; idx < length; ++idx) {

                    ++frame;

                    // ループは一回だけなので最後のフレームで終了
                    if (frame > totalFrame) {
                        frame = totalFrame;
                        break;
                    }

                }
            }
            break;

        case LoopController.FIXED_ONE:
            frame = place.loop.start;
            break;

        case LoopController.NO_REPEAT_REVERSAL:
            frame = place.loop.end
                ? place.loop.end
                : total_frame;

            for (let idx = 0; idx < length; ++idx) {

                --frame;

                // ループは一回だけなので最初のフレームにセットして終了
                if (place.loop.start > frame) {
                    frame = place.loop.start;
                    break;
                }
            }
            break;

        case LoopController.REPEAT_REVERSAL:
            {
                const totalFrame = place.loop.end
                    ? place.loop.end
                    : total_frame;

                frame = totalFrame;
                for (let idx = 0; idx < length; ++idx) {

                    --frame;

                    if (place.loop.start > frame) {
                        frame = totalFrame;
                    }
                }
            }
            break;

        case LoopController.DEFAULT:

            if (static_frame === 0) {
                frame = 1;
                for (let idx = 0; idx < length; ++idx) {

                    ++frame;

                    if (frame > total_frame) {
                        frame = 1;
                    }

                }
            } else {
                frame = static_frame;
                if (frame > total_frame) {
                    frame = 1;
                }
            }

            break;

    }

    return frame;
};

/**
 * @class
 * @memberOf global
 */
class GlobalKeyboardCommand
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$activeTool = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$executeMulti = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        // 元に戻す
        Util.$setShortcut(
            Util.$generateShortcutKey("z", { "ctrl": true }),
            this.undo
        );

        // 戻したデータを進める
        Util.$setShortcut(
            Util.$generateShortcutKey("z", { "ctrl": true, "shift": true }),
            this.redo
        );

        // データをローカルに保存
        Util.$setShortcut(
            Util.$generateShortcutKey("s", { "ctrl": true }),
            Util.$autoSave
        );

        Util.$setShortcut("Enter", () =>
        {
            Util.$timelinePlayer.executeTimelinePlay();
        });

        // プレビュー画面を起動
        Util.$setShortcut(
            Util.$generateShortcutKey("Enter", { "ctrl": true }),
            Util.$showPreview
        );

        // データの書き出し
        Util.$setShortcut(
            Util.$generateShortcutKey("Enter", { "ctrl": true, "shift": true }),
            Util.$project.publish
        );

        // プレビューを終了
        Util.$setShortcut("Escape", Util.$hidePreview);

        // リピートモードの切り替え
        Util.$setShortcut(
            Util.$generateShortcutKey("p", { "ctrl": true }),
            this.changeRepeatMode
        );

        // プロジェクト移動(タブ移動)
        Util.$setShortcut(
            Util.$generateShortcutKey("ArrowRight", { "ctrl": true }),
            this.changeProject
        );
        Util.$setShortcut(
            Util.$generateShortcutKey("ArrowLeft", { "ctrl": true }),
            this.changeProject
        );

        Util.$initializeEnd();
    }

    /**
     * @description redoを実行
     *
     * @return {void}
     * @method
     * @public
     */
    redo ()
    {
        const workSpace = Util.$currentWorkSpace();
        if (workSpace) {
            workSpace.redo();
        }
    }

    /**
     * @description undoを実行
     *
     * @return {void}
     * @method
     * @public
     */
    undo ()
    {
        const workSpace = Util.$currentWorkSpace();
        if (workSpace) {
            workSpace.undo();
        }
    }

    /**
     * @description リピートモードの切り替え
     *
     * @return {void}
     * @method
     * @public
     */
    changeRepeatMode ()
    {
        if (Util.$timelinePlayer.repeat) {
            Util.$timelinePlayer.executeTimelineRepeat();
        } else {
            Util.$timelinePlayer.executeTimelineNoRepeat();
        }
    }

    /**
     * @description プロジェクトの切り替え
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    changeProject (event)
    {
        const children = Array.from(document
            .getElementById("view-tab-area")
            .children);

        let index = 0;
        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];

            const tabId = node.dataset.tabId | 0;
            if (tabId === Util.$activeWorkSpaceId) {
                index = idx;
                break;
            }
        }

        let node = null;
        if (event.key === "ArrowLeft") {

            node = children[index - 1];
            if (!node) {
                node = children[children.length - 1];
            }

        } else {

            node = children[index + 1];
            if (!node) {
                node = children[0];
            }

        }

        if (node) {
            const tabId = node.dataset.tabId | 0;
            if (Util.$activeWorkSpaceId !== tabId) {
                Util.$screenTab.activeTab({
                    "currentTarget": {
                        "dataset": {
                            "tabId": tabId
                        }
                    }
                });
            }
        }
    }
}

Util.$globalKeyboardCommand = new GlobalKeyboardCommand();

/**
 * Animation PNG エンコーダー
 * Animation PNG Encoder
 *
 * @class
 * @memberOf encoder
 */
class ApngEncoder
{
    /**
     * @param {array}   pngs
     * @param {number}  [width = 0]
     * @param {number}  [height = 0]
     * @param {number}  [fps = 60]
     * @param {boolean} [loop = true]
     * @public
     */
    constructor (pngs, width = 0, height = 0, fps = 60, loop = true)
    {
        this._$pngs   = pngs;
        this._$width  = width;
        this._$height = height;
        this._$fps    = fps;
        this._$loop   = loop ? 0 : 1;

        this._$crcTable = new Uint32Array(256);
        for (let idx = 0; idx < 256; idx++) {

            let c = idx;
            for (let idx = 0; idx < 8; idx++) {
                c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;
            }

            this._$crcTable[idx] = c;
        }
    }

    /**
     * @param  {number} crc
     * @param  {Uint8Array} buffer
     * @param  {number} offset
     * @param  {number} length
     * @return {number}
     * @method
     * @private
     */
    _$crcUpdate (crc, buffer, offset, length)
    {
        for (let idx = 0; idx < length; idx++) {
            crc = this._$crcTable[(crc ^ buffer[offset + idx]) & 0xff] ^ crc >>> 8;
        }
        return crc;
    }

    /**
     * @param  {Uint8Array} buffer
     * @param  {number} offset
     * @param  {number} length
     * @return {number}
     * @method
     * @private
     */
    _$crc (buffer, offset, length)
    {
        return this._$crcUpdate(
            0xffffffff, buffer, offset, length
        ) ^ 0xffffffff;
    }

    /**
     * @param {Uint8Array} buffer
     * @param {number} pos
     * @param {string} value
     * @method
     * @private
     */
    _$writeString (buffer, pos, value)
    {
        for (let idx = 0; idx < value.length; idx++) {
            buffer[pos + idx] = value.charCodeAt(idx);
        }
    }

    /**
     * @description 各フレームにセットされたcanvasをAPNGにエンコード
     *              Encode the canvas set in each frame to APNG
     *
     * @return {Promise}
     * @method
     * @public
     */
    encode ()
    {
        return new Promise((resolve) =>
        {
            requestAnimationFrame(() =>
            {
                let sequenceNumber = 0;
                let frame = 0;

                const chunks = [];
                const reader = new FileReader();

                // PNG header (8 bytes)
                const header = new Uint8Array([
                    137, 80, 78, 71, 13, 10, 26, 10
                ]);
                chunks.push(header.buffer);

                const IHDR     = new Uint8Array(25);
                const IHDRView = new DataView(IHDR.buffer);
                IHDRView.setUint32(0, 13);
                this._$writeString(IHDR, 4, "IHDR");
                IHDRView.setUint32(8, this._$width);
                IHDRView.setUint32(12, this._$height);
                IHDRView.setUint8(16, 8); // bit depth
                IHDRView.setUint8(17, 6); // color_type, 2 = RGB, 6 = RGBA
                IHDRView.setUint8(18, 0); // compression method
                IHDRView.setUint8(19, 0); // filter method
                IHDRView.setUint8(20, 0); // interlace method
                IHDRView.setUint32(21, this._$crc(IHDR, 4, 4 + 13));
                chunks.push(IHDR.buffer);

                // animation control
                const acTL   = new Uint8Array(20);
                const acView = new DataView(acTL.buffer);
                acView.setUint32(0, 8);
                this._$writeString(acTL, 4, "acTL");
                acView.setUint32(8, this._$pngs.length);
                acView.setUint32(12, this._$loop);
                acView.setUint32(16, this._$crc(acTL, 4, 4 + 8));
                chunks.push(acTL.buffer);

                reader.onload = () =>
                {
                    const view = new DataView(reader.result);

                    let pos = 8;

                    // frame control
                    const fcTL   = new Uint8Array(38);
                    const fcView = new DataView(fcTL.buffer);
                    fcView.setUint32(0, 26);
                    this._$writeString(fcTL, 4, "fcTL");
                    fcView.setUint32(8, sequenceNumber++);
                    fcView.setUint32(12, this._$width);
                    fcView.setUint32(16, this._$height);
                    fcView.setUint32(20, 0);
                    fcView.setUint32(24, 0);
                    fcView.setUint16(28, 1000 / this._$fps); // delay_num
                    fcView.setUint16(30, 1000); // delay_den
                    fcView.setUint8(32, 0); // dispose_op
                    fcView.setUint8(33, 0); // blend_op
                    fcView.setUint32(34, this._$crc(fcTL, 4, 4 + 26));
                    chunks.push(fcTL.buffer);

                    const length = reader.result.byteLength;
                    for (;;) {

                        const chunkLen = view.getUint32(pos);
                        if (view.getUint32(pos + 4) === 0x49444154) {

                            if (!frame) {

                                chunks.push(
                                    reader.result.slice(pos, pos + chunkLen + 8 + 4)
                                );

                            } else {

                                let fdAT   = new Uint8Array(4);
                                let fdView = new DataView(fdAT.buffer);

                                fdView.setUint32(0, chunkLen + 4);
                                chunks.push(fdAT.buffer);

                                fdAT = new Uint8Array(
                                    reader.result.slice(pos, pos + chunkLen + 8 + 4)
                                );

                                fdView = new DataView(fdAT.buffer);
                                this._$writeString(fdAT, 0, "fdAT");
                                fdView.setUint32(4, sequenceNumber++);
                                fdView.setUint32(
                                    chunkLen + 8,
                                    this._$crc(fdAT, 0, chunkLen + 8)
                                );
                                chunks.push(fdAT.buffer);
                            }
                        }

                        pos += chunkLen + 12;
                        if (pos >= length) {
                            break;
                        }
                    }

                    frame++;
                    if (this._$pngs.length > frame) {

                        reader.readAsArrayBuffer(this._$pngs[frame]);

                    } else {

                        chunks.push(new Uint8Array([
                            0, 0, 0, 0,
                            0x49, 0x45, 0x4E, 0x44,
                            0xAE, 0x42, 0x60, 0x82
                        ]).buffer);

                        resolve(new Blob(chunks, { "type" : "image/apng" }));
                    }
                };

                reader.readAsArrayBuffer(this._$pngs[0]);
            });
        });
    }
}

/**
 * 全てのライブラリの親クラス
 * Parent class for all libraries
 *
 * @class
 * @memberOf instance
 */
class Instance
{
    /**
     * @param {object} object
     * @constructor
     * @public
     */
    constructor (object)
    {
        this._$id       = object.id;
        this._$name     = object.name;
        this._$type     = object.type;
        this._$symbol   = object.symbol || "";
        this._$folderId = object.folderId | 0;
    }

    /**
     * @description 初期起動関数
     *              initial invoking function
     *
     * @return {void}
     * @method
     * @abstract
     */
    // eslint-disable-next-line no-empty-function
    initialize () {}

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @abstract
     */
    // eslint-disable-next-line no-empty-function
    toObject () {}

    /**
     * @description 書き出し用のObjectを返す
     *              Returns an Object for export
     *
     * @return {object}
     * @method
     * @abstract
     */
    // eslint-disable-next-line no-empty-function
    toPublish () {}

    /**
     * @description シンボルを指定した時の継承先を返す
     *              Returns the inheritance destination when a symbol is specified.
     *
     * @readonly
     * @abstract
     */
    // eslint-disable-next-line no-empty-function,getter-return
    get defaultSymbol () {}

    /**
     * @description Next2DのDisplayObjectを生成
     *              Generate Next2D DisplayObject
     *
     * @return {*}
     * @method
     * @abstract
     */
    // eslint-disable-next-line no-empty-function
    createInstance () {}

    /**
     * @description 表示領域(バウンディングボックス)のObjectを返す
     *              Returns the Object of the display area (bounding box)
     *
     * @param  {array}  [matrix=null]
     * @param  {object} [place=null]
     * @param  {object} [range=null]
     * @return {object}
     * @method
     * @abstract
     */
    // eslint-disable-next-line no-empty-function,no-unused-vars
    getBounds (matrix = null, place = null, range = null) {}

    /**
     * @description ライブラリ内のユニークな値
     *              Unique value in the library
     *
     * @member {number}
     * @public
     */
    get id ()
    {
        return this._$id;
    }
    set id (id)
    {
        this._$id = id | 0;
    }

    /**
     * @description 格納先のフォルダID
     *              Destination folder ID
     *
     * @default 0
     * @member {number}
     * @public
     */
    get folderId ()
    {
        return this._$folderId;
    }
    set folderId (folder_id)
    {
        this._$folderId = folder_id | 0;
    }

    /**
     * @description フォルダを含めたライブラリのパスを返す
     *              Returns the path to the library, including folders
     *
     * @member {string}
     * @readonly
     * @public
     */
    get path ()
    {
        const workSpace = Util.$currentWorkSpace();

        let path = this._$name;
        if (this._$folderId) {
            let parent = this;
            while (parent._$folderId) {
                parent = workSpace.getLibrary(parent._$folderId);
                path = `${parent._$name}/${path}`;
            }
        }

        return path;
    }

    /**
     * @description 指定したワークスペースからPathを取得
     *              Get Path from the specified workspace
     *
     * @param  {WorkSpace} work_space
     * @return {string}
     * @method
     * @public
     */
    getPathWithWorkSpace (work_space)
    {
        let path = this._$name;
        if (this._$folderId) {
            let parent = this;
            while (parent._$folderId) {
                parent = work_space.getLibrary(parent._$folderId);
                path = `${parent._$name}/${path}`;
            }
        }

        return path;
    }

    /**
     * @description ライブラリ名、フォルダのパスを含めた名前をユニークとして利用する
     *              Use the name including the library name and folder path as unique
     *
     * @member {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }
    set name (name)
    {
        this._$name = `${name}`;

        if (this.id) {
            // ライブラリのelementのテキストも更新
            const element = document
                .getElementById(`library-name-${this.id}`);
            if (element) {
                element.textContent = `${this._$name}`;
            }
        }

        // コントローラーに表示中のシーンの場合は、コントローラー表示も更新
        const workSpace = Util.$currentWorkSpace();
        if (workSpace && workSpace.scene.id === this.id) {

            const objectName = document.getElementById("object-name");
            if (objectName) {
                objectName.value = `${this._$name}`;
            }

            const sceneName = document.getElementById("scene-name");
            if (sceneName) {
                sceneName.textContent = `${this._$name}`;
            }

        }

    }

    /**
     * @description ライブラリの方の値、InstanceTypeクラスの固定値を参照
     *              See the value toward the library, fixed value in the InstanceType class.
     *
     * @member {string}
     * @public
     */
    get type ()
    {
        return this._$type;
    }
    set type (type)
    {
        type = `${type}`.toLowerCase();
        switch (type) {

            case InstanceType.SHAPE:
            case InstanceType.BITMAP:
            case InstanceType.VIDEO:
            case InstanceType.FOLDER:
            case InstanceType.SOUND:
            case InstanceType.MOVIE_CLIP:
            case InstanceType.TEXT:
                this._$type = type;
                break;

            default:
                break;

        }
    }

    /**
     * @description Next2D Playerでのシンボルアクセス用の値
     *              Value for symbol access in Next2D Player
     *
     * @member {string}
     * @public
     */
    get symbol ()
    {
        return this._$symbol;
    }
    set symbol (symbol)
    {
        this._$symbol = `${symbol}`;

        if (this.id) {
            // ライブラリ内のelementのテキストデータも更新
            const element = document
                .getElementById(`library-symbol-name-${this.id}`);
            if (element) {
                element.textContent = `${symbol}`;
            }
        }
    }

    /**
     * @description このアイテムが設定されたDisplayObjectが選択された時
     *              内部情報をコントローラーに表示する
     *              When a DisplayObject with this item set is selected,
     *              internal information is displayed on the controller.
     *
     * @param {object} place
     * @param {string} [name=""]
     * @public
     */
    showController (place, name = "")
    {
        Util.$controller.hideObjectSetting([
            "sound-setting",
            "ease-setting"
        ]);

        Util.$controller.showObjectSetting([
            "object-setting",
            "reference-setting",
            "transform-setting",
            "color-setting",
            "blend-setting",
            "filter-setting",
            "instance-setting"
        ]);

        // 選択されたインスタンス名をセット
        Util
            .$instanceSelectController
            .createInstanceSelect(this);

        // 名前とシンボルの値をセット
        document
            .getElementById("object-name")
            .value = name;

        document
            .getElementById("object-symbol")
            .value = this.symbol;

        // matrixの値をセット
        const matrix  = place.matrix;
        const xScale  = Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale  = Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);
        const radianX = Math.atan2( matrix[1], matrix[0]) * Util.$Rad2Deg;
        const radianY = Math.atan2(-matrix[2], matrix[3]) * Util.$Rad2Deg;

        document
            .getElementById("transform-scale-x")
            .value = Math.abs(Math.ceil(radianX - radianY)) >= 180
                ? xScale * -100
                : xScale * 100;

        document
            .getElementById("transform-scale-y")
            .value = yScale * 100;

        document
            .getElementById("transform-rotate")
            .value = radianX;

        // ColorTransformの値をセット
        const colorTransform = place.colorTransform;

        document
            .getElementById("color-red-multiplier")
            .value = colorTransform[0] * 100;
        document
            .getElementById("color-green-multiplier")
            .value = colorTransform[1] * 100;
        document
            .getElementById("color-blue-multiplier")
            .value = colorTransform[2] * 100;
        document
            .getElementById("color-alpha-multiplier")
            .value = colorTransform[3] * 100;

        document
            .getElementById("color-red-offset")
            .value = colorTransform[4];
        document
            .getElementById("color-green-offset")
            .value = colorTransform[5];
        document
            .getElementById("color-blue-offset")
            .value = colorTransform[6];
        document
            .getElementById("color-alpha-offset")
            .value = colorTransform[7];

        // 指定したブレンドモードにselectedを設定
        const children = document
            .getElementById("blend-select")
            .children;

        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];

            if (node.value !== place.blendMode) {
                continue;
            }

            node.selected = true;
            break;
        }

        // フィルター情報を初期化
        Util.$filterController.clear();

        // フィルターがあれば対象のElementを追加
        const length = place.filter.length;
        if (length) {
            document
                .querySelectorAll(".filter-none")[0]
                .style.display = "none";
        }

        for (let idx = 0; idx < length; ++idx) {
            const filter = place.filter[idx];
            Util.$filterController[`add${filter.name}`](filter, false);
        }
    }

    /**
     * @description Next2DのBitmapDataクラスを経由してImageクラスを生成
     *              Generate Image class via Next2D BitmapData class
     *
     * @param  {HTMLCanvasElement} canvas
     * @param  {number}  width
     * @param  {number}  height
     * @param  {object}  place
     * @param  {object}  [range = null]
     * @param  {number}  [static_frame = 0]
     * @param  {boolean} [preview = false]
     * @return {CanvasRenderingContext2D}
     * @method
     * @public
     */
    draw (
        canvas, width, height, place,
        range = null, static_frame = 0, preview = false
    ) {
        // empty image
        if (!width || !height) {
            canvas.width  = 0;
            canvas.height = 0;
            return canvas.getContext("2d");
        }

        const { Matrix } = window.next2d.geom;

        // ライブラリからplayer用のオブジェクトを作成
        const instance = this.createInstance(place, range, static_frame);

        // place objectの値をセット
        let matrix = place.matrix;
        if (!preview && Util.$sceneChange.length) {
            matrix = Util.$multiplicationMatrix(
                Util.$sceneChange.concatenatedMatrix,
                place.matrix
            );
        }

        const container = this.createContainer(
            instance, place, matrix, preview
        );

        // フィルターの描画反映を計算してセット
        const object     = this.calcFilter(width, height, place);
        instance.filters = object.filters;

        // BitmapDataオブジェクトを作成
        const bitmapData = this.createBitmapData(
            object.width, object.height, preview
        );

        let ratio = window.devicePixelRatio;
        if (!preview) {
            ratio *= Util.$zoomScale;
        }

        const drawBounds = container.getBounds(container);

        let tx = -drawBounds.x;
        if (0 > object.offsetX) {
            tx -= object.offsetX * ratio;
        }

        let ty = -drawBounds.y;
        if (0 > object.offsetY) {
            ty -= object.offsetY * ratio;
        }

        // playerで描画を実行
        bitmapData.draw(container, new Matrix(1, 0, 0, 1, tx, ty));

        // 指定のcanvasに描画
        const context = bitmapData.drawFromCanvas(canvas);

        // player側のメモリを解放
        bitmapData.dispose();

        canvas._$width   = object.width;
        canvas._$height  = object.height;
        canvas.draggable = false;

        const bounds = this.getBounds(matrix, place, range);

        canvas._$tx = bounds.xMin;
        canvas._$ty = bounds.yMin;

        canvas._$offsetX = 0 > object.offsetX ? object.offsetX : 0;
        canvas._$offsetY = 0 > object.offsetY ? object.offsetY : 0;

        return context;
    }

    /**
     * @description 指定されたFilterの描画範囲を計算
     *              Calculates the drawing range of the specified Filter
     *
     * @param  {number} width
     * @param  {number} height
     * @param  {object} place
     * @return {object}
     * @method
     * @public
     */
    calcFilter (width, height, place)
    {
        const { Rectangle } = window.next2d.geom;

        let xScale = Math.sqrt(
            place.matrix[0] * place.matrix[0]
            + place.matrix[1] * place.matrix[1]
        );

        let yScale = Math.sqrt(
            place.matrix[2] * place.matrix[2]
            + place.matrix[3] * place.matrix[3]
        );

        const object = {
            "width":   width,
            "height":  height,
            "offsetX": 0,
            "offsetY": 0,
            "filters": []
        };

        if (place.filter.length) {

            let rect = new Rectangle(0, 0, width, height);

            for (let idx = 0; idx < place.filter.length; ++idx) {

                const filter = place.filter[idx];
                if (!filter.state) {
                    continue;
                }

                const instance = filter.createInstance();

                rect = instance._$generateFilterRect(rect, xScale, yScale);

                object.filters.push(instance);

            }

            object.width  = Math.ceil(rect.width);
            object.height = Math.ceil(rect.height);

            object.offsetX = rect.x;
            object.offsetY = rect.y;
        }

        return object;
    }

    /**
     * @description BitmapDataに渡すSpriteを生成
     *              Generate Sprite to be passed to BitmapData
     *
     * @param  {DisplayObject} instance
     * @param  {object} place
     * @param  {array} matrix
     * @param  {boolean} [preview=false]
     * @return {next2d.display.Sprite}
     * @method
     * @public
     */
    createContainer (instance, place, matrix, preview = false)
    {
        const { Sprite } = window.next2d.display;
        const { Matrix, ColorTransform } = window.next2d.geom;

        instance
            .transform
            .matrix = new Matrix(
                matrix[0], matrix[1],
                matrix[2], matrix[3],
                matrix[4], matrix[5]
            );

        // fixed logic
        instance
            .transform
            .colorTransform = new ColorTransform(
                place.colorTransform[0], place.colorTransform[1],
                place.colorTransform[2], place.colorTransform[3],
                place.colorTransform[4], place.colorTransform[5],
                place.colorTransform[6], place.colorTransform[7]
            );

        const sprite = new Sprite();
        sprite.addChild(instance);

        let ratio = window.devicePixelRatio;
        if (!preview) {
            ratio *= Util.$zoomScale;
        }

        sprite.scaleX = ratio;
        sprite.scaleY = ratio;

        const container = new Sprite();
        container.addChild(sprite);

        return container;
    }

    /**
     * @description 幅と高さを指定して、BitmapDataクラスを生成
     *              Generate BitmapData class by specifying width and height
     *
     * @param  {number} width
     * @param  {number} height
     * @return {next2d.display.BitmapData}
     * @method
     * @public
     */
    createBitmapData (width, height, preview = false)
    {
        const { BitmapData } = window.next2d.display;

        let ratio = window.devicePixelRatio;
        if (!preview) {
            ratio *= Util.$zoomScale;
        }

        return new BitmapData(
            Math.ceil(width  * ratio),
            Math.ceil(height * ratio),
            true, 0
        );
    }

    /**
     * @description プレビュー用のImageクラスを生成
     *              Generate Image class for preview
     *
     * @return {HTMLImageElement}
     * @method
     * @public
     */
    getPreview ()
    {
        if (this.type === InstanceType.FOLDER) {
            return new Image();
        }

        const bounds = this.getBounds([1, 0, 0, 1, 0, 0]);

        // size
        let width  = Math.abs(bounds.xMax - bounds.xMin);
        let height = Math.abs(bounds.yMax - bounds.yMin);
        if (!width || !height) {
            return new Image();
        }

        let scaleX   = 1;
        const scaleY = 150 / height;

        width  = width  * scaleY | 0;
        height = height * scaleY | 0;

        const controllerWidth = (document
            .documentElement
            .style
            .getPropertyValue("--controller-width")
            .split("px")[0] | 0) - 10;

        if (width > controllerWidth) {
            scaleX = controllerWidth / width;
            width  = width  * scaleX | 0;
            height = height * scaleX | 0;
        }

        const canvas = Util.$getCanvas();
        this.draw(
            canvas,
            Math.ceil(width),
            Math.ceil(height),
            {
                "frame": 1,
                "matrix": [scaleY * scaleX, 0, 0, scaleY * scaleX, 0, 0],
                "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                "blendMode": "normal",
                "filter": []
            },
            null, 0, true
        );

        if (canvas.height !== height) {
            const height = Math.min(150, canvas.height);
            canvas.style.width  = `${canvas.width * height / canvas.height}px`;
            canvas.style.height = `${height}px`;
        }

        return canvas;
    }

    /**
     * @description ライブラリからの削除処理、配置先からも削除を行う
     *              Process deletion from the library and also from the placement site.
     *
     * @return {void}
     * @method
     * @public
     */
    remove ()
    {
        const workSpace = Util.$currentWorkSpace();

        const scene = workSpace.scene;
        for (let instance of workSpace._$libraries.values()) {

            if (instance.type !== InstanceType.MOVIE_CLIP) {
                continue;
            }

            // 削除するインスタンスならスキップ
            if (instance.id === this.id) {
                continue;
            }

            for (let layer of instance._$layers.values()) {

                let reload = false;

                // 削除してもいいようにクローンして利用する
                const characters = layer._$characters.slice();

                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];
                    if (this.id === character.libraryId) {

                        for (const keyFrame of character._$places.keys()) {

                            const range = character.getRange(keyFrame);

                            // 空のキーフレームがあればスキップ
                            if (layer.getActiveEmptyCharacter(keyFrame)) {
                                continue;
                            }

                            // DisplayObjectが配置されていればスキップ
                            const activeCharacters = layer.getActiveCharacter(keyFrame);
                            let done = false;
                            for (let idx = 0; idx < activeCharacters.length; ++idx) {

                                const activeCharacter = activeCharacters[idx];
                                if (activeCharacter.id === character.id) {
                                    continue;
                                }

                                done = true;
                            }

                            if (done) {
                                continue;
                            }

                            // 削除するレンジに空のキーフレームを登録
                            layer.addEmptyCharacter(new EmptyCharacter({
                                "startFrame": range.startFrame,
                                "endFrame": range.endFrame
                            }));
                        }

                        // 登録先のレイヤーから削除
                        layer.deleteCharacter(character.id);
                        reload = true;
                    }
                }

                // 表示中のレイヤーならスタイルを更新
                if (reload && scene.id === instance.id) {
                    layer.reloadStyle();
                }
            }

            if (instance._$sounds.size) {
                for (const [frame, sounds] of instance._$sounds) {

                    const pool = [];
                    for (let idx = 0; idx < sounds.length; ++idx) {

                        const sound = sounds[idx];
                        if (this.id === sound.characterId) {
                            continue;
                        }

                        pool.push(sound);
                    }

                    // 削除対象以外を再登録
                    instance._$sounds.set(frame, pool);
                }
            }
        }
    }
}

/**
 * 画像データを管理するクラス、Next2DのShapeクラスとして出力されます。
 * The output is as a Next2D Shape class, a class that manages image data.
 *
 * @class
 * @extends {Instance}
 * @memberOf instance
 */
class Bitmap extends Instance
{
    /**
     * @param {object} object
     * @constructor
     * @public
     */
    constructor (object)
    {
        super(object);

        this.imageType = object.imageType;
        this.width     = object.width;
        this.height    = object.height;

        this._$buffer = null;
        if (object.buffer) {
            this.buffer = object.buffer;
        }
        this._$command = null;
        this._$binary  = "";
    }

    /**
     * @description Bitmapクラスを複製
     *              Duplicate Bitmap class
     *
     * @return {Bitmap}
     * @method
     * @public
     */
    clone ()
    {
        return new Bitmap(JSON.parse(JSON.stringify(this.toObject())));
    }

    /**
     * @description このアイテムが設定されたDisplayObjectが選択された時
     *              内部情報をコントローラーに表示する
     *              When a DisplayObject with this item set is selected,
     *              internal information is displayed on the controller.
     *
     * @param  {object} place
     * @param  {string} [name=""]
     * @return {void}
     * @method
     * @public
     */
    showController(place, name = "")
    {
        super.showController(place, name);

        Util.$controller.hideObjectSetting([
            "text-setting",
            "loop-setting",
            "video-setting",
            "fill-color-setting",
            "nine-slice-setting"
        ]);
    }

    /**
     * @description 表示領域(バウンディングボックス)のObjectを返す
     *              Returns the Object of the display area (bounding box)
     *
     * @param  {array} [matrix=null]
     * @return {object}
     * @method
     * @public
     */
    getBounds (matrix = null)
    {
        const bounds = {
            "xMin": 0,
            "xMax": this.width,
            "yMin": 0,
            "yMax": this.height
        };

        return matrix
            ? Util.$boundsMatrix(bounds, matrix)
            : bounds;
    }

    /**
     * @description シンボルを指定した時の継承先を返す
     *              Returns the inheritance destination when a symbol is specified.
     *
     * @return {string}
     * @public
     * @readonly
     */
    get defaultSymbol ()
    {
        return window.next2d.display.Shape.namespace;
    }

    /**
     * @description 画像のカラー配列のバイナリデータ
     *              Binary data of the color array of the image
     *
     * @default ""
     * @member {Uint8Array|string}
     * @public
     */
    get buffer ()
    {
        if (!this._$binary) {

            const length = this._$buffer.length;

            for (let idx = 0; idx < length; ++idx) {
                this._$binary += String.fromCharCode(this._$buffer[idx]);
            }

        }

        return this._$binary;
    }
    set buffer (binary)
    {

        switch (typeof binary) {

            case "object":
                if (binary.constructor === Uint8Array) {
                    this._$buffer = binary;
                }
                break;

            case "string":
                if (!this._$binary) {
                    let length = binary.length;

                    this._$buffer = new Uint8Array(length);
                    for (let idx = 0; idx < length; ++idx) {
                        this._$buffer[idx] = binary.charCodeAt(idx) & 0xff;
                    }

                    this._$binary = binary;
                }
                break;

            default:
                break;

        }
    }

    /**
     * @description 画像種別を返す(image/png, image/jpeg, image/gif, etc...)
     *              return image type (image/png, image/jpeg, image/gif, etc...)
     *
     * @member {string}
     * @public
     */
    get imageType ()
    {
        return this._$imageType;
    }
    set imageType (image_type)
    {
        this._$imageType = image_type;
    }

    /**
     * @description 画像の幅を返す
     *              Return image width
     *
     * @member {number}
     * @public
     */
    get width ()
    {
        return this._$width;
    }
    set width (width)
    {
        this._$width = width;
    }

    /**
     * @description 画像の高さを返す
     *              Returns the height of the image
     *
     * @return {number}
     * @public
     */
    get height ()
    {
        return this._$height;
    }
    set height (height)
    {
        this._$height = height;
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "id":        this.id,
            "name":      this.name,
            "type":      this.type,
            "symbol":    this.symbol,
            "folderId":  this.folderId,
            "width":     this.width,
            "height":    this.height,
            "imageType": this.imageType,
            "buffer":    this.buffer
        };
    }

    /**
     * @description 書き出し用のObjectを返す
     *              Returns an Object for export
     *
     * @return {object}
     * @method
     * @public
     */
    toPublish ()
    {
        return {
            "symbol":  this.symbol,
            "extends": this.defaultSymbol,
            "buffer":  Array.from(this._$buffer),
            "bounds":  this.getBounds()
        };
    }

    /**
     * @description Next2DのShapeを生成
     *              Generate Next2D Shape
     *
     * @return {next2d.display.Shape}
     * @method
     * @public
     */
    createInstance ()
    {
        const { Shape, BitmapData } = window.next2d.display;
        const { width, height } = this;

        const shape = new Shape();

        const bitmapData = new BitmapData(width, height, true, 0);
        bitmapData._$buffer = this._$buffer;

        shape
            .graphics
            .beginBitmapFill(bitmapData, null, false)
            .drawRect(0, 0, width, height)
            .endFill();

        // setup
        shape.graphics._$maxAlpha = 1;
        shape.graphics._$canDraw  = true;
        shape.graphics._$xMin     = 0;
        shape.graphics._$xMax     = this.width;
        shape.graphics._$yMin     = 0;
        shape.graphics._$yMax     = this.height;
        shape.graphics._$command  = this._$command;

        return shape;
    }
}

/**
 * スクリーンに配置されたDisplayObjectクラス
 * DisplayObject class placed on the screen
 *
 * @class
 * @memberOf instance
 */
class Character
{
    /**
     * @param {object} [object=null]
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        this._$libraryId      = -1;
        this._$places         = new Map();
        this._$tween          = new Map();
        this._$context        = null;
        this._$currentFrame   = 0;
        this._$currentPlace   = null;
        this._$screenX        = 0;
        this._$screenY        = 0;
        this._$offsetX        = 0;
        this._$offsetY        = 0;
        this._$name           = "";
        this._$cachePlaces    = [];
        this._$referencePoint = { "x": 0, "y": 0 };

        if (object) {
            this._$id         = object.id;
            this._$libraryId  = object.libraryId;
            this._$name       = object.name || "";
            this._$startFrame = object.startFrame;
            this._$endFrame   = object.endFrame;
            this.places       = object.places || [];
            this.tween        = object.tween || [];
        } else {
            this._$id         = Util.$currentWorkSpace()._$characterId++;
            this._$startFrame = 1;
            this._$endFrame   = 2;
        }
    }

    /**
     * @description 選択したDisplayObjectの情報をコントローラーに表示する
     *              Display information on the selected DisplayObject in the controller
     *
     * @return {void}
     * @method
     * @public
     */
    showController ()
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(this.libraryId);

        const frame = Util.$timelineFrame.currentFrame;

        instance.showController(this.getPlace(frame), this.name);

        // tweenの設定があれば表示
        const range = this.getRange(frame);
        if (this.hasTween(range.startFrame)) {

            // コントローラーエリアを表示
            Util.$controller.showObjectSetting([
                "ease-setting"
            ]);

            // 選択中の関数をselectにセット
            const tweenObject = this.getTween(range.startFrame);

            const children = document
                .getElementById("ease-select")
                .children;

            for (let idx = 0; idx < children.length; ++idx) {

                const node = children[idx];
                if (node.value !== tweenObject.method) {
                    continue;
                }

                node.selected = true;
                break;
            }

            // カスタム設定であればcanvasを表示
            if (tweenObject.method === "custom") {

                Util.$tweenController.showCustomArea();

            } else {

                Util.$tweenController.hideCustomArea();

            }
        }
    }

    /**
     * @description 選択時にコントローラーの不要な値は非表示に、変更可能な値は表示する
     *              Hides unwanted values of the controller when selected and shows values that can be changed
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    showShapeColor (event)
    {
        Util.$controller.hideObjectSetting([
            "fill-color-setting"
        ]);

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(this.libraryId);

        if (instance.type !== InstanceType.SHAPE) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;

        instance.showShapeColor(this.getPlace(frame), event);
    }

    /**
     * @description Characterクラスを複製
     *              Duplicate Character class
     *
     * @return {Character}
     * @method
     * @public
     */
    clone ()
    {
        const character = new Character(
            JSON.parse(JSON.stringify(this.toObject()))
        );

        character._$id = Util.$currentWorkSpace()._$characterId++;
        return character;
    }

    /**
     * @description タイムラインからDisplayObjectを削除
     *              Remove DisplayObject from Timeline
     *
     * @param  {Layer} layer
     * @return {void}
     * @method
     * @public
     */
    remove (layer)
    {
        if (this._$places.size === 1) {
            layer.deleteCharacter(this.id);
            return ;
        }

        const range = this.getRange(
            Util.$timelineFrame.currentFrame
        );

        switch (true) {

            case range.startFrame === this.startFrame:
                this._$places.delete(range.startFrame);
                this.startFrame = range.endFrame;
                break;

            case range.endFrame === this.endFrame:
                this._$places.delete(range.startFrame);
                this.endFrame = range.startFrame;
                break;

            default:
                {
                    const character = this.split(
                        layer, range.startFrame, range.endFrame
                    );

                    if (character._$tween.size) {
                        Util
                            .$tweenController
                            .clearPointer();
                    }
                }
                break;

        }

        // tween情報を削除
        if (this._$tween.has(range.startFrame)) {

            this._$tween.delete(range.startFrame);

            for (let keyFrame = range.startFrame; keyFrame < range.endFrame; ++keyFrame) {
                if (!this._$places.has(keyFrame)) {
                    continue;
                }
                this._$places.delete(keyFrame);
            }

            Util
                .$tweenController
                .clearPointer();
        }
    }

    /**
     * @description tweenの座標を再計算してポインターを再配置
     *              Recalculate tween coordinates and reposition pointer
     *
     * @param {number} frame
     * @method
     * @public
     */
    relocationTween (frame)
    {
        if (!this._$tween.size) {
            return ;
        }

        const range = this.getRange(frame);
        if (this.hasTween(range.startFrame)) {

            // 変更したフレームにキーフレームがなければ自動的に追加
            // 最後のフレームは対象外
            if (this.endFrame - 1 > frame && !this.hasTween(frame)) {
                Util
                    .$timelineTool
                    .executeTimelineKeyAdd();
            }

            Util
                .$tweenController
                .relocationPlace(this, range.startFrame);

            Util
                .$tweenController
                .clearPointer()
                .relocationPointer();
        }
    }

    /**
     * @description 指定したフレームをキーフレームの開始・終了のフレームを返す
     *              Returns the specified frame as the start and end frame of the keyframe
     *
     * @param  {number} frame
     * @return {object}
     * @method
     * @public
     */
    getRange (frame)
    {
        if (this._$places.size === 1) {
            return {
                "startFrame": this.startFrame,
                "endFrame": this.endFrame
            };
        }

        let places = this._$cachePlaces;
        if (!places.length) {
            // 降順
            places = Array.from(this._$places.keys());
            places.sort((a, b) =>
            {
                switch (true) {

                    case a > b:
                        return -1;

                    case a < b:
                        return 1;

                    default:
                        return 0;

                }
            });
        }

        let prevFrame = 0;
        for (let idx = 0; idx < places.length; ++idx) {

            const placeFrame = places[idx];
            if (frame >= placeFrame) {
                const place = this.getPlace(placeFrame);
                if (place.tweenFrame) {
                    const tweenObject = this.getTween(place.tweenFrame);
                    return {
                        "startFrame": tweenObject.startFrame,
                        "endFrame": tweenObject.endFrame
                    };
                }

                return {
                    "startFrame": placeFrame,
                    "endFrame": prevFrame ? prevFrame : this.endFrame
                };
            }

            prevFrame = placeFrame;
        }
    }

    /**
     * @description tweenオブジェクトを複製
     *              Duplicate tween object
     *
     * @param  {number} frame
     * @return {object}
     * @method
     * @public
     */
    getCloneTween (frame)
    {
        return JSON.parse(JSON.stringify(this.getTween(frame)));
    }

    /**
     * @description キーフレームに設定したtweenの設定objectを返す
     *              Returns the tween setting object set to the keyframe
     *
     * @param  {number} frame
     * @return {object}
     * @method
     * @public
     */
    getTween (frame)
    {
        return this.hasTween(frame)
            ? this._$tween.get(frame)
            : null;
    }

    /**
     * @description 指定のキーフレームにtweenの設定objectを設定する
     *              Set tween setting object to specified keyframe
     *
     * @param  {number} frame
     * @param  {object} object
     * @return {void}
     * @method
     * @public
     */
    setTween (frame, object)
    {
        this._$tween.set(frame, object);
    }

    /**
     * @description 指定のキーフレームにtweenの設定objectが設定されているかを判定
     *              Determines if a tween setting object is set for a given keyframe
     *
     * @param  {number} frame
     * @return {boolean}
     * @method
     * @public
     */
    hasTween (frame)
    {
        return this._$tween.has(frame);
    }

    /**
     * @description 指定のキーフレームのtweenの設定objectを削除
     *              Delete tween setting object for specified keyframe
     *
     * @param  {number} frame
     * @return {boolean}
     * @method
     * @public
     */
    deleteTween (frame)
    {
        return this._$tween.delete(frame | 0);
    }

    /**
     * @description 表示領域(バウンディングボックス)のObjectを返す
     *              Returns the Object of the display area (bounding box)
     *
     * @return {object}
     * @method
     * @public
     */
    getBounds (matrix = null)
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(this.libraryId);

        const frame = Util.$timelineFrame.currentFrame;
        const place = this.getPlace(frame);
        const range = place.loop && place.loop.type === LoopController.DEFAULT
            ? { "startFrame": this.startFrame, "endFrame": this.endFrame }
            : this.getRange(frame);

        // cache
        const currentFrame = Util.$currentFrame;
        Util.$currentFrame = frame;

        let multiMatrix = place.matrix;
        if (matrix) {
            multiMatrix = Util.$multiplicationMatrix(
                [matrix[0], matrix[1], matrix[2], matrix[3], 0, 0],
                place.matrix
            );
        }

        const bounds = instance.getBounds(multiMatrix, place, range);

        // reset
        Util.$currentFrame = currentFrame;

        return bounds;
    }

    /**
     * @description DisplayObject インスタンスの元の位置からの回転角を度単位で示します。
     *              Indicates the rotation of the DisplayObject instance,
     *              in degrees, from its original orientation.
     *
     * @member {number}
     * @public
     */
    get rotation ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        const matrix = this.getPlace(frame).matrix;
        return Math.atan2(matrix[1], matrix[0]) * Util.$Rad2Deg;
    }
    set rotation (rotate)
    {
        const frame = Util.$timelineFrame.currentFrame;

        const matrix = this.getPlace(frame).matrix;
        let radianX  = Math.atan2(matrix[1], matrix[0]);
        let radianY  = Math.atan2(-matrix[2], matrix[3]);

        const xScale = Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale = Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        const radian = rotate * Util.$Deg2Rad;
        radianY      = radianY + radian - radianX;
        radianX      = radian;

        matrix[0] = xScale  * Math.cos(radianX);
        matrix[1] = xScale  * Math.sin(radianX);
        matrix[2] = -yScale * Math.sin(radianY);
        matrix[3] = yScale  * Math.cos(radianY);
    }

    /**
     * @description 表示オブジェクトの幅を示します（ピクセル単位）。
     *              Indicates the width of the display object, in pixels.
     *
     * @member {number}
     * @public
     */
    get width ()
    {
        const bounds = this.getBounds();
        const width  = +Math.abs(bounds.xMax - bounds.xMin);
        return width !== Infinity ? width : 0;
    }
    set width (width)
    {
        const bounds  = this.getBounds();
        const exWidth = Math.abs(bounds.xMax - bounds.xMin);
        this.scaleX   = width / exWidth;
    }

    /**
     * @description 基準点から適用されるオブジェクトの水平スケール（パーセンテージ）を示します。
     *              Indicates the horizontal scale (percentage)
     *              of the object as applied from the registration point.
     *
     * @member {number}
     * @public
     */
    get scaleX ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        const matrix = this.getPlace(frame).matrix;
        return Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
    }
    set scaleX (scale_x)
    {
        scale_x = Util.$toFixed4(scale_x);

        const frame = Util.$timelineFrame.currentFrame;

        const matrix = this.getPlace(frame).matrix;
        if (matrix[1]) {

            const radianX = Math.atan2(matrix[1], matrix[0]);

            matrix[1] = scale_x * Math.sin(radianX);
            if (matrix[1] === 1 || matrix[1] === -1) {
                matrix[0] = 0;
            } else {
                matrix[0] = scale_x * Math.cos(radianX);
            }

        } else {

            matrix[0] = scale_x;

        }

    }

    /**
     * @description 表示オブジェクトの高さを示します（ピクセル単位）。
     *              Indicates the height of the display object, in pixels.
     *
     * @member {number}
     * @public
     */
    get height ()
    {
        const bounds = this.getBounds();
        const height = +Math.abs(bounds.yMax - bounds.yMin);
        return height !== Infinity ? height : 0;
    }
    set height (height)
    {
        const bounds   = this.getBounds();
        const exHeight = Math.abs(bounds.yMax - bounds.yMin);
        this.scaleY    = height / exHeight;
    }

    /**
     * @description 基準点から適用されるオブジェクトの垂直スケール（パーセンテージ）を示します。
     *              IIndicates the vertical scale (percentage)
     *              of an object as applied from the registration point.
     *
     * @member {number}
     * @public
     */
    get scaleY ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        const matrix = this.getPlace(frame).matrix;
        return Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);
    }
    set scaleY (scale_y)
    {
        scale_y = Util.$toFixed4(scale_y);

        const frame = Util.$timelineFrame.currentFrame;

        const matrix = this.getPlace(frame).matrix;
        if (matrix[2]) {

            const radianY = Math.atan2(-matrix[2], matrix[3]);
            matrix[2] = -scale_y * Math.sin(radianY);
            if (matrix[2] === 1 || matrix[2] === -1) {
                matrix[3] = 0;
            } else {
                matrix[3] = scale_y * Math.cos(radianY);
            }

        } else {

            matrix[3] = scale_y;

        }
    }

    /**
     * @description 親 DisplayObjectContainer のローカル座標を基準にした
     *              DisplayObject インスタンスの x 座標を示します。
     *              Indicates the x coordinate
     *              of the DisplayObject instance relative to the local coordinates
     *              of the parent DisplayObjectContainer.
     *
     * @member {number}
     * @public
     */
    get x ()
    {
        const frame = Util.$timelineFrame.currentFrame;
        const place = this.getPlace(frame);
        return place.matrix[4];
    }
    set x (x)
    {
        const frame = Util.$timelineFrame.currentFrame;
        const place = this.getPlace(frame);
        place.matrix[4] = x;

        const bounds = this.getBounds();
        this.screenX = bounds.xMin;

        const element = document
            .getElementById(`character-${this.id}`);

        if (element) {
            element.style.left = `${Util.$offsetLeft + bounds.xMin * Util.$zoomScale}px`;
        }
    }

    /**
     * @description 親 DisplayObjectContainer のローカル座標を基準にした
     *              DisplayObject インスタンスの y 座標を示します。
     *              Indicates the y coordinate
     *              of the DisplayObject instance relative to the local coordinates
     *              of the parent DisplayObjectContainer.
     *
     * @member {number}
     * @public
     */
    get y ()
    {
        const frame = Util.$timelineFrame.currentFrame;
        const place = this.getPlace(frame);
        return place.matrix[5];
    }
    set y (y)
    {
        const frame = Util.$timelineFrame.currentFrame;
        const place = this.getPlace(frame);
        place.matrix[5] = y;

        const bounds = this.getBounds();
        this.screenY = bounds.yMin;

        const element = document
            .getElementById(`character-${this.id}`);

        if (element) {
            element.style.top = `${Util.$offsetTop + bounds.yMin * Util.$zoomScale}px`;
        }
    }

    /**
     * @description 表示用のHTMLCanvasElementクラスを生成
     *              Generate HTMLCanvasElement class for display
     *
     * @param  {HTMLCanvasElement} canvas
     * @return {HTMLCanvasElement}
     * @method
     * @public
     */
    draw (canvas)
    {
        if (this._$context) {
            if (canvas instanceof HTMLCanvasElement) {
                Util.$canvases.push(canvas);
            }
            return this._$context.canvas;
        }

        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace.getLibrary(this.libraryId);

        const frame = Util.$timelineFrame.currentFrame;

        const place = this.getPlace(frame);
        const range = place.loop && place.loop.type === LoopController.DEFAULT
            ? { "startFrame": this.startFrame, "endFrame": this.endFrame }
            : this.getRange(frame);

        // reset
        Util.$currentFrame = frame;

        let matrix = place.matrix;
        if (Util.$sceneChange.length) {
            matrix = Util.$multiplicationMatrix(
                Util.$sceneChange.concatenatedMatrix,
                place.matrix
            );
        }

        const bounds = instance.getBounds(matrix, place, range);
        const width  = +Math.ceil(Math.abs(bounds.xMax - bounds.xMin));
        const height = +Math.ceil(Math.abs(bounds.yMax - bounds.yMin));

        // styleを初期化
        canvas.setAttribute("style", "");

        let context = null;
        switch (place.blendMode) {

            case "invert":
                context = instance.draw(canvas, width, height,
                    {
                        "frame": place.frame,
                        "matrix": place.matrix,
                        "colorTransform": [
                            0, 0, 0, place.colorTransform[3],
                            0, 0, 0, place.colorTransform[7]
                        ],
                        "blendMode": place.blendMode,
                        "filter": place.filter,
                        "tweenFrame": place.tweenFrame,
                        "loop": place.loop
                    },
                    range
                );
                break;

            case "alpha":
            case "erase":
                {
                    const bounds = this.getBounds(place.matrix, place, range);
                    canvas._$tx      = bounds.xMin;
                    canvas._$ty      = bounds.yMin;
                    canvas._$offsetX = 0;
                    canvas._$offsetY = 0;
                    canvas._$width   = 0;
                    canvas._$height  = 0;
                    canvas.draggable = false;

                    canvas.width = canvas.height = 0;
                    context = canvas.getContext("2d");
                }
                break;

            default:
                context = instance.draw(canvas, width, height, place, range);
                break;

        }

        this._$context = context;

        // set blend mode
        switch (place.blendMode) {

            case "normal":
                break;

            case "add":
                canvas.style.mixBlendMode = "color-dodge";
                break;

            case "subtract":
                canvas.style.filter = "invert(100%)";
                canvas.style.mixBlendMode = "multiply";
                break;

            case "invert":
                canvas.style.filter = "invert(100%)";
                canvas.style.mixBlendMode = "difference";
                break;

            case "hardlight":
                canvas.style.mixBlendMode = "hard-light";
                break;

            case "alpha":
            case "erase":
            case "layer":
                break;

            default:
                canvas.style.mixBlendMode = place.blendMode;
                break;

        }

        this.screenX = canvas._$tx;
        this.screenY = canvas._$ty;
        this._$offsetX = canvas._$offsetX;
        this._$offsetY = canvas._$offsetY;

        return canvas;
    }

    /**
     * @description フィルター適用で移動したx座標の値
     *              Value of x-coordinate moved by applying filter
     *
     * @member {number}
     * @readonly
     * @public
     */
    get offsetX ()
    {
        return this._$offsetX;
    }

    /**
     * @description フィルター適用で移動したy座標の値
     *              Value of y-coordinate moved by applying filter
     *
     * @member {number}
     * @readonly
     * @public
     */
    get offsetY ()
    {
        return this._$offsetY;
    }

    /**
     * @description インスタンス内で移動したx座標の値
     *              Value of x-coordinate moved within the instance
     *
     * @member {number}
     * @public
     */
    get screenX ()
    {
        return this._$screenX;
    }
    set screenX (screen_x)
    {
        this._$screenX = Util.$clamp(
            +screen_x,
            -Number.MAX_VALUE,
            Number.MAX_VALUE,
            0
        );
    }

    /**
     * @description インスタンス内で移動したy座標の値
     *              Value of x-coordinate moved within the instance
     *
     * @member {number}
     * @public
     */
    get screenY ()
    {
        return this._$screenY;
    }
    set screenY (screen_y)
    {
        this._$screenY = Util.$clamp(
            +screen_y,
            -Number.MAX_VALUE,
            Number.MAX_VALUE,
            0
        );
    }

    /**
     * @description DisplayObjectのid、ワークスペース内ではユニークの値
     *              DisplayObject id, unique value in the workspace
     *
     * @member {number}
     * @readonly
     * @public
     */
    get id ()
    {
        return this._$id;
    }

    /**
     * @description コントローラーに読み込まれたアイテムID
     *              Item ID loaded in controller
     *
     * @member {number}
     * @public
     */
    get libraryId ()
    {
        return this._$libraryId;
    }
    set libraryId (library_id)
    {
        this._$libraryId = library_id | 0;
    }

    /**
     * @description MovieClip内で有効なアクセス名
     *              Valid access name in MovieClip
     *
     * @member {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }
    set name (name)
    {
        this._$name = `${name}`.replace(/ /g, "").trim();
    }

    /**
     * @description 中心点の座標
     *              Coordinates of the center point
     *
     * @member {object}
     * @public
     */
    get referencePoint ()
    {
        return {
            "x": this._$referencePoint.x,
            "y": this._$referencePoint.y
        };
    }
    set referencePoint (point)
    {
        if (point) {
            this._$referencePoint.x = Util.$clamp(
                +point.x,
                -Number.MAX_VALUE,
                Number.MAX_VALUE,
                0
            );
            this._$referencePoint.y = Util.$clamp(
                +point.y,
                -Number.MAX_VALUE,
                Number.MAX_VALUE,
                0
            );
        }
    }

    /**
     * @description フレームに設定したtween情報
     *              Tween information set for the frame
     *
     * @member {array}
     * @public
     */
    get tween ()
    {
        const values = [];
        for (let [frame, value] of this._$tween) {
            values.push({
                "frame": frame,
                "value": value
            });
        }
        return values;
    }
    set tween (values)
    {
        for (let idx = 0; idx < values.length; ++idx) {
            const object = values[idx];
            if (!object.value.custom) {
                object.value.custom = Util
                    .$tweenController
                    .createEasingObject();
            }
            this._$tween.set(object.frame | 0, object.value);
        }
    }

    /**
     * @description フレームに設定した座標、フィルター、ブレンド、カラー、カスタムループ設定の情報
     *              Information on coordinates, filters, blends, colors, and custom loop settings for the frame.
     *
     * @member {array}
     * @public
     */
    get places ()
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(this.libraryId);

        if (!instance) {
            return [];
        }

        const places = [];
        for (let [frame, place] of this._$places) {

            place.frame = frame;

            const filters = [];
            for (let idx = 0; idx < place.filter.length; ++idx) {
                filters.push(place.filter[idx].toObject());
            }

            const object = {
                "frame": frame,
                "depth": place.depth,
                "blendMode": place.blendMode,
                "filter": filters,
                "matrix": place.matrix.slice(0),
                "colorTransform": place.colorTransform.slice(0),
                "point": place.point
            };

            if (place.tweenFrame) {
                object.tweenFrame = place.tweenFrame;
            }

            if (instance.type === InstanceType.MOVIE_CLIP) {

                if (place.loop) {

                    object.loop = {
                        "type": place.loop.type,
                        "start": place.loop.start,
                        "end": place.loop.end
                    };

                } else {

                    object.loop = Util.$getDefaultLoopConfig();

                }
            }

            places.push(object);
        }
        return places;
    }
    set places (places)
    {
        for (let idx = 0; idx < places.length; ++idx) {

            const place = places[idx];

            const filters = [];
            for (let idx = 0; place.filter.length > idx; ++idx) {
                const object = place.filter[idx];
                filters.push(new Util.$filterClasses[object.name](object));
            }

            place.filter = null;
            place.filter = filters;

            if (!place.loop) {
                place.loop = Util.$getDefaultLoopConfig();
            }

            this._$places.set(place.frame | 0, place);
        }
    }

    /**
     * @description PlaceObjectを複製
     *              Duplicate PlaceObject.
     *
     * @param  {number} frame
     * @return {object}
     * @method
     * @public
     */
    getClonePlace (frame)
    {
        const place = this.getPlace(frame);
        const clone = JSON.parse(JSON.stringify(place));

        const filters = [];
        for (let idx = 0; idx < place.filter.length; ++idx) {
            filters.push(place.filter[idx].clone());
        }
        clone.filter = filters;

        return clone;
    }

    /**
     * @description 指定フレームのPlaceObjectを返す
     *              Returns the PlaceObject of the specified frame
     *
     * @param  {number} frame
     * @return {object}
     * @method
     * @public
     */
    getPlace (frame)
    {
        if (this._$places.size === 1) {
            return this._$places.get(this.startFrame);
        }

        if (this.hasPlace(frame)) {
            return this._$places.get(frame | 0);
        }

        return this._$places.get(
            this.getNearPlaceFrame(frame | 0)
        );
    }

    /**
     * @description 指定したフレームより若く一番近いキーフレーム番号を返す
     *              Returns the nearest keyframe number younger than the specified frame
     *
     * @param  {number} frame
     * @return {number}
     * @method
     * @public
     */
    getNearPlaceFrame (frame)
    {
        // キャッシュがなければキャッシュ
        if (!this._$cachePlaces.length) {
            // 降順
            this._$cachePlaces = Array.from(this._$places.keys());
            this._$cachePlaces.sort((a, b) =>
            {
                switch (true) {

                    case a > b:
                        return -1;

                    case a < b:
                        return 1;

                    default:
                        return 0;

                }
            });
        }

        let idx = 0;
        while (this._$cachePlaces.length > idx) {

            const placeFrame = this._$cachePlaces[idx++] | 0;

            if (frame > placeFrame) {
                return placeFrame;
            }

        }

        return 1;
    }

    /**
     * @description 指定フレームにPlaceObjectをセット
     *              Set PlaceObject to the specified frame.
     *
     * @param  {number} frame
     * @param  {object} place
     * @return {void}
     * @method
     * @public
     */
    setPlace (frame, place)
    {
        place.frame = frame | 0;
        this._$places.set(frame | 0, place);

        // キャッシュを削除
        this._$cachePlaces.length = 0;
    }

    /**
     * @description 指定フレームにPlaceObjectがあるかの判定
     *              Determines if there is a PlaceObject in the specified frame.
     *
     * @param  {number} frame
     * @return {boolean}
     * @method
     * @public
     */
    hasPlace (frame)
    {
        return this._$places.has(frame | 0);
    }

    /**
     * @description 指定フレームのPlaceObjectを削除
     *              Delete PlaceObject in specified frame.
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    deletePlace (frame)
    {
        this._$places.delete(frame | 0);

        // キャッシュを削除
        this._$cachePlaces.length = 0;
    }

    /**
     * @description このDisplayObjectの開始フレーム
     *              Start frame of this DisplayObject.
     *
     * @member {number}
     * @public
     */
    get startFrame ()
    {
        return this._$startFrame;
    }
    set startFrame (start_frame)
    {
        this._$startFrame = Util.$clamp(start_frame | 0, 1, Number.MAX_VALUE, 1);
    }

    /**
     * @description このDisplayObjectの終了フレーム
     *              End frame of this DisplayObject.
     *
     * @member {number}
     * @public
     */
    get endFrame ()
    {
        return this._$endFrame;
    }
    set endFrame (end_frame)
    {
        this._$endFrame = Util.$clamp(end_frame | 0, 2, Number.MAX_VALUE, 2);
    }

    /**
     * @description tween設定を元に座標、カラー、ブレンド、フィルターの値を再計算して更新
     *              Recalculate and update coordinate, color, blend, and filter values based on tween settings.
     *
     * @param  {number} start_frame
     * @param  {number} end_frame
     * @return {void}
     * @method
     * @public
     */
    updateTweenPlace (start_frame, end_frame)
    {
        for (let frame = start_frame; frame < end_frame; ++frame) {

            const place = this.hasPlace(frame)
                ? this.getPlace(frame)
                : this.getClonePlace(start_frame);

            place.tweenFrame = start_frame;

            this.setPlace(frame, place);
        }
    }

    /**
     * @description ブレンドモード追加時にレンジ内のPlaceObjectを更新
     *              Update PlaceObject in range when blend mode is added.
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    updateTweenBlend (frame)
    {
        if (!this._$tween.size) {
            return ;
        }

        const range    = this.getRange(frame);
        const keyPlace = this.getPlace(range.startFrame);

        for (let frame = range.startFrame; frame < range.endFrame; ++frame) {

            if (!this.hasPlace(frame)) {

                const clonePlace = this.getClonePlace(range.startFrame);
                clonePlace.blendMode = keyPlace.blendMode;
                this.setPlace(frame, clonePlace);

            } else {

                this
                    .getPlace(frame)
                    .blendMode = keyPlace.blendMode;

            }
        }
    }

    /**
     * @description filter追加時にレンジ内のPlaceObjectを更新
     *              Update PlaceObject in range when filter is added.
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    updateTweenFilter (frame)
    {
        if (!this._$tween.size) {
            return ;
        }

        const range    = this.getRange(frame);
        const keyPlace = this.getPlace(range.startFrame);

        for (let frame = range.startFrame; frame < range.endFrame; ++frame) {

            const filters = [];
            const length = keyPlace.filter.length;
            for (let idx = 0; idx < length; ++idx) {
                filters.push(keyPlace.filter[idx].clone());
            }

            if (!this.hasPlace(frame)) {

                const clonePlace  = this.getClonePlace(range.startFrame);
                clonePlace.filter = filters;
                this.setPlace(frame, clonePlace);

            } else {

                this
                    .getPlace(frame)
                    .filter = filters;

            }

        }
    }

    /**
     * @description 指定フレームに移動
     *              Move to the specified frame.
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    move (frame)
    {
        const places = new Map();
        for (const [keyFrame, place] of this._$places) {

            place.frame = keyFrame + frame;

            // tweenの情報があればtweenも移動
            if (place.tweenFrame) {
                place.tweenFrame += frame;
            }

            places.set(place.frame, place);
        }

        // キーフレームの情報を上書き
        this._$places = places;

        if (this._$tween.size) {

            const tween = new Map();
            for (const [keyFrame, tweenObject] of this._$tween) {
                tweenObject.startFrame += frame;
                tweenObject.endFrame   += frame;
                tween.set(keyFrame + frame, tweenObject);
            }

            // tweenの情報を上書き
            this._$tween = tween;
        }

        // 開始位置と終了位置を移動
        this.startFrame += frame;
        this.endFrame   += frame;
    }

    /**
     * @description DisplayObjectを指定フレームで分割
     *              Split DisplayObject at specified frame.
     *
     * @param  {Layer} layer
     * @param  {number} start_frame
     * @param  {number} end_frame
     * @return {Character}
     * @method
     * @public
     */
    split (layer, start_frame, end_frame)
    {
        // 開始と終了位置が一致したらLayerから削除
        if (start_frame === this.startFrame
            && end_frame === this.endFrame
        ) {
            layer.deleteCharacter(this.id);
            return this;
        }

        // キャッシュを削除
        this._$cachePlaces.length = 0;

        // 開始位置より先のフレームを指定した場合は分割
        if (start_frame > this.startFrame) {

            // 分離用のobject
            const character = new Character();
            character._$libraryId  = this._$libraryId;
            character._$startFrame = this.startFrame;
            character._$endFrame   = start_frame;

            // object placeを分割して再登録
            const places = new Map();
            for (const [keyFrame, place] of this._$places) {

                if (start_frame > keyFrame) {

                    character.setPlace(keyFrame, place);

                } else {

                    places.set(keyFrame, place);

                }
            }

            const tweenMap = new Map();
            for (const [keyFrame, tween] of this._$tween) {

                if (start_frame > keyFrame) {

                    character.setTween(keyFrame, tween);

                } else {

                    tweenMap.set(keyFrame, tween);

                }

            }

            // レイヤーに設置
            layer.addCharacter(character);

            // 分割したDisplayObjectの情報を更新
            this._$tween      = tweenMap;
            this._$places     = places;
            this._$startFrame = start_frame;
        }

        // 返却用のDisplayObject
        const character = new Character();
        character._$libraryId  = this._$libraryId;
        character._$startFrame = start_frame;
        character._$endFrame   = end_frame;

        const removeFrames = [];
        for (const [keyFrame, place] of this._$places) {

            if (start_frame > keyFrame) {
                continue;
            }

            if (keyFrame >= end_frame) {
                continue;
            }

            removeFrames.push(keyFrame);
            character._$places.set(keyFrame, place);
        }

        // 分割したplace objectは削除
        for (let idx = 0; idx < removeFrames.length; ++idx) {
            this._$places.delete(removeFrames[idx]);
        }

        // 初期化
        removeFrames.length = 0;
        for (const [keyFrame, tween] of this._$tween) {

            if (start_frame > keyFrame) {
                continue;
            }

            if (keyFrame >= end_frame) {
                continue;
            }

            removeFrames.push(keyFrame);
            character._$tween.set(keyFrame, tween);
        }

        // 分割したtween objectは削除
        for (let idx = 0; idx < removeFrames.length; ++idx) {
            this._$tween.delete(removeFrames[idx]);
        }

        // キーフレームがなければ削除
        if (!this._$places.size) {

            layer.deleteCharacter(this.id);

        } else {

            // キーフレームを配列変換
            const keys = Array.from(this._$places.keys());

            // 昇順に並び替え
            if (this._$places.size > 1) {
                keys.sort((a, b) =>
                {
                    switch (true) {

                        case a > b:
                            return 1;

                        case a < b:
                            return -1;

                        default:
                            return 0;

                    }
                });
            }

            this._$startFrame = keys[0] | 0;
        }

        return character;
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "id":         this.id,
            "name":       this.name,
            "libraryId":  this.libraryId,
            "places":     this.places,
            "startFrame": this.startFrame,
            "endFrame":   this.endFrame,
            "tween":      this.tween
        };
    }

    /**
     * @description キャッシュしているcanvasのcontextを初期化
     *              Initialize cached canvas context.
     *
     * @return {void}
     * @method
     * @public
     */
    dispose ()
    {
        if (!this._$context) {
            return ;
        }

        Util.$poolCanvas(this._$context);
        this._$context = null;
    }
}

/**
 * 空のキーフレーム用クラス
 * Class for empty keyframes
 *
 * @class
 * @memberOf instance
 */
class EmptyCharacter
{
    /**
     * @param {object} [object=null]
     *
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$startFrame = object ? object.startFrame : 1;

        /**
         * @type {number}
         * @default 2
         * @private
         */
        this._$endFrame = object ? object.endFrame : 2;
    }

    /**
     * @description 開始フレーム番号
     *              start frame number
     *
     * @member {number}
     * @public
     */
    get startFrame ()
    {
        return this._$startFrame;
    }
    set startFrame (start_frame)
    {
        this._$startFrame = start_frame | 0;
    }

    /**
     * @description 終了フレーム番号
     *              end frame number
     *
     * @member {number}
     * @public
     */
    get endFrame ()
    {
        return this._$endFrame;
    }
    set endFrame (end_frame)
    {
        this._$endFrame = end_frame | 0;
    }

    /**
     * @description EmptyCharacterクラスを複製
     *              Duplicate EmptyCharacter class
     *
     * @return {EmptyCharacter}
     * @method
     * @public
     */
    clone ()
    {
        return new EmptyCharacter(JSON.parse(JSON.stringify(this.toObject())));
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "startFrame": this.startFrame,
            "endFrame": this.endFrame
        };
    }

    /**
     * @description 指定フレームに移動
     *              Move to the specified frame
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    move (frame)
    {
        this._$startFrame += frame;
        this._$endFrame   += frame;
    }

    /**
     * @description 指定フレームの幅を削除して分割
     *              Deletes the width of the specified frame and splits it
     *
     * @param  {Layer} layer
     * @param  {number} start_frame
     * @param  {number} end_frame
     * @return {void}
     * @method
     * @public
     */
    split (layer, start_frame, end_frame)
    {
        // 一旦削除
        layer.deleteEmptyCharacter(this);

        if (start_frame > this.startFrame) {
            layer.addEmptyCharacter(new EmptyCharacter({
                "startFrame": this.startFrame,
                "endFrame": start_frame
            }));
        }

        if (this.endFrame > end_frame) {
            layer.addEmptyCharacter(new EmptyCharacter({
                "startFrame": end_frame,
                "endFrame": this.endFrame
            }));
        }

    }

    /**
     * @description 空のキーフレームの開始・終了のフレームを返す
     *              Returns the start and end frames of empty keyframes
     *
     * @return {object}
     * @method
     * @public
     */
    getRange ()
    {
        return {
            "startFrame": this.startFrame,
            "endFrame": this.endFrame
        };
    }
}

/**
 * ライブラリ内のフォルダ階層管理クラス
 * Folder hierarchy management class in the library
 *
 * @class
 * @extends {Instance}
 * @memberOf instance
 */
class Folder extends Instance
{
    /**
     * @param {object} object
     * @constructor
     * @public
     */
    constructor (object)
    {
        super(object);

        /**
         * @type {string}
         * @default FolderType.CLOSE
         * @private
         */
        this._$mode = FolderType.CLOSE;

        if (object.mode) {
            this._$mode = object.mode;
        }
    }

    /**
     * @description Folderクラスを複製
     *              Duplicate Folder class
     *
     * @return {Folder}
     * @method
     * @public
     */
    clone ()
    {
        return new Folder(JSON.parse(JSON.stringify(this.toObject())));
    }

    /**
     * @description 開閉状態の値を返す
     *              Returns the value of the open/closed state
     *
     * @default "close"
     * @member {string}
     * @public
     */
    get mode ()
    {
        return this._$mode;
    }
    set mode (mode)
    {
        this._$mode = FolderType.OPEN === `${mode}`.toLowerCase()
            ? FolderType.OPEN
            : FolderType.CLOSE;
    }

    /**
     * @description フォルダーの中身の削除処理
     *              Deletion process of folder contents
     *
     * @return {void}
     * @method
     * @public
     */
    remove ()
    {
        const workSpace = Util.$currentWorkSpace();
        for (let instance of workSpace._$libraries.values()) {

            // フォルダの中にないか、IDが一致ない時はスキップ
            if (!instance.folderId || instance.folderId !== this.id) {
                continue;
            }

            instance.remove();

            // 内部データからも削除
            workSpace.removeLibrary(instance.id);
        }
    }

    /**
     * @description プレビュー用のImageクラスを生成
     *              Generate Image class for preview
     *
     * @return {HTMLImageElement}
     * @method
     * @public
     */
    getPreview ()
    {
        const image = new Image();
        image.src = "data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"12\" viewBox=\"0 0 24 24\"><path fill=\"gainsboro\" d=\"M11 5c-1.629 0-2.305-1.058-4-3h-7v20h24v-17h-13z\"/></svg>";
        image.style.width  = "100px";
        image.style.height = "100px";
        return image;
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "id":       this.id,
            "name":     this.name,
            "type":     this.type,
            "symbol":   this.symbol,
            "folderId": this.folderId,
            "mode":     this.mode
        };
    }

    /**
     * @description フォルダ内のアイテムIDを変数の配列に格納
     *              Stores the item IDs in the folder in an array of variables
     *
     * @return {void}
     * @method
     * @public
     */
    getInstanceIds (instance_ids)
    {
        const workSpace = Util.$currentWorkSpace();
        for (const instance of workSpace._$libraries.values()) {

            if (!instance.folderId || instance.folderId !== this.id) {
                continue;
            }

            if (instance.type === InstanceType.FOLDER) {
                instance.getInstanceIds(instance_ids);
                continue;
            }

            instance_ids.push(instance.id);
        }
    }
}

/**
 * フォルダーの開閉状態の固定値
 * Fixed value for folder open/closed status
 *
 * @class
 * @memberOf instance
 */
class FolderType
{
    /**
     * @description フォルダーを開いた状態
     *              Folder open state
     *
     * @return {string}
     * @static
     * @const
     */
    static get OPEN ()
    {
        return "open";
    }

    /**
     * @description フォルダを閉じた状態
     *              Folder close state
     *
     * @return {string}
     * @static
     * @const
     */
    static get CLOSE ()
    {
        return "close";
    }
}

/**
 * インスタンスの型の固定値
 * Fixed value of instance type
 *
 * @class
 * @memberOf instance
 */
class InstanceType
{
    /**
     * @description ライブラリ内でのShapeを定義
     *              Define Shape in the library
     *
     * @return {string}
     * @static
     * @const
     */
    static get SHAPE ()
    {
        return "shape";
    }

    /**
     * @description ライブラリ内でのBitmapを定義
     *              Define Bitmap in the library
     *
     * @return {string}
     * @static
     * @const
     */
    static get BITMAP ()
    {
        return "bitmap";
    }

    /**
     * @description ライブラリ内でのVideoを定義
     *              Define Video in the library
     *
     * @return {string}
     * @static
     * @const
     */
    static get VIDEO ()
    {
        return "video";
    }

    /**
     * @description ライブラリ内でのFolderを定義
     *              Define Folder in the library
     *
     * @return {string}
     * @static
     * @const
     */
    static get FOLDER ()
    {
        return "folder";
    }

    /**
     * @description ライブラリ内でのSoundを定義
     *              Define Sound in the library
     *
     * @return {string}
     * @static
     * @const
     */
    static get SOUND ()
    {
        return "sound";
    }

    /**
     * @description ライブラリ内でのMovieClipを定義
     *              Define MovieClip in the library
     *
     * @return {string}
     * @static
     * @const
     */
    static get MOVIE_CLIP ()
    {
        return "container";
    }

    /**
     * @description ライブラリ内でのTextを定義
     *              Define Text in the library
     *
     * @return {string}
     * @static
     * @const
     */
    static get TEXT ()
    {
        return "text";
    }
}

/**
 * タイムラインのレイヤーを管理するクラス
 * Class that manages layers in the timeline
 *
 * @class
 * @memberOf instance
 */
class Layer
{
    /**
     * @param {object} [object=null]
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$id = 0;

        /**
         * @type {array}
         * @private
         */
        this._$characters = [];

        /**
         * @type {array}
         * @private
         */
        this._$emptys = [];

        /**
         * @type {Map}
         * @private
         */
        this._$instances = new Map();

        /**
         * @type {array}
         * @private
         */
        this._$children = [];

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$maskId = null;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$guideId = null;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$name = "";

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$display = "";

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$light = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$disable = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$lock = false;

        /**
         * @type {number}
         * @default LayerMode.NORMAL
         * @private
         */
        this._$mode = LayerMode.NORMAL;

        /**
         * @type {string}
         * @default TimelineHighlight.color
         * @private
         */
        this._$color = TimelineHighlight.color;

        // 設定値があれば初期値を上書き
        if (object) {
            this._$name          = object.name;
            this._$light         = object.light;
            this._$disable       = object.disable;
            this._$lock          = object.lock;
            this._$mode          = object.mode;
            this._$maskId        = object.maskId;
            this._$guideId       = object.guideId;
            this._$color         = object.color || this._$color;
            this.characters      = object.characters;
            this.emptyCharacters = object.emptyCharacters || [];
        }
    }

    /**
     * @description シーン移動時の初期起動関数
     *              Initial startup function when moving scenes
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        const parent = document.getElementById("timeline-content");
        if (!parent) {
            return ;
        }

        // 初期化
        this._$children = [];
        this._$display  = "";

        // レイヤに必要なフレームをタイムラインに生成
        Util.$timelineLayer.create(this._$id);

        const element = parent.lastElementChild;
        if (!element) {
            return ;
        }

        const name = document.getElementById(`layer-name-${this.id}`);
        if (this.name) {
            name.textContent = this.name;
            document
                .getElementById(`layer-name-input-${this.id}`)
                .value = this.name;
        } else {
            this.name = name.textContent;
        }

        const lightIcon = document
            .getElementById(`layer-light-icon-${this.id}`);

        lightIcon
            .style
            .backgroundImage = `url('${this.getHighlightURL()}')`;

        if (this.light) {

            lightIcon
                .classList
                .remove("icon-disable");

            lightIcon
                .classList
                .add("light-icon-active");

            element
                .style
                .borderBottom = `1px solid ${this.color}`;
        }

        if (this.disable) {

            const disableIcon = document
                .getElementById(`layer-disable-icon-${this.id}`);

            disableIcon
                .classList
                .remove("icon-disable");

            disableIcon
                .classList
                .add("icon-active");
        }

        if (this.lock) {

            const lockIcon = document
                .getElementById(`layer-lock-icon-${this.id}`);

            lockIcon
                .classList
                .remove("icon-disable");

            lockIcon
                .classList
                .add("icon-active");
        }

        // view
        this.showIcon();
    }

    /**
     * @description 擬似スクロールでの表示領域に対してのレイヤー表示・非表示の状態管理
     *              Management of the state of display and non-display
     *              of layers for the displayed area in pseudo-scrolling
     *
     * @member {string}
     * @method
     * @public
     */
    get display ()
    {
        return this._$display;
    }
    set display (state)
    {
        this._$display = state === "none" ? state : "";
    }

    /**
     * @description ハイライトカラーをセットしたsvgのパスを返す
     *              Returns the path to the svg with highlight color set
     *
     * @return {string}
     * @method
     * @public
     */
    getHighlightURL ()
    {
        const object = Util.$intToRGB(
            `0x${this.color.slice(1)}` | 0
        );
        return `data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="13" height="13" viewBox="0 0 24 24"><path fill="rgb(${object.R},${object.G},${object.B})" d="M14 19h-4c-.276 0-.5.224-.5.5s.224.5.5.5h4c.276 0 .5-.224.5-.5s-.224-.5-.5-.5zm0 2h-4c-.276 0-.5.224-.5.5s.224.5.5.5h4c.276 0 .5-.224.5-.5s-.224-.5-.5-.5zm.25 2h-4.5l1.188.782c.154.138.38.218.615.218h.895c.234 0 .461-.08.615-.218l1.187-.782zm3.75-13.799c0 3.569-3.214 5.983-3.214 8.799h-1.989c-.003-1.858.87-3.389 1.721-4.867.761-1.325 1.482-2.577 1.482-3.932 0-2.592-2.075-3.772-4.003-3.772-1.925 0-3.997 1.18-3.997 3.772 0 1.355.721 2.607 1.482 3.932.851 1.478 1.725 3.009 1.72 4.867h-1.988c0-2.816-3.214-5.23-3.214-8.799 0-3.723 2.998-5.772 5.997-5.772 3.001 0 6.003 2.051 6.003 5.772zm4-.691v1.372h-2.538c.02-.223.038-.448.038-.681 0-.237-.017-.464-.035-.69h2.535zm-10.648-6.553v-1.957h1.371v1.964c-.242-.022-.484-.035-.726-.035-.215 0-.43.01-.645.028zm-3.743 1.294l-1.04-1.94 1.208-.648 1.037 1.933c-.418.181-.822.401-1.205.655zm10.586 1.735l1.942-1.394.799 1.115-2.054 1.473c-.191-.43-.423-.827-.687-1.194zm-3.01-2.389l1.038-1.934 1.208.648-1.041 1.941c-.382-.254-.786-.473-1.205-.655zm-10.068 3.583l-2.054-1.472.799-1.115 1.942 1.393c-.264.366-.495.763-.687 1.194zm13.707 6.223l2.354.954-.514 1.271-2.425-.982c.21-.397.408-.812.585-1.243zm-13.108 1.155l-2.356 1.06-.562-1.251 2.34-1.052c.173.433.371.845.578 1.243zm-1.178-3.676h-2.538v-1.372h2.535c-.018.226-.035.454-.035.691 0 .233.018.458.038.681z"/></svg>`;
    }

    /**
     * @description レイヤーを複製
     *              Duplicate Layer
     *
     * @return {Layer}
     * @method
     * @public
     */
    clone ()
    {
        return new Layer(JSON.parse(JSON.stringify(this.toObject())));
    }

    /**
     * @description 指定フレームに設置したDisplayObjectをスクリーンに配置
     *              DisplayObject placed in the specified frame on the screen
     *
     * @param  {number} [frame=1]
     * @return {void}
     * @method
     * @public
     */
    appendCharacter (frame = 1)
    {
        // 非表示のレイヤーはスキップ
        if (this.disable) {
            return ;
        }

        const element = document
            .getElementById("timeline-onion-skin");

        if (element.classList.contains("onion-skin-active")
            && Util.$timelinePlayer.stopFlag
        ) {

            const cacheFrame = Util.$timelineFrame.currentFrame;

            // レイヤーのキーフレームをセット
            const keyMap = new Map();
            for (let idx = 0; idx < this._$characters.length; ++idx) {

                const character = this._$characters[idx];

                for (let keyFrame of character._$places.keys()) {
                    keyMap.set(keyFrame, true);
                }

            }

            // 選択中のキーフレームは排除
            const activeCharacters = this.getActiveCharacter(cacheFrame);
            if (activeCharacters.length) {
                const range = activeCharacters[0].getRange(cacheFrame);
                keyMap.delete(range.startFrame);
            }

            for (const frame of keyMap.keys()) {

                Util.$timelineFrame.currentFrame = frame;

                const characters = this.getActiveCharacter(frame);
                if (!characters.length) {
                    continue;
                }

                if (characters.length > 1) {
                    this.sort(characters, frame);
                }

                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];
                    character.dispose();

                    Util.$screen.appendOnionCharacter(character, this.id);
                }
            }

            Util.$timelineFrame.currentFrame = cacheFrame;

            const characters = this.getActiveCharacter(cacheFrame);
            if (characters.length) {

                if (characters.length > 1) {
                    this.sort(characters, cacheFrame);
                }

                const event = this.lock ? "none" : "auto";
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];
                    character.dispose();

                    Util.$screen.appendCharacter(
                        character, cacheFrame, this.id, event
                    );
                }

            }

        } else {

            const characters = this.getActiveCharacter(frame);
            if (characters.length) {

                if (characters.length > 1) {
                    this.sort(characters, frame);
                }

                const event = this.lock ? "none" : "auto";
                for (let idx = 0; idx < characters.length; ++idx) {
                    Util.$screen.appendCharacter(
                        characters[idx], frame, this.id, event
                    );
                }

            }
        }
    }

    /**
     * @description 深度順に並び替え(昇順)
     *              Sort by depth (ascending order)
     *
     * @param  {array}  characters
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    sort (characters, frame)
    {
        characters.sort((a, b) =>
        {
            const depthA = a.getPlace(frame).depth;
            const depthB = b.getPlace(frame).depth;
            switch (true) {

                case depthA > depthB:
                    return 1;

                case depthA < depthB:
                    return -1;

                default:
                    return 0;

            }
        });
    }

    /**
     * @description 指定フレームに配置されているDisplayObjectを配列で返す
     *              Returns an array of DisplayObjects placed in the specified frame.
     *
     * @param  {number} [frame=1]
     * @return {array}
     * @method
     * @public
     */
    getActiveCharacter (frame = 1)
    {
        const characters = [];
        for (let idx = 0; idx < this._$characters.length; ++idx) {

            const character = this._$characters[idx];

            if (character.startFrame > frame) {
                continue;
            }

            if (frame >= character.endFrame) {
                continue;
            }

            characters.push(character);
        }
        return characters;
    }

    /**
     * @description 内部キャッシュしたDivのelementを返す
     *
     * @param  {number} frame
     * @return {HTMLDivElement|null}
     * @method
     * @public
     */
    getChildren (frame = 1)
    {
        const leftFrame = Util.$timelineHeader.leftFrame;
        return leftFrame > frame ? null : this._$children[frame - leftFrame];
    }

    /**
     * @description 指定したフレームに空のキャラクターオブジェクトがあれば返す
     *              Returns an empty character object if one exists in the specified frame.
     *
     * @param  {number} [frame=1]
     * @return {object}
     * @method
     * @public
     */
    getActiveEmptyCharacter (frame = 1)
    {
        for (let idx = 0; idx < this._$emptys.length; ++idx) {

            const character = this._$emptys[idx];

            if (character.startFrame > frame) {
                continue;
            }

            if (frame >= character.endFrame) {
                continue;
            }

            return character;
        }
        return null;
    }

    /**
     * @description レイヤーのモードによってアイコンを出し分ける
     *              Separate icons for each layer mode
     *
     * @return {void}
     * @method
     * @public
     */
    showIcon ()
    {

        // default
        const layerNameElement = document
            .getElementById(`layer-name-${this.id}`);

        layerNameElement
            .classList
            .remove("in-view-text");

        layerNameElement
            .classList
            .add("view-text");

        const inputElement = document
            .getElementById(`layer-name-input-${this.id}`);

        inputElement
            .classList
            .remove("in-view-text-input");

        switch (this._$mode) {

            case LayerMode.NORMAL:

                document
                    .getElementById(`layer-icon-${this.id}`)
                    .style.display = "";
                document
                    .getElementById(`layer-mask-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`layer-mask-in-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`layer-guide-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`layer-guide-in-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`timeline-exit-icon-${this.id}`)
                    .style.display = "none";
                document
                    .getElementById(`timeline-exit-in-icon-${this.id}`)
                    .style.display = "none";

                break;

            case LayerMode.MASK:
                {
                    document
                        .getElementById(`layer-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-icon-${this.id}`)
                        .style.display = "";
                    document
                        .getElementById(`layer-mask-in-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-guide-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-guide-in-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`timeline-exit-in-icon-${this.id}`)
                        .style.display = "none";

                    const exitIcon = document
                        .getElementById(`timeline-exit-icon-${this.id}`);

                    exitIcon.style.display = "";
                    exitIcon.style.opacity = "0";
                }
                break;

            case LayerMode.MASK_IN:
                {
                    document
                        .getElementById(`layer-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-in-icon-${this.id}`)
                        .style.display = "";
                    document
                        .getElementById(`layer-guide-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-guide-in-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`timeline-exit-icon-${this.id}`)
                        .style.display = "none";

                    const exitInIcon = document
                        .getElementById(`timeline-exit-in-icon-${this.id}`);

                    exitInIcon.style.display = "";
                    exitInIcon.style.opacity = "0";

                    const layerNameElement = document
                        .getElementById(`layer-name-${this.id}`);

                    layerNameElement
                        .classList
                        .remove("view-text");

                    layerNameElement
                        .classList
                        .add("in-view-text");

                    const inputElement = document
                        .getElementById(`layer-name-input-${this.id}`);

                    inputElement
                        .classList
                        .add("in-view-text-input");

                }
                break;

            case LayerMode.GUIDE:
                {
                    document
                        .getElementById(`layer-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-in-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-guide-icon-${this.id}`)
                        .style.display = "";
                    document
                        .getElementById(`layer-guide-in-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`timeline-exit-in-icon-${this.id}`)
                        .style.display = "none";

                    const exitIcon = document
                        .getElementById(`timeline-exit-icon-${this.id}`);

                    exitIcon.style.display = "";
                    exitIcon.style.opacity = "0";
                }
                break;

            case LayerMode.GUIDE_IN:
                {
                    document
                        .getElementById(`layer-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-mask-in-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-guide-icon-${this.id}`)
                        .style.display = "none";
                    document
                        .getElementById(`layer-guide-in-icon-${this.id}`)
                        .style.display = "";
                    document
                        .getElementById(`timeline-exit-icon-${this.id}`)
                        .style.display = "none";

                    const exitInIcon = document
                        .getElementById(`timeline-exit-in-icon-${this.id}`);

                    exitInIcon.style.display = "";
                    exitInIcon.style.opacity = "0";

                    const layerNameElement = document
                        .getElementById(`layer-name-${this.id}`);

                    layerNameElement
                        .classList
                        .remove("view-text");

                    layerNameElement
                        .classList
                        .add("in-view-text");

                    const inputElement = document
                        .getElementById(`layer-name-input-${this.id}`);

                    inputElement
                        .classList
                        .add("in-view-text-input");
                }
                break;

            default:
                break;

        }
    }

    /**
     * @description タイムラインのCSSを再配置する
     *              Rearranging the CSS in the Timeline
     *
     * @return {void}
     * @method
     * @public
     */
    reloadStyle ()
    {
        // 初期化
        this.resetStyle();

        // 空のフレーム
        this.setEmptyStyle();

        // DisplayObjectを配置したフレーム
        this.setCharacterStyle();
    }

    /**
     * @description DisplayObjectを配置したフレームのスタイルをセット
     *              Set the style of the frame in which the DisplayObject is placed
     *
     * @return {void}
     * @method
     * @public
     */
    setCharacterStyle ()
    {
        const leftFrame = Util.$timelineHeader.leftFrame;
        const lastFrame = leftFrame + this._$children.length;

        const duplication = new Map();
        for (let idx = 0; idx < this._$characters.length; ++idx) {

            const character = this._$characters[idx];
            if (character.startFrame > lastFrame) {
                continue;
            }

            if (leftFrame >= character.endFrame) {
                continue;
            }

            const places = Array.from(character._$places.keys());

            // 昇順
            places.sort((a, b) =>
            {
                switch (true) {

                    case a > b:
                        return 1;

                    case a < b:
                        return -1;

                    default:
                        return 0;

                }
            });

            for (let idx = 0; idx < places.length; ++idx) {

                const startFrame = places[idx];
                if (duplication.has(startFrame)) {
                    continue;
                }

                // スタイル処理完了用のフラグ
                duplication.set(startFrame, true);

                const endFrame = places[idx + 1] || character.endFrame;
                if (startFrame === endFrame - 1) {

                    if (leftFrame > startFrame) {
                        continue;
                    }

                    const element = this._$children[startFrame - leftFrame];
                    if (!element) {
                        return ;
                    }

                    element
                        .dataset
                        .frameState = "key-frame";

                    if (character.hasTween(startFrame)) {

                        element
                            .classList
                            .add("tween-key-frame");

                        const tweenObject = character.getTween(startFrame);
                        const rangeFrame  = tweenObject.endFrame - tweenObject.startFrame;

                        if (rangeFrame > 1 || character.hasTween(tweenObject.endFrame)) {
                            element
                                .classList
                                .add("tween-key-frame-join");
                        }

                    } else {

                        const place = character.getPlace(startFrame);
                        if (place.tweenFrame) {

                            const tweenObject = character
                                .getTween(place.tweenFrame);

                            if (tweenObject.endFrame - 1 === startFrame) {

                                if (character.hasTween(tweenObject.endFrame)) {

                                    element
                                        .classList
                                        .add("tween-space-frame");

                                } else {

                                    element
                                        .classList
                                        .add("tween-frame-end");

                                }

                            } else {

                                element
                                    .classList
                                    .add("tween-space-frame");

                            }

                        } else {

                            element
                                .classList
                                .add("key-frame");

                        }
                    }

                    continue;
                }

                // 複数フレームの場合のスタイル
                let frame = startFrame;
                if (leftFrame > frame) {

                    frame++;

                } else {

                    // 開始フレーム
                    const index   = frame - leftFrame;
                    const element = this._$children[index];
                    frame++;

                    if (element) {
                        element
                            .dataset
                            .frameState = "key-frame";

                        if (character.hasTween(startFrame)) {

                            element
                                .classList
                                .add(
                                    "tween-key-frame",
                                    "tween-key-frame-join"
                                );

                        } else {

                            element
                                .classList
                                .add(
                                    "key-frame",
                                    "key-frame-join"
                                );

                        }
                    }
                }

                // 間のフレーム
                const spaceTotalFrame = endFrame - 1;
                for (; frame < spaceTotalFrame; ) {

                    if (leftFrame > frame) {
                        frame++;
                        continue;
                    }

                    const index   = frame - leftFrame;
                    const element = this._$children[index];
                    frame++;

                    if (!element) {
                        continue;
                    }

                    element
                        .dataset
                        .frameState = "key-space-frame";

                    if (character.hasTween(startFrame)) {

                        element
                            .classList
                            .add("tween-space-frame");

                    } else {

                        element
                            .classList
                            .add("key-space-frame");

                    }

                }

                if (leftFrame > frame) {
                    continue;
                }

                // 終了フレーム
                const endElement = this._$children[frame - leftFrame];
                if (endElement) {
                    endElement
                        .dataset
                        .frameState = "key-space-frame-end";

                    if (character.hasTween(startFrame)) {

                        endElement
                            .classList
                            .add("tween-frame-end");

                    } else {

                        endElement
                            .classList
                            .add("key-space-frame-end");

                    }
                }
            }
        }
    }

    /**
     * @description 空フレームのスタイルをセット
     *              Set empty frame style
     *
     * @return {void}
     * @method
     * @public
     */
    setEmptyStyle ()
    {
        const leftFrame = Util.$timelineHeader.leftFrame;
        const lastFrame = leftFrame + this._$children.length;
        for (let idx = 0; idx < this._$emptys.length; ++idx) {

            const character = this._$emptys[idx];
            if (character.startFrame > lastFrame) {
                continue;
            }

            if (leftFrame >= character.endFrame) {
                continue;
            }

            // 1フレームだけの場合
            if (character.startFrame === character.endFrame - 1) {

                if (leftFrame > character.startFrame) {
                    continue;
                }

                const index   = character.startFrame - leftFrame;
                const element = this._$children[index];

                if (element) {
                    element
                        .dataset
                        .frameState = "empty-key-frame";

                    element
                        .classList
                        .add("empty-key-frame");
                }

                continue;
            }

            // 複数フレームの場合のスタイル
            let frame = character.startFrame;
            if (leftFrame > frame) {

                frame++;

            } else {

                const index   = frame - leftFrame;
                const element = this._$children[index];

                // 開始フレーム
                if (element) {
                    element
                        .dataset
                        .frameState = "empty-key-frame";

                    element
                        .classList
                        .add(
                            "empty-key-frame",
                            "empty-key-frame-join"
                        );
                }

                frame++;
            }

            // 間のフレーム
            const endFrame = character.endFrame - 1;
            for (; frame < endFrame; ) {

                if (leftFrame > frame) {
                    frame++;
                    continue;
                }

                const index   = frame - leftFrame;
                const element = this._$children[index];
                frame++;

                if (!element) {
                    continue;
                }

                element
                    .dataset
                    .frameState = "empty-space-frame";

                element
                    .classList
                    .add("empty-space-frame");

            }

            // 終了フレーム
            if (leftFrame > frame) {
                continue;
            }

            const index   = frame - leftFrame;
            const element = this._$children[index];
            if (element) {
                element
                    .dataset
                    .frameState = "empty-space-frame-end";

                element
                    .classList
                    .add("empty-space-frame-end");
            }
        }
    }

    /**
     * @description レイヤーのタイムラインのスタイルを初期化
     *              Initialize layer timeline style
     *
     * @return {void}
     * @method
     * @public
     */
    resetStyle ()
    {
        let frame = Util.$timelineHeader.leftFrame;
        for (let idx = 0; idx < this._$children.length; ++idx) {

            const element = this._$children[idx];

            // Emptyフレームを見つけたら終了
            if (!element || element.dataset.frameState === "empty") {
                return ;
            }

            // 5の倍数のフレームにはポインター用のスタイルを追加する
            element.setAttribute("class", frame % 5 !== 0
                ? "frame"
                : "frame frame-pointer"
            );

            // 状態を初期化
            element.setAttribute("data-frame-state", "empty");

            frame++;
        }
    }

    /**
     * @description レイヤーID、MovieClip内でユニークなID
     *              Layer ID, unique ID in MovieClip
     *
     * @default 0
     * @member {number}
     * @public
     */
    get id ()
    {
        return this._$id;
    }
    set id (id)
    {
        this._$id = Util.$clamp(id | 0, 0, 0xffff);
    }

    /**
     * @description レイヤー名
     *              Layer Name
     *
     * @default ""
     * @member {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }
    set name (name)
    {
        this._$name = `${name}`;
    }

    /**
     * @description ハイライトのon/off設定
     *              Highlight on/off setting
     *
     * @default false
     * @member {boolean}
     * @public
     */
    get light ()
    {
        return this._$light;
    }
    set light (light)
    {
        this._$light = !!light;
    }

    /**
     * @description 表示/非表示の設定
     *              Show/Hide settings
     *
     * @default false
     * @member {boolean}
     * @public
     */
    get disable ()
    {
        return this._$disable;
    }
    set disable (disable)
    {
        this._$disable = !!disable;
    }

    /**
     * @description レイヤーロックのon/off設定
     *              Layer lock on/off setting
     *
     * @default false
     * @member {boolean}
     * @public
     */
    get lock ()
    {
        return this._$lock;
    }
    set lock (lock)
    {
        this._$lock = !!lock;
    }

    /**
     * @description レイヤー内の空のキーフレーム配列
     *              Empty keyframe array in layer
     *
     * @member {array}
     * @public
     */
    get emptyCharacters ()
    {
        const characters = [];
        for (let idx = 0; idx < this._$emptys.length; ++idx) {
            characters.push(this._$emptys[idx].toObject());
        }
        return characters;
    }
    set emptyCharacters (characters)
    {
        for (let idx = 0; idx < characters.length; ++idx) {
            const character = new EmptyCharacter(characters[idx]);
            this._$emptys.push(character);
        }
    }

    /**
     * @description レイヤー内のDisplayObject配列
     *              DisplayObject array in layer
     *
     * @member {array}
     * @public
     */
    get characters ()
    {
        const characters = [];
        for (let idx = 0; idx < this._$characters.length; ++idx) {
            characters.push(this._$characters[idx].toObject());
        }
        return characters;
    }
    set characters (characters)
    {
        for (let idx = 0; idx < characters.length; ++idx) {
            const character = new Character(characters[idx]);

            this._$instances.set(character.id, character);
            this._$characters.push(character);
        }
    }

    /**
     * @description 指定したIDのDisplayObjectを返す
     *              Returns the DisplayObject with the specified ID
     *
     * @param  {number} character_id
     * @return {Character}
     * @method
     * @public
     */
    getCharacter (character_id)
    {
        return this._$instances.get(character_id | 0);
    }

    /**
     * @description レイヤーにDisplayObjectを追加
     *              Add DisplayObject to layer
     *
     * @param  {Character} character
     * @return {void}
     * @method
     * @public
     */
    addCharacter (character)
    {
        // 同一のDisplayObjectなら登録せずにスキップ
        if (this._$instances.has(character.id)) {
            return ;
        }

        this._$characters.push(character);
        this._$instances.set(character.id, character);
    }

    /**
     * @description 指定したIDのDisplayObjectをレイヤーから削除
     *              Delete the DisplayObject with the specified ID from the layer
     *
     * @param  {number} character_id
     * @return {void}
     * @method
     * @public
     */
    deleteCharacter (character_id)
    {
        if (!this._$instances.has(character_id | 0)) {
            return ;
        }

        const character = this._$instances.get(character_id | 0);

        this._$characters.splice(this._$characters.indexOf(character), 1);

        this._$instances.delete(character_id | 0);
    }

    /**
     * @description 空のキーフレームを追加
     *              Add empty keyframes
     *
     * @param  {EmptyCharacter} character
     * @return {void}
     * @method
     * @public
     */
    addEmptyCharacter (character)
    {
        this._$emptys.push(character);
    }

    /**
     * @description 空のキーフレームを削除
     *              Delete empty keyframes
     *
     * @param  {EmptyCharacter} character
     * @return {void}
     * @method
     * @public
     */
    deleteEmptyCharacter (character)
    {
        const index = this._$emptys.indexOf(character);
        if (index > -1) {
            this._$emptys.splice(index, 1);
        }
    }

    /**
     * @description 現在のフレームを起点に追加できるフレームを調整して、追加できるフレームの幅を返す
     *              Adjusts the frames that can be added starting from the current frame and returns the width of the frames that can be added
     *
     * @param  {number} frame
     * @return {object}
     * @method
     * @public
     */
    adjustmentLocation (frame)
    {
        // 空のフレームがあれば削除して、範囲を返す
        const emptyCharacter = this.getActiveEmptyCharacter(frame);
        if (emptyCharacter) {

            this.deleteEmptyCharacter(emptyCharacter);

            return {
                "startFrame": emptyCharacter.startFrame,
                "endFrame": emptyCharacter.endFrame
            };
        }

        // 既存のDisplayObjectがあればキーフームから幅を算出
        const characters = this.getActiveCharacter(frame);
        if (characters.length) {

            let startFrame = 1;
            let endFrame   = Number.MAX_VALUE;
            for (let idx = 0; idx < characters.length; ++idx) {

                const character = characters[idx];

                startFrame = Math.max(startFrame, character.startFrame);
                endFrame   = Math.min(endFrame, character.endFrame);
                for (const keyFrame of character._$places.keys()) {

                    if (keyFrame > frame) {
                        endFrame = Math.min(endFrame, keyFrame);
                    }

                    if (frame >= keyFrame) {
                        startFrame = Math.max(startFrame, keyFrame);
                    }

                }
            }

            return {
                "startFrame": startFrame,
                "endFrame": endFrame
            };
        }

        // 前方のフレームの補完
        if (frame > 1) {

            let idx = 1;
            for (; frame - idx > 0; ++idx) {

                // 空のフレームがあれば、フレームを伸ばす
                const emptyCharacter = this
                    .getActiveEmptyCharacter(frame - idx);

                if (emptyCharacter) {
                    emptyCharacter.endFrame = frame;
                    break;
                }

                // DisplayObjectがあれば、フレームを伸ばす
                const characters = this.getActiveCharacter(frame - idx);
                if (characters.length) {
                    for (let idx = 0; idx < characters.length; ++idx) {
                        characters[idx].endFrame = frame;
                    }
                    break;
                }
            }

            // 前方に何も配置されてない場合は空のキーフレームを登録
            if (!(frame - idx)) {
                this.addEmptyCharacter(new EmptyCharacter({
                    "startFrame": 1,
                    "endFrame": frame
                }));
            }
        }

        return {
            "startFrame": frame,
            "endFrame": frame + 1
        };
    }

    /**
     * @description レイヤーのアクティブなトータルフレーム数
     *              Number of active total frames in the layer
     *
     * @return {number}
     * @readonly
     * @public
     */
    get totalFrame ()
    {
        let frame = 0;
        for (let idx = 0; idx < this._$characters.length; ++idx) {

            const character = this._$characters[idx];
            frame = Math.max(frame, character.endFrame);

        }

        for (let idx = 0; idx < this._$emptys.length; ++idx) {

            const character = this._$emptys[idx];
            frame = Math.max(frame, character.endFrame);

        }

        return frame;
    }

    /**
     * @description レイヤーのモードの値
     *              Layer mode value
     *
     * @default 0
     * @member {number}
     * @public
     */
    get mode ()
    {
        return this._$mode;
    }
    set mode (mode)
    {
        mode = mode | 0;
        switch (mode) {

            case LayerMode.NORMAL:
            case LayerMode.MASK:
            case LayerMode.MASK_IN:
            case LayerMode.GUIDE:
            case LayerMode.GUIDE_IN:
                this._$mode = mode;
                break;

            default:
                this._$mode = LayerMode.NORMAL;
                break;

        }
    }

    /**
     * @description マスクレイヤーのID
     *              Mask Layer ID
     *
     * @default null
     * @member {number|null}
     * @public
     */
    get maskId ()
    {
        return this._$maskId;
    }
    set maskId (mask_id)
    {
        this._$maskId = typeof mask_id === "number"
            ? Util.$clamp(mask_id | 0, 0, 0xffff)
            : null;
    }

    /**
     * @description ガイドレイヤーのID
     *              Guide Layer ID
     *
     * @default null
     * @member {number|null}
     * @public
     */
    get guideId ()
    {
        return this._$guideId;
    }
    set guideId (guide_id)
    {
        this._$guideId = typeof guide_id === "number"
            ? Util.$clamp(guide_id | 0, 0, 0xffff)
            : null;
    }

    /**
     * @description ハイライトカラーの値
     *              Highlight Color Value
     *
     * @member {string}
     * @public
     */
    get color ()
    {
        return this._$color;
    }
    set color (color)
    {
        this._$color = `${color}`;
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "name":            this.name,
            "light":           this.light,
            "disable":         this.disable,
            "lock":            this.lock,
            "mode":            this.mode,
            "maskId":          this.maskId,
            "guideId":         this.guideId,
            "color":           this.color,
            "characters":      this.characters,
            "emptyCharacters": this.emptyCharacters
        };
    }
}

/**
 * レイヤーの型の固定値
 * Fixed value of the layer type
 *
 * @class
 * @memberOf instance
 */
class LayerMode
{
    /**
     * @description 通常レイヤー
     *              Normal Layer
     *
     * @return {number}
     * @static
     * @const
     */
    static get NORMAL ()
    {
        return 0;
    }

    /**
     * @description マスクレイヤー
     *              Mask Layer
     *
     * @return {number}
     * @static
     * @const
     */
    static get MASK ()
    {
        return 1;
    }

    /**
     * @description Nested layers of masks
     *              Normal Layer
     *
     * @return {number}
     * @static
     * @const
     */
    static get MASK_IN ()
    {
        return 2;
    }

    /**
     * @description ガイドレイヤー
     *              Guide Layer
     *
     * @return {number}
     * @static
     * @const
     */
    static get GUIDE ()
    {
        return 3;
    }

    /**
     * @description ガイドの入れ子になっているレイヤー
     *              Nested layers of guides
     *
     * @return {number}
     * @static
     * @const
     */
    static get GUIDE_IN ()
    {
        return 4;
    }
}

/**
 * コンテナとしてレイヤーやタイムラインを管理するクラス、Next2DのMovieClipクラスとして出力されます。
 * The output is a class that manages layers and timelines as containers and Next2D's MovieClip class.
 *
 * @class
 * @extends {Instance}
 * @memberOf instance
 */
class MovieClip extends Instance
{
    /**
     * @param {object} object
     * @constructor
     * @public
     */
    constructor (object)
    {
        super(object);

        // default
        this._$currentFrame  = 1;
        this._$layerId       = 0;
        this._$labels        = new Map();
        this._$layers        = new Map();
        this._$actions       = new Map();
        this._$sounds        = new Map();
        this._$publishObject = null;

        if (object.layers) {
            this.layers = object.layers;
        }

        if (object.labels) {
            this.labels = object.labels;
        }

        if (object.placeMap) {
            this.placeMap = object.placeMap;
        }

        if (object.sounds) {
            this.sounds = object.sounds;
        }

        if (object.actions) {
            this.actions = object.actions;
        }

        if (object.currentFrame) {
            this._$currentFrame = Math.max(1, object.currentFrame | 0);
        }
    }

    /**
     * @description MovieClipクラスを複製
     *              Duplicate MovieClip class
     *
     * @return {MovieClip}
     * @method
     * @public
     */
    clone ()
    {
        return new MovieClip(JSON.parse(JSON.stringify(this.toObject())));
    }

    /**
     * @description このアイテムが設定されたDisplayObjectが選択された時
     *              内部情報をコントローラーに表示する
     *              When a DisplayObject with this item set is selected,
     *              internal information is displayed on the controller.
     *
     * @param  {object} place
     * @param  {string} [name=""]
     * @return {void}
     * @method
     * @public
     */
    showController(place, name = "")
    {
        super.showController(place, name);

        Util.$controller.hideObjectSetting([
            "text-setting",
            "video-setting",
            "fill-color-setting",
            "nine-slice-setting"
        ]);

        Util.$controller.showObjectSetting([
            "loop-setting"
        ]);

        // カスタムループコントローラーを初期化
        Util.$loopController.reload(place.loop);

        // フレームピッカーの画像表示を非表示に
        document
            .getElementById("loop-image-list")
            .style.display = "none";
    }

    /**
     * @description 初期起動関数
     *              initial invoking function
     *
     * @return {void}
     * @public
     */
    initialize ()
    {
        // ツールを初期化
        Util.$tools.reset();

        // スクリーンを初期化
        Util.$screen.clearStageArea();
        Util.$clearShapePointer();

        // DisplayObjectを初期化
        this.cacheClear();

        // object setting
        const sceneName = document.getElementById("scene-name");
        if (sceneName) {
            sceneName.textContent = this.name;
        }

        const objectName = document.getElementById("object-name");
        if (objectName) {
            objectName.value = this.name;
        }

        const objectSymbol = document.getElementById("object-symbol");
        if (objectSymbol) {
            objectSymbol.value = this.symbol;
        }

        // シーンの初期化
        if (this.id === 0) {
            const scenes = document.getElementById("scene-name-menu-list");
            if (scenes) {
                while (scenes.children.length) {
                    scenes.children[0].remove();
                }
            }
        }

        // タイムラインを初期化
        Util.$timelineLayer.removeAll();

        // フレームを登録してヘッダーを再編成
        const currentFrame = 1;//this.currentFrame;
        Util.$timelineFrame.currentFrame = currentFrame;

        // ヘッダーを生成
        Util.$timelineHeader.setWidth();
        Util.$timelineHeader.scrollX = (currentFrame - 1) * Util.$timelineTool.timelineWidth;
        Util.$timelineHeader.rebuild();

        // マーカーを移動
        Util.$timelineMarker.move(); // fixed logic

        // frame1 label
        Util.$timelineLayer.changeLabel(currentFrame);

        // レイヤーの擬似スクロールをセット
        Util.$timelineLayer.updateClientSize();
        Util.$timelineScroll.updateWidth();
        Util.$timelineScroll.updateHeight();

        // スクロールの座標をセット
        Util.$timelineScroll.execute(
            -Util.$timelineScroll.x,
            -Util.$timelineScroll.y
        );

        // insert layer
        this._$layerId = 0;
        for (const layer of this._$layers.values()) {
            layer._$id = this._$layerId++;
            layer.initialize();
        }

        // タイムラインが空の時は初期レイヤーをセットする
        if (!this._$layers.size) {
            this.addLayer();
        }

        Util.$controller.default();
        if (this.id) {

            // スクリーンに表示されてるシーンはドラッグできないようロック
            const element = document
                .getElementById(`library-child-id-${this.id}`);

            if (element) {
                element.draggable = false;
            }

        }

        // 定規を設定
        if (!this.id) {

            const workSpace = Util.$currentWorkSpace();
            if (workSpace._$ruler) {

                // 定規を表示
                Util.$screenRuler.show();

            } else {

                // 線があれば線だけ表示
                const rulerX = workSpace._$rulerX;
                const rulerY = workSpace._$rulerY;
                if (rulerX.length || rulerY.length) {
                    Util.$screenRuler.createBorder();
                }

            }
        }

        // サウンド設定を反映
        Util.$soundController.createSoundElements();

        // スクリーンに描画
        this.changeFrame(
            Util.$timelineFrame.currentFrame
        );
    }

    /**
     * @description タイムライン内の再生ヘッドが置かれているフレームの番号を示します。
     *              Indicates the number of the frame in the timeline at which the playback head is placed.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get currentFrame ()
    {
        return this._$currentFrame;
    }

    /**
     * @description MovieClip インスタンス内のフレーム総数です。
     *              The total number of frames in the MovieClip instance.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get totalFrame ()
    {
        let frame = 1;
        for (const layer of this._$layers.values()) {
            frame = Math.max(frame, layer.totalFrame - 1);
        }
        return frame;
    }

    /**
     * @description 指定フレームに配置されたDisplayObjectを設置
     *              DisplayObject placed in the specified frame
     *
     * @param  {number} [frame=1]
     * @return {void}
     * @method
     * @public
     */
    changeFrame (frame = 1)
    {
        // ステージのelementを全て削除
        Util.$screen.clearStageArea();

        const element = document.getElementById("stage-area");
        if (!element) {
            return ;
        }

        const pointers = [];
        const children = element.children;
        for (let idx = 0; children.length > idx; ++idx) {

            const node = children[idx];
            if (!node.dataset.shapePointer) {
                continue;
            }

            node.remove();
            pointers.push(node);
            --idx;
        }

        // 子孫のMovieClipの時は先祖のシーン情報を透明にして描画
        if (Util.$sceneChange.length) {

            const children = document
                .getElementById("scene-name-menu-list")
                .children;

            const characterId = Util.$activeCharacterIds.length
                ? Util.$activeCharacterIds[Util.$activeCharacterIds.length - 1]
                : -1;

            const workSpace  = Util.$currentWorkSpace();

            // 現在のパラメーターをキャッシュ
            const offsetX = Util.$sceneChange.offsetX;
            const offsetY = Util.$sceneChange.offsetY;
            const length  = Util.$sceneChange.length;
            const matrix  = Util.$sceneChange.matrix.slice(0);

            // 初期化
            Util.$sceneChange.clear();
            for (let idx = 0; children.length > idx; ++idx) {

                const node = children[idx];

                // 親子関係でない場合は終了
                if (node.dataset.parent === "false") {
                    continue;
                }

                const instance = workSpace.getLibrary(
                    node.dataset.libraryId | 0
                );

                Util.$sceneChange.offsetX = +node.dataset.offsetX;
                Util.$sceneChange.offsetY = +node.dataset.offsetY;

                if (idx) {
                    Util.$sceneChange.length = idx;
                    Util.$sceneChange.matrix.push(matrix[idx - 1]);
                }

                const parentFrame = instance.currentFrame;
                for (const layer of instance._$layers.values()) {

                    if (layer.mode === LayerMode.MASK) {
                        continue;
                    }

                    const characters = layer
                        .getActiveCharacter(parentFrame);

                    if (!characters.length) {
                        continue;
                    }

                    if (characters.length > 1) {
                        layer.sort(characters, parentFrame);
                    }

                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];
                        if (character.id === characterId) {
                            continue;
                        }
                        character.dispose();

                        Util.$screen.appendCharacter(
                            character, parentFrame, layer.id,
                            "none", instance, 0.25
                        );
                    }
                }

                break;
            }

            // キャッシュした情報をセット
            Util.$sceneChange.length   = length;
            Util.$sceneChange._$matrix = matrix;
            Util.$sceneChange.offsetX  = offsetX;
            Util.$sceneChange.offsetY  = offsetY;
        }

        const layers = Array.from(this._$layers.values());
        while (layers.length) {
            const layer = layers.pop();
            if (layer.mode === LayerMode.MASK && layer.lock) {
                continue;
            }
            layer.appendCharacter(frame);
        }

        this._$currentFrame = frame;

        // スクリーンエリアの変形Elementの配置を再計算
        // 非表示の時は何もしない
        Util.$transformController.relocation();
        Util.$gridController.relocation();

        for (let idx = 0; pointers.length > idx; ++idx) {
            element.appendChild(pointers[idx]);
        }

        // tweenのポインターを再配置
        Util
            .$tweenController
            .clearPointer()
            .relocationPointer();

        if (this.id) {

            const div = document.createElement("div");
            div.setAttribute("class", "standard-point");

            const left = Util.$offsetLeft + Util.$sceneChange.offsetX * Util.$zoomScale - 6;
            const top  = Util.$offsetTop  + Util.$sceneChange.offsetY * Util.$zoomScale - 6;
            div.setAttribute(
                "style", `left: ${left}px; top: ${top}px;`
            );
            div.dataset.child = "true";

            document
                .getElementById("stage-area")
                .appendChild(div);

        }
    }

    /**
     * @description シーン移動時に、直前に表示していたシーンをリストに追加する
     *              When moving scenes, add the scene that was displayed immediately before to the list.
     *
     * @param  {boolean} [parent = false]
     * @return {void}
     * @method
     * @public
     */
    addSceneName (parent = false)
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(this.id | 0);

        // add menu
        const htmlTag = `
<div id="scene-instance-id-${instance.id}" data-library-id="${instance.id}" data-offset-x="${Util.$sceneChange.offsetX}" data-offset-y="${Util.$sceneChange.offsetY}" data-parent="${parent}">${instance.name}</div>
`;

        document
            .getElementById("scene-name-menu-list")
            .insertAdjacentHTML("beforeend", htmlTag);

        const element = document
            .getElementById(`scene-instance-id-${instance.id}`);

        element.addEventListener("mousedown", (event) =>
        {
            // 全てのイベントを中止
            event.stopPropagation();
            event.preventDefault();
        });

        element.addEventListener("click", (event) =>
        {
            // 全てのイベントを中止
            event.stopPropagation();
            event.preventDefault();

            // モーダルを全て閉じる
            Util.$endMenu();

            const children = Array.from(
                document
                    .getElementById("scene-name-menu-list")
                    .children
            );

            const element = event.target;
            const index   = children.indexOf(element);
            for (let idx = children.length - 1; idx > -1; --idx) {

                const node = children[idx];
                node.remove();

                // アクティブな情報を削除
                Util.$activeCharacterIds.pop();
                Util.$sceneChange.matrix.pop();
                Util.$sceneChange.length--;

                if (index === idx) {
                    break;
                }
            }

            Util.$sceneChange.offsetX = +element.dataset.offsetX;
            Util.$sceneChange.offsetY = +element.dataset.offsetY;

            // シーン移動
            Util.$sceneChange.execute(
                element.dataset.libraryId | 0
            );
        });

        // 配列数を加算
        Util.$sceneChange.length++;
    }

    /**
     * @description MovieClip内の全てのDisplayObjectにキャッシュをクリア
     *
     * @return {void}
     * @method
     * @public
     */
    cacheClear ()
    {
        for (const layer of this._$layers.values()) {
            const characters = layer._$characters;
            for (let idx = 0; idx < characters.length; ++idx) {
                characters[idx].dispose();
            }
        }
    }

    /**
     * @description シーン終了関数
     *              end-of-scene function
     *
     * @return {void}
     * @method
     * @public
     */
    stop ()
    {
        // rootでなければ、ライブラリの選択を可能に変更
        if (this.id) {

            const element = document
                .getElementById(`library-child-id-${this.id}`);

            if (element) {
                element.draggable = true;
            }

        }

        const element = document
            .getElementById("timeline-content");

        if (!element) {
            return ;
        }

        const children = element.children;

        const layers = [];
        const length = children.length;
        for (let idx = 0; idx < length; ++idx) {

            const layer = this.getLayer(
                children[idx].dataset.layerId | 0
            );

            // 内部キャッシュを初期化
            layer._$children.length = 0;

            layers.push(layer);
        }

        // レイヤー順に並び替え
        this._$layers.clear();
        for (let idx = 0; idx < layers.length; ++idx) {
            const layer = layers[idx];
            layer._$id  = idx;
            this.setLayer(idx, layer);
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();

        // キャッシュを削除
        this.cacheClear();
    }

    /**
     * @description タイムラインに設置した全てのラベルを配列で返す
     *              Returns an array of all labels placed on the timeline
     *
     * @member {array}
     * @public
     */
    get labels ()
    {
        const labels = [];
        for (let [frame, value] of this._$labels) {
            labels.push({
                "frame": frame,
                "name": value
            });
        }
        return labels;
    }
    set labels (labels)
    {
        for (let idx = 0; idx < labels.length; ++idx) {

            const object = labels[idx];

            this._$labels.set(
                object.frame | 0,
                object.name
            );

        }
    }

    /**
     * @description 指定フレームにラベルをセットする
     *              Sets a label on the specified frame
     *
     * @param  {number} frame
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    setLabel (frame, value)
    {
        this._$labels.set(frame | 0, value);
    }

    /**
     * @description 指定フレームのラベルを返す
     *              Returns the label of the specified frame
     *
     * @param  {number} frame
     * @return {object}
     * @method
     * @public
     */
    getLabel (frame)
    {
        return this.hasLabel(frame)
            ? this._$labels.get(frame | 0)
            : null;
    }

    /**
     * @description 指定フレームにラベル情報が設置されているか判定
     *              Judges whether label information is installed in the specified frame.
     *
     * @param  {number} frame
     * @return {boolean}
     * @method
     * @public
     */
    hasLabel (frame)
    {
        return this._$labels.has(frame);
    }

    /**
     * @description 指定フレームに設置したラベル情報を削除
     *              Delete label information placed in the specified frame
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    deleteLabel (frame)
    {
        this._$labels.delete(frame | 0);
    }

    /**
     * @description 設置された全てのレイヤーを配列で返す
     *              Returns all installed layers as an array
     *
     * @member {array}
     * @public
     */
    get layers ()
    {
        let index = 0;
        let parentId = null;
        const layers = [];
        for (const value of this._$layers.values()) {

            const object = value.toObject();
            switch (object.mode) {

                case LayerMode.MASK:
                case LayerMode.GUIDE:
                    parentId = index;
                    break;

                case LayerMode.MASK_IN:
                    object.maskId = parentId;
                    break;

                case LayerMode.GUIDE_IN:
                    object.guideId = parentId;
                    break;

                default:
                    parentId = null;
                    break;

            }

            layers.push(object);
            index++;
        }
        return layers;
    }
    set layers (layers)
    {
        for (let idx = 0; idx < layers.length; ++idx) {
            this._$layers.set(idx, new Layer(layers[idx]));
        }
    }

    /**
     * @description シーンにレイヤーを追加
     *              Adding Layers to a Scene
     *
     * @param  {Layer} [layer=null]
     * @return {void}
     * @method
     * @public
     */
    addLayer (layer = null)
    {
        if (!layer) {
            layer = new Layer();
        }

        layer._$id = this._$layerId++;
        this._$layers.set(layer._$id, layer);
        layer.initialize();
    }

    /**
     * @description 指定したIDのLayerオブジェクトを返す
     *              Returns a Layer object with the specified ID
     *
     * @param  {number} layer_id
     * @return {Layer}
     * @method
     * @public
     */
    getLayer (layer_id)
    {
        return this._$layers.get(layer_id | 0);
    }

    /**
     * @description IDを指定してLayerオブジェクトを登録
     *              Register a Layer object by specifying its ID
     *
     * @param  {number} layer_id
     * @param  {Layer}  layer
     * @return {void}
     * @method
     * @public
     */
    setLayer (layer_id, layer)
    {
        this._$layers.set(layer_id | 0, layer);
    }

    /**
     * @description 指定したIDのLayerオブジェクトを削除
     *              Delete Layer object with specified ID
     *
     * @param  {number} layer_id
     * @return {void}
     * @method
     * @public
     */
    deleteLayer (layer_id)
    {
        this._$layers.delete(layer_id | 0);
    }

    /**
     * @description 全てのLayerオブジェクトを削除
     *              Delete all Layer objects
     *
     * @return {void}
     * @method
     * @public
     */
    clearLayer ()
    {
        this._$layers.clear();
    }

    /**
     * @description シーン内に設置されたサウンド情報を配列で返す
     *              Returns an array of sound information placed in the scene
     *
     * @member {array}
     * @public
     */
    get sounds ()
    {
        const sounds = [];
        for (let [frame, sound] of this._$sounds) {
            sounds.push({
                "frame": frame,
                "sound": sound
            });
        }
        return sounds;
    }
    set sounds (sounds)
    {
        for (let idx = 0; idx < sounds.length; ++idx) {
            const object = sounds[idx];
            this._$sounds.set(object.frame | 0, object.sound);
        }
    }

    /**
     * @description シーン内に設置されたJavaScript情報を配列で返す
     *              Returns an array of JavaScript information placed in the scene
     *
     * @member {array}
     * @public
     */
    get actions ()
    {
        const actions = [];
        for (let [frame, action] of this._$actions) {
            actions.push({
                "frame": frame,
                "action": action
            });
        }
        return actions;
    }
    set actions (actions)
    {
        for (let idx = 0; idx < actions.length; ++idx) {
            const object = actions[idx];
            this._$actions.set(object.frame | 0, object.action);
        }
    }

    /**
     * @description 指定したフレームのサウンド情報を配列で返す
     *              Returns an array of sound information for a given frame
     *
     * @param  {number} frame
     * @return {array}
     * @method
     * @public
     */
    getSound (frame)
    {
        return this._$sounds.get(frame);
    }

    /**
     * @description 指定したフレームにサウンド情報を登録
     *              Register sound information to the specified frame
     *
     * @param  {number} frame
     * @param  {array} sounds
     * @return {void}
     * @method
     * @public
     */
    setSound (frame, sounds)
    {
        return this._$sounds.set(frame, sounds);
    }

    /**
     * @description 指定したフレームにサウンド情報が設置されているか判定
     *              Determines if sound information is installed in the specified frame
     *
     * @param  {number} frame
     * @return {boolean}
     * @method
     * @public
     */
    hasSound (frame)
    {
        return this._$sounds.has(frame);
    }

    /**
     * @description 指定したフレームのサウンド情報を削除
     *              Delete sound information for the specified frame
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    deleteSound (frame)
    {
        this._$sounds.delete(frame);
    }

    /**
     * @description 指定したフレームのJavaScript情報を返す
     *              Returns JavaScript information for the specified frame
     *
     * @param  {number} frame
     * @return {string}
     * @method
     * @public
     */
    getAction (frame)
    {
        return this._$actions.get(frame);
    }

    /**
     * @description 指定したフレームにJavaScript情報を登録する
     *              Register JavaScript information in the specified frame
     *
     * @param  {number} frame
     * @param  {string} script
     * @return {void}
     * @method
     * @public
     */
    setAction (frame, script)
    {
        this._$actions.set(frame, script);

        // コントローラーのelementを再構築
        Util
            .$javascriptController
            .reload();
    }

    /**
     * @description 指定フレームにJavaScript情報の設定の有無を判定
     *              Judges whether JavaScript information is set in the specified frame.
     *
     * @param  {number} frame
     * @return {boolean}
     * @method
     * @public
     */
    hasAction (frame)
    {
        return this._$actions.has(frame);
    }

    /**
     * @description 指定フレームのJavaScript情報を削除
     *              Delete JavaScript information for specified frames
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    deleteAction (frame)
    {
        this._$actions.delete(frame);

        Util
            .$javascriptController
            .reload();
    }

    /**
     * @description 表示領域(バウンディングボックス)のObjectを返す
     *              Returns the Object of the display area (bounding box)
     *
     * @param  {array}  [matrix=[1, 0, 0, 1, 0, 0]]
     * @param  {object} [place=null]
     * @param  {object} [range=null]
     * @param  {number} [parent_frame=0]
     * @return {object}
     * @method
     * @public
     */
    getBounds (
        matrix = [1, 0, 0, 1, 0, 0],
        place = null, range = null, parent_frame = 0
    ) {

        if (!this._$layers.size) {
            return {
                "xMin": 0,
                "xMax": 0,
                "yMin": 0,
                "yMax": 0
            };
        }

        const currentFrame = Util.$currentFrame;

        let frame = parent_frame || 1;
        if (place && range) {
            frame = Util.$getFrame(
                place, range, currentFrame, this.totalFrame, parent_frame
            );
        }

        if (frame > this.totalFrame) {
            frame = 1;
        }

        const parentMatrix = matrix;

        Util.$currentFrame = frame;

        const workSpace = Util.$currentWorkSpace();

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;
        for (const layer of this._$layers.values()) {

            if (layer.disable) {
                continue;
            }

            const characters = layer.getActiveCharacter(frame);

            const length = characters.length;
            for (let idx = 0; idx < length; ++idx) {

                const character = characters[idx];
                const place     = character.getPlace(frame);
                const range     = place.loop && place.loop.type === LoopController.DEFAULT
                    ? {
                        "startFrame": character.startFrame,
                        "endFrame": character.endFrame
                    }
                    : character.getRange(frame);

                const instance = workSpace
                    .getLibrary(character.libraryId | 0);

                const matrix = Util.$multiplicationMatrix(parentMatrix, place.matrix);
                const bounds = instance.getBounds(matrix, place, range, frame);

                const width  = bounds.xMax - bounds.xMin;
                const height = bounds.yMax - bounds.yMin;
                if (!width || !height) {
                    bounds.xMin = matrix[4];
                    bounds.xMax = matrix[4];
                    bounds.yMin = matrix[5];
                    bounds.yMax = matrix[5];
                }

                xMin = Math.min(bounds.xMin, xMin);
                xMax = Math.max(bounds.xMax, xMax);
                yMin = Math.min(bounds.yMin, yMin);
                yMax = Math.max(bounds.yMax, yMax);
            }
        }

        // reset
        Util.$currentFrame = currentFrame;

        return {
            "xMin": xMin,
            "xMax": xMax,
            "yMin": yMin,
            "yMax": yMax
        };
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "id":           this.id,
            "name":         this.name,
            "type":         this.type,
            "symbol":       this.symbol,
            "folderId":     this.folderId,
            "currentFrame": this.currentFrame,
            "layers":       this.layers,
            "labels":       this.labels,
            "sounds":       this.sounds,
            "actions":      this.actions
        };
    }

    /**
     * @description 書き出し用のObjectを返す
     *              Returns an Object for export
     *
     * @param  {boolean} [with_character_id=false]
     * @return {object}
     * @method
     * @public
     */
    toPublish (with_character_id = false)
    {
        const dictionary   = [];
        const controller   = [];
        const placeMap     = [];
        const placeObjects = [];

        const workSpace  = Util.$currentWorkSpace();
        const libraryMap = new Map();

        let index = 0;
        for (const id of workSpace._$libraries.keys()) {
            libraryMap.set(id, index++);
        }

        // setup
        let currentPlaceId = 0;
        let clipStart      = false;
        let clipIndex      = 0;
        const setting      = Util.$userSetting.getPublishSetting();

        const layers = Array.from(this._$layers);

        const clipLayers = [];
        let clipCount    = 0;
        let depth        = 0;
        for (let idx = layers.length - 1; idx > -1; --idx) {

            if (clipIndex && !clipLayers.length) {
                clipIndex = 0;
                clipCount = 0;
                continue;
            }

            const layer = !clipStart && clipLayers.length
                ? clipLayers.shift()
                : layers[idx][1];

            // 非表示レイヤー処理
            if (!setting.layer && layer.disable) {
                continue;
            }

            // ガイドレイヤーは描画に含めない
            if (layer.mode === LayerMode.GUIDE) {
                continue;
            }

            if (layer.mode === LayerMode.MASK_IN
                && !clipStart && !clipIndex
            ) {
                clipStart = true;
                clipIndex = idx;
            }

            if (clipStart && layer.mode === LayerMode.MASK_IN) {
                clipCount += layer._$characters.length;
                clipLayers.push(layer);
                continue;
            }

            const characters = layer._$characters;

            const length = layer.mode === LayerMode.MASK
                ? Math.min(1, characters.length)
                : characters.length;

            let index = layer.mode === LayerMode.MASK
                ? length - 1
                : 0;

            for (;;) {

                const id = dictionary.length;

                const character = characters[index];
                if (!character) {
                    break;
                }

                const startFrame = character.startFrame;
                const endFrame   = character.endFrame;

                const instance = workSpace._$libraries.get(character.libraryId);
                if (!Util.$useIds.has(instance.id)) {
                    Util.$useIds.set(instance.id, true);
                }

                const object = {
                    "name": character.name,
                    "characterId": instance.id,
                    "endFrame": endFrame,
                    "startFrame": startFrame,
                    "clipDepth": layer.mode === LayerMode.MASK
                        ? index + clipCount + currentPlaceId
                        : 0
                };

                if (with_character_id) {
                    object.id = character.id;
                }

                dictionary.push(object);

                let placeIndex = 0;
                for (let frame = startFrame; frame < endFrame; ++frame) {

                    if (!(frame in controller)) {
                        controller[frame] = [];
                    }

                    if (!(frame in placeMap)) {
                        placeMap[frame] = [];
                    }

                    const place = character.getPlace(frame);
                    if (character.hasPlace(frame)) {

                        placeIndex = placeObjects.length;

                        const filters = [];
                        for (let idx = 0; idx < place.filter.length; ++idx) {
                            const filter = place.filter[idx];
                            if (!filter.state) {
                                continue;
                            }

                            filters.push({
                                "class": filter.name,
                                "params": filter.toParamArray()
                            });
                        }

                        const placeObject = {
                            "matrix": place.matrix,
                            "colorTransform": place.colorTransform,
                            "blendMode": place.blendMode,
                            "surfaceFilterList": filters
                        };

                        if (instance.type === InstanceType.MOVIE_CLIP
                            && LoopController.DEFAULT > place.loop.type
                        ) {

                            if (place.loop.referenceFrame) {

                                const referencePlace = character.getPlace(
                                    place.loop.referenceFrame
                                );

                                placeObject.loop = {
                                    "type": referencePlace.loop.type,
                                    "frame": referencePlace.frame,
                                    "start": referencePlace.loop.start,
                                    "end": referencePlace.loop.end
                                };

                            } else {

                                placeObject.loop = {
                                    "type": place.loop.type,
                                    "frame": place.frame,
                                    "start": place.loop.start,
                                    "end": place.loop.end
                                };
                            }

                            if (place.loop.tweenFrame) {
                                placeObject.loop.tweenFrame = place.loop.tweenFrame;
                            }
                        }

                        placeObjects.push(placeObject);
                    }

                    controller[frame][depth + place.depth] = id;
                    placeMap[frame][depth   + place.depth] = placeIndex;
                }

                if (layer.mode === LayerMode.MASK) {
                    --index;
                    if (-1 === index) {
                        break;
                    }
                } else {
                    ++index;
                    if (index === length) {
                        break;
                    }
                }
            }

            currentPlaceId += length;
            depth += length;

            if (clipStart && clipLayers.length) {
                idx = clipIndex + 1;
                clipStart = false;
            }
        }

        // empty keyを詰める
        for (let frame = 1; controller.length > frame; ++frame) {

            if (!(frame in controller)) {
                continue;
            }

            const characters = controller[frame];
            const placeMaps  = placeMap[frame];

            controller[frame] = characters.filter((value) => { return typeof value === "number" });
            placeMap[frame]   = placeMaps.filter((value)  => { return typeof value === "number" });
        }

        const sounds = [];
        for (let [frame, values] of this._$sounds) {

            const object = {
                "frame": frame,
                "sound": []
            };

            for (let idx = 0; idx < values.length; ++idx) {

                const sound = values[idx];

                const characterId = sound.characterId | 0;
                object.sound.push({
                    "characterId": characterId,
                    "volume":      sound.volume / 100,
                    "autoPlay":    sound.autoPlay,
                    "loopCount":   sound.loopCount
                });

                if (!Util.$useIds.has(characterId)) {
                    Util.$useIds.set(characterId, true);
                }
            }

            sounds.push(object);
        }

        const actions = [];
        for (let [frame, action] of this._$actions) {

            const scriptList = action
                .replace(/("[^"]*\/\/.*?")|\/\/(?:.|\r?\n)*?(?:\r?\n|.*)?/g, "$1")
                .replace(/(["'][^"']*\/\*.*?\*\/[^"']*["'])|\/\*(?:.|\r?\n)*?\*\//g, "$1")
                .replace(/^\s+|\s+$/g, "")
                .replace(/ +/g, " ")
                .split(/\r?\n/);

            let list = [];
            for (let idx = 0; idx < scriptList.length; ++idx) {
                const value = scriptList[idx].trim();
                if (!value.length) {
                    continue;
                }

                list.push(value);
            }

            actions.push({
                "frame": frame,
                "action": list.join("\n")
            });
        }

        return {
            "actions": actions,
            "symbol":  this.symbol,
            "extends": this.defaultSymbol,
            "totalFrame": this.totalFrame,
            "controller": controller,
            "dictionary": dictionary,
            "labels": this.labels,
            "placeMap": placeMap,
            "placeObjects": placeObjects,
            "sounds": sounds
        };
    }

    /**
     * @description シンボルを指定した時の継承先を返す
     *              Returns the inheritance destination when a symbol is specified.
     *
     * @member   {string}
     * @readonly
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.display.MovieClip.namespace;
    }

    /**
     * @description Next2DのDisplayObjectを生成
     *              Generate Next2D DisplayObject
     *
     * @param  {object} place
     * @param  {object} range
     * @param  {number} [parent_frame = 0]
     * @return {next2d.display.Sprite}
     * @method
     * @public
     */
    createInstance (place, range, parent_frame = 0)
    {
        const { MovieClip } = window.next2d.display;
        const { Matrix, ColorTransform } = window.next2d.geom;

        const workSpace = Util.$currentWorkSpace();
        const movieClip = new MovieClip();

        // cache
        const currentFrame = Util.$currentFrame;

        Util.$useIds.clear();

        let object = null;

        // 再生中は内部キャッシュを利用して高速化
        if (!Util.$timelinePlayer._$stopFlag) {

            // キャッシュがなけれなキャッシュ
            if (!this._$publishObject) {
                this._$publishObject = this.toPublish(true);
            }

            object = this._$publishObject;

        } else {

            if (this._$publishObject) {
                this._$publishObject = null;
            }

            object = this.toPublish(true);
        }

        let frame = parent_frame || 1;
        if (place && range) {
            frame = Util.$getFrame(
                place, range, currentFrame, this.totalFrame, parent_frame
            );
        }

        if (frame > this.totalFrame) {
            frame = 1;
        }

        Util.$currentFrame = frame;
        movieClip._$currentFrame = frame;

        const controller = object.controller[frame];
        if (!controller) {
            return movieClip;
        }

        // 描画対象外のIDをセット
        const characterId = Util.$activeCharacterIds.length
            ? Util.$activeCharacterIds[Util.$activeCharacterIds.length - 1]
            : -1;

        const placeMap = object.placeMap[frame];
        for (let idx = 0; controller.length > idx; ++idx) {

            const tag = object.dictionary[controller[idx]];

            const instance = workSpace.getLibrary(tag.characterId);

            const place = object.placeObjects[placeMap[idx]];
            if (!place.loop) {
                place.loop = Util.$getDefaultLoopConfig();
            }

            let displayObject = null;
            switch (instance.type) {

                case InstanceType.MOVIE_CLIP:
                    {
                        if (!instance._$layers.size) {
                            continue;
                        }

                        const layers = Array.from(
                            instance._$layers.values()
                        ).reverse();

                        let childRange = null;
                        let depth = -1;
                        for (let i = 0; i < layers.length; ++i) {

                            depth++;

                            if (depth !== idx) {
                                continue;
                            }

                            const layer = layers[i];
                            const activeCharacters = layer.getActiveCharacter(frame);
                            if (activeCharacters.length > 1) {
                                // 昇順
                                activeCharacters.sort((a, b) =>
                                {
                                    const aDepth = a.getPlace(frame).depth;
                                    const bDepth = b.getPlace(frame).depth;
                                    switch (true) {

                                        case aDepth > bDepth:
                                            return 1;

                                        case aDepth < bDepth:
                                            return -1;

                                        default:
                                            return 0;

                                    }
                                });
                            }

                            if (activeCharacters.length) {
                                childRange = activeCharacters[0].getRange(frame);
                            }

                        }

                        if (place) {
                            place.frame = frame;

                            if (place.loop.type === LoopController.DEFAULT) {
                                childRange = range;
                            }
                        }

                        displayObject = instance
                            .createInstance(place, childRange, frame);
                    }
                    break;

                case InstanceType.SHAPE:
                    displayObject = instance.createInstance();
                    displayObject._$bitmapId = instance._$bitmapId;
                    break;

                default:
                    displayObject = instance.createInstance();
                    break;

            }

            if (characterId > -1 && tag.id === characterId) {
                displayObject.visible = false;
            }

            // matrix
            displayObject.transform.matrix = new Matrix(
                place.matrix[0], place.matrix[1],
                place.matrix[2], place.matrix[3],
                place.matrix[4], place.matrix[5]
            );

            // colorTransform
            displayObject.transform.colorTransform = new ColorTransform(
                place.colorTransform[0], place.colorTransform[1],
                place.colorTransform[2], place.colorTransform[3],
                place.colorTransform[4], place.colorTransform[5],
                place.colorTransform[6], place.colorTransform[7]
            );

            // blendMode
            displayObject.blendMode = place.blendMode;

            // filters
            const filters = [];
            for (let idx = 0; idx < place.surfaceFilterList.length; ++idx) {

                const filterTag = place.surfaceFilterList[idx];
                const filterClass = window.next2d.filters[filterTag.class];

                filters.push(
                    new (filterClass.bind.apply(filterClass, filterTag.params))()
                );
            }
            displayObject.filters = filters;

            // tag data
            displayObject._$placeId     = idx;
            displayObject._$clipDepth   = tag.clipDepth;

            // player use cache
            displayObject._$loaderInfo  = { "_$id": 0 };
            displayObject._$characterId = tag.characterId;

            // added
            movieClip.addChild(displayObject);
        }

        // reset
        Util.$currentFrame = currentFrame;

        return movieClip;
    }
}

/**
 * ベクターデータを管理するクラス、Next2DのShapeクラスとして出力されます。
 * The output is as a Next2D Shape class, a class that manages vector data.
 *
 * @class
 * @extends {Instance}
 * @memberOf instance
 */
class Shape extends Instance
{
    /**
     * @param {object} object
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        super(object);

        this._$bitmapId = 0;
        this._$bounds   = null;
        this._$grid     = null;
        this._$inBitmap = false;
        this._$recodes  = [];

        if (object.inBitmap) {
            this.inBitmap = object.inBitmap;
        }

        if (object.recodes) {
            this.recodes = object.recodes;
        }

        if (object.bounds) {
            this.bounds = object.bounds;
        }

        if (object.bitmapId) {
            this.bitmapId = object.bitmapId;
        }

        if (object.grid) {
            this.grid = object.grid;
        }
    }

    /**
     * @description Shapeクラスを複製
     *              Duplicate Shape class
     *
     * @return {MovieClip}
     * @method
     * @public
     */
    clone ()
    {
        return new Shape(JSON.parse(JSON.stringify(this.toObject())));
    }

    /**
     * @description このアイテムが設定されたDisplayObjectが選択された時
     *              内部情報をコントローラーに表示する
     *              When a DisplayObject with this item set is selected,
     *              internal information is displayed on the controller.
     *
     * @param  {object} place
     * @param  {string} [name=""]
     * @return {void}
     * @method
     * @public
     */
    showController(place, name = "")
    {
        super.showController(place, name);

        // 9スライスの値を初期化
        document
            .getElementById("nine-slice-setting-x")
            .value = "0";

        document
            .getElementById("nine-slice-setting-y")
            .value = "0";

        document
            .getElementById("nine-slice-setting-w")
            .value = "0";

        document
            .getElementById("nine-slice-setting-h")
            .value = "0";

        // Shapeに必要なコントローラーを表示する
        Util.$controller.showObjectSetting([
            "nine-slice-setting"
        ]);

        // Shapeに不要なコントローラーを非表示にする
        Util.$controller.hideObjectSetting([
            "text-setting",
            "loop-setting",
            "video-setting",
            "fill-color-setting"
        ]);
    }

    /**
     * @description タップした範囲のShapeのカラーをコントローラーに表示
     *              Display the color of the shape in the tapped area on the controller
     *
     * @param {object} place
     * @param {MouseEvent} event
     * @method
     * @public
     */
    showShapeColor (place, event)
    {
        // マウスのタッチポイントがShapeの描画範囲か判定する
        this.setHitColor(event.offsetX, event.offsetY, place.matrix);

        // 9スライスの設定があれば値をセット
        const grid = this._$grid;
        if (grid && grid.x && grid.y) {

            document
                .getElementById("nine-slice-setting-x")
                .value = `${grid.x}`;

            document
                .getElementById("nine-slice-setting-y")
                .value = `${grid.y}`;

            document
                .getElementById("nine-slice-setting-w")
                .value = `${grid.w}`;

            document
                .getElementById("nine-slice-setting-h")
                .value = `${grid.h}`;

            Util
                .$gridController
                .show()
                .relocation();
        }

        // マウスポイントがShapeの描画範囲にヒットしていれば
        // 必要なコントローラーを表示して値をセットする
        if (Util.$hitColor) {
            Util.$controller.showObjectSetting([
                "fill-color-setting",
                "nine-slice-setting"
            ]);
        }
    }

    /**
     * @description 表示領域(バウンディングボックス)のObjectを返す
     *              Returns the Object of the display area (bounding box)
     *
     * @param  {array} [matrix=null]
     * @return {object}
     * @method
     * @public
     */
    getBounds (matrix = null)
    {
        return matrix
            ? Util.$boundsMatrix(this._$bounds, matrix)
            : this._$bounds;
    }

    /**
     * @description SWFのShapeで画像が使われているかの判定
     *              Determining if an image is used in a SWF Shape
     *
     * @member {boolean}
     * @default false
     * @public
     */
    get inBitmap ()
    {
        return this._$inBitmap;
    }
    set inBitmap (in_bitmap)
    {
        this._$inBitmap = !!in_bitmap;
    }

    /**
     * @description Shapeの幅を返す
     *              Return image width
     *
     * @member {number}
     * @readonly
     * @public
     */
    get width ()
    {
        return Math.abs(this._$bounds.xMax - this._$bounds.xMin);
    }

    /**
     * @description Shapeの高さを返す
     *              Return image width
     *
     * @member {number}
     * @readonly
     * @public
     */
    get height ()
    {
        return Math.abs(this._$bounds.yMax - this._$bounds.yMin);
    }

    /**
     * @description シンボルを指定した時の継承先を返す
     *              Returns the inheritance destination when a symbol is specified.
     *
     * @member   {string}
     * @readonly
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.display.Shape.namespace;
    }

    /**
     * @description Shapeの描画のポイント情報を配列で返す
     *              Returns an array of shape drawing point information
     *
     * @member {array}
     * @public
     */
    get recodes ()
    {
        if (!this._$inBitmap) {
            return this._$recodes;
        }

        const recodes = [];
        const { BitmapData } = window.next2d.display;
        for (let idx = 0; this._$recodes.length > idx; ++idx) {

            const value = this._$recodes[idx];
            recodes[idx] = value;

            if (typeof value !== "object") {
                continue;
            }

            if (value.namespace !== BitmapData.namespace) {
                continue;
            }

            recodes[idx] = {
                "buffer": Array.from(value._$buffer),
                "width": value.width,
                "height": value.height
            };
        }

        return recodes;
    }
    set recodes (recodes)
    {
        this._$recodes = recodes;
        if (this._$inBitmap) {

            const { BitmapData } = window.next2d.display;
            for (let idx = 0; this._$recodes.length > idx; ++idx) {

                const value = this._$recodes[idx];

                if (typeof value !== "object") {
                    continue;
                }

                if (value.namespace === BitmapData.namespace) {
                    continue;
                }

                if (!value.buffer) {
                    continue;
                }

                const bitmapData = new BitmapData(
                    value.width, value.height, true, 0
                );
                bitmapData._$buffer = new Uint8Array(value.buffer);

                this._$recodes[idx] = bitmapData;
            }
        }
    }

    /**
     * @description 表示領域(バウンディングボックス)のObjectを返す
     *              Returns the Object of the display area (bounding box)
     *
     * @member {object}
     * @default null
     * @public
     */
    get bounds ()
    {
        return this._$bounds;
    }
    set bounds (bounds)
    {
        this._$bounds = bounds;
    }

    /**
     * @description 画像の色設定で画像がセットされた際の画像ID
     *              Image ID when the image is set in the image color settings
     *
     * @member {number}
     * @default 0
     * @public
     */
    get bitmapId ()
    {
        return this._$bitmapId;
    }
    set bitmapId (bitmap_id)
    {
        this._$bitmapId = bitmap_id | 0;
    }

    /**
     * @description 9sliceの4点の座標情報
     *              Coordinate information for 4 points of 9slice
     *
     * @member {object}
     * @default null
     * @public
     */
    get grid ()
    {
        return this._$grid;
    }
    set grid (grid)
    {
        this._$grid = grid;
    }

    /**
     * @description 描画パスのxyポインターを生成
     *              Generate xy pointer for drawing path
     *
     * @param  {array}  matrix
     * @param  {number} layer_id
     * @param  {number} character_id
     * @return {void}
     * @method
     * @public
     */
    createPointer (matrix, layer_id, character_id)
    {
        Util.$clearShapePointer();

        const element = document.getElementById("stage-area");

        let syncId = 2;
        const { Graphics } = window.next2d.display;
        for (let idx = 0; idx < this._$recodes.length; ) {

            switch (this._$recodes[idx++]) {

                case Graphics.MOVE_TO:
                    syncId = idx;
                    idx += 2;
                    break;

                case Graphics.LINE_TO:

                    this.addPointer(
                        layer_id,
                        character_id,
                        idx,
                        this._$recodes[idx++],
                        this._$recodes[idx++],
                        matrix,
                        Graphics.LINE_TO
                    );

                    this._$adjustmentPointer(idx, matrix, layer_id, character_id, syncId);

                    break;

                case Graphics.CUBIC:

                    for (let jdx = 0; 2 > jdx; ++jdx) {
                        this.addPointer(
                            layer_id,
                            character_id,
                            idx,
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            matrix,
                            Graphics.CUBIC,
                            true
                        );
                    }

                    this.addPointer(
                        layer_id,
                        character_id,
                        idx,
                        this._$recodes[idx++],
                        this._$recodes[idx++],
                        matrix,
                        Graphics.CUBIC,
                        false
                    );

                    this._$adjustmentPointer(idx, matrix, layer_id, character_id, syncId);

                    break;

                case Graphics.CURVE_TO:

                    this.addPointer(
                        layer_id,
                        character_id,
                        idx,
                        this._$recodes[idx++],
                        this._$recodes[idx++],
                        matrix,
                        Graphics.CURVE_TO,
                        true
                    );

                    this.addPointer(
                        layer_id,
                        character_id,
                        idx,
                        this._$recodes[idx++],
                        this._$recodes[idx++],
                        matrix,
                        Graphics.CURVE_TO
                    );

                    this._$adjustmentPointer(idx, matrix, layer_id, character_id, syncId);

                    break;

                case Graphics.FILL_STYLE:
                    idx += 4;
                    break;

                case Graphics.STROKE_STYLE:
                    idx += 8;
                    break;

                case Graphics.GRADIENT_FILL:
                    idx += 6;
                    break;

                case Graphics.GRADIENT_STROKE:
                    idx += 10;
                    break;

                case Graphics.BEGIN_PATH:
                case Graphics.END_FILL:
                case Graphics.END_STROKE:
                    break;

                default:
                    break;

            }

        }

        Util.$addModalEvent(element);
    }

    /**
     * @description 始点と終点が重なるポインターは調整
     *              Pointers where the start and end points overlap are adjusted
     *
     * @param  {number} index
     * @param  {array}  matrix
     * @param  {number} layer_id
     * @param  {number} character_id
     * @param  {number} sync_id
     * @return {void}
     * @method
     * @private
     */
    _$adjustmentPointer (index, matrix, layer_id, character_id, sync_id)
    {
        const { Graphics } = window.next2d.display;
        switch (this._$recodes[index]) {

            case Graphics.MOVE_TO:
            case Graphics.FILL_STYLE:
            case Graphics.GRADIENT_FILL:
                {
                    const children = document
                        .getElementById("stage-area")
                        .children;

                    const node = children[children.length - 1];
                    node.dataset.syncId = `${sync_id}`;
                }
                break;

            case Graphics.STROKE_STYLE:
            case Graphics.GRADIENT_STROKE:
                this.addPointer(
                    layer_id,
                    character_id,
                    5,
                    this._$recodes[5],
                    this._$recodes[6],
                    matrix,
                    Graphics.MOVE_TO
                );
                break;

            default:
                break;

        }
    }

    /**
     * @description 指定のxy座標にパスのelementを追加
     *              Add a path element at the specified xy-coordinates
     *
     * @param  {number}  layer_id
     * @param  {number}  character_id
     * @param  {number}  index
     * @param  {number}  x
     * @param  {number}  y
     * @param  {array}   matrix
     * @param  {number}  type
     * @param  {boolean} [curve=false]
     * @return {void}
     * @method
     * @public
     */
    addPointer (
        layer_id, character_id, index, x, y, matrix, type, curve = false
    ) {

        const stageArea = document
            .getElementById("stage-area");

        const div = document.createElement("div");

        div.classList.add("transform");

        // dataset
        div.dataset.shapePointer = "true";
        div.dataset.layerId      = `${layer_id}`;
        div.dataset.characterId  = `${character_id}`;
        div.dataset.index        = `${index}`;
        div.dataset.libraryId    = `${this.id}`;
        div.dataset.curve        = `${curve}`;
        div.dataset.type         = `${type}`;
        div.dataset.position     = `${stageArea.children.length}`;

        // css
        const tx = x * matrix[0] + y * matrix[2] + matrix[4];
        const ty = x * matrix[1] + y * matrix[3] + matrix[5];

        div.style.left = `${tx * Util.$zoomScale + Util.$offsetLeft - 3}px`;
        div.style.top  = `${ty * Util.$zoomScale + Util.$offsetTop  - 3}px`;

        if (curve) {
            div.style.borderRadius = "5px";
        } else {
            div.dataset.detail = "{{ダブルクリックでカーブポイントが追加されます}}";
        }

        div.addEventListener("mousedown", (event) =>
        {
            if (event.button) {
                return ;
            }

            // 親のイベントを中止する
            event.stopPropagation();

            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                event.shapePointer = true;
                activeTool.dispatchEvent(
                    EventType.MOUSE_DOWN,
                    event
                );
            }
        });

        div.addEventListener("dblclick", (event) =>
        {
            // 親のイベントを中止する
            event.stopPropagation();

            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                event.shapePointer = true;
                event.matrix       = matrix;
                activeTool.dispatchEvent(
                    EventType.DBL_CLICK,
                    event
                );
            }
        });

        stageArea.appendChild(div);
    }

    /**
     * @description リサイズやパスの座標変更時にバウンディングボックスの座標を再計算
     *              Recalculate bounding box coordinates when resizing or changing path coordinates
     *
     * @param  {number} [stroke=0]
     * @return {object}
     * @method
     * @public
     */
    reloadBounds (stroke = 0)
    {
        const { Graphics, Shape } = window.next2d.display;
        const shape = new Shape();

        if (stroke) {
            shape
                .graphics
                .lineStyle(stroke);
        } else {
            shape
                .graphics
                .beginFill();
        }

        for (let idx = 0; idx < this._$recodes.length; ) {

            switch (this._$recodes[idx++]) {

                case Graphics.MOVE_TO:
                    shape
                        .graphics
                        .moveTo(
                            this._$recodes[idx++],
                            this._$recodes[idx++]
                        );
                    break;

                case Graphics.LINE_TO:
                    shape
                        .graphics
                        .lineTo(
                            this._$recodes[idx++],
                            this._$recodes[idx++]
                        );
                    break;

                case Graphics.CUBIC:
                    shape
                        .graphics
                        .cubicCurveTo(
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++]
                        );
                    break;

                case Graphics.CURVE_TO:
                    shape
                        .graphics
                        .curveTo(
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++],
                            this._$recodes[idx++]
                        );
                    break;

                case Graphics.FILL_STYLE:
                    idx += 4;
                    break;

                case Graphics.STROKE_STYLE:
                    idx += 8;
                    break;

                case Graphics.GRADIENT_FILL:
                    {
                        const { Matrix } = window.next2d.geom;
                        const matrix = new Matrix();
                        const xScale = this.width  / 2 / 819.2;
                        const yScale = this.height / 2 / 819.2;
                        matrix.scale(xScale, yScale);
                        matrix.translate(
                            this.width  / 2 + shape.graphics._$xMin,
                            this.height / 2 + shape.graphics._$yMin
                        );

                        this._$recodes[idx + 2] = Array.from(matrix._$matrix);
                        idx += 6;
                    }
                    break;

                case Graphics.GRADIENT_STROKE:
                    {
                        const { Matrix } = window.next2d.geom;
                        const matrix = new Matrix();
                        const xScale = this.width  / 2 / 819.2;
                        const yScale = this.height / 2 / 819.2;
                        matrix.scale(xScale, yScale);
                        matrix.translate(
                            this.width  / 2 + shape.graphics._$xMin,
                            this.height / 2 + shape.graphics._$yMin
                        );

                        this._$recodes[idx + 6] = Array.from(matrix._$matrix);
                        idx += 10;
                    }
                    break;

                case Graphics.BEGIN_PATH:
                case Graphics.END_FILL:
                case Graphics.END_STROKE:
                    break;

                default:
                    break;

            }

        }

        return {
            "xMin": shape.graphics._$xMin,
            "xMax": shape.graphics._$xMax,
            "yMin": shape.graphics._$yMin,
            "yMax": shape.graphics._$yMax
        };
    }

    /**
     * @description 引数のShapeオブジェクトにこのオブジェクトのパス情報をコピーする
     *              Copy the path information of this object to the argument Shape object
     *
     * @param  {Shape} shape
     * @return {Shape}
     * @method
     * @public
     */
    copyFrom (shape)
    {
        shape._$recodes  = this._$recodes.slice();
        shape._$bounds   = {
            "xMin": this._$bounds.xMin,
            "xMax": this._$bounds.xMax,
            "yMin": this._$bounds.yMin,
            "yMax": this._$bounds.yMax
        };
        shape._$bitmapId = this._$bitmapId;

        return shape;
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "id":       this.id,
            "name":     this.name,
            "type":     this.type,
            "symbol":   this.symbol,
            "folderId": this.folderId,
            "bitmapId": this.bitmapId,
            "grid":     this.grid,
            "inBitmap": this.inBitmap,
            "recodes":  this.recodes,
            "bounds":   this.bounds
        };
    }

    /**
     * @description 書き出し用のObjectを返す
     *              Returns an Object for export
     *
     * @return {object}
     * @method
     * @public
     */
    toPublish ()
    {
        if (this._$bitmapId) {
            Util.$useIds.set(this._$bitmapId, true);
        }

        return {
            "symbol":   this.symbol,
            "extends":  this.defaultSymbol,
            "bitmapId": this.bitmapId,
            "grid":     this.grid,
            "inBitmap": this.inBitmap,
            "recodes":  this.recodes,
            "bounds": {
                "xMin": this._$bounds.xMin,
                "xMax": this._$bounds.xMax,
                "yMin": this._$bounds.yMin,
                "yMax": this._$bounds.yMax
            }
        };
    }

    /**
     * @description Shapeの色設定の変更関数
     *              Function to change the color settings of a Shape
     *
     * @param  {string} style
     * @return {void}
     * @method
     * @public
     */
    changeStyle (style)
    {
        const { Graphics, GradientType } = window.next2d.display;

        const index = Util.$hitColor.index;
        const currentStyle = Util.$hitColor.style;
        switch (currentStyle) {

            case Graphics.BITMAP_FILL:
            case Graphics.FILL_STYLE:
                {
                    const element = document
                        .getElementById("fill-color-type-select");

                    switch (element.value) {

                        case GradientType.LINEAR:
                        case GradientType.RADIAL:
                            {
                                const colorValue = document
                                    .getElementById("fill-color-value")
                                    .value;

                                const color = Util.$intToRGB(
                                    `0x${colorValue.slice(1)}` | 0
                                );

                                const alpha = (document
                                    .getElementById("fill-alpha-value")
                                    .value | 0) / 100 * 255;

                                this.changeGradient(
                                    index, style, Graphics.GRADIENT_FILL,
                                    6, color, alpha
                                );
                            }
                            break;

                        default:
                            break;

                    }
                }
                break;

            case Graphics.GRADIENT_FILL:
                {
                    const element = document
                        .getElementById("fill-color-type-select");

                    const stops = this._$recodes[index + 1];
                    const color = stops.pop();
                    switch (element.value) {

                        case "bitmap":
                        case "rgba":
                            this._$recodes.splice(index - 1, 12,
                                Graphics.FILL_STYLE,
                                color.R, color.G,
                                color.B, color.A,
                                Graphics.END_FILL
                            );

                            Util.$hitColor = {
                                "index": index,
                                "style": Graphics.FILL_STYLE,
                                "shape": this
                            };
                            break;

                        default:
                            this.changeGradient(
                                index, style, Graphics.GRADIENT_FILL,
                                12, color, color.A
                            );
                            break;

                    }
                }
                break;

            case Graphics.STROKE_STYLE:
                {
                    const element = document
                        .getElementById("fill-color-type-select");

                    switch (element.value) {

                        case GradientType.LINEAR:
                        case GradientType.RADIAL:
                            {
                                const colorValue = document
                                    .getElementById("fill-color-value")
                                    .value;

                                const color = Util.$intToRGB(
                                    `0x${colorValue.slice(1)}` | 0
                                );

                                const alpha = (document
                                    .getElementById("fill-alpha-value")
                                    .value | 0) / 100 * 255;

                                this.changeGradient(
                                    index, style, Graphics.GRADIENT_STROKE,
                                    5, color, alpha
                                );
                            }
                            break;

                        default:
                            break;

                    }
                }
                break;

            case Graphics.GRADIENT_STROKE:
                {
                    const element = document
                        .getElementById("fill-color-type-select");

                    const stops      = this._$recodes[index + 5];
                    const color      = stops.pop();
                    const width      = this._$recodes[index];
                    const caps       = this._$recodes[index + 1];
                    const joints     = this._$recodes[index + 2];
                    const miterLimit = this._$recodes[index + 3];
                    switch (element.value) {

                        case "bitmap":
                        case "rgba":
                            this._$recodes.splice(index - 1, 11,
                                Graphics.STROKE_STYLE,
                                width, caps,
                                joints, miterLimit,
                                color.R, color.G,
                                color.B, color.A,
                                Graphics.END_STROKE
                            );

                            Util.$hitColor = {
                                "index": index,
                                "width": width,
                                "style": Graphics.STROKE_STYLE,
                                "shape": this
                            };
                            break;

                        default:
                            this.changeGradient(
                                index, style, Graphics.GRADIENT_STROKE,
                                6, color, color.A
                            );
                            break;

                    }
                }
                break;

        }

        this.cacheClear();

        const frame = Util.$timelineFrame.currentFrame;

        Util.$currentWorkSpace().scene.changeFrame(frame);
    }

    /**
     * @description 色設定をグラデーションへ変更
     *              Change color setting to gradient
     *
     * @param  {number} index
     * @param  {string} style
     * @param  {number} graphics_type
     * @param  {number} delete_number
     * @param  {object} color
     * @param  {number} alpha
     * @return {void}
     * @method
     * @public
     */
    changeGradient (index, style, graphics_type, delete_number, color, alpha)
    {
        const { Graphics, SpreadMethod, InterpolationMethod } = window.next2d.display;
        const { Matrix } = window.next2d.geom;

        const matrix = new Matrix();
        const xScale = this.width  / 2 / 819.2;
        const yScale = this.height / 2 / 819.2;
        matrix.scale(xScale, yScale);
        matrix.translate(
            this.width  / 2 + this._$bounds.xMin,
            this.height / 2 + this._$bounds.yMin
        );

        const ratios = [{
            "ratio": 0,
            "R": 255,
            "G": 255,
            "B": 255,
            "A": 255
        }, {
            "ratio": 1,
            "R": color.R,
            "G": color.G,
            "B": color.B,
            "A": alpha
        }];

        Util.$hitColor = {
            "index"  : index,
            "style"  : graphics_type,
            "type"   : style,
            "ratios" : ratios,
            "shape"  : this
        };

        if (Graphics.GRADIENT_STROKE === graphics_type) {

            this._$recodes[index - 1] = Graphics.GRADIENT_STROKE;

            this._$recodes.splice(index + 4, delete_number,
                style, ratios,
                Array.from(matrix._$matrix),
                SpreadMethod.PAD,
                InterpolationMethod.RGB,
                0
            );

            Util.$hitColor.width = this._$recodes[index];

        } else {

            this._$recodes.splice(index - 1, delete_number,
                graphics_type, style, ratios,
                Array.from(matrix._$matrix),
                SpreadMethod.PAD,
                InterpolationMethod.RGB,
                0
            );

        }

        Util
            .$shapeController
            .initializeGradient();

    }

    /**
     * @description 色情報を更新
     *              Update color information
     *
     * @param  {number} [color_index=-1]
     * @return {void}
     * @method
     * @public
     */
    changeColor (color_index = -1)
    {
        const { Graphics } = window.next2d.display;

        const index = Util.$hitColor.index;
        switch (Util.$hitColor.style) {

            case Graphics.BITMAP_FILL:
                break;

            case Graphics.BITMAP_STROKE:
                {
                    const width = Util.$clamp(document
                        .getElementById("fill-stroke-width-value")
                        .value | 0, 1, 255);

                    if (this._$recodes[index] !== width) {

                        Util.$hitColor.width  = width;
                        this._$recodes[index] = width;

                        const bounds = this.reloadBounds(width);
                        this._$bounds.xMin = bounds.xMin;
                        this._$bounds.xMax = bounds.xMax;
                        this._$bounds.yMin = bounds.yMin;
                        this._$bounds.yMax = bounds.yMax;

                        this.cacheClear();
                    }
                }
                break;

            case Graphics.FILL_STYLE:
                {
                    const colorValue = document
                        .getElementById("fill-color-value")
                        .value;

                    const color = Util.$intToRGB(
                        `0x${colorValue.slice(1)}` | 0
                    );

                    this._$recodes[index    ] = color.R;
                    this._$recodes[index + 1] = color.G;
                    this._$recodes[index + 2] = color.B;
                    this._$recodes[index + 3] = Util.$clamp((document
                        .getElementById("fill-alpha-value")
                        .value | 0) / 100 * 255, 0, 255);
                }
                break;

            case Graphics.GRADIENT_FILL:
                {
                    const colors = this._$recodes[index + 1];

                    const colorIndex = color_index > -1
                        ? color_index
                        : colors.length - 1;

                    const object = colors[colorIndex];

                    const colorValue = document
                        .getElementById("fill-color-value")
                        .value;

                    const color = Util.$intToRGB(
                        `0x${colorValue.slice(1)}` | 0
                    );

                    object.R = color.R;
                    object.G = color.G;
                    object.B = color.B;
                    object.A = Util.$clamp((document
                        .getElementById("fill-alpha-value")
                        .value | 0) / 100 * 255, 0, 255);
                }

                break;

            case Graphics.STROKE_STYLE:
                {
                    const colorValue = document
                        .getElementById("fill-color-value")
                        .value;

                    const color = Util.$intToRGB(
                        `0x${colorValue.slice(1)}` | 0
                    );

                    this._$recodes[index + 4] = color.R;
                    this._$recodes[index + 5] = color.G;
                    this._$recodes[index + 6] = color.B;
                    this._$recodes[index + 7] = Util.$clamp((document
                        .getElementById("fill-alpha-value")
                        .value | 0) / 100 * 255, 0, 255);

                    const width = Util.$clamp(document
                        .getElementById("fill-stroke-width-value")
                        .value | 0, 1, 255);

                    if (this._$recodes[index] !== width) {

                        Util.$hitColor.width  = width;
                        this._$recodes[index] = width;

                        const bounds = this.reloadBounds(width);
                        this._$bounds.xMin = bounds.xMin;
                        this._$bounds.xMax = bounds.xMax;
                        this._$bounds.yMin = bounds.yMin;
                        this._$bounds.yMax = bounds.yMax;

                        this.cacheClear();
                    }

                }
                break;

            case Graphics.GRADIENT_STROKE:
                {
                    const colors = this._$recodes[index + 5];

                    const colorIndex = color_index > -1
                        ? color_index
                        : colors.length - 1;

                    const object = colors[colorIndex];

                    const colorValue = document
                        .getElementById("fill-color-value")
                        .value;

                    const color = Util.$intToRGB(
                        `0x${colorValue.slice(1)}` | 0
                    );

                    object.R = color.R;
                    object.G = color.G;
                    object.B = color.B;
                    object.A = Util.$clamp((document
                        .getElementById("fill-alpha-value")
                        .value | 0) / 100 * 255, 0, 255);

                    const width = Util.$clamp(document
                        .getElementById("fill-stroke-width-value")
                        .value | 0, 1, 255);

                    if (this._$recodes[index] !== width) {

                        Util.$hitColor.width  = width;
                        this._$recodes[index] = width;

                        const bounds = this.reloadBounds(width);
                        this._$bounds.xMin = bounds.xMin;
                        this._$bounds.xMax = bounds.xMax;
                        this._$bounds.yMin = bounds.yMin;
                        this._$bounds.yMax = bounds.yMax;

                        this.cacheClear();
                    }
                }
                break;

        }

        this.cacheClear();
    }

    /**
     * @description このオブジェクトが設置されてる全てのDisplayObjectのキャッシュを削除
     *              Delete the cache of all DisplayObjects where this object is located
     *
     * @return {void}
     * @method
     * @public
     */
    cacheClear ()
    {
        const scene =  Util.$currentWorkSpace().scene;
        for (const layer of scene._$layers.values()) {

            const length = layer._$characters.length;
            for (let idx = 0; idx < length; ++idx) {

                const character = layer._$characters[idx];

                if (character.libraryId !== this.id) {
                    continue;
                }

                character.dispose();
            }
        }
    }

    /**
     * @description マウスダウンしたxy座標にShapeの色があれば、ヒットした色をコントローラーに表示する
     *              If there is a Shape color at the xy-coordinates of the mouse down, display the hit color on the controller.
     *
     * @param  {number} x
     * @param  {number} y
     * @param  {array} place_matrix
     * @return {void}
     * @method
     * @public
     */
    setHitColor (x, y, place_matrix)
    {
        if (!this._$recodes.length) {
            return ;
        }

        const { Graphics, GradientType } = window.next2d.display;
        const { Point, Matrix } = window.next2d.geom;

        const matrix = new Matrix();

        const xScale = Math.sqrt(
            place_matrix[0] * place_matrix[0]
            + place_matrix[1] * place_matrix[1]
        ) * Util.$zoomScale;

        const yScale = Math.sqrt(
            place_matrix[2] * place_matrix[2]
            + place_matrix[3] * place_matrix[3]
        ) * Util.$zoomScale;
        matrix.scale(xScale, yScale);

        const radian = Math.atan2(place_matrix[1], place_matrix[0]);
        if (radian) {
            matrix.translate(-this.width / 2, -this.height / 2);
            matrix.rotate(radian);
            matrix.translate(this.width / 2, this.height / 2);
        }

        const topLeft     = matrix.transformPoint(new Point(0, 0));
        const topRight    = matrix.transformPoint(new Point(this.width, 0));
        const bottomLeft  = matrix.transformPoint(new Point(0, this.height));
        const bottomRight = matrix.transformPoint(new Point(this.width, this.height));

        const left = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
        const top  = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
        matrix.translate(-left, -top);

        // reset
        Util.$hitColor = null;

        Util.$hitContext.lineWidth = 0;
        Util.$hitContext.beginPath();
        Util.$hitContext.setTransform(
            matrix._$matrix[0], matrix._$matrix[1],
            matrix._$matrix[2], matrix._$matrix[3],
            -this._$bounds.xMin * xScale + matrix._$matrix[4],
            -this._$bounds.yMin * yScale + matrix._$matrix[5]
        );

        const recode = this._$recodes;
        const length  = recode.length;
        for (let idx = 0; idx < length; ) {
            switch (recode[idx++]) {

                case Graphics.BEGIN_PATH:
                    Util.$hitContext.beginPath();
                    break;

                case Graphics.MOVE_TO:
                    Util.$hitContext.moveTo(recode[idx++], recode[idx++]);
                    break;

                case Graphics.LINE_TO:
                    Util.$hitContext.lineTo(recode[idx++], recode[idx++]);
                    break;

                case Graphics.CURVE_TO:
                    Util.$hitContext.quadraticCurveTo(
                        recode[idx++], recode[idx++],
                        recode[idx++], recode[idx++]
                    );
                    break;

                case Graphics.CUBIC:
                    Util.$hitContext.bezierCurveTo(
                        recode[idx++], recode[idx++],
                        recode[idx++], recode[idx++],
                        recode[idx++], recode[idx++]
                    );
                    break;

                case Graphics.FILL_STYLE:
                    if (Util.$hitContext.isPointInPath(x, y)) {
                        if (this._$bitmapId) {

                            Util.$hitColor = {
                                "index": idx,
                                "style": Graphics.BITMAP_FILL,
                                "shape": this
                            };

                            document
                                .getElementById("fill-color-type-select")[1]
                                .selected = true;

                        } else {

                            Util.$hitColor = {
                                "index": idx,
                                "style": Graphics.FILL_STYLE,
                                "shape": this
                            };

                            const R = recode[idx    ].toString(16).padStart(2, "0");
                            const G = recode[idx + 1].toString(16).padStart(2, "0");
                            const B = recode[idx + 2].toString(16).padStart(2, "0");

                            document
                                .getElementById("fill-color-type-select")[0]
                                .selected = true;

                            document
                                .getElementById("fill-color-value")
                                .value = `#${R}${G}${B}`;

                            document
                                .getElementById("fill-alpha-value")
                                .value = `${recode[idx + 3] / 255 * 100}`;

                        }

                        Util
                            .$shapeController
                            .changeFillColorTypeSelect();

                    }
                    idx += 4;
                    break;

                case Graphics.GRADIENT_FILL:
                    if (Util.$hitContext.isPointInPath(x, y)) {

                        document
                            .getElementById("fill-color-type-select")[
                                recode[idx] === GradientType.LINEAR ? 2 : 3
                            ]
                            .selected = true;

                        Util.$hitColor = {
                            "index"  : idx,
                            "style"  : Graphics.GRADIENT_FILL,
                            "type"   : recode[idx],
                            "ratios" : recode[idx + 1],
                            "shape"  : this
                        };

                        Util
                            .$shapeController
                            .changeFillColorTypeSelect();

                    }
                    idx += 6;
                    break;

                case Graphics.STROKE_STYLE:
                    Util.$hitContext.lineWidth = recode[idx] | 0;
                    if (Util.$hitContext.isPointInStroke(x, y)) {

                        if (this._$bitmapId) {

                            Util.$hitColor = {
                                "index": idx,
                                "width": Util.$hitContext.lineWidth,
                                "style": Graphics.BITMAP_STROKE,
                                "shape": this
                            };

                            document
                                .getElementById("fill-color-type-select")[1]
                                .selected = true;

                        } else {

                            Util.$hitColor = {
                                "index": idx,
                                "width": Util.$hitContext.lineWidth,
                                "style": Graphics.STROKE_STYLE,
                                "shape": this
                            };

                            const R = recode[idx + 4].toString(16).padStart(2, "0");
                            const G = recode[idx + 5].toString(16).padStart(2, "0");
                            const B = recode[idx + 6].toString(16).padStart(2, "0");

                            document
                                .getElementById("fill-color-type-select")[0]
                                .selected = true;

                            document
                                .getElementById("fill-color-value")
                                .value = `#${R}${G}${B}`;

                            document
                                .getElementById("fill-alpha-value")
                                .value = `${recode[idx + 7] / 255 * 100}`;
                        }

                        document
                            .getElementById("fill-stroke-width-value")
                            .value = `${Util.$hitContext.lineWidth}`;

                        Util
                            .$shapeController
                            .changeFillColorTypeSelect();

                    }
                    idx += 8;
                    break;

                case Graphics.GRADIENT_STROKE:
                    Util.$hitContext.lineWidth = recode[idx];
                    if (Util.$hitContext.isPointInStroke(x, y)) {

                        document
                            .getElementById("fill-color-type-select")[
                                recode[idx + 4] === GradientType.LINEAR ? 2 : 3
                            ]
                            .selected = true;

                        Util.$hitColor = {
                            "index"  : idx,
                            "width"  : recode[idx],
                            "style"  : Graphics.GRADIENT_STROKE,
                            "type"   : recode[idx + 4],
                            "ratios" : recode[idx + 5],
                            "shape"  : this
                        };

                        Util
                            .$shapeController
                            .changeFillColorTypeSelect();

                    }
                    idx += 10;
                    break;

                case Graphics.CLOSE_PATH:
                case Graphics.END_STROKE:
                case Graphics.END_FILL:
                    break;

                default:
                    break;

            }
        }
    }

    /**
     * @description Next2DのDisplayObjectを生成
     *              Generate Next2D DisplayObject
     *
     * @return {next2d.display.Shape}
     * @method
     * @public
     */
    createInstance ()
    {
        const { Shape, Graphics } = window.next2d.display;

        const shape = new Shape();

        if (this._$grid) {
            const { Rectangle } = window.next2d.geom;
            shape.scale9Grid = new Rectangle(
                this._$grid.x, this._$grid.y,
                this._$grid.w, this._$grid.h
            );
        }

        const graphics = shape.graphics;

        graphics._$maxAlpha = 1;
        graphics._$canDraw  = true;
        graphics._$xMin     = this._$bounds.xMin;
        graphics._$xMax     = this._$bounds.xMax;
        graphics._$yMin     = this._$bounds.yMin;
        graphics._$yMax     = this._$bounds.yMax;

        if (this._$bitmapId) {

            const { BitmapData } = window.next2d.display;

            const instance = Util
                .$currentWorkSpace()
                .getLibrary(this._$bitmapId);

            if (instance) {

                shape._$bitmapId = this._$bitmapId;

                // setup
                graphics._$recode = [];

                const bitmapData = new BitmapData(
                    instance.width, instance.height, true, 0
                );
                bitmapData._$buffer = instance._$buffer;

                // clone
                const recodes = this._$recodes;
                if (recodes[recodes.length - 1] === Graphics.END_FILL) {

                    const length  = recodes.length - 6;
                    for (let idx = 0; idx < length; ++idx) {
                        graphics._$recode.push(recodes[idx]);
                    }

                    // add Bitmap Fill
                    graphics._$recode.push(
                        Graphics.BITMAP_FILL,
                        bitmapData,
                        null,
                        "repeat",
                        false
                    );

                } else {

                    const width      = this._$recodes[recodes.length - 9];
                    const caps       = this._$recodes[recodes.length - 8];
                    const joints     = this._$recodes[recodes.length - 7];
                    const miterLimit = this._$recodes[recodes.length - 6];

                    const length  = recodes.length - 10;
                    for (let idx = 0; idx < length; ++idx) {
                        graphics._$recode.push(recodes[idx]);
                    }

                    graphics._$recode.push(
                        Graphics.BITMAP_STROKE,
                        width,
                        caps,
                        joints,
                        miterLimit,
                        bitmapData,
                        [1, 0, 0, 1, graphics._$xMin, graphics._$yMin],
                        "repeat",
                        false
                    );

                }

            } else {

                graphics._$recode = this._$recodes.slice(0);

            }

        } else {

            graphics._$recode = this._$recodes.slice(0);

        }

        return shape;
    }
}

/**
 * サウンドを管理するクラス、Next2DのSoundクラスとして出力されます。
 * The output is as Next2D's Sound class, a class that manages sound.
 *
 * @class
 * @extends {Instance}
 * @memberOf instance
 */
class Sound extends Instance
{
    /**
     * @param {object} object
     * @constructor
     * @public
     */
    constructor (object)
    {
        super(object);
        this.buffer = object.buffer;

        this._$binary    = "";
        this._$volume    = 100;
        this._$loopCount = 0;

        if ("volume" in object) {
            this.volume = object.volume;
        }

        if ("loopCount" in object) {
            this.loopCount = object.loopCount;
        }

        this._$audio = document.createElement("audio");

        this._$audio.preload  = "auto";
        this._$audio.autoplay = false;
        this._$audio.loop     = false;
        this._$audio.controls = true;

        this._$audio.src = URL.createObjectURL(new Blob(
            [new Uint8Array(this._$buffer)],
            { "type": "audio/mp3" }
        ));
        this._$audio.load();
    }

    /**
     * @description Soundクラスを複製
     *              Duplicate Video class
     *
     * @return {Sound}
     * @method
     * @public
     */
    clone ()
    {
        return new Sound(JSON.parse(JSON.stringify(this.toObject())));
    }

    /**
     * @description プレビュー画面に表示する、HTMLAudioElementを返す
     *              Returns an HTMLAudioElement to be displayed on the preview screen.
     *
     * @return {HTMLAudioElement}
     * @method
     * @public
     */
    getPreview ()
    {
        return this._$audio;
    }

    /**
     * @description シンボルを指定した時の継承先を返す
     *              Returns the inheritance destination when a symbol is specified.
     *
     * @return {string}
     * @public
     * @readonly
     */
    get defaultSymbol ()
    {
        return window.next2d.media.Sound.namespace;
    }

    /**
     * @description サウンドデータ(buffer)をバイナリデータとして利用
     *              Sound data (buffer) is used as binary data
     *
     * @member {string}
     * @default ""
     * @public
     */
    get buffer ()
    {
        if (!this._$binary) {

            const length = this._$buffer.length;

            for (let idx = 0; idx < length; ++idx) {
                this._$binary += String.fromCharCode(this._$buffer[idx]);
            }

        }

        return this._$binary;
    }
    set buffer (binary)
    {

        switch (typeof binary) {

            case "object":
                if (binary.constructor === Uint8Array) {
                    this._$buffer = binary;
                }
                break;

            case "string":
                if (!this._$binary) {
                    let length = binary.length;

                    this._$buffer = new Uint8Array(length);
                    for (let idx = 0; idx < length; ++idx) {
                        this._$buffer[idx] = binary.charCodeAt(idx) & 0xff;
                    }

                    this._$binary = binary;
                }
                break;

            default:
                break;

        }
    }

    /**
     * @description サウンドのボリューム設定
     *              Sound volume setting
     *
     * @member {number}
     * @default 100
     * @public
     */
    get volume ()
    {
        return this._$volume;
    }
    set volume (volume)
    {
        this._$volume = volume;
    }

    /**
     * @description サウンドのループ設定
     *              Sound loop settings
     *
     * @member {number}
     * @default 0
     * @public
     */
    get loopCount ()
    {
        return this._$loopCount;
    }
    set loopCount (loop_count)
    {
        this._$loopCount = loop_count;
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "id":        this.id,
            "name":      this.name,
            "type":      this.type,
            "symbol":    this.symbol,
            "folderId":  this.folderId,
            "buffer":    this.buffer,
            "volume":    this.volume,
            "loopCount": this.loopCount
        };
    }

    /**
     * @description 書き出し用のObjectを返す
     *              Returns an Object for export
     *
     * @return {object}
     * @method
     * @public
     */
    toPublish ()
    {
        return {
            "buffer": Array.from(this._$buffer),
            "audioBuffer": null,
            "init": false
        };
    }
}

/**
 * ステージを管理するクラス、Next2DのStage情報として出力されます。
 * This information is output as Stage information in Next2D, the class that manages stages.
 *
 * @class
 * @memberOf instance
 */
class Stage
{
    /**
     * @param {object} [object=null]
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        if (object) {
            this._$width   = object.width;
            this._$height  = object.height;
            this._$fps     = object.fps;
            this._$bgColor = object.bgColor;
            this._$lock    = object.lock;
        } else {
            this._$width   = Stage.STAGE_DEFAULT_WIDTH;
            this._$height  = Stage.STAGE_DEFAULT_HEIGHT;
            this._$fps     = Stage.STAGE_DEFAULT_FPS;
            this._$bgColor = "#ffffff";
            this._$lock    = false;
        }
    }

    /**
     * @description ステージのデフォルトの幅
     *              Default stage width
     *
     * @return {number}
     * @const
     * @static
     */
    static get STAGE_DEFAULT_WIDTH ()
    {
        return 550;
    }

    /**
     * @description ステージのデフォルトの高さ
     *              Default stage height
     *
     * @return {number}
     * @const
     * @static
     */
    static get STAGE_DEFAULT_HEIGHT ()
    {
        return 400;
    }

    /**
     * @description ステージのデフォルトのフレームレート
     *              Default frame rate of the stage
     *
     * @return {number}
     * @const
     * @static
     */
    static get STAGE_DEFAULT_FPS ()
    {
        return 24;
    }

    /**
     * @description 初期起動関数
     *              initial invoking function.
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // reset
        Util.$zoomScale = 1;

        const screenScale = document
            .getElementById("screen-scale");

        if (screenScale) {
            screenScale.value = "100";
        }

        // canvas
        const stage = document.getElementById("stage");
        if (stage) {
            stage.style.width           = `${this.width}px`;
            stage.style.height          = `${this.height}px`;
            stage.style.backgroundColor = this.bgColor;
        }

        const libraryPreviewArea = document
            .getElementById("library-preview-area");

        if (libraryPreviewArea) {
            libraryPreviewArea.style.backgroundColor = this.bgColor;
        }

        // stage area
        const area = document.getElementById("stage-area");
        if (area) {
            area.style.transformOrigin = "50% 50%";
            area.style.width  = `${this.width  + window.screen.width}px`;
            area.style.height = `${this.height + window.screen.height}px`;
        }

        // DOM
        const labelName = document
            .getElementById("label-name");

        if (labelName) {
            labelName.value = "";
        }

        const stageWidth = document
            .getElementById("stage-width");

        if (stageWidth) {
            stageWidth.value = this.width;
        }

        const stageHeight = document
            .getElementById("stage-height");

        if (stageHeight) {
            stageHeight.value = this.height;
        }

        const stageFps = document
            .getElementById("stage-fps");

        if (stageFps) {
            stageFps.value = this.fps;
        }

        const stageBgColor = document
            .getElementById("stage-bgColor");

        if (stageBgColor) {
            stageBgColor.value = this.bgColor;
        }

        const stageLock = document
            .getElementById("stage-lock");

        if (stageLock) {
            const element = stageLock.childNodes[1];

            element
                .setAttribute("class", this.lock ? "active" : "disable");
        }

        Util.$controller._$stageLock = this.lock;

        // set xy
        const screen = document.getElementById("screen");
        if (screen) {
            screen.scrollLeft = window.screen.width  / 2 - (screen.clientWidth  - this.width)  / 2;
            screen.scrollTop  = window.screen.height / 2 - (screen.clientHeight - this.height) / 2;
        }

        if (stage) {
            Util.$offsetLeft = stage.offsetLeft;
            Util.$offsetTop  = stage.offsetTop;
        }
    }

    /**
     * @description ステージの表示の幅
     *              Stage display width
     *
     * @member {number}
     * @default Stage.STAGE_DEFAULT_WIDTH
     * @public
     */
    get width ()
    {
        return this._$width;
    }
    set width (width)
    {
        this._$width = Util.$clamp(+width, 1, 1024 * 4);
    }

    /**
     * @description ステージの表示の高さ
     *              Stage display height
     *
     * @member {number}
     * @default Stage.STAGE_DEFAULT_HEIGHT
     * @public
     */
    get height ()
    {
        return this._$height;
    }
    set height (height)
    {
        this._$height = Util.$clamp(+height, 1, 1024 * 4);
    }

    /**
     * @description ステージの描画速度の設定
     *              Set the stage drawing speed.
     *
     * @member {number}
     * @default Stage.STAGE_DEFAULT_FPS
     * @public
     */
    get fps ()
    {
        return this._$fps;
    }
    set fps (fps)
    {
        this._$fps = Util.$clamp(fps | 0, 1, 60);
    }

    /**
     * @description ステージの背景色の設定
     *              Setting the background color of the stage
     *
     * @return {string}
     * @default "#ffffff"
     * @public
     */
    get bgColor ()
    {
        return this._$bgColor;
    }
    set bgColor (color)
    {
        this._$bgColor = `${color}`.toLowerCase();
    }

    /**
     * @description 幅と高さのサイズ変更を同時に行う設定
     *              Set to resize width and height at the same time
     *
     * @member {boolean}
     * @default false
     * @public
     */
    get lock ()
    {
        return this._$lock;
    }
    set lock (lock)
    {
        this._$lock = !!lock;
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "width": this.width,
            "height": this.height,
            "fps": this.fps,
            "bgColor": this.bgColor,
            "lock": this.lock
        };
    }
}

/**
 * テキストを管理するクラス、Next2DのTextFieldクラスとして出力されます。
 * The output is as a Next2D TextField class, a class that manages text.
 *
 * @class
 * @extends {Instance}
 * @memberOf instance
 */
class TextField extends Instance
{
    /**
     * @param {object} [object=null]
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        super(object);

        this._$text           = "";
        this._$font           = "sans-serif";
        this._$size           = 12;
        this._$align          = "left";
        this._$color          = 0;
        this._$fontType       = 0;
        this._$inputType      = "static";
        this._$leading        = 0;
        this._$letterSpacing  = 0;
        this._$leftMargin     = 0;
        this._$rightMargin    = 0;
        this._$autoSize       = 0;
        this._$multiline      = true;
        this._$wordWrap       = true;
        this._$border         = false;
        this._$scroll         = true;
        this._$cache          = null;
        this._$htmlText       = null;
        this._$thickness      = 0;
        this._$thicknessColor = 0;

        this._$bounds = {
            "xMin": 0,
            "xMax": TextField.FONT_DEFAULT_SIZE,
            "yMin": 0,
            "yMax": TextField.FONT_DEFAULT_SIZE
        };

        this._$originBounds = {
            "xMin": 0,
            "xMax": TextField.FONT_DEFAULT_SIZE,
            "yMin": 0,
            "yMax": TextField.FONT_DEFAULT_SIZE
        };

        if (object.text) {
            this.text = object.text;
        }

        if (object.font) {
            this.font = object.font;
        }

        if (object.fontType) {
            this.fontType = object.fontType;
        }

        if (object.inputType) {
            this.inputType = object.inputType;
        }

        if (object.size) {
            this.size = object.size;
        }

        if (object.align) {
            this.align = object.align;
        }

        if (object.color) {
            this.color = object.color;
        }

        if (object.leading) {
            this.leading = object.leading;
        }

        if (object.letterSpacing) {
            this.letterSpacing = object.letterSpacing;
        }

        if (object.leftMargin) {
            this.leftMargin = object.leftMargin;
        }

        if (object.rightMargin) {
            this.rightMargin = object.rightMargin;
        }

        if ("multiline" in object) {
            this.multiline = object.multiline;
        }

        if ("wordWrap" in object) {
            this.wordWrap = object.wordWrap;
        }

        if (object.autoFontSize) {
            this.autoFontSize = object.autoFontSize;
        }

        if ("scroll" in object) {
            this.scroll = object.scroll;
        }

        if (object.border) {
            this.border = object.border;
        }

        if (object.bounds) {
            this.bounds = object.bounds;
        }

        if (object.originBounds) {
            this.originBounds = object.originBounds;
        }

        if (object.autoSize) {
            this.autoSize = object.autoSize;
        }

        if (object.thickness) {
            this.thickness = object.thickness;
        }

        if (object.thicknessColor) {
            this.thicknessColor = object.thicknessColor;
        }
    }

    /**
     * @description テキストエリアのデフォルトの幅と高さのサイズ
     *              Default width and height size of text area
     *
     * @return {number}
     * @const
     * @static
     */
    static get FONT_DEFAULT_SIZE ()
    {
        return 200;
    }

    /**
     * @description TextFieldクラスを複製
     *              Duplicate TextField class
     *
     * @return {Video}
     * @method
     * @public
     */
    clone ()
    {
        return new TextField(JSON.parse(JSON.stringify(this.toObject())));
    }

    /**
     * @description このアイテムが設定されたDisplayObjectが選択された時
     *              内部情報をコントローラーに表示する
     *              When a DisplayObject with this item set is selected,
     *              internal information is displayed on the controller.
     *
     * @param  {object} place
     * @param  {string} [name=""]
     * @return {void}
     * @method
     * @public
     */
    showController(place, name = "")
    {
        super.showController(place, name);

        Util.$controller.hideObjectSetting([
            "video-setting",
            "loop-setting",
            "fill-color-setting",
            "nine-slice-setting"
        ]);

        Util.$controller.showObjectSetting([
            "text-setting"
        ]);

        const fontSelect = document
            .getElementById("font-select");

        // font
        fontSelect.children[0].selected = true;
        for (let idx = 0; idx < fontSelect.children.length; ++idx) {

            const node = fontSelect.children[idx];

            if (node.value !== this._$font) {
                continue;
            }

            node.selected = true;
            break;
        }

        const fontStyleSelect = document
            .getElementById("font-style-select");

        for (let idx = 0; idx < fontStyleSelect.children.length; ++idx) {

            const node = fontStyleSelect.children[idx];

            if ((node.value | 0) !== this._$fontType) {
                continue;
            }

            node.selected = true;
            break;
        }

        const fontAlignSelect = document
            .getElementById("font-align-select");

        for (let idx = 0; idx < fontAlignSelect.children.length; ++idx) {

            const node = fontAlignSelect.children[idx];

            if (node.value !== this._$align) {
                continue;
            }

            node.selected = true;
            break;
        }

        const fontWrapSelect = document
            .getElementById("font-wrap-select");

        switch (true) {

            case !this._$wordWrap && !this._$multiline:
                fontWrapSelect.children[0].selected = true;
                break;

            case !this._$wordWrap && this._$multiline:
                fontWrapSelect.children[1].selected = true;
                break;

            case this._$wordWrap && this._$multiline:
                fontWrapSelect.children[2].selected = true;
                break;

        }

        const fontInputSelect = document
            .getElementById("font-input-select");

        fontInputSelect.children[
            this._$inputType === "static" ? 0 : 1
        ].selected = true;

        document
            .getElementById("font-size")
            .value = `${this._$size}`;

        document
            .getElementById("font-color")
            .value = `#${this._$color.toString(16).padStart(6, "0")}`;

        document
            .getElementById("font-stroke-size")
            .value = `${this._$thickness}`;

        document
            .getElementById("font-stroke-color")
            .value = `#${this._$thicknessColor.toString(16).padStart(6, "0")}`;

        const params = [
            "font-leading",
            "font-letterSpacing",
            "font-leftMargin",
            "font-rightMargin"
        ];

        for (let idx = 0; idx < params.length; ++idx) {

            const name = params[idx];

            document
                .getElementById(name)
                .value = `${this[name.split("-")[1]]}`;

        }

        document
            .getElementById("font-auto-size-select")
            .children[this._$autoSize].selected = true;

        if (this._$border) {
            document
                .getElementById("font-border-select")
                .children[1].selected = true;
        }

        if (this._$scroll) {
            document
                .getElementById("font-scroll-select")
                .children[0].selected = true;
        }
    }

    /**
     * @description 表示領域(バウンディングボックス)のObjectを返す
     *              Returns the Object of the display area (bounding box)
     *
     * @param  {array} [matrix=null]
     * @return {object}
     * @method
     * @public
     */
    getBounds (matrix = null)
    {
        const bounds = {
            "xMin": -this._$thickness,
            "xMax": this._$bounds.xMax + this._$thickness,
            "yMin": -this._$thickness,
            "yMax": this._$bounds.yMax + 4 + this._$thickness
        };

        return matrix
            ? Util.$boundsMatrix(bounds, matrix)
            : bounds;
    }

    /**
     * @description テキストエリアに登録した文字情報
     *              Text information registered in the text area
     *
     * @member {string}
     * @default ""
     * @public
     */
    get text ()
    {
        return this._$text;
    }
    set text (text)
    {
        this._$text = `${text}`;
        this.resize();
    }

    /**
     * @description テキストのフォントサイズ設定
     *              Font size setting for text
     *
     * @member {number}
     * @default 12
     * @public
     */
    get size ()
    {
        return this._$size;
    }
    set size (size)
    {
        this._$size = size | 0;
        this.resize();
    }

    /**
     * @description テキストのフォント設定
     *              Text font settings
     *
     * @member {string}
     * @default "sans-serif"
     * @public
     */
    get font ()
    {
        return this._$font;
    }
    set font (font)
    {
        this._$font = `${font}`;
        this.resize();
    }

    /**
     * @description テキストのフォントスタイルの設定
     *              Set font style for text
     *
     * @member {number}
     * @default 0
     * @public
     */
    get fontType ()
    {
        return this._$fontType;
    }
    set fontType (font_type)
    {
        this._$fontType = font_type | 0;
        this.resize();
    }

    /**
     * @description 入力モードの設定、入力不可(static)、入力可能(input)
     *              Input mode setting, input disabled (static), input enabled (input)
     *
     * @member {string}
     * @default "static"
     * @public
     */
    get inputType ()
    {
        return this._$inputType;
    }
    set inputType (input_type)
    {
        input_type = `${input_type}`.toLowerCase();
        this._$inputType = input_type === "static" ? input_type : "input";
    }

    /**
     * @description 段落の行揃えの設定を示します。
     *              Indicates the alignment of the paragraph.
     *
     * @member {string}
     * @default "left"
     * @public
     */
    get align ()
    {
        return this._$align;
    }
    set align (align)
    {
        align = `${align}`.toLowerCase();
        switch (align) {

            case "right":
            case "center":
                this._$align = align;
                break;

            default:
                this._$align = "left";
                break;

        }
        this._$align = align;
    }

    /**
     * @description フォントの塗り色の設定
     *              Font fill color setting
     *
     * @member {number}
     * @default 0
     * @public
     */
    get color ()
    {
        return this._$color;
    }
    set color (color)
    {
        this._$color = color | 0;
    }

    /**
     * @description 行間の垂直の行送りを示す整数です。
     *              An integer representing the amount
     *              of vertical space (called leading) between lines.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get leading ()
    {
        return this._$leading;
    }
    set leading (leading)
    {
        this._$leading = leading | 0;
        this.resize();
    }

    /**
     * @description すべての文字の間に均等に配分されるスペースの量を表す数値です。
     *              A object representing the amount
     *              of space that is uniformly distributed between all characters.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get letterSpacing ()
    {
        return this._$letterSpacing;
    }
    set letterSpacing (letter_spacing)
    {
        this._$letterSpacing = letter_spacing | 0;
        this.resize();
    }

    /**
     * @description 段落の左インデントをピクセル単位で示します。
     *              The left margin of the paragraph, in pixels.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get leftMargin ()
    {
        return this._$leftMargin;
    }
    set leftMargin (left_margin)
    {
        this._$leftMargin = left_margin | 0;
        this.resize();
    }

    /**
     * @description 段落の右インデントをピクセル単位で示します。
     *              The right margin of the paragraph, in pixels.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get rightMargin ()
    {
        return this._$rightMargin;
    }
    set rightMargin (right_margin)
    {
        this._$rightMargin = right_margin | 0;
        this.resize();
    }

    /**
     * @description フィールドが複数行テキストフィールドであるかどうかを示します。
     *              Indicates whether field is a multiline text field.
     *
     * @member {boolean}
     * @default true
     * @public
     */
    get multiline ()
    {
        return this._$multiline;
    }
    set multiline (multiline)
    {
        this._$multiline = !!multiline;
        this.resize();
    }

    /**
     * @description テキストフィールドに境界線があるかどうかを指定します。
     *              Specifies whether the text field has a border.
     *
     * @member {boolean}
     * @default false
     * @public
     */
    get border ()
    {
        return this._$border;
    }
    set border (border)
    {
        this._$border = !!border;
    }

    /**
     * @description スクロール機能のon/off
     *              Scroll function on/off
     *
     * @member {boolean}
     * @default true
     * @public
     */
    get scroll ()
    {
        return this._$scroll;
    }
    set scroll (scroll)
    {
        this._$scroll = !!scroll;
    }

    /**
     * @description テキストフィールドのテキストを折り返すかどうかを示すブール値です。
     *              A Boolean value that indicates whether the text field has word wrap.
     *
     * @member {boolean}
     * @default true
     * @public
     */
    get wordWrap ()
    {
        return this._$wordWrap;
    }
    set wordWrap (word_wrap)
    {
        this._$wordWrap = !!word_wrap;
        this.resize();
    }

    /**
     * @description 表示領域(バウンディングボックス)のObjectを返す
     *              Returns the Object of the display area (bounding box)
     *
     * @member {object}
     * @public
     */
    get bounds ()
    {
        return this._$bounds;
    }
    set bounds (bounds)
    {
        this._$bounds = bounds;
    }

    /**
     * @description 登録時の表示領域(バウンディングボックス)のObjectを返す
     *              Returns the Object of the display area (bounding box) at registration
     *
     * @member {object}
     * @public
     */
    get originBounds ()
    {
        return this._$originBounds;
    }
    set originBounds (origin_bounds)
    {
        this._$originBounds = origin_bounds;
    }

    /**
     * @description テキストエリア内のスケール設定
     *              Scale settings within text area
     *
     * @member {number}
     * @default 0
     * @public
     */
    get autoSize ()
    {
        return this._$autoSize;
    }
    set autoSize (auto_size)
    {
        this._$autoSize = auto_size | 0;
        if (this._$autoSize !== 1) {
            this._$bounds.xMax = this._$originBounds.xMax;
            this._$bounds.yMax = this._$originBounds.yMax;
        }
        this.resize();
    }

    /**
     * @description テキスト外枠の幅
     *              Width of text border
     *
     * @member {number}
     * @default 0
     * @public
     */
    get thickness ()
    {
        return this._$thickness;
    }
    set thickness (thickness)
    {
        this._$thickness = thickness | 0;
        this.resize();
    }

    /**
     * @description テキスト外枠の色設定
     *              Color setting of text outer frame
     *
     * @member {number}
     * @default 0
     * @public
     */
    get thicknessColor ()
    {
        return this._$thicknessColor;
    }
    set thicknessColor (thickness_color)
    {
        this._$thicknessColor = thickness_color | 0;
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "id":             this.id,
            "name":           this.name,
            "type":           this.type,
            "symbol":         this.symbol,
            "folderId":       this.folderId,
            "text":           this.text,
            "font":           this.font,
            "fontType":       this.fontType,
            "inputType":      this.inputType,
            "size":           this.size,
            "align":          this.align,
            "color":          this.color,
            "leading":        this.leading,
            "letterSpacing":  this.letterSpacing,
            "leftMargin":     this.leftMargin,
            "rightMargin":    this.rightMargin,
            "multiline":      this.multiline,
            "wordWrap":       this.wordWrap,
            "border":         this.border,
            "autoSize":       this.autoSize,
            "scroll":         this.scroll,
            "originBounds":   this.originBounds,
            "bounds":         this.bounds,
            "thickness":      this.thickness,
            "thicknessColor": this.thicknessColor
        };
    }

    /**
     * @return {string}
     * @public
     */
    get defaultSymbol ()
    {
        return window.next2d.text.TextField.namespace;
    }

    /**
     * @description 書き出し用のObjectを返す
     *              Returns an Object for export
     *
     * @return {object}
     * @method
     * @public
     */
    toPublish ()
    {
        return {
            "symbol":         this.symbol,
            "extends":        this.defaultSymbol,
            "text":           this.text,
            "font":           this.font,
            "fontType":       this.fontType,
            "inputType":      this.inputType,
            "size":           this.size,
            "align":          this.align,
            "color":          this.color,
            "leading":        this.leading,
            "letterSpacing":  this.letterSpacing,
            "leftMargin":     this.leftMargin,
            "rightMargin":    this.rightMargin,
            "multiline":      this.multiline,
            "wordWrap":       this.wordWrap,
            "border":         this.border,
            "autoSize":       this.autoSize,
            "scroll":         this.scroll,
            "originBounds":   this.originBounds,
            "bounds":         this.bounds,
            "thickness":      this.thickness,
            "thicknessColor": this.thicknessColor
        };
    }

    /**
     * @description テキストエリアの状態変化による、表示領域を再取得
     *              Re-acquisition of display area due to change of text area status
     *
     * @return {void}
     * @method
     * @public
     */
    resize ()
    {
        const textField = this.createInstance();
        this._$bounds = {
            "xMin": textField._$bounds.xMin,
            "xMax": textField._$bounds.xMax,
            "yMin": textField._$bounds.yMin,
            "yMax": textField._$bounds.yMax
        };
    }

    /**
     * @description Next2DのDisplayObjectを生成
     *              Generate Next2D DisplayObject
     *
     * @return {next2d.display.Shape}
     * @method
     * @public
     */
    createInstance ()
    {
        const { TextField } = window.next2d.text;
        const textField = new TextField();

        textField._$bounds = {
            "xMin": this._$originBounds.xMin,
            "xMax": this._$originBounds.xMax,
            "yMin": this._$originBounds.yMin,
            "yMax": this._$originBounds.yMax
        };
        textField._$originBounds = {
            "xMin": this._$originBounds.xMin,
            "xMax": this._$originBounds.xMax,
            "yMin": this._$originBounds.yMin,
            "yMax": this._$originBounds.yMax
        };

        const textFormat         = textField.defaultTextFormat;
        textFormat.font          = this._$font;
        textFormat.size          = this._$size;
        textFormat.align         = this._$align;
        textFormat.color         = this._$color;
        textFormat.leading       = this._$leading;
        textFormat.letterSpacing = this._$letterSpacing;
        textFormat.leftMargin    = this._$leftMargin;
        textFormat.rightMargin   = this._$rightMargin;

        switch (this._$fontType) {

            case 1:
                textFormat.bold = true;
                break;

            case 2:
                textFormat.italic = true;
                break;

            case 3:
                textFormat.bold   = true;
                textFormat.italic = true;
                break;

        }

        switch (this._$autoSize) {

            case 1:
                textField.autoSize = this._$align;
                break;

            case 2:
                textField.autoFontSize = true;
                break;

        }

        textField.multiline      = this._$multiline;
        textField.wordWrap       = this._$wordWrap;
        textField.border         = this._$border;
        textField.scroll         = this._$scroll;
        textField.thickness      = this._$thickness;
        textField.thicknessColor = this._$thicknessColor;
        textField.text           = this._$text;

        return textField;
    }

    /**
     * @description Next2DのBitmapDataクラスを経由してImageクラスを生成
     *              Generate Image class via Next2D BitmapData class
     *
     * @param  {HTMLCanvasElement} canvas
     * @param  {number}  width
     * @param  {number}  height
     * @param  {object}  place
     * @param  {object}  [range = null]
     * @param  {number}  [static_frame = 0]
     * @param  {boolean} [preview = false]
     * @return {CanvasRenderingContext2D}
     * @method
     * @public
     */
    draw (
        canvas, width, height, place,
        range = null, static_frame = 0, preview = false
    ) {

        const context = super.draw(
            canvas, width, height, place,
            range, static_frame, preview
        );

        context.canvas._$tx -= this._$thickness;
        context.canvas._$ty -= this._$thickness;

        let resizeX = 0;
        switch (this._$autoSize) {

            case 0:
                if (this._$align === "right") {
                    resizeX = -4;
                }
                break;

            case 1:
                switch (this._$align) {

                    case "center":
                        resizeX = (this._$bounds.xMax - this._$originBounds.xMax) / 2;
                        if (resizeX) {
                            resizeX -= 2;
                        }
                        break;

                    case "right":
                        resizeX = this._$originBounds.xMax - this._$bounds.xMax;
                        if (resizeX) {
                            resizeX += 2;
                            resizeX *= -1;
                        }
                        break;

                }
                break;

        }

        if (this._$autoSize === 1) {
            context.canvas._$tx -= resizeX;
        }

        return context;
    }
}

/**
 * 動画を管理するクラス、Next2DのVideoクラスとして出力されます。
 * The output is as the Video class of Next2D, a class that manages video.
 *
 * @class
 * @extends {Instance}
 * @memberOf instance
 */
class Video extends Instance
{
    /**
     * @param {object} object
     * @constructor
     * @public
     */
    constructor (object)
    {
        super(object);

        this._$volume   = 100;
        this._$loop     = false;
        this._$autoPlay = true;
        this._$binary   = "";
        this._$queue    = [];
        this._$loaded   = false;

        this.buffer   = object.buffer;
        this.width    = object.width | 0;
        this.height   = object.height | 0;

        if ("volume" in object) {
            this.volume = object.volume;
        }

        if ("loop" in object) {
            this.loop = object.loop;
        }

        if ("autoPlay" in object) {
            this.autoPlay = object.autoPlay;
        }

        this._$video = document.createElement("video");
        this._$video.crossOrigin = "anonymous";
        this._$video.type        = "video/mp4";
        this._$video.muted       = true;
        this._$video.autoplay    = false;

        const start = (event) =>
        {
            event.target.removeEventListener("canplaythrough", start);

            event.target.play();
            event.target.currentTime = 1;
            event.target.pause();

            this._$loaded = true;
            setTimeout(() => { this.delayImage() }, 150);

        };
        this._$video.addEventListener("canplaythrough", start);

        this._$video.src = URL.createObjectURL(new Blob(
            [new Uint8Array(this._$buffer)],
            { "type": "video/mp4" }
        ));
        this._$video.load();
    }

    /**
     * @description Videoクラスを複製
     *              Duplicate Video class
     *
     * @return {Video}
     * @method
     * @public
     */
    clone ()
    {
        return new Video(JSON.parse(JSON.stringify(this.toObject())));
    }

    /**
     * @description このアイテムが設定されたDisplayObjectが選択された時
     *              内部情報をコントローラーに表示する
     *              When a DisplayObject with this item set is selected,
     *              internal information is displayed on the controller.
     *
     * @param  {object} place
     * @param  {string} [name=""]
     * @return {void}
     * @method
     * @public
     */
    showController(place, name = "")
    {
        super.showController(place, name);

        Util.$controller.hideObjectSetting([
            "text-setting",
            "loop-setting",
            "fill-color-setting",
            "nine-slice-setting"
        ]);

        Util.$controller.showObjectSetting([
            "video-setting"
        ]);

        document
            .getElementById("video-volume")
            .value = this.volume;

        document
            .getElementById("video-loop-select")
            .children[this.loop ? 1 : 0]
            .selected = true;

        document
            .getElementById("video-auto-select")
            .children[this.autoPlay ? 1 : 0]
            .selected = true;
    }

    /**
     * @description プレビュー画面に表示する、HTMLVideoElementを返す
     *              Returns an HTMLVideoElement to be displayed on the preview screen.
     *
     * @return {HTMLVideoElement}
     * @method
     * @public
     */
    getPreview ()
    {
        const bounds = this.getBounds();

        // size
        let width  = Math.abs(bounds.xMax - bounds.xMin);
        let height = Math.abs(bounds.yMax - bounds.yMin);

        let scaleX   = 1;
        const scaleY = 150 / height;

        width  = width  * scaleY | 0;
        height = height * scaleY | 0;

        const controllerWidth = (document
            .documentElement
            .style
            .getPropertyValue("--controller-width")
            .split("px")[0] | 0) - 10;

        if (width > controllerWidth) {
            scaleX = controllerWidth / width;
            width  = width  * scaleX | 0;
            height = height * scaleX | 0;
        }

        this._$video.style.width  = `${width}px`;
        this._$video.style.height = `${height}px`;

        this._$video.controls = true;
        return this._$video;
    }

    /**
     * @description 表示領域(バウンディングボックス)のObjectを返す
     *              Returns the Object of the display area (bounding box)
     *
     * @param  {array} [matrix=null]
     * @return {object}
     * @method
     * @public
     */
    getBounds (matrix = null)
    {
        const bounds = {
            "xMin": 0,
            "xMax": this.width,
            "yMin": 0,
            "yMax": this.height
        };

        return matrix
            ? Util.$boundsMatrix(bounds, matrix)
            : bounds;
    }

    /**
     * @description シンボルを指定した時の継承先を返す
     *              Returns the inheritance destination when a symbol is specified.
     *
     * @return {string}
     * @public
     * @readonly
     */
    get defaultSymbol ()
    {
        return window.next2d.media.Video.namespace;
    }

    /**
     * @description 動画データ(buffer)をバイナリデータとして利用
     *              Video data (buffer) is used as binary data
     *
     * @member {string}
     * @default ""
     * @public
     */
    get buffer ()
    {
        if (!this._$binary) {

            const length = this._$buffer.length;

            for (let idx = 0; idx < length; ++idx) {
                this._$binary += String.fromCharCode(this._$buffer[idx]);
            }

        }

        return this._$binary;
    }
    set buffer (binary)
    {

        switch (typeof binary) {

            case "object":
                if (binary.constructor === Uint8Array) {
                    this._$buffer = binary;
                }
                break;

            case "string":
                if (!this._$binary) {
                    let length = binary.length;

                    this._$buffer = new Uint8Array(length);
                    for (let idx = 0; idx < length; ++idx) {
                        this._$buffer[idx] = binary.charCodeAt(idx) & 0xff;
                    }

                    this._$binary = binary;
                }
                break;

            default:
                break;

        }
    }

    /**
     * @description 動画音声の設定
     *              Video audio settings.
     *
     * @member {number}
     * @default 100
     * @public
     */
    get volume ()
    {
        return this._$volume;
    }
    set volume (volume)
    {
        this._$volume = Util.$clamp(volume | 0, 0, 100);
    }

    /**
     * @description 動画再生のループのon/off設定
     *              Video playback loop on/off setting
     *
     * @member {boolean}
     * @default false
     * @public
     */
    get loop ()
    {
        return this._$loop;
    }
    set loop (loop)
    {
        this._$loop = !!loop;
    }

    /**
     * @description 動画の自動再生のon/off設定
     *              Video autoplay on/off setting.
     *
     * @member {boolean}
     * @default true
     * @public
     */
    get autoPlay ()
    {
        return this._$autoPlay;
    }
    set autoPlay (auto_play)
    {
        this._$autoPlay = !!auto_play;
    }

    /**
     * @description 動画の幅
     *              Video width
     *
     * @member {number}
     * @public
     */
    get width ()
    {
        return this._$width;
    }
    set width (width)
    {
        this._$width = width | 0;
    }

    /**
     * @description 動画の高さ
     *              Video height
     *
     * @member {number}
     * @public
     */
    get height ()
    {
        return this._$height;
    }
    set height (height)
    {
        this._$height = height | 0;
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "id":        this.id,
            "name":      this.name,
            "type":      this.type,
            "symbol":    this.symbol,
            "folderId":  this.folderId,
            "width":     this.width,
            "height":    this.height,
            "buffer":    this.buffer,
            "volume":    this.volume,
            "loop":      this.loop,
            "autoPlay":  this.autoPlay
        };
    }

    /**
     * @description 書き出し用のObjectを返す
     *              Returns an Object for export
     *
     * @return {object}
     * @method
     * @public
     */
    toPublish ()
    {
        return {
            "symbol":   this.symbol,
            "extends":  this.defaultSymbol,
            "buffer":   Array.from(this._$buffer),
            "bounds":   this.getBounds(),
            "volume":   this.volume / 100,
            "loop":     this.loop,
            "autoPlay": this.autoPlay
        };
    }

    /**
     * @description Next2DのDisplayObjectを生成
     *              Generate Next2D DisplayObject
     *
     * @param  {object} place
     * @return {next2d.display.Video}
     * @method
     * @public
     */
    createInstance (place)
    {
        if (!place) {
            console.log(place);
        }

        const { Video } = window.next2d.media;

        const video = this._$loaded
            ? new Video(this._$video.videoWidth, this._$video.videoHeight)
            : new Video(this.width, this.height);

        video._$characterId = this.id;
        video._$video       = this._$video;

        if (this._$loaded) {
            const context = Util.$root.stage._$player._$context;

            const currentFrame = Util.$timelineFrame.currentFrame;

            video._$video.currentTime = currentFrame / 60;

            video._$texture = context
                .frameBuffer
                .createTextureFromVideo(video._$video, video._$smoothing);
        }

        return video;
    }

    /**
     * @description 動画データの読み込み後にキャプチャー画像を生成
     *              Generate captured images after loading video data
     *
     * @return {void}
     * @method
     * @public
     */
    delayImage ()
    {
        for (let idx = 0; idx < this._$queue.length; ++idx) {
            const object = this._$queue[idx];
            this.draw(
                object.canvas, object.width, object.height,
                object.place, object.range, object.staticFrame
            );
        }
        this._$queue.length = 0;
    }

    /**
     * @description Next2DのBitmapDataクラスを経由してImageクラスを生成
     *              Generate Image class via Next2D BitmapData class
     *
     * @param  {HTMLCanvasElement} canvas
     * @param  {number}  width
     * @param  {number}  height
     * @param  {object}  place
     * @param  {object}  [range = null]
     * @param  {number}  [static_frame = 0]
     * @param  {boolean} [preview = false]
     * @return {CanvasRenderingContext2D}
     * @method
     * @public
     */
    draw (
        canvas, width, height, place,
        range = null, static_frame = 0, preview = false
    ) {

        const context = super.draw(
            canvas, width, height, place,
            range, static_frame, preview
        );

        if (this._$loaded) {
            return context;
        }

        this._$queue.push({
            "canvas": canvas,
            "width": width,
            "height": height,
            "place": place,
            "range": range,
            "staticFrame": static_frame
        });

        return context;
    }
}

/**
 * 各種Filterの親クラスで、共通処理が定義されてます。
 * Common processes are defined in the parent classes of various Filters.
 *
 * @class
 * @memberOf filter
 */
class Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        this._$blurX   = 4;
        this._$blurY   = 4;
        this._$quality = 1;
        this._$state   = true;
        this._$name    = "";

        if (object) {
            this.blurX   = object.blurX;
            this.blurY   = object.blurY;
            this.quality = object.quality | 0;
            this.state   = object.state;
        }
    }

    /**
     * @description 子のクラスのクローンを生成
     *              Generate a clone of the child class
     *
     * @return {Filter}
     * @method
     * @public
     */
    clone ()
    {
        return new this.constructor(JSON.parse(JSON.stringify(this.toObject())));
    }

    /**
     * @description 指定されたフィルターと同一の設定がないか判定
     *              Determine if there are any settings identical to the specified filter
     *
     * @param  {Filter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$quality !== filter._$quality) {
            return false;
        }

        if (this._$blurX !== filter._$blurX) {
            return false;
        }

        if (this._$blurY !== filter._$blurY) {
            return false;
        }

        return true;
    }

    /**
     * @description 水平方向のぼかし量。
     *              The amount of horizontal blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurX ()
    {
        return this._$blurX;
    }
    set blurX (blur_x)
    {
        this._$blurX = Util.$clamp(
            +blur_x,
            FilterController.MIN_BLUR,
            FilterController.MAX_BLUR
        );
    }

    /**
     * @description 垂直方向のぼかし量。
     *              The amount of vertical blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurY ()
    {
        return this._$blurY;
    }
    set blurY (blur_y)
    {
        this._$blurY = Util.$clamp(
            +blur_y,
            FilterController.MIN_BLUR,
            FilterController.MAX_BLUR
        );
    }

    /**
     * @description ぼかしの実行回数です。
     *              The number of times to perform the blur.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get quality ()
    {
        return this._$quality;
    }
    set quality (quality)
    {
        this._$quality = Util.$clamp(quality | 0, 1, 3);
    }

    /**
     * @description コントローラーの表示/非表示のフラグ
     *              Flag to show/hide controllers
     *
     * @member {boolean}
     * @default true
     * @public
     */
    get state ()
    {
        return this._$state;
    }
    set state (state)
    {
        this._$state = state;
    }

    /**
     * @description 子のFilterクラスのクラス名
     *              Class name of the child Filter class
     *
     * @member {string}
     * @default ""
     * @public
     */
    get name ()
    {
        return this._$name;
    }
    set name (name)
    {
        this._$name = name;
    }
}

/**
 * Next2Dのフィルターと連動したBevelFilterクラス
 * BevelFilter class in conjunction with Next2D filters
 *
 * @class
 * @extends {Filter}
 * @memberOf filter
 */
class BevelFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        super(object);
        this.name = "BevelFilter";

        this._$distance       = 4;
        this._$angle          = 45;
        this._$highlightColor = 0xffffff;
        this._$highlightAlpha = 100;
        this._$shadowColor    = 0;
        this._$shadowAlpha    = 100;
        this._$strength       = 1;
        this._$type           = "inner";
        this._$knockout       = false;

        if (object) {
            this.distance       = object.distance;
            this.angle          = object.angle;
            this.highlightColor = object.highlightColor | 0;
            this.highlightAlpha = object.highlightAlpha * 100;
            this.shadowColor    = object.shadowColor | 0;
            this.shadowAlpha    = object.shadowAlpha * 100;
            this.strength       = object.strength;
            this.type           = object.type;
            this.knockout       = object.knockout;
        }
    }

    /**
     * @description シャドウのオフセット距離です。
     *              The offset distance for the shadow, in pixels.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }
    set distance (distance)
    {
        this._$distance = Util.$clamp(
            +distance,
            FilterController.MIN_DISTANCE,
            FilterController.MAX_DISTANCE
        );
    }

    /**
     * @description シャドウの角度
     *              The angle of the shadow.
     *
     * @member  {number}
     * @default 45
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }
    set angle (angle)
    {
        this._$angle = +angle % 360;
    }

    /**
     * @description グローのカラー
     *              The color of the glow.
     *
     * @member  {number}
     * @default 0xffffff
     * @public
     */
    get highlightColor ()
    {
        return this._$highlightColor;
    }
    set highlightColor (highlight_color)
    {
        this._$highlightColor = Util.$clamp(highlight_color | 0, 0, 0xffffff);
    }

    /**
     * @description アルファ透明度の値です。
     *              The alpha transparency value for the color.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get highlightAlpha ()
    {
        return this._$highlightAlpha;
    }
    set highlightAlpha (highlight_alpha)
    {
        this._$highlightAlpha = Util.$clamp(+highlight_alpha, 0, 100);
    }

    /**
     * @description グローのカラー
     *              The color of the glow.
     *
     * @member  {number}
     * @default 0
     * @public
     */
    get shadowColor ()
    {
        return this._$shadowColor;
    }
    set shadowColor (shadow_color)
    {
        this._$shadowColor = Util.$clamp(shadow_color | 0, 0, 0xffffff);
    }

    /**
     * @description アルファ透明度の値です。
     *              The alpha transparency value for the color.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get shadowAlpha ()
    {
        return this._$shadowAlpha;
    }
    set shadowAlpha (shadow_alpha)
    {
        this._$shadowAlpha = Util.$clamp(+shadow_alpha, 0, 100);
    }

    /**
     * @description インプリントの強さまたは広がりです。
     *              The strength of the imprint or spread.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }
    set strength (strength)
    {
        this._$strength = Util.$clamp(
            +strength,
            FilterController.MIN_STRENGTH,
            FilterController.MAX_STRENGTH
        );
    }

    /**
     * @description オブジェクトでのベベルの配置
     *              The placement of the bevel on the object.
     *
     * @member  {string}
     * @default BitmapFilterType.INNER
     * @public
     */
    get type ()
    {
        return this._$type;
    }
    set type (type)
    {
        type = `${type}`.toLowerCase();
        switch (type) {

            case "outer":
            case "inner":
                this._$type = type;
                break;

            default:
                this._$type = "full";
                break;

        }
    }

    /**
     * @description オブジェクトにノックアウト効果を適用するかどうか
     *              Specifies whether the object has a knockout effect.
     *
     * @member  {boolean}
     * @default false
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }
    set knockout (knockout)
    {
        this._$knockout = !!knockout;
    }

    /**
     * @description 指定されたフィルターと同一の設定がないか判定
     *              Determine if there are any settings identical to the specified filter
     *
     * @param  {BevelFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        if (this._$highlightColor !== filter._$highlightColor) {
            return false;
        }

        if (this._$highlightAlpha !== filter._$highlightAlpha) {
            return false;
        }

        if (this._$shadowColor !== filter._$shadowColor) {
            return false;
        }

        if (this._$shadowAlpha !== filter._$shadowAlpha) {
            return false;
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$type !== filter._$type) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @description Next2DのBevelFilterを生成
     *              Generate Next2D BevelFilter
     *
     * @return {window.next2d.filters.BevelFilter}
     * @method
     * @public
     */
    createInstance ()
    {
        return new window.next2d.filters.BevelFilter(
            this.distance, this.angle, this.highlightColor, this.highlightAlpha / 100,
            this.shadowColor, this.shadowAlpha / 100, this.blurX, this.blurY,
            this.strength, this.quality, this.type, this.knockout
        );
    }

    /**
     * @description クラス内の変数を配列にして返す
     *              Returns an array of variables in the class
     *
     * @return {array}
     * @method
     * @public
     */
    toParamArray ()
    {
        return [null,
            this.distance, this.angle, this.highlightColor, this.highlightAlpha / 100,
            this.shadowColor, this.shadowAlpha / 100, this.blurX, this.blurY,
            this.strength, this.quality, this.type, this.knockout
        ];
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "distance": this.distance,
            "angle": this.angle,
            "highlightColor": this.highlightColor,
            "highlightAlpha": this.highlightAlpha / 100,
            "shadowColor": this.shadowColor,
            "shadowAlpha": this.shadowAlpha / 100,
            "strength": this.strength,
            "type": this.type,
            "knockout": this.knockout
        };
    }
}

/**
 * Next2Dのフィルターと連動したBlurFilterクラス
 * BlurFilter class in conjunction with Next2D filters
 *
 * @class
 * @extends {Filter}
 * @memberOf filter
 */
class BlurFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        super(object);
        this.name = "BlurFilter";
    }

    /**
     * @description Next2DのBlurFilterを生成
     *              Generate Next2D BlurFilter
     *
     * @return {window.next2d.filters.BlurFilter}
     * @method
     * @public
     */
    createInstance ()
    {
        return new window.next2d.filters.BlurFilter(
            this.blurX, this.blurY, this.quality
        );
    }

    /**
     * @description クラス内の変数を配列にして返す
     *              Returns an array of variables in the class
     *
     * @return {array}
     * @method
     * @public
     */
    toParamArray ()
    {
        return [null, this.blurX, this.blurY, this.quality];
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state
        };
    }
}

/**
 * Next2Dのフィルターと連動したDropShadowFilterクラス
 * DropShadowFilter class in conjunction with Next2D filters
 *
 * @class
 * @extends {Filter}
 * @memberOf filter
 */
class DropShadowFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        super(object);
        this.name = "DropShadowFilter";

        this._$distance   = 4;
        this._$angle      = 45;
        this._$color      = 0;
        this._$alpha      = 100;
        this._$strength   = 1;
        this._$inner      = false;
        this._$knockout   = false;
        this._$hideObject = false;

        if (object) {
            this.distance   = object.distance;
            this.angle      = object.angle;
            this.color      = object.color;
            this.alpha      = object.alpha * 100;
            this.strength   = object.strength;
            this.inner      = object.inner;
            this.knockout   = object.knockout;
            this.hideObject = object.hideObject;
        }
    }

    /**
     * @description シャドウのオフセット距離です。
     *              The offset distance for the shadow, in pixels.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }
    set distance (distance)
    {
        this._$distance = Util.$clamp(
            +distance,
            FilterController.MIN_DISTANCE,
            FilterController.MAX_DISTANCE
        );
    }

    /**
     * @description シャドウの角度
     *              The angle of the shadow.
     *
     * @member  {number}
     * @default 45
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }
    set angle (angle)
    {
        this._$angle = +angle % 360;
    }

    /**
     * @description グローのカラー
     *              The color of the glow.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get color ()
    {
        return this._$color;
    }
    set color (color)
    {
        this._$color = Util.$clamp(color | 0, 0, 0xffffff);
    }

    /**
     * @description アルファ透明度の値です。
     *              The alpha transparency value for the color.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get alpha ()
    {
        return this._$alpha;
    }
    set alpha (alpha)
    {
        this._$alpha = Util.$clamp(+alpha, 0, 100);
    }

    /**
     * @description インプリントの強さまたは広がりです。
     *              The strength of the imprint or spread.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }
    set strength (strength)
    {
        this._$strength = Util.$clamp(
            +strength,
            FilterController.MIN_STRENGTH,
            FilterController.MAX_STRENGTH
        );
    }

    /**
     * @description グローが内側グローであるかどうか
     *              Specifies whether the glow is an inner glow.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get inner ()
    {
        return this._$inner;
    }
    set inner (inner)
    {
        this._$inner = !!inner;
    }

    /**
     * @description オブジェクトにノックアウト効果を適用するかどうか
     *              Specifies whether the object has a knockout effect.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }
    set knockout (knockout)
    {
        this._$knockout = !!knockout;
    }

    /**
     * @description オブジェクトが非表示であるかどうかを示します。
     *              Indicates whether or not the object is hidden.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get hideObject ()
    {
        return this._$hideObject;
    }
    set hideObject (hideObject)
    {
        this._$hideObject = !!hideObject;
    }

    /**
     * @description 指定されたフィルターと同一の設定がないか判定
     *              Determine if there are any settings identical to the specified filter
     *
     * @param  {DropShadowFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        if (this._$color !== filter._$color) {
            return false;
        }

        if (this._$alpha !== filter._$alpha) {
            return false;
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$inner !== filter._$inner) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        if (this._$hideObject !== filter._$hideObject) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @description Next2DのDropShadowFilterを生成
     *              Generate Next2D DropShadowFilter
     *
     * @return {window.next2d.filters.DropShadowFilter}
     * @method
     * @public
     */
    createInstance ()
    {
        return new window.next2d.filters.DropShadowFilter(
            this.distance, this.angle, this.color, this.alpha / 100,
            this.blurX, this.blurY, this.strength, this.quality,
            this.inner, this.knockout, this.hideObject
        );
    }

    /**
     * @description クラス内の変数を配列にして返す
     *              Returns an array of variables in the class
     *
     * @return {array}
     * @method
     * @public
     */
    toParamArray ()
    {
        return [null,
            this.distance, this.angle, this.color, this.alpha / 100,
            this.blurX, this.blurY, this.strength, this.quality,
            this.inner, this.knockout, this.hideObject
        ];
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "distance": this.distance,
            "angle": this.angle,
            "color": this.color,
            "alpha": this.alpha / 100,
            "strength": this.strength,
            "inner": this.inner,
            "knockout": this.knockout,
            "hideObject": this.hideObject
        };
    }
}

/**
 * Next2Dのフィルターと連動したGlowFilterクラス
 * GlowFilter class in conjunction with Next2D filters
 *
 * @class
 * @extends {Filter}
 * @memberOf filter
 */
class GlowFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        super(object);
        this.name = "GlowFilter";

        this._$color      = 0;
        this._$alpha      = 100;
        this._$strength   = 1;
        this._$inner      = false;
        this._$knockout   = false;

        if (object) {
            this.color      = object.color;
            this.alpha      = object.alpha * 100;
            this.strength   = object.strength;
            this.inner      = object.inner;
            this.knockout   = object.knockout;
        }
    }

    /**
     * @description グローのカラー
     *              The color of the glow.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get color ()
    {
        return this._$color;
    }
    set color (color)
    {
        this._$color = Util.$clamp(color | 0, 0, 0xffffff);
    }

    /**
     * @description アルファ透明度の値です。
     *              The alpha transparency value for the color.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get alpha ()
    {
        return this._$alpha;
    }
    set alpha (alpha)
    {
        this._$alpha = Util.$clamp(+alpha, 0, 100);
    }

    /**
     * @description インプリントの強さまたは広がりです。
     *              The strength of the imprint or spread.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }
    set strength (strength)
    {
        this._$strength = Util.$clamp(
            +strength,
            FilterController.MIN_STRENGTH,
            FilterController.MAX_STRENGTH
        );
    }

    /**
     * @description グローが内側グローであるかどうか
     *              Specifies whether the glow is an inner glow.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get inner ()
    {
        return this._$inner;
    }
    set inner (inner)
    {
        this._$inner = !!inner;
    }

    /**
     * @description オブジェクトにノックアウト効果を適用するかどうか
     *              Specifies whether the object has a knockout effect.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }
    set knockout (knockout)
    {
        this._$knockout = !!knockout;
    }

    /**
     * @description 指定されたフィルターと同一の設定がないか判定
     *              Determine if there are any settings identical to the specified filter
     *
     * @param  {GlowFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$color !== filter._$color) {
            return false;
        }

        if (this._$alpha !== filter._$alpha) {
            return false;
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$inner !== filter._$inner) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @description Next2DのGlowFilterを生成
     *              Generate Next2D GlowFilter
     *
     * @return {window.next2d.filters.GlowFilter}
     * @method
     * @public
     */
    createInstance ()
    {
        return new window.next2d.filters.GlowFilter(
            this.color, this.alpha / 100, this.blurX, this.blurY,
            this.strength, this.quality, this.inner, this.knockout
        );
    }

    /**
     * @description クラス内の変数を配列にして返す
     *              Returns an array of variables in the class
     *
     * @return {array}
     * @method
     * @public
     */
    toParamArray ()
    {
        return [null,
            this.color, this.alpha / 100, this.blurX, this.blurY,
            this.strength, this.quality, this.inner, this.knockout
        ];
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "color": this.color,
            "alpha": this.alpha / 100,
            "strength": this.strength,
            "inner": this.inner,
            "knockout": this.knockout
        };
    }
}

/**
 * Next2Dのフィルターと連動したGradientBevelFilterクラス
 * GradientBevelFilter class in conjunction with Next2D filters
 *
 * @class
 * @extends {Filter}
 * @memberOf filter
 */
class GradientBevelFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        super(object);
        this.name = "GradientBevelFilter";

        this._$distance = 4;
        this._$angle    = 45;
        this._$colors   = [0xffffff, 0xff0000, 0];
        this._$alphas   = [100, 0, 100];
        this._$ratios   = [0, 128, 255];
        this._$strength = 1;
        this._$type     = "inner";
        this._$knockout = false;

        if (object) {
            this.distance = +object.distance;
            this.angle    = +object.angle;
            this.colors   = object.colors;
            this.alphas   = object.alphas;
            this.ratios   = object.ratios;
            this.strength = +object.strength;
            this.type     = object.type;
            this.knockout = object.knockout;
        }
    }

    /**
     * @description シャドウのオフセット距離です。
     *              The offset distance for the shadow, in pixels.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }
    set distance (distance)
    {
        this._$distance = Util.$clamp(
            +distance,
            FilterController.MIN_DISTANCE,
            FilterController.MAX_DISTANCE
        );
    }

    /**
     * @description シャドウの角度
     *              The angle of the shadow.
     *
     * @member  {number}
     * @default 45
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }
    set angle (angle)
    {
        this._$angle = +angle % 360;
    }

    /**
     * @description グラデーションで使用する RGB 16 進数カラー値の配列です。
     *              An array of RGB hexadecimal color values to use in the gradient.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get colors ()
    {
        return this._$colors;
    }
    set colors (colors)
    {
        this._$colors.length = 0;
        this._$colors = colors;
    }

    /**
     * @description カラー配列内の各色に対応するアルファ透明度の値の配列です。
     *              An array of alpha transparency values
     *              for the corresponding colors in the colors array.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get alphas ()
    {
        return this._$alphas;
    }
    set alphas (alphas)
    {
        this._$alphas.length = 0;
        for (let idx = 0; idx < alphas.length; ++idx) {
            this._$alphas.push(alphas[idx] * 100);
        }
    }

    /**
     * @description カラー配列内の対応するカラーの色分布比率の配列です。
     *              An array of color distribution ratios
     *              for the corresponding colors in the colors array.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get ratios ()
    {
        return this._$ratios;
    }
    set ratios (ratios)
    {
        this._$ratios.length = 0;
        for (let idx = 0; idx < ratios.length; ++idx) {
            this._$ratios.push(ratios[idx] * 255);
        }
    }

    /**
     * @description インプリントの強さまたは広がりです。
     *              The strength of the imprint or spread.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }
    set strength (strength)
    {
        this._$strength = Util.$clamp(
            +strength,
            FilterController.MIN_STRENGTH,
            FilterController.MAX_STRENGTH
        );
    }

    /**
     * @description オブジェクトでのベベルの配置
     *              The placement of the bevel on the object.
     *
     * @member  {string}
     * @default BitmapFilterType.INNER
     * @public
     */
    get type ()
    {
        return this._$type;
    }
    set type (type)
    {
        type = `${type}`.toLowerCase();
        switch (type) {

            case "outer":
            case "full":
                this._$type = type;
                break;

            default:
                this._$type = "inner";
                break;

        }
    }

    /**
     * @description オブジェクトにノックアウト効果を適用するかどうか
     *              Specifies whether the object has a knockout effect.
     *
     * @member  {boolean}
     * @default false
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }
    set knockout (knockout)
    {
        this._$knockout = !!knockout;
    }

    /**
     * @description カラー、アルファー、分布比率の配列の値をバリデーションを行い算出
     *              Validated and calculated values for color, alpha, and distribution ratio arrays
     *
     * @return {object}
     * @method
     * @public
     */
    adjustment ()
    {
        const ratios = [];
        const colors = [];
        const alphas = [];

        const ratioMap = new Map();
        for (let idx = 0; idx < this._$ratios.length; ++idx) {

            const ratio = this._$ratios[idx] / 255;

            ratios.push(ratio);
            ratioMap.set(ratio, idx);
        }

        ratios.sort(function (a, b)
        {
            switch (true) {

                case a > b:
                    return 1;

                case a < b:
                    return -1;

                default:
                    return 0;

            }
        });

        for (let idx = 0; idx < ratios.length; ++idx) {

            const index = ratioMap.get(ratios[idx]);

            colors.push(this._$colors[index]);
            alphas.push(this._$alphas[index] / 100);
        }

        return {
            "ratios": ratios,
            "colors": colors,
            "alphas": alphas
        };
    }

    /**
     * @description 指定されたフィルターと同一の設定がないか判定
     *              Determine if there are any settings identical to the specified filter
     *
     * @param  {GradientBevelFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        for (let idx = 0; idx < this._$colors.length; ++idx) {
            if (this._$colors[idx] !== filter._$colors[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$alphas.length; ++idx) {
            if (this._$alphas[idx] !== filter._$alphas[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$ratios.length; ++idx) {
            if (this._$ratios[idx] !== filter._$ratios[idx]) {
                return false;
            }
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$type !== filter._$type) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @description Next2DのGradientBevelFilterを生成
     *              Generate Next2D GradientBevelFilter
     *
     * @return {window.next2d.filters.GradientBevelFilter}
     * @method
     * @public
     */
    createInstance ()
    {
        const object = this.adjustment();
        return new window.next2d.filters.GradientBevelFilter(
            this.distance, this.angle, object.colors, object.alphas,
            object.ratios, this.blurX, this.blurY, this.strength,
            this.quality, this.type, this.knockout
        );
    }

    /**
     * @description クラス内の変数を配列にして返す
     *              Returns an array of variables in the class
     *
     * @return {array}
     * @method
     * @public
     */
    toParamArray ()
    {
        const object = this.adjustment();
        return [null,
            this.distance, this.angle, object.colors, object.alphas,
            object.ratios, this.blurX, this.blurY, this.strength,
            this.quality, this.type, this.knockout
        ];
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        const object = this.adjustment();
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "distance": this.distance,
            "angle": this.angle,
            "colors": object.colors,
            "alphas": object.alphas,
            "ratios": object.ratios,
            "strength": this.strength,
            "type": this.type,
            "knockout": this.knockout
        };
    }
}

/**
 * Next2Dのフィルターと連動したGradientGlowFilterクラス
 * GradientGlowFilter class in conjunction with Next2D filters
 *
 * @class
 * @extends {Filter}
 * @memberOf filter
 */
class GradientGlowFilter extends Filter
{
    /**
     * @param {object} [object=null]
     * @constructor
     * @public
     */
    constructor (object = null)
    {
        super(object);
        this.name = "GradientGlowFilter";

        this._$distance = 4;
        this._$angle    = 45;
        this._$colors   = [0xffffff, 0];
        this._$alphas   = [0, 100];
        this._$ratios   = [0, 255];
        this._$strength = 1;
        this._$type     = "outer";
        this._$knockout = false;

        if (object) {
            this.distance = +object.distance;
            this.angle    = +object.angle;
            this.colors   = object.colors;
            this.alphas   = object.alphas;
            this.ratios   = object.ratios;
            this.strength = +object.strength;
            this.type     = object.type;
            this.knockout = object.knockout;
        }
    }

    /**
     * @description シャドウのオフセット距離です。
     *              The offset distance for the shadow, in pixels.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }
    set distance (distance)
    {
        this._$distance = Util.$clamp(
            +distance,
            FilterController.MIN_DISTANCE,
            FilterController.MAX_DISTANCE
        );
    }

    /**
     * @description シャドウの角度
     *              The angle of the shadow.
     *
     * @member  {number}
     * @default 45
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }
    set angle (angle)
    {
        this._$angle = +angle % 360;
    }

    /**
     * @description グラデーションで使用する RGB 16 進数カラー値の配列です。
     *              An array of RGB hexadecimal color values to use in the gradient.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get colors ()
    {
        return this._$colors;
    }
    set colors (colors)
    {
        this._$colors.length = 0;
        this._$colors = colors;
    }

    /**
     * @description カラー配列内の各色に対応するアルファ透明度の値の配列です。
     *              An array of alpha transparency values
     *              for the corresponding colors in the colors array.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get alphas ()
    {
        return this._$alphas;
    }
    set alphas (alphas)
    {
        this._$alphas.length = 0;
        for (let idx = 0; idx < alphas.length; ++idx) {
            this._$alphas.push(alphas[idx] * 100);
        }
    }

    /**
     * @description カラー配列内の対応するカラーの色分布比率の配列です。
     *              An array of color distribution ratios
     *              for the corresponding colors in the colors array.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get ratios ()
    {
        return this._$ratios;
    }
    set ratios (ratios)
    {
        this._$ratios.length = 0;
        for (let idx = 0; idx < ratios.length; ++idx) {
            this._$ratios.push(ratios[idx] * 255);
        }
    }

    /**
     * @description インプリントの強さまたは広がりです。
     *              The strength of the imprint or spread.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }
    set strength (strength)
    {
        this._$strength = Util.$clamp(
            +strength,
            FilterController.MIN_STRENGTH,
            FilterController.MAX_STRENGTH
        );
    }

    /**
     * @description オブジェクトでのベベルの配置
     *              The placement of the bevel on the object.
     *
     * @member  {string}
     * @default BitmapFilterType.INNER
     * @public
     */
    get type ()
    {
        return this._$type;
    }
    set type (type)
    {
        type = `${type}`.toLowerCase();
        switch (type) {

            case "outer":
            case "full":
                this._$type = type;
                break;

            default:
                this._$type = "inner";
                break;

        }
    }

    /**
     * @description オブジェクトにノックアウト効果を適用するかどうか
     *              Specifies whether the object has a knockout effect.
     *
     * @member  {boolean}
     * @default false
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }
    set knockout (knockout)
    {
        this._$knockout = !!knockout;
    }

    /**
     * @description カラー、アルファー、分布比率の配列の値をバリデーションを行い算出
     *              Validated and calculated values for color, alpha, and distribution ratio arrays
     *
     * @return {object}
     * @method
     * @public
     */
    adjustment ()
    {
        const ratios = [];
        const colors = [];
        const alphas = [];

        const ratioMap = new Map();
        for (let idx = 0; idx < this._$ratios.length; ++idx) {

            const ratio = this._$ratios[idx] / 255;

            ratios.push(ratio);
            ratioMap.set(ratio, idx);
        }

        ratios.sort(function (a, b)
        {
            switch (true) {

                case a > b:
                    return 1;

                case a < b:
                    return -1;

                default:
                    return 0;

            }
        });

        for (let idx = 0; idx < ratios.length; ++idx) {

            const index = ratioMap.get(ratios[idx]);

            colors.push(this._$colors[index]);
            alphas.push(this._$alphas[index] / 100);
        }

        return {
            "ratios": ratios,
            "colors": colors,
            "alphas": alphas
        };
    }

    /**
     * @description 指定されたフィルターと同一の設定がないか判定
     *              Determine if there are any settings identical to the specified filter
     *
     * @param  {GradientGlowFilter} filter
     * @return {boolean}
     * @method
     * @public
     */
    isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        for (let idx = 0; idx < this._$colors.length; ++idx) {
            if (this._$colors[idx] !== filter._$colors[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$alphas.length; ++idx) {
            if (this._$alphas[idx] !== filter._$alphas[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$ratios.length; ++idx) {
            if (this._$ratios[idx] !== filter._$ratios[idx]) {
                return false;
            }
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$type !== filter._$type) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return super.isSame(filter);
    }

    /**
     * @description Next2DのGradientGlowFilterを生成
     *              Generate Next2D GradientGlowFilter
     *
     * @return {window.next2d.filters.GradientGlowFilter}
     * @method
     * @public
     */
    createInstance ()
    {
        const object = this.adjustment();
        return new window.next2d.filters.GradientGlowFilter(
            this.distance, this.angle, object.colors, object.alphas,
            object.ratios, this.blurX, this.blurY, this.strength,
            this.quality, this.type, this.knockout
        );
    }

    /**
     * @description クラス内の変数を配列にして返す
     *              Returns an array of variables in the class
     *
     * @return {array}
     * @method
     * @public
     */
    toParamArray ()
    {
        const object = this.adjustment();
        return [null,
            this.distance, this.angle, object.colors, object.alphas,
            object.ratios, this.blurX, this.blurY, this.strength,
            this.quality, this.type, this.knockout
        ];
    }

    /**
     * @description クラス内の変数をObjectにして返す
     *              Return variables in a class as Objects
     *
     * @return {object}
     * @method
     * @public
     */
    toObject ()
    {
        const object = this.adjustment();
        return {
            "name": this.name,
            "blurX": this.blurX,
            "blurY": this.blurY,
            "quality": this.quality,
            "state": this.state,
            "distance": this.distance,
            "angle": this.angle,
            "colors": object.colors,
            "alphas": object.alphas,
            "ratios": object.ratios,
            "strength": this.strength,
            "type": this.type,
            "knockout": this.knockout
        };
    }
}

/**
 * @class
 * @memberOf parser
 */
class ByteStream
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        this._$buffer     = null;
        this._$bitOffset  = 0;
        this._$byteOffset = 0;
    }

    /**
     * @param   {Uint8Array} data
     * @returns {void}
     */
    setData (data)
    {
        this._$buffer = data;
    }

    /**
     * @param   {number} length
     * @returns {Uint8Array}
     */
    getData (length)
    {
        this.byteAlign();

        const offset = this._$byteOffset + length;
        const array  = this._$buffer.slice(this._$byteOffset, offset);

        this._$byteOffset = offset;

        return array;
    }

    /**
     * @returns {string}
     */
    getHeaderSignature ()
    {
        let signature = "";

        let count = 3;
        while (count) {

            const code = this.getUI8();
            switch (code) {

                // trim
                case 32:
                case 96:
                case 127:
                    continue;

                default:
                    break;

            }

            signature += String.fromCharCode(code);

            --count;

        }

        return signature;
    }

    /**
     * @returns {number}
     */
    getVersion ()
    {
        return this.getUI8();
    }

    /**
     * @returns void
     */
    byteAlign ()
    {
        if (!this._$bitOffset) {
            return;
        }

        this._$byteOffset = this._$byteOffset + (this._$bitOffset + 7) / 8 | 0;
        this._$bitOffset  = 0;
    }

    /**
     * @returns void
     */
    byteCarry ()
    {
        if (this._$bitOffset > 7) {
            this._$byteOffset  = this._$byteOffset + (0 | (this._$bitOffset + 7) / 8);
            this._$bitOffset  &= 0x07;
        } else {
            while (this._$bitOffset < 0) {
                --this._$byteOffset;
                this._$bitOffset += 8;
            }
        }
    }

    /**
     * @param   {number} number
     * @returns {number}
     */
    getUIBits (number)
    {
        let value = 0;
        while (number) {

            value <<= 1;
            value |= this.getUIBit();

            --number;
        }
        return value;
    }

    /**
     * @returns {number}
     */
    getUIBit ()
    {
        this.byteCarry();
        return this._$buffer[this._$byteOffset] >> 7 - this._$bitOffset++ & 0x1;
    }

    /**
     * @param   {number} number
     * @returns {number}
     */
    getSIBits (number)
    {
        const value = this.getUIBits(number);
        const msb   = value & 0x1 << number - 1;
        if (msb) {
            return -(value ^ 2 * msb - 1) - 1;
        }
        return value;
    }

    /**
     * @returns {number}
     */
    getUI8 ()
    {
        this.byteAlign();
        return this._$buffer[this._$byteOffset++];
    }

    /**
     * @returns {number}
     */
    getUI16 ()
    {
        this.byteAlign();
        return this.getUI8() | this.getUI8() << 8;
    }

    /**
     * @returns {number}
     */
    getUI32 ()
    {
        this.byteAlign();
        return this.getUI8() | (this.getUI8()
            | (this.getUI8() | this.getUI8() << 8) << 8) << 8;
    }
}

/**
 * @class
 * @memberOf parser
 */
class ReComposition
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$folderId = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$libraryId = 0;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$fileName = "";

        /**
         * @type {ByteStream}
         * @private
         */
        this._$byteStream = new ByteStream();

        /**
         * @type {object}
         * @private
         */
        this._$bounds = {
            "xMin": 0,
            "xMax": 0,
            "yMin": 0,
            "yMax": 0
        };

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$swfVersion = 0;

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$info = null;

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$buildData = null;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$fileSize = 0;

        /**
         * @type {string}
         * @default "swf"
         * @private
         */
        this._$mode = "swf";

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$offset = 0;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$resolve = null;
    }

    /**
     * @return {string}
     * @public
     */
    get mode ()
    {
        return this._$mode;
    }

    /**
     * @return {number}
     * @public
     */
    get fileSize ()
    {
        return this._$fileSize;
    }

    /**
     * @param  {Uint8Array} buffer
     * @return {ReComposition}
     * @public
     */
    setData (buffer)
    {
        this._$byteStream.setData(buffer);
        return this;
    }

    /**
     * @param  {string} file_name
     * @param  {function} resolve
     * @param  {number} [folder_id=0]
     * @param  {number} [library_id=0]
     * @return {void}
     * @public
     */
    run (file_name, resolve, folder_id = 0, library_id = 0)
    {
        this._$resolve   = resolve;
        this._$fileName  = file_name.replace(".swf", "");
        this._$folderId  = folder_id;
        this._$libraryId = library_id;

        // signature
        const signature = this._$byteStream.getHeaderSignature();

        // version
        this._$byteStream.getVersion();

        Util.$saveProgress.parseSWF();

        // file size
        this._$fileSize = this._$byteStream.getUI32();
        this._$mode     = "swf";
        switch (signature) {

            // No ZIP
            case "FWS":
                return this.parseAndBuild();

            // ZLIB
            case "CWS":
                {
                    if (Util.$unzipWorkerActive) {
                        Util.$unzipQueues.push(this);
                        return ;
                    }

                    // start worker
                    Util.$unzipWorkerActive = true;

                    if (!Util.$unzipWorker) {
                        Util.$unzipWorker = new Worker(Util.$unzipURL);
                    }

                    const worker = Util.$unzipWorker;

                    // set message event
                    worker.onmessage = Util.$unzipHandler.bind(this);

                    const data = this._$byteStream._$buffer;
                    worker.postMessage({
                        "fileSize": this._$fileSize,
                        "mode":     this._$mode,
                        "buffer":   data
                    }, [data.buffer]);
                }

                break;

            // LZMA
            case "ZWS":
                {
                    if (Util.$unlzmaWorkerActive) {
                        Util.$unlzmaQueues.push(this);
                        return ;
                    }

                    // start worker
                    Util.$unlzmaWorkerActive = true;

                    const worker = new Worker(Util.$unlzmaWorkerURL);

                    // set message event
                    worker.onmessage = Util.$unlzmaHandler.bind(this);

                    const data = this._$byteStream._$buffer;
                    worker.postMessage({
                        "fileSize": this._$fileSize,
                        "mode":     this._$mode,
                        "buffer":   data
                    }, [data.buffer]);
                }

                break;

            // error
            default:
                throw new Error("this data is not swf.");

        }

    }

    /**
     * @returns void
     * @public
     */
    parseAndBuild ()
    {
        // set stage bounds
        this._$byteStream.byteAlign();

        const nBits = this._$byteStream.getUIBits(5);
        this._$bounds.xMin = this._$byteStream.getSIBits(nBits);
        this._$bounds.xMax = this._$byteStream.getSIBits(nBits);
        this._$bounds.yMin = this._$byteStream.getSIBits(nBits);
        this._$bounds.yMax = this._$byteStream.getSIBits(nBits);

        this._$byteStream.getUI16(); // frameRate
        this._$byteStream.getUI16(); // frameCount

        // current offset
        this._$offset = this._$byteStream._$byteOffset;

        if (Util.$parserWorkerWait) {
            Util.$parserQueues.push(this);
            return ;
        }

        Util.$parserWorkerWait = true;

        if (!Util.$parserWorker) {
            Util.$parserWorker = new Worker(Util.$parserURL);
        }

        Util.$parserWorker.onmessage = Util.$parserHandler.bind(this);

        const buffer = this._$byteStream._$buffer;
        Util.$parserWorker.postMessage({
            "version": this._$swfVersion,
            "offset":  this._$offset,
            "buffer":  buffer
        }, [buffer.buffer]);

    }

    /**
     * @return {MovieClip|DisplayObject}
     * @public
     */
    build ()
    {

        // setup
        const info   = this.buildData.info;
        const object = this.buildData.parent;

        this.loaderInfo._$bytes._$byteArray   = this.buildData.buffer;
        this.loaderInfo._$actionScriptVersion = info._$asv;

        // symbol copy and build
        let isMain = false;
        let length = this.loaderInfo._$symbols.length;
        if (length) {

            const applicationDomain = this.loaderInfo._$applicationDomain;
            const symbols   = Util.$getArray();
            for (let idx = 0; idx < length; ++idx) {

                const symbol = this.loaderInfo._$symbols[idx];

                const id = symbol.tagId;
                if (id === 0) {
                    isMain = true;
                }

                switch (true) {

                    case id in this.loaderInfo._$characters:
                    case this.loaderInfo._$fonts.has(id):
                        {

                            const instance = Util.$getPackage(applicationDomain, symbol.path);
                            if (instance._$loaderInfoId === this.loaderInfo._$id
                                || !("__$$characterId" in instance.prototype)
                            ) {

                                instance.prototype.__$$characterId  = id;
                                instance.prototype.__$$loaderInfoId = this.loaderInfo._$id;

                                const slots = instance.__$$slots;

                                const names  = Util.$Object.keys(slots);
                                const length = names.length;
                                for (let idx = 0; idx < length; ++idx) {

                                    const slot = slots[names[idx]];

                                    if (!slot.__$$classInit) {
                                        continue;
                                    }

                                    slot.__$$classInit();
                                }

                                Util.$poolArray(names);

                            }

                        }
                        break;

                    default:
                        break;

                }

                symbols[id] = symbol.path;
            }

            // set new symbol
            this.loaderInfo._$symbols = symbols;

        }

        // create main
        if (isMain) {

            const main = Util.$buildAVM2(
                this.loaderInfo._$applicationDomain,
                this.loaderInfo._$symbols[0]
            );
            main._$root = main;
            main._$symbolBuild(0, this.loaderInfo._$id, object);

            // init set
            this.loaderInfo._$content = main;

        } else {

            MovieClip._$targetBuild(this.loaderInfo._$content, object);
            this.loaderInfo._$content._$characterBuild();

        }

        // init scenes
        length = info._$sceneInfo.length;
        if (length) {

            const scenes = Util.$getArray();
            for (let idx = 0; idx < length; ++idx) {

                const sceneInfo = info._$sceneInfo[idx];

                // create Scene
                const scene    = new Scene(sceneInfo.name, Util.$getArray(), 1);
                scene._$offset = sceneInfo.offset;

                // set numFrames
                const next = idx + 1 | 0;

                let offset = this.loaderInfo._$content._$totalFrames;
                if (next in info._$sceneInfo) {
                    offset = info._$sceneInfo[next].offset | 0;
                }
                scene._$numFrames = offset - scene._$offset | 0;

                // set labels
                const labels = this.loaderInfo._$content.currentLabels;
                if (labels) {
                    const total  = labels.length;
                    const sceneLabels = Util.$getArray();
                    for (let idx = 0; idx < total; ++idx) {

                        const label = labels[idx];

                        if (label.frame > sceneInfo.offset && label.frame <= offset) {
                            sceneLabels[sceneLabels.length] = label;
                        }

                    }
                    scene._$labels = sceneLabels;
                }

                // set array
                scenes[scenes.length] = scene;

            }

            this.loaderInfo._$content._$scenes = scenes;
        }
    }
}

/**
 * @class
 * @memberOf parser
 */
class SVGToShape
{
    /**
     * @param  {string} value
     * @param  {MovieClip} movie_clip
     * @return {void}
     * @method
     * @static
     */
    static parse (value, movie_clip)
    {
        const defs  = /<defs>(.*)<\/defs>/sgi.exec(value);
        const paths = SVGToShape.parseXML(
            `${value.replace(/<defs>(.*)<\/defs>/sgi, "")}`
        );

        if (paths) {

            SVGToShape.parsePath(paths, movie_clip, defs ? defs[1] : null);

            const layers = [];
            for (const layer of movie_clip._$layers.values()) {
                layers.unshift(layer);
            }

            movie_clip.clearLayer();
            for (let idx = 0; idx < layers.length; ++idx) {
                movie_clip.setLayer(idx, layers[idx]);
            }
        }
    }

    /**
     * @param  {string} xml
     * @return {array}
     * @method
     * @static
     */
    static parseXML (xml)
    {
        const pathReg = /<((path|rect|circle|polygon).+?)\/>/gi;

        const paths = [];
        for (let reg = "1"; reg;) {
            reg = pathReg.exec(xml);
            reg && paths.push(reg[1]);
        }

        return paths;
    }

    /**
     * @param  {array}     paths
     * @param  {MovieClip} movie_clip
     * @param  {string}    [defs=null]
     * @method
     * @static
     */
    static parsePath (paths, movie_clip, defs = null)
    {
        const { Shape, Graphics } = window.next2d.display;
        const workSpace = Util.$currentWorkSpace();

        for (let idx = 0; idx < paths.length; ++idx) {

            const graphics = new Shape().graphics;

            const value = paths[idx];

            // STROKE
            let strokeWidth = /stroke-width=\"(.+?)\"/gi.exec(value);
            if (!strokeWidth) {
                strokeWidth = /stroke-width:(.+?)["|;]/gi.exec(value);
            }

            if (strokeWidth) {
                strokeWidth = +strokeWidth[1];
                if (strokeWidth) {
                    let color = /stroke=\"(.+?)\"/gi.exec(value);
                    if (!color) {
                        color = /stroke:(.+?)["|;]/gi.exec(value);
                    }

                    graphics.lineStyle(strokeWidth, color ? color[1] : 0);
                }
            }

            // FILL
            let color = /fill=\"(.+?)\"/gi.exec(value);
            if (!color) {
                color = /fill:(.+?)["|;]/gi.exec(value);
            }

            let alpha = 1;
            let style = /style=\"(.+?)\"/gi.exec(value);
            if (style && style[1].indexOf("opacity") > -1) {
                alpha = style[1].split(":")[1];
            }

            if (color) {
                graphics.beginFill(color[1], +alpha);
            } else {
                if (!strokeWidth) {
                    graphics.beginFill(0, +alpha);
                }
            }

            const id = workSpace.nextLibraryId;

            const shape = workSpace.addLibrary(
                Util
                    .$libraryController
                    .createInstance(InstanceType.SHAPE, `Shape_${id}`, id)
            );

            const layer = new Layer();
            layer.name  = `Layer_${movie_clip._$layers.size}`;

            movie_clip.setLayer(movie_clip._$layers.size, layer);

            const character = new Character();
            character.libraryId  = shape.id;

            const location = layer.adjustmentLocation(1);
            character.startFrame = location.startFrame;
            character.endFrame   = location.endFrame;

            character.setPlace(location.startFrame, {
                "frame": location.startFrame,
                "matrix": [1, 0, 0, 1, 0, 0],
                "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                "blendMode": "normal",
                "filter": [],
                "depth": layer._$characters.length
            });
            layer.addCharacter(character);

            // draw rect
            if (value.indexOf("rect") > -1) {

                const param  = value.replace("rect", "");
                const x      = +/x=\"(.+?)\"/gi.exec(param)[1];
                const y      = +/y=\"(.+?)\"/gi.exec(param)[1];
                const width  = +/width=\"(.+?)\"/gi.exec(param)[1];
                const height = +/height=\"(.+?)\"/gi.exec(param)[1];
                const rx     = +/rx=\"(.+?)\"/gi.exec(param)[1];

                graphics
                    .drawRoundRect(x, y, width, height, rx * 2)
                    .endFill();

                shape._$recodes = graphics._$recode.slice();
                shape._$bounds = {
                    "xMin": graphics._$xMin,
                    "xMax": graphics._$xMax,
                    "yMin": graphics._$yMin,
                    "yMax": graphics._$yMax
                };

                continue;
            }

            if (value.indexOf("circle") > -1) {

                const param = value.replace("rect", "");
                const x     = +/cx=\"(.+?)\"/gi.exec(param)[1];
                const y     = +/cy=\"(.+?)\"/gi.exec(param)[1];
                const r     = +/r=\"(.+?)\"/gi.exec(param)[1];

                graphics
                    .drawCircle(x, y, r)
                    .endFill();

                shape._$recodes = graphics._$recode.slice();
                shape._$bounds = {
                    "xMin": graphics._$xMin,
                    "xMax": graphics._$xMax,
                    "yMin": graphics._$yMin,
                    "yMax": graphics._$yMax
                };

                continue;
            }

            if (value.indexOf("polygon") > -1) {

                const path = value.replace("polygon", "");

                let points = /points=\"(.+?)\"/gi.exec(path)[1];

                points = points.replace(/,/g, " ");
                points = points.replace(/-/g, " -");
                points = points.trim().split(" ");
                points = SVGToShape._$adjParam(points);

                graphics.moveTo(+points[0], +points[1]);
                for (let idx = 2; idx < points.length; idx += 2) {
                    graphics.lineTo(
                        +points[idx    ],
                        +points[idx + 1]
                    );
                }
                graphics.endFill();

                shape._$recodes = graphics._$recode.slice();
                shape._$bounds = {
                    "xMin": graphics._$xMin,
                    "xMax": graphics._$xMax,
                    "yMin": graphics._$yMin,
                    "yMax": graphics._$yMax
                };

                continue;
            }

            let start   = false;
            let startX  = 0;
            let startY  = 0;

            const currentPoint = [0, 0];
            const lastControl  = [0, 0];
            const actionReg = /([a-z])([^a-z]*)/gi;

            const d = / d=\"(.+?)\"/gi.exec(value)[1];
            for (let reg = "1"; reg;) {

                // TODO transform
                // let tx = 0;
                // let ty = 0;
                // if (value.indexOf("translate") > -1) {
                //
                //     let translate = /translate\((.+?)\)/gi.exec(value)[1];
                //     translate = translate.replace(/,/g, " ");
                //     translate = translate.replace(/-/g, " -");
                //     translate = translate.trim().split(" ");
                //     translate = SVGToShape._$adjParam(translate);
                //
                //     const param = [];
                //     for (let idx = 0; idx < translate.length; ++idx) {
                //
                //         const value = translate[idx];
                //         if (value === "") {
                //             continue;
                //         }
                //
                //         param.push(+value);
                //     }
                //
                //     tx = param[0];
                //     ty = param[1];
                // }

                reg = actionReg.exec(d);
                if (reg) {

                    const type = `${reg[1]}`;

                    let param = reg[2];
                    switch (type) {

                        case "m":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            currentPoint[0] += +param[0];
                            currentPoint[1] += +param[1];

                            if (!start) {
                                start = true;
                                startX = currentPoint[0];
                                startY = currentPoint[1];
                            }

                            graphics.moveTo(
                                currentPoint[0],
                                currentPoint[1]
                            );

                            for (let idx = 2; idx < param.length; idx += 2) {
                                currentPoint[0] += +param[idx    ];
                                currentPoint[1] += +param[idx + 1];
                                lastControl[0]   = currentPoint[0];
                                lastControl[1]   = currentPoint[1];
                                graphics.lineTo(
                                    currentPoint[0],
                                    currentPoint[1]
                                );
                            }
                            break;

                        case "M":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            currentPoint[0] = +param[0];
                            currentPoint[1] = +param[1];

                            if (!start) {
                                start = true;
                                startX = currentPoint[0];
                                startY = currentPoint[1];
                            }

                            graphics.moveTo(
                                currentPoint[0],
                                currentPoint[1]
                            );

                            for (let idx = 2; idx < param.length; idx += 2) {
                                currentPoint[0] = +param[idx    ];
                                currentPoint[1] = +param[idx + 1];
                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                                graphics.lineTo(
                                    currentPoint[0],
                                    currentPoint[1]
                                );
                            }
                            break;

                        case "l":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 2) {
                                currentPoint[0] += +param[idx    ];
                                currentPoint[1] += +param[idx + 1];
                                lastControl[0]   = currentPoint[0];
                                lastControl[1]   = currentPoint[1];
                                graphics.lineTo(
                                    currentPoint[0],
                                    currentPoint[1]
                                );
                            }
                            break;

                        case "L":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 2) {
                                currentPoint[0] = +param[idx    ];
                                currentPoint[1] = +param[idx + 1];
                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                                graphics.lineTo(
                                    currentPoint[0],
                                    currentPoint[1]
                                );
                            }
                            break;

                        case "h":
                            currentPoint[0] += +param;
                            lastControl[0]   = currentPoint[0];
                            graphics.lineTo(
                                currentPoint[0],
                                currentPoint[1]
                            );
                            break;

                        case "H":
                            currentPoint[0] = +param;
                            lastControl[0]  = currentPoint[0];
                            graphics.lineTo(
                                currentPoint[0],
                                currentPoint[1]
                            );
                            break;

                        case "v":
                            currentPoint[1] += +param;
                            lastControl[1]   = currentPoint[1];
                            graphics.lineTo(
                                currentPoint[0],
                                currentPoint[1]
                            );
                            break;

                        case "V":
                            currentPoint[1] = +param;
                            lastControl[1]  = currentPoint[1];
                            graphics.lineTo(currentPoint[0], currentPoint[1]);
                            break;

                        case "q":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 4) {

                                param[idx    ] = +param[idx    ] + currentPoint[0];
                                param[idx + 1] = +param[idx + 1] + currentPoint[1];
                                param[idx + 2] = +param[idx + 2] + currentPoint[0];
                                param[idx + 3] = +param[idx + 3] + currentPoint[1];

                                graphics.curveTo(
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2], param[idx + 3]
                                );

                                currentPoint[0] = param[idx + 2];
                                currentPoint[1] = param[idx + 3];

                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                            }
                            break;

                        case "Q":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 4) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];

                                graphics.curveTo(
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2], param[idx + 3]
                                );

                                currentPoint[0] = param[idx + 2];
                                currentPoint[1] = param[idx + 3];

                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                            }
                            break;

                        case "c":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 6) {

                                param[idx    ] = +param[idx    ] + currentPoint[0];
                                param[idx + 1] = +param[idx + 1] + currentPoint[1];
                                param[idx + 2] = +param[idx + 2] + currentPoint[0];
                                param[idx + 3] = +param[idx + 3] + currentPoint[1];
                                param[idx + 4] = +param[idx + 4] + currentPoint[0];
                                param[idx + 5] = +param[idx + 5] + currentPoint[1];

                                graphics.cubicCurveTo(
                                    param[idx    ], param[idx + 1], param[idx + 2],
                                    param[idx + 3], param[idx + 4], param[idx + 5]
                                );

                                currentPoint[0] = param[idx + 4];
                                currentPoint[1] = param[idx + 5];

                                lastControl[0] = 2 * param[idx + 4] - param[idx + 2];
                                lastControl[1] = 2 * param[idx + 5] - param[idx + 3];
                            }

                            break;

                        case "C":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 6) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];
                                param[idx + 4] = +param[idx + 4];
                                param[idx + 5] = +param[idx + 5];

                                graphics.cubicCurveTo(
                                    param[idx    ], param[idx + 1], param[idx + 2],
                                    param[idx + 3], param[idx + 4], param[idx + 5]
                                );

                                currentPoint[0] = param[idx + 4];
                                currentPoint[1] = param[idx + 5];

                                lastControl[0] = 2 * param[idx + 4] - param[idx + 2];
                                lastControl[1] = 2 * param[idx + 5] - param[idx + 3];

                            }
                            break;

                        case "s":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 4) {

                                param[idx    ] = +param[idx    ] + currentPoint[0];
                                param[idx + 1] = +param[idx + 1] + currentPoint[1];
                                param[idx + 2] = +param[idx + 2] + currentPoint[0];
                                param[idx + 3] = +param[idx + 3] + currentPoint[1];

                                graphics.cubicCurveTo(
                                    lastControl[0], lastControl[1],
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2], param[idx + 3]
                                );

                                currentPoint[0] = param[idx + 2];
                                currentPoint[1] = param[idx + 3];

                                lastControl[0] = 2 * param[idx + 2] - param[idx    ];
                                lastControl[1] = 2 * param[idx + 3] - param[idx + 1];
                            }

                            break;

                        case "S":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 4) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];

                                graphics.cubicCurveTo(
                                    lastControl[0], lastControl[1],
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2], param[idx + 3]
                                );

                                currentPoint[0] = param[idx + 2];
                                currentPoint[1] = param[idx + 3];

                                lastControl[0] = 2 * param[idx + 2] - param[idx    ];
                                lastControl[1] = 2 * param[idx + 3] - param[idx + 1];
                            }
                            break;

                        case "a":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 7) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];
                                param[idx + 4] = +param[idx + 4];
                                param[idx + 5] = +param[idx + 5] + currentPoint[0];
                                param[idx + 6] = +param[idx + 6] + currentPoint[1];

                                const curves = SVGToShape._$arcToCurve(
                                    currentPoint[0], currentPoint[1],
                                    param[idx + 5], param[idx + 6],
                                    param[idx + 3], param[idx + 4],
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2]
                                );

                                for (let idx = 0; idx < curves.length; ++idx) {
                                    const curve = curves[idx];
                                    graphics.cubicCurveTo(
                                        curve[0], curve[1],
                                        curve[2], curve[3],
                                        curve[4], curve[5]
                                    );
                                }

                                currentPoint[0] = param[idx + 5];
                                currentPoint[1] = param[idx + 6];

                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                            }

                            break;

                        case "A":
                            param = param.replace(/,/g, " ");
                            param = param.replace(/-/g, " -");
                            param = param.trim().split(" ");
                            param = SVGToShape._$adjParam(param);

                            for (let idx = 0; idx < param.length; idx += 7) {

                                param[idx    ] = +param[idx    ];
                                param[idx + 1] = +param[idx + 1];
                                param[idx + 2] = +param[idx + 2];
                                param[idx + 3] = +param[idx + 3];
                                param[idx + 4] = +param[idx + 4];
                                param[idx + 5] = +param[idx + 5];
                                param[idx + 6] = +param[idx + 6];

                                const curves = SVGToShape._$arcToCurve(
                                    currentPoint[0], currentPoint[1],
                                    param[idx + 5], param[idx + 6],
                                    param[idx + 3], param[idx + 4],
                                    param[idx    ], param[idx + 1],
                                    param[idx + 2]
                                );

                                for (let idx = 0; idx < curves.length; ++idx) {
                                    const curve = curves[idx];
                                    graphics.cubicCurveTo(
                                        curve[0], curve[1],
                                        curve[2], curve[3],
                                        curve[4], curve[5]
                                    );
                                }

                                currentPoint[0] = param[idx + 5];
                                currentPoint[1] = param[idx + 6];

                                lastControl[0]  = currentPoint[0];
                                lastControl[1]  = currentPoint[1];
                            }
                            break;

                        case "z":
                        case "Z":
                            if (graphics._$fills) {
                                graphics._$fills.push(Graphics.CLOSE_PATH);
                            }
                            if (graphics._$lines) {
                                graphics._$lines.push(Graphics.CLOSE_PATH);
                            }

                            currentPoint[0] = startX;
                            currentPoint[1] = startY;
                            lastControl[0]  = currentPoint[0];
                            lastControl[1]  = currentPoint[1];
                            start = false;
                            break;

                        default:
                            console.log("TODO: ", type, param);
                            break;

                    }
                }
            }
            graphics.endLine();
            graphics.endFill();

            if (graphics._$recode) {
                shape._$recodes = graphics._$recode.slice();
            }

            shape._$bounds = {
                "xMin": graphics._$xMin,
                "xMax": graphics._$xMax,
                "yMin": graphics._$yMin,
                "yMax": graphics._$yMax
            };
        }
    }

    /**
     * @param  {array} param
     * @return {array}
     * @private
     */
    static _$adjParam (param)
    {
        for (;;) {
            let count = 0;
            for (let idx = 0; idx < param.length; ++idx) {

                const value = param[idx];
                if (!isNaN(value)) {
                    count++;
                    continue;
                }

                const values = value.split(".");
                param.splice(idx + 1, 0, `0.${values.pop()}`);
                param[idx] = values.join(".");
            }

            if (param.length === count) {
                break;
            }
        }
        return param;
    }

    /**
     * @param {next2d.display.Graphics} graphics
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {number} start_ang
     * @param {number} end_ang
     * @private
     * @static
     */
    static _$arc (graphics, x, y, radius, start_ang, end_ang)
    {
        let num = Math.min(Math.ceil(radius * 2 + 1), 1024);
        if (num < 1) {
            return;
        }

        start_ang = start_ang === undefined
            ? 0
            : start_ang;

        end_ang = end_ang === undefined
            ? Math.PI * 2
            : end_ang;

        const delta = (end_ang - start_ang) / num;
        for (let idx = 0; idx <= num; idx++) {
            const f = start_ang + idx * delta;
            graphics.lineTo(x + Math.cos(f) * radius, y + Math.sin(f) * radius);
        }
    }

    /**
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} fa
     * @param {number} fs
     * @param {number} rx
     * @param {number} ry
     * @param {number} phi
     * @private
     * @static
     */
    static _$arcToCurve (x1, y1, x2, y2, fa, fs, rx, ry, phi)
    {
        const TAU = Math.PI * 2;
        const sin_phi = Math.sin(phi * TAU / 360);
        const cos_phi = Math.cos(phi * TAU / 360);

        const x1p = cos_phi  * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
        const y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;

        if (x1p === 0 && y1p === 0 || rx === 0 || ry === 0) {
            return [];
        }

        rx = Math.abs(rx);
        ry = Math.abs(ry);

        const lambda = x1p * x1p / (rx * rx) + y1p * y1p / (ry * ry);
        if (lambda > 1) {
            rx *= Math.sqrt(lambda);
            ry *= Math.sqrt(lambda);
        }

        const cc = SVGToShape._$getArcCenter(
            x1, y1, x2, y2, fa, fs,
            rx, ry, sin_phi, cos_phi
        );

        const result = [];
        let theta1 = cc[2];
        let delta_theta = cc[3];

        const segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);
        delta_theta /= segments;

        for (let idx = 0; idx < segments; idx++) {
            result.push(SVGToShape._$approximateUnitArc(theta1, delta_theta));
            theta1 += delta_theta;
        }

        return result.map((curve) =>
        {
            for (let idx = 0; idx < curve.length; idx += 2) {

                let x = curve[idx    ];
                let y = curve[idx + 1];

                // scale
                x *= rx;
                y *= ry;

                // rotate
                const xp = cos_phi * x - sin_phi * y;
                const yp = sin_phi * x + cos_phi * y;

                // translate
                curve[idx    ] = xp + cc[0];
                curve[idx + 1] = yp + cc[1];
            }

            curve.shift();
            curve.shift();

            return curve;
        });
    }

    /**
     * @param {number} theta1
     * @param {number} delta_theta
     * @return {array}
     * @private
     * @static
     */
    static _$approximateUnitArc (theta1, delta_theta)
    {
        const alpha = 4 / 3 * Math.tan(delta_theta / 4);

        const x1 = Math.cos(theta1);
        const y1 = Math.sin(theta1);
        const x2 = Math.cos(theta1 + delta_theta);
        const y2 = Math.sin(theta1 + delta_theta);

        return [
            x1, y1,
            x1 - y1 * alpha,
            y1 + x1 * alpha,
            x2 + y2 * alpha,
            y2 - x2 * alpha,
            x2, y2
        ];
    }

    /**
     *
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} fa
     * @param {number} fs
     * @param {number} rx
     * @param {number} ry
     * @param {number} sin_phi
     * @param {number} cos_phi
     * @return {array}
     * @private
     * @static
     */
    static _$getArcCenter (x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi)
    {
        const TAU = Math.PI * 2;

        const x1p = cos_phi  * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
        const y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;

        const rx_sq  = rx * rx;
        const ry_sq  = ry * ry;
        const x1p_sq = x1p * x1p;
        const y1p_sq = y1p * y1p;

        let radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;

        if (radicant < 0) {
            radicant = 0;
        }

        radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;
        radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);

        const cxp = radicant *  rx / ry * y1p;
        const cyp = radicant * -ry / rx * x1p;

        const cx = cos_phi * cxp - sin_phi * cyp + (x1 + x2) / 2;
        const cy = sin_phi * cxp + cos_phi * cyp + (y1 + y2) / 2;

        const v1x = (x1p - cxp)  / rx;
        const v1y = (y1p - cyp)  / ry;
        const v2x = (-x1p - cxp) / rx;
        const v2y = (-y1p - cyp) / ry;

        const theta1 = SVGToShape._$unitVectorAngle(1, 0, v1x, v1y);
        let delta_theta = SVGToShape._$unitVectorAngle(v1x, v1y, v2x, v2y);

        if (fs === 0 && delta_theta > 0) {
            delta_theta -= TAU;
        }
        if (fs === 1 && delta_theta < 0) {
            delta_theta += TAU;
        }

        return [cx, cy, theta1, delta_theta];
    }

    /**
     * @param  {number} ux
     * @param  {number} uy
     * @param  {number} vx
     * @param  {number} vy
     * @return {number}
     * @static
     * @private
     */
    static _$unitVectorAngle (ux, uy, vx, vy)
    {
        const sign = ux * vy - uy * vx < 0 ? -1 : 1;
        let dot = ux * vx + uy * vy;

        if (dot > 1.0) {
            dot = 1.0;
        }

        if (dot < -1.0) {
            dot = -1.0;
        }

        return sign * Math.acos(dot);
    }
}

/**
 * @class
 * @memberOf parser
 */
class VectorToCanvas
{
    /**
     * @param   {object} src
     * @returns {object}
     * @public
     */
    clone (src)
    {
        const execute = function (src, obj)
        {
            const keys   = Object.keys(src);
            const length = keys.length | 0;
            for (let idx = 0; idx < length; ++idx) {

                const prop  = keys[idx];
                const value = src[prop];

                switch (true) {

                    case Util.$isArray(value):
                        obj[prop] = [];
                        execute(value, obj[prop]);
                        break;

                    case typeof value === "object":
                        obj[prop] = {};
                        execute(value, obj[prop]);
                        break;

                    default:
                        obj[prop] = value;
                        break;

                }
            }
        };

        const obj = {};
        execute(src, obj);

        return obj;
    }

    /**
     * @param   {object}  shapes
     * @param   {boolean} [is_morph=false]
     * @returns {array}
     * @public
     */
    convert (shapes, is_morph = false)
    {
        let lineStyles = shapes.lineStyles;
        let fillStyles = shapes.fillStyles;
        let idx        = 0;
        let obj        = {};
        let cache      = [];
        let AnchorX    = 0;
        let AnchorY    = 0;
        let MoveX      = 0;
        let MoveY      = 0;
        let LineX      = 0;
        let LineY      = 0;
        let FillStyle0 = 0;
        let FillStyle1 = 0;
        let LineStyle  = 0;
        let fills0     = [];
        let fills1     = [];
        let lines      = [];
        let stack      = [];
        let depth      = 0;

        // setup
        const shapeData = shapes.ShapeData;
        const records   = shapeData.records;
        const newStyles = shapeData.styles;

        let i = 0;
        let s = 0;
        for (;;) {

            const state = records[i++];

            // end
            if (state === -1) {
                stack = this.setStack(stack, this.fillMerge(fills0, fills1, is_morph));
                stack = this.setStack(stack, lines);
                break;
            }

            // data change
            if (state) {

                ++depth;

                // StateNewStyles
                if (records[i++]) {

                    //  build data
                    stack   = this.setStack(stack, this.fillMerge(fills0, fills1, is_morph));
                    stack   = this.setStack(stack, lines);

                    // reset
                    AnchorX = 0;
                    AnchorY = 0;
                    fills0  = [];
                    fills1  = [];
                    lines   = [];

                    const styles = newStyles[s++];
                    if (records[i++]) {
                        fillStyles = styles.FillStyles;
                    }

                    if (records[i++]) {
                        lineStyles = styles.LineStyles;
                    }

                }

                // default
                MoveX = AnchorX;
                MoveY = AnchorY;

                // override
                if (records[i++]) {
                    MoveX = AnchorX = records[i++] / 20;
                    MoveY = AnchorX = records[i++] / 20;
                }

                LineX = MoveX;
                LineY = MoveY;

                // StateFillStyle0
                if (records[i++]) {
                    FillStyle0 = records[i++];
                }

                // StateFillStyle1
                if (records[i++]) {
                    FillStyle1 = records[i++];
                }

                // StateLineStyle
                if (records[i++]) {
                    LineStyle = records[i++];
                }

                continue;
            }

            const isCurved = records[i++];
            const ControlX = isCurved ? records[i++] / 20 : 0;
            const ControlY = isCurved ? records[i++] / 20 : 0;
            AnchorX        = records[i++] / 20;
            AnchorY        = records[i++] / 20;

            const record = {
                "isCurved": isCurved,
                "ControlX": ControlX,
                "ControlY": ControlY,
                "AnchorX":  AnchorX,
                "AnchorY":  AnchorY
            };

            // fill0
            if (FillStyle0) {

                idx = FillStyle0 - 1 | 0;
                if (!(idx in fills0)) {
                    fills0[idx] = [];
                }

                if (!(depth in fills0[idx])) {
                    fills0[idx][depth] = {
                        "obj":    fillStyles ? fillStyles[idx] : null,
                        "startX": MoveX,
                        "startY": MoveY,
                        "endX":   0,
                        "endY":   0,
                        "cache":  []
                    };
                }

                obj   = fills0[idx][depth];
                cache = obj.cache;
                cache[cache.length] = this.clone(record);

                obj.endX = AnchorX;
                obj.endY = AnchorY;
            }

            // fill1
            if (FillStyle1) {

                idx = FillStyle1 - 1 | 0;
                if (!(idx in fills1)) {
                    fills1[idx] = [];
                }

                if (!(depth in fills1[idx])) {
                    fills1[idx][depth] = {
                        "obj":    fillStyles ? fillStyles[idx] : null,
                        "startX": MoveX,
                        "startY": MoveY,
                        "endX":   0,
                        "endY":   0,
                        "cache":  []
                    };
                }

                obj   = fills1[idx][depth];
                cache = obj.cache;
                cache[cache.length] = this.clone(record);

                obj.endX = AnchorX;
                obj.endY = AnchorY;
            }

            // lines
            if (LineStyle) {

                idx = LineStyle - 1 | 0;
                if (!(idx in lines)) {
                    lines[idx] = {
                        "obj":   lineStyles ? lineStyles[idx] : null,
                        "cache": []
                    };
                }

                obj   = lines[idx];
                cache = obj.cache;
                cache[cache.length] = [0, LineX, LineY];

                let code = [2, AnchorX, AnchorY];
                if (isCurved) {
                    code = [1, ControlX, ControlY, AnchorX, AnchorY];
                }

                cache[cache.length] = code;
            }

            LineX = AnchorX;
            LineY = AnchorY;
        }

        return this.toGraphicPath(stack);
    }

    /**
     * @param  {array} stack
     * @return {array}
     * @public
     */
    toGraphicPath (stack)
    {
        const {
            Graphics,
            GradientType,
            InterpolationMethod,
            SpreadMethod,
            CapsStyle,
            JointStyle
        } = window.next2d.display;

        let inBitmap = false;
        const recodes = [];
        for (let idx = 0; idx < stack.length; ++idx) {

            const data = stack[idx];

            recodes.push(Graphics.BEGIN_PATH);

            for (let idx = 0; idx < data.recode.length; ++idx) {
                recodes.push.apply(recodes, data.recode[idx]);
            }

            const isStroke = "Width" in data.object;
            let lineWidth  = 0;
            let capsStyle  = CapsStyle.NONE;
            let miterLimit = 0;
            let jointStyle = JointStyle.ROUND;
            if (isStroke) {

                lineWidth = data.object.Width;

                switch (data.object.StartCapStyle) {

                    case 0:
                        capsStyle = CapsStyle.ROUND;
                        break;

                    case 1:
                        capsStyle = CapsStyle.NONE;
                        break;

                    case 2:
                        capsStyle = CapsStyle.SQUARE;
                        break;

                }

                switch (data.object.JoinStyle) {

                    case 0:
                        jointStyle = JointStyle.ROUND;
                        break;

                    case 1:
                        jointStyle = JointStyle.BEVEL;
                        break;

                    case 2:
                        jointStyle = JointStyle.MITER;
                        miterLimit = data.object.MiterLimitFactor;
                        break;

                }
            }

            const styleObject = data.object.HasFillFlag
                ? data.object.FillType
                : data.object;

            switch (styleObject.fillStyleType) {

                case 0x00: // solid fill

                    if (isStroke) {

                        recodes.push(
                            Graphics.STROKE_STYLE,
                            lineWidth,
                            capsStyle,
                            jointStyle,
                            miterLimit,
                            styleObject.Color.R,
                            styleObject.Color.G,
                            styleObject.Color.B,
                            styleObject.Color.A * 255,
                            Graphics.END_STROKE
                        );

                    } else {

                        recodes.push(
                            Graphics.FILL_STYLE,
                            styleObject.Color.R,
                            styleObject.Color.G,
                            styleObject.Color.B,
                            styleObject.Color.A * 255,
                            Graphics.END_FILL
                        );

                    }

                    break;

                case 0x10: // linear gradient fill
                case 0x12: // radial gradient fill
                case 0x13: // radial gradient fill
                    {
                        const gradient = styleObject.gradient;

                        const colorStops = [];
                        const gradientRecords = gradient.GradientRecords;
                        for (let idx = 0; idx < gradientRecords.length; ++idx) {
                            const recode = gradientRecords[idx];
                            colorStops.push({
                                "ratio": recode.Ratio,
                                "R": recode.Color.R,
                                "G": recode.Color.G,
                                "B": recode.Color.B,
                                "A": recode.Color.A * 255
                            });
                        }

                        const interpolationMode = gradient.InterpolationMode === 0
                            ? InterpolationMethod.RGB
                            : InterpolationMethod.LINEAR_RGB;

                        let spreadMode = SpreadMethod.PAD;
                        switch (gradient.SpreadMode) {

                            case 0:
                                spreadMode = SpreadMethod.PAD;
                                break;

                            case 1:
                                spreadMode = SpreadMethod.REFLECT;
                                break;

                            case 2:
                                spreadMode = SpreadMethod.REPEAT;
                                break;

                        }

                        if (isStroke) {

                            recodes.push(
                                Graphics.GRADIENT_STROKE,
                                lineWidth,
                                capsStyle,
                                jointStyle,
                                miterLimit,
                                styleObject.fillStyleType === 0x10
                                    ? GradientType.LINEAR
                                    : GradientType.RADIAL,
                                colorStops,
                                styleObject.gradientMatrix,
                                spreadMode,
                                interpolationMode,
                                gradient.FocalPoint
                            );

                        } else {

                            recodes.push(
                                Graphics.GRADIENT_FILL,
                                styleObject.fillStyleType === 0x10
                                    ? GradientType.LINEAR
                                    : GradientType.RADIAL,
                                colorStops,
                                styleObject.gradientMatrix,
                                spreadMode,
                                interpolationMode,
                                gradient.FocalPoint
                            );

                        }
                    }
                    break;

                case 0x40: // repeating bitmap fill
                case 0x41: // clipped bitmap fill
                case 0x42: // non-smoothed repeating bitmap fill
                case 0x43: // non-smoothed clipped bitmap fill
                    {
                        inBitmap = true;
                        const bitmap = Util
                            .$currentWorkSpace()
                            .getLibrary(
                                Util.$characters.get(styleObject.bitmapId)
                            );

                        // eslint-disable-next-line no-loop-func
                        const wait = function (recodes, style_object)
                        {
                            if (!this._$buffer) {
                                return requestAnimationFrame(wait);
                            }

                            const smooth =
                                style_object.fillStyleType === 0x40
                                || style_object.fillStyleType === 0x41;

                            const repeat =
                                style_object.fillStyleType === 0x40
                                || style_object.fillStyleType === 0x42;

                            const matrix = Util.$multiplicationMatrix(
                                style_object.bitmapMatrix,
                                [0.05, 0, 0, 0.05, 0, 0]
                            );

                            const { BitmapData } = window.next2d.display;
                            const bitmapData = new BitmapData(
                                this.width, this.height, true, 0
                            );
                            bitmapData._$buffer = this._$buffer;

                            recodes.push(
                                Graphics.BITMAP_FILL,
                                bitmapData,
                                Array.from(matrix),
                                repeat ? "repeat" : "no-repeat",
                                smooth
                            );

                        }.bind(bitmap, recodes, styleObject);
                        wait();
                    }
                    break;

                default:
                    break;

            }
        }

        recodes.push(inBitmap);
        return recodes;
    }

    /**
     * @param   {array}   fills0
     * @param   {array}   fills1
     * @param   {boolean} is_morph
     * @returns {array}
     * @public
     */
    fillMerge (fills0, fills1, is_morph)
    {
        fills0 = this.fillReverse(fills0);

        if (fills0.length) {

            const keys   = Object.keys(fills0);
            const length = keys.length | 0;
            for (let key = 0; key < length; ++key) {

                const idx   = keys[key];
                const fills = fills0[idx];

                if (idx in fills1) {

                    const fill1 = fills1[idx];
                    const fKeys = Object.keys(fills);
                    const kLen  = fKeys.length | 0;
                    for (let kIdx = 0; kIdx < kLen; ++kIdx) {
                        fill1[fill1.length] = fills[fKeys[kIdx]];
                    }

                } else {

                    fills1[idx] = fills;

                }
            }
        }

        return this.coordinateAdjustment(fills1, is_morph);
    }

    /**
     * @param   {array} fills0
     * @returns {array}
     * @public
     */
    fillReverse (fills0)
    {
        if (!fills0.length) {
            return fills0;
        }

        const f0Keys = Object.keys(fills0);
        const f0Len  = f0Keys.length | 0;
        for (let f0Idx = 0; f0Idx < f0Len; ++f0Idx) {

            const i     = f0Keys[f0Idx];
            const fills = fills0[i];
            const fKeys = Object.keys(fills);
            const fLen  = fKeys.length | 0;
            for (let fIdx = 0; fIdx < fLen; ++fIdx) {

                const depth   = fKeys[fIdx];

                let AnchorX = 0;
                let AnchorY = 0;
                const obj   = fills[depth];
                let cacheX  = obj.startX;
                let cacheY  = obj.startY;
                const cache = obj.cache;
                let length  = cache.length | 0;
                if (length) {

                    const cKeys = Object.keys(cache);
                    const cLen  = cKeys.length | 0;
                    for (let cIdx = 0; cIdx < cLen; ++cIdx) {
                        const idx      = cKeys[cIdx];
                        const recode   = cache[idx];
                        AnchorX        = recode.AnchorX;
                        AnchorY        = recode.AnchorY;
                        recode.AnchorX = cacheX;
                        recode.AnchorY = cacheY;
                        cacheX         = AnchorX;
                        cacheY         = AnchorY;
                    }

                    const array = [];
                    if (length > 0) {

                        while (length) {

                            --length;

                            array[array.length] = cache[length];

                        }

                    }

                    obj.cache = array;

                }

                // set
                cacheX     = obj.startX;
                cacheY     = obj.startY;
                obj.startX = obj.endX;
                obj.startY = obj.endY;
                obj.endX   = cacheX;
                obj.endY   = cacheY;
            }
        }

        return fills0;
    }

    /**
     * @param   {array}   fills1
     * @param   {boolean} is_morph
     * @returns {array}
     * @public
     */
    coordinateAdjustment (fills1, is_morph)
    {
        const f1Keys = Object.keys(fills1);
        const f1Len  = f1Keys.length | 0;
        for (let f1Idx = 0; f1Idx < f1Len; ++f1Idx) {

            // setup
            const i     = f1Keys[f1Idx];
            const array = [];
            const fills = fills1[i];

            const fKeys = Object.keys(fills);
            const fLen  = fKeys.length | 0;
            for (let fIdx = 0; fIdx < fLen; ++fIdx) {
                array[array.length] = fills[fKeys[fIdx]];
            }

            let adjustment = [];
            switch (true) {

                case array.length > 1 && !is_morph:

                    for (;;) {

                        if (!array.length) {
                            break;
                        }

                        const fill = array.shift();
                        if (fill.startX === fill.endX && fill.startY === fill.endY) {
                            adjustment[adjustment.length] = fill;
                            continue;
                        }

                        let isMatch = 0;
                        let length  = array.length | 0;
                        while (length) {

                            --length;

                            const comparison = array[length];
                            if (comparison.startX === fill.endX && comparison.startY === fill.endY) {

                                fill.endX  = comparison.endX;
                                fill.endY  = comparison.endY;

                                const cache0 = fill.cache;
                                const cache1 = comparison.cache;
                                const cLen   = cache1.length | 0;
                                for (let cIdx = 0; cIdx < cLen; ++cIdx) {
                                    cache0[cache0.length] = cache1[cIdx];
                                }

                                array.splice(length, 1);
                                array.unshift(fill);
                                isMatch = 1;

                                break;
                            }
                        }

                        if (!isMatch) {
                            array.unshift(fill);
                        }

                    }

                    break;

                default:
                    adjustment = array;
                    break;

            }

            const aLen  = adjustment.length | 0;
            const cache = [];

            let obj = {};
            for (let idx = 0; idx < aLen; ++idx) {

                const data = adjustment[idx];
                obj        = data.obj;

                const caches = data.cache;
                const cacheLength = caches.length | 0;
                cache[cache.length] = [0, data.startX, data.startY];

                for (let compIdx = 0; compIdx < cacheLength; ++compIdx) {
                    const r = caches[compIdx];
                    cache[cache.length] = r.isCurved
                        ? [1, r.ControlX, r.ControlY, r.AnchorX, r.AnchorY]
                        : [2, r.AnchorX, r.AnchorY];
                }
            }

            fills1[i] = {
                "cache": cache,
                "obj":   obj
            };

        }

        return fills1;
    }

    /**
     * @param   {array} stack
     * @param   {array} array
     * @returns {array}
     * @public
     */
    setStack (stack, array)
    {
        if (array.length) {
            const keys   = Object.keys(array);
            const length = keys.length | 0;
            for (let idx = 0; idx < length; ++idx) {

                const data = array[keys[idx]];

                stack.push({
                    "object": data.obj,
                    "recode": data.cache
                });
            }
        }

        return stack;
    }
}
Util.$vtc = new VectorToCanvas();

/**
 * @class
 * @memberOf global
 */
class WorkSpace
{
    /**
     * @param {string} [json=""]
     *
     * @constructor
     * @public
     */
    constructor (json = "")
    {
        this._$name            = "";
        this._$scene           = null;
        this._$stage           = null;
        this._$libraries       = new Map();
        this._$nameMap         = new Map();
        this._$plugins         = new Map();
        this._$position        = 0;
        this._$ruler           = false;
        this._$rulerX          = [];
        this._$rulerY          = [];
        this._$characterId     = 0;
        this._$revision        = [];
        this._$currentData     = null;
        this._$timelineHeight  = TimelineAdjustment.TIMELINE_DEFAULT_SIZE;
        this._$controllerWidth = ControllerAdjustment.DEFAULT_SIZE;

        if (json) {
            this.load(json);
        }

        if (!this._$libraries.has(0)) {

            const root = new MovieClip({
                "id": 0,
                "type": InstanceType.MOVIE_CLIP,
                "name": "main",
                "symbol": ""
            });

            this._$libraries.set(0, root);
        }

        if (!this._$stage) {
            this._$stage = new Stage();
        }
    }

    /**
     * @description rootのMovieClipを戻す
     *
     * @return {MovieClip}
     * @readonly
     * @public
     */
    get root ()
    {
        return this._$libraries.get(0);
    }

    /**
     * @description プロジェクトのStageオブジェクトを返す
     *
     * @return {Stage}
     * @readonly
     * @public
     */
    get stage ()
    {
        return this._$stage;
    }

    /**
     * @description プロジェクト名を返す
     *
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @description プロジェクト名をセット
     *
     * @param  {string} name
     * @return {void}
     * @public
     */
    set name (name)
    {
        this._$name = `${name}`;
    }

    /**
     * @description 現在表示中のシーン(MovieClip)を返す
     *
     * @return {MovieClip}
     * @public
     */
    get scene ()
    {
        return this._$scene;
    }

    /**
     * @description 指定のシーン(MovieClip)を起動する
     *
     * @param  {MovieClip} scene
     * @return {void}
     * @public
     */
    set scene (scene)
    {
        if (this._$scene) {
            this._$scene.stop();
        }

        this._$scene = scene;
        scene.initialize();
    }

    /**
     * @description ライブラリのユニークIDを生成
     *
     * @return {number}
     * @readonly
     * @public
     */
    get nextLibraryId ()
    {
        const keys = Array.from(this._$libraries.keys());
        keys.sort(function (a, b)
        {
            if (a > b) {
                return 1;
            }

            if (a < b) {
                return -1;
            }

            return 0;
        });

        const lastLibraryId = this._$libraries.get(keys.pop() | 0).id | 0;
        return lastLibraryId + 1;
    }

    /**
     * @description 初期起動関数
     *
     * @param  {MovieClip} scene
     * @return {void}
     * @public
     */
    initialize (scene)
    {
        // シーンをセット
        this.scene = scene;

        // 選択中のライブラリを非アクティブに
        Util.$libraryController.clearActive();

        // ライブラリを初期化
        Util.$libraryController.reload(
            Array.from(this._$libraries.values())
        );

        // 内部スクリプトを初期化
        Util.$javascriptController.reload();

        // プラグインを初期化
        Util.$pluginController.reload(
            Array.from(this._$plugins.values())
        );

        // スクリーンの表示をrootに変更
        Util.$sceneChange.reload();
    }

    /**
     * @description 起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    run ()
    {
        document
            .documentElement
            .style
            .setProperty(
                "--timeline-height",
                `${this._$timelineHeight}px`
            );

        document
            .documentElement
            .style
            .setProperty(
                "--controller-width",
                `${this._$controllerWidth}px`
            );

        // ステージをセット
        this.stage.initialize();

        // 初期化
        this.initialize(this.root);
    }

    /**
     * @description プロジェクトを停止
     *
     * @return {void}
     * @method
     * @public
     */
    stop ()
    {
        if (this._$scene) {
            this._$scene.stop();
            this._$scene = null;
        }

        // 定規を初期化
        Util.$screenRuler.clear();
    }

    /**
     * @description 指定のプロジェクトJSONを読み込む
     *
     * @param  {string} json
     * @return {void}
     * @method
     * @public
     */
    load (json)
    {
        const object = JSON.parse(json);

        // copy
        this._$characterId = object.characterId | 0;
        this._$name        = object.name;
        this._$stage       = new Stage(object.stage);

        if (this._$plugins.size) {
            this._$plugins.clear();
        }

        if (object.plugins) {
            for (let idx = 0; idx < object.plugins.length; ++idx) {
                const plugin = object.plugins[idx];
                this._$plugins.set(plugin.name, plugin);
            }
        }

        if (this._$libraries.size) {
            this._$libraries.clear();
        }

        const libraries = object.libraries;
        for (let idx = 0; idx < libraries.length; ++idx) {
            this.addLibrary(libraries[idx]);
        }

        // settings
        if (object.setting) {
            this._$timelineHeight  = object.setting.timelineHeight;
            this._$controllerWidth = object.setting.controllerWidth;
            this._$ruler           = !!object.setting.ruler;
            this._$rulerX          = object.setting.rulerX || [];
            this._$rulerY          = object.setting.rulerY || [];
        }
    }

    /**
     * @description プロジェクトのJSONを生成
     *
     * @return {string}
     * @method
     * @public
     */
    toJSON ()
    {
        // ライブラリデータ
        const libraries = [];
        for (const value of this._$libraries.values()) {
            libraries.push(value.toObject());
        }

        return JSON.stringify({
            "version": Util.VERSION,
            "name": this.name,
            "characterId": this._$characterId,
            "stage": this.stage.toObject(),
            "libraries": libraries,
            "plugins": Array.from(this._$plugins.values()),
            "setting": {
                "timelineHeight":  this._$timelineHeight,
                "controllerWidth": this._$controllerWidth,
                "ruler": this._$ruler,
                "rulerX": this._$rulerX.slice(0),
                "rulerY": this._$rulerY.slice(0)
            }
        });
    }

    /**
     * @description メモリに現在のプロジェクトデータを保存
     *
     * @return {void}
     * @method
     * @public
     */
    temporarilySaved ()
    {
        Util.$updated = true;
        if (this._$currentData) {
            this._$currentData = null;
        }

        if (this._$position !== this._$revision.length) {
            this._$revision.length = this._$position;
        }

        this._$revision.push(this.toJSON());
        this._$position++;

        // remove old data
        if (this._$revision.length > Util.REVISION_LIMIT) {

            this._$revision.shift();

            this._$position = this._$revision.length;
        }
    }

    /**
     * @description 保存した一個前のプロジェクトデータを読み込む
     *
     * @return {void}
     * @method
     * @public
     */
    undo ()
    {
        if (!this._$position) {
            return ;
        }

        if (!this._$currentData) {
            this._$currentData = this.toJSON();
        }

        this.reloadData(this._$revision[--this._$position]);
    }

    /**
     * @description 保存した一個先のプロジェクトデータを読み込む
     *
     * @return {void}
     * @method
     * @public
     */
    redo ()
    {
        if (!this._$revision.length
            || this._$position === this._$revision.length
        ) {
            return ;
        }

        let data = null;
        if (this._$position + 1 === this._$revision.length) {

            if (!this._$currentData) {
                return ;
            }

            data = this._$currentData;

            this._$position++;
            this._$currentData = null;

        } else {

            data = this._$revision[++this._$position];

        }

        if (!data) {
            return ;
        }

        this.reloadData(data);
    }

    /**
     * @description undo/redoのデータの再読み込み
     *
     * @param  {string} data
     * @return {void}
     * @method
     * @public
     */
    reloadData (data)
    {
        const layerIds = [];
        const targetLayers = Util.$timelineLayer.targetLayers;
        for (const layerId of targetLayers.keys()) {
            layerIds.push(layerId);
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();
        Util.$tools.reset();

        // 値をキャッシュ
        const currentFrame   = this._$scene.currentFrame;
        const currentSceneId = this._$scene.id;

        // シーンを初期化
        this._$scene.stop();
        this._$scene = null;

        // 再読み込み
        this.load(data);

        // loadしたデータでレイヤーを再構築
        const scene = this.getLibrary(currentSceneId);
        scene._$currentFrame = currentFrame;
        this.initialize(scene);

        // 再読み込み
        if (layerIds.length) {

            const ctrlKey = Util.$ctrlKey;
            Util.$ctrlKey = true;
            for (let idx = 0; idx < layerIds.length; ++idx) {

                const element = document
                    .getElementById(`${layerIds[idx]}`);

                if (!element) {
                    continue;
                }

                Util.$timelineLayer.activeLayer(element);
            }

            Util.$ctrlKey = ctrlKey;
        }
    }

    /**
     * @description ライブラリに追加されたObjectをプロジェクト内部に格納
     *
     * @param  {object} library
     * @return {object}
     * @method
     * @public
     */
    addLibrary (library)
    {
        let instance;
        switch (library.type) {

            case InstanceType.MOVIE_CLIP:
                instance = new MovieClip(library);
                break;

            case InstanceType.BITMAP:
                instance = new Bitmap(library);
                break;

            case InstanceType.TEXT:
                instance = new TextField(library);
                break;

            case InstanceType.SOUND:
                instance = new Sound(library);
                break;

            case InstanceType.VIDEO:
                instance = new Video(library);
                break;

            case InstanceType.SHAPE:
                instance = new Shape(library);
                break;

            case InstanceType.FOLDER:
                instance = new Folder(library);
                break;

        }

        this._$libraries.set(instance.id, instance);

        return instance;
    }

    /**
     * @description 指定のライブラリのアイテムを返す
     *
     * @param  {uint} id
     * @return {object}
     * @method
     * @public
     */
    getLibrary (id)
    {
        return this._$libraries.get(id | 0);
    }

    /**
     * @description 指定のライブラリのアイテムを削除
     *
     * @param  {uint} id
     * @return {void}
     * @method
     * @public
     */
    removeLibrary (id)
    {
        this._$libraries.delete(id | 0);
    }
}

/**
 * ツールのイベントを管理するクラス
 * Class to manage tool events
 *
 * @class
 * @memberOf event
 */
class EventDispatcher
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @description イベント関数のマッピング変数
         * @type {Map}
         * @private
         */
        this._$events = new Map();
    }

    /**
     * @description イベント登録関数
     *              event registration function
     *
     * @param {string} type
     * @param {function} callback
     * @method
     * @public
     */
    addEventListener (type, callback)
    {
        if (!this._$events.has(type)) {
            this._$events.set(type, []);
        }

        this
            ._$events
            .get(type)
            .push(callback);
    }

    /**
     * @description 登録したイベントの起動関数
     *              Launch function for registered events
     *
     * @param  {string} type
     * @param  {MouseEvent|Event} [event=null]
     * @return {void}
     * @method
     * @public
     */
    dispatchEvent (type, event = null)
    {
        if (!this._$events.has(type)) {
            return ;
        }

        const events = this._$events.get(type);
        for (let idx = 0; idx < events.length; ++idx) {
            const callback = events[idx];
            callback(event);
        }
    }
}

/**
 * イベントの型の固定値
 * Fixed value of event type
 *
 * @class
 * @memberOf event
 */
class EventType
{
    /**
     * @description マウスダウンのイベント名
     *              Mouse down event name
     *
     * @return {string}
     * @static
     * @const
     */
    static get MOUSE_DOWN ()
    {
        return "mousedown";
    }

    /**
     * @description マウスアップのイベント名
     *              Mouse-up event name
     *
     * @return {string}
     * @static
     * @const
     */
    static get MOUSE_UP ()
    {
        return "mouseup";
    }

    /**
     * @description マウスムーブのイベント名
     *              Mouse move event name
     *
     * @return {string}
     * @static
     * @const
     */
    static get MOUSE_MOVE ()
    {
        return "mousemove";
    }

    /**
     * @description ツール起動時のイベント名
     *              Event name at tool startup
     *
     * @return {string}
     * @static
     * @const
     */
    static get START ()
    {
        return "start";
    }

    /**
     * @description ツール終了時のイベント名
     *              Event name at end of tool
     *
     * @return {string}
     * @static
     * @const
     */
    static get END ()
    {
        return "end";
    }

    /**
     * @description ダブルクリック時のイベント名
     *              Event name on double-click
     *
     * @return {string}
     * @static
     * @const
     */
    static get DBL_CLICK ()
    {
        return "dblclick";
    }

    /**
     * @description Input、Selectの変更時のイベント名
     *              Event name when Input or Select is changed
     *
     * @return {string}
     * @static
     * @const
     */
    static get CHANGE ()
    {
        return "change";
    }

    /**
     * @description マウスオーバのイベント名
     *              Mouse over event name
     *
     * @return {string}
     * @static
     * @const
     */
    static get MOUSE_OVER ()
    {
        return "mouseover";
    }

    /**
     * @description マウスアウトのイベント名
     *              Mouse-out event name
     *
     * @return {string}
     * @static
     * @const
     */
    static get MOUSE_OUT ()
    {
        return "mouseout";
    }

    /**
     * @description キーボード押下のイベント名
     *              Event name for keyboard presses
     *
     * @return {string}
     * @static
     * @const
     */
    static get KEY_DOWN ()
    {
        return "keydown";
    }

    /**
     * @description マウスが指定領域から出た際のイベント名
     *              Event name when the mouse leaves the specified area
     *
     * @return {string}
     * @static
     * @const
     */
    static get MOUSE_LEAVE ()
    {
        return "mouseleave";
    }
}


/**
 * Inputタグの共有イベントクラス、マウスでの数値変動やフォーカスの状態管理
 * Shared event class for Input tag, numerical value change with mouse and focus state management
 *
 * @class
 * @memberOf event
 */
class InputEvent
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @description 自動セーブの判定フラグ
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;

        /**
         * @description フォーカスされたかの判定変数
         * @type {boolean}
         * @default false
         * @private
         */
        this._$focus = false;

        /**
         * @description 発火したイベントオブジェクト
         * @type {Event}
         * @default null
         * @private
         */
        this._$currentEvent = null;

        /**
         * @description 指定されたInputElement
         *
         * @type {HTMLInputElement}
         * @default null
         * @private
         */
        this._$currentTarget = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;
    }

    /**
     * @description Input Elementにイベント登録
     *              Event registration to Input Element
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setInputEvent (element)
    {
        if (!element) {
            return ;
        }

        element.addEventListener("mouseover", (event) =>
        {
            this.mouseOver(event);
        });
        element.addEventListener("mouseout", (event) =>
        {
            this.mouseOut(event);
        });
        element.addEventListener("mousedown", (event) =>
        {
            this.mouseDown(event);
        });
        element.addEventListener("focusin", (event) =>
        {
            this.focusIn(event);
        });
        element.addEventListener("focusout",  (event) =>
        {
            this.finishInput(event);
        });
        element.addEventListener("keypress",  (event) =>
        {
            this.finishInput(event);
        });
    }

    /**
     * @description Elementのid名をキャメルケースに変換して関数を実行
     *              例) font-select => changeFontSelectがコールされる
     *              valueはstringで渡すので、コール先の関数内で変換とバリデーションを行う必要がある
     *
     *              Convert Element's id name to CamelCase and execute function
     *              e.g.) font-select => changeFontSelect is called
     *              Since value is passed as a string, conversion and validation must be performed in the calling function
     *
     * @param  {string} name
     * @param  {string|number|Event} value
     * @return {*}
     * @method
     * @public
     */
    changeFunction (name, value)
    {
        const names = name.split("-");

        let functionName = names
            .map((value) =>
            {
                return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
            })
            .join("");

        return this[`change${functionName}`](value);
    }

    /**
     * @description Inputが数値の場合マウス動作で加算減算できればカーソルを変化させる
     *              If Input is a number, the cursor is changed if it can be added and subtracted by mouse movement.
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseOver (event)
    {
        event.stopPropagation();

        switch (true) {

            case this._$focus:
            case this._$currentTarget !== null:
                return ;

            default:
                Util.$setCursor("ew-resize");
                event.target.style.cursor = "ew-resize";
                break;

        }

        this._$currentValue = +event.target.value;
    }

    /**
     * @description Inputが数値の場合マウス動作終了関数
     *              Mouse operation end function if Input is numeric
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseOut (event)
    {
        event.stopPropagation();

        if (this._$focus || !this._$currentTarget) {
            Util.$setCursor("auto");
            event.target.style.cursor = "";
        }
    }

    /**
     * @description 数値のInputElementの場合はマウスで値を変更可能
     *              状態に合わせてカーソルや変数を初期化する
     *              For numeric InputElement, values can be changed with the mouse
     *              Initialize cursors and variables according to state
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        // Inputモードなら何もしない
        if (this._$focus) {
            return ;
        }

        event.preventDefault();

        // 初期化
        this._$saved         = false;
        this._$pointX        = event.screenX;
        this._$currentTarget = event.target;

        Util.$setCursor("ew-resize");

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description マウスアップで登録されたイベントを解除する
     *              Unregister a registered event with mouse up.
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        Util.$setCursor("auto");

        if (this._$currentTarget) {
            this._$currentTarget.style.cursor = "";
            this._$currentTarget.focus();
        }
    }

    /**
     * @description マウスで数値の加算減算を行う
     *              Add and subtract numbers with the mouse
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        if (this._$focus || !this._$currentTarget) {
            return ;
        }

        window.requestAnimationFrame(() =>
        {
            if (this._$focus || !this._$currentTarget) {
                return ;
            }

            event.preventDefault();

            Util.$setCursor("ew-resize");

            const diff = event.screenX - this._$pointX;

            let currentValue = +this._$currentTarget.value;
            if (isNaN(currentValue)) {
                currentValue = 0;
            }

            // clampで補正された値をセット
            this._$currentTarget.value = this.changeFunction(
                this._$currentTarget.id,
                currentValue + diff
            );

            // 値を更新
            this._$pointX = event.screenX;
        });
    }

    /**
     * @description Inputにフォーカスされた時に変数を初期化する
     *              Initialize variables when Input is focused
     *
     * @return {void}
     * @method
     * @public
     */
    focusIn ()
    {
        this._$focus  = true;
        Util.$keyLock = true;
    }

    /**
     * @description Inputにフォーカス終了した時にロックを解放する
     *              Release lock when focus ends on Input
     *
     * @return {void}
     * @method
     * @public
     */
    focusOut ()
    {
        this._$saved         = false;
        this._$focus         = false;
        this._$currentTarget = null;
        Util.$keyLock        = false;
    }

    /**
     * @description Inputタグでの編集終了関数
     *              End-of-edit function on Input tag
     *
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    finishInput (event)
    {
        // Enterを押下したら、focusoutイベントを発火させる
        if (event.key === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        // focusoutなら更新関数を実行
        if (event.type === "focusout") {

            this._$currentTarget = event.target;

            // Inputの値を更新
            event.target.value = this.changeFunction(
                this._$currentTarget.id,
                this._$currentTarget.value
            );

            this.focusOut();
        }
    }

    /**
     * @description スクリーンエリアで変更があったElementを再描画
     *              Redraw Element with changes in screen area
     *
     * @return {void}
     * @method
     * @public
     */
    reloadScreen ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        Util
            .$currentWorkSpace()
            .scene
            .changeFrame(frame);
    }

    /**
     * @description undo用にデータを内部保管する
     *              Internal storage of data for undo
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }
}

/**
 * ツールの共通イベントの管理を行うクラス
 * Class to manage common events of the tool
 *
 * @class
 * @memberOf event
 */
class ToolEvent extends EventDispatcher
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$active = false;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$target = null;

        // マウスダウン時にアクティブ化
        this._$events.set(EventType.MOUSE_DOWN, [(event) =>
        {
            this.activation(event);
        }]);

        // マウスダウン時に非アクティブ化
        this._$events.set(EventType.MOUSE_UP, [() =>
        {
            this.termination();
        }]);

        // ツールの開始時の起動イベント
        this._$events.set(EventType.START, [() =>
        {
            this.toolStart();
        }]);

        // ツールの終了時の起動イベント
        this._$events.set(EventType.END, [() =>
        {
            this.toolEnd();
        }]);
    }

    /**
     * @description ツールが選択されていれば、true。選択が終了したらfalseになります。
     *              True if the tool is selected; false if the selection is finished.
     *
     * @default false
     * @member {boolean}
     * @public
     */
    get active ()
    {
        return this._$active;
    }
    set active (active)
    {
        this._$active = !!active;
    }

    /**
     * @description 選択されたツールで利用するElement
     *              Element to be used with the selected tool
     *
     * @default null
     * @member {HTMLDivElement}
     * @public
     */
    get target ()
    {
        return this._$target;
    }
    set target (target)
    {
        this._$target = target;
    }

    /**
     * @description ツール選択時は変数をアクティブ化
     *              Variables are activated when the tool is selected
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    activation (event)
    {
        this.active = true;
        this.target = event.currentTarget;
    }

    /**
     * @description ツール選択終了したら変数を非アクティブ化
     *              Deactivate variables when tool selection is finished
     *
     * @return {void}
     * @method
     * @public
     */
    termination ()
    {
        this.active = false;
        this.target = null;
    }

    /**
     * @description ツール切り替え、開始時のイベント関数
     *              Tool switching, event function at start
     *
     * @return {void}
     * @method
     * @public
     */
    toolStart ()
    {
        // カーソルをリセット
        Util.$setCursor("auto");

        // 対象のElementがあればアクティブ表示
        const element = document
            .getElementById(`tools-${this._$name}`);

        if (element) {
            element.classList.add("active");
        }
    }

    /**
     * @description ツール切り替え、終了時のイベント関数
     *              Event functions for tool switching and exit
     *
     * @return {void}
     * @method
     * @public
     */
    toolEnd ()
    {
        // 対象のElementがあれば非アクティブ表示
        const element = document
            .getElementById(`tools-${this._$name}`);

        if (element) {
            element.classList.remove("active");
        }
    }
}


/**
 * @class
 * @memberOf view
 */
class KeyboardCommand
{
    /**
     * @constructor
     * @public
     */
    constructor (name)
    {
        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$areaName = name;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$active = false;

        /**
         * @type {Map}
         * @private
         */
        this._$mapping = new Map();

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$execute = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @return {string}
     */
    get areaName ()
    {
        return this._$areaName;
    }

    /**
     * @return {boolean}
     * @public
     */
    get active ()
    {
        return this._$active;
    }

    /**
     * @param  {boolean} active
     * @return {void}
     * @public
     */
    set active (active)
    {
        this._$active = !!active;
        if (this._$active) {
            window.addEventListener("keydown", this._$execute);
        } else {
            window.removeEventListener("keydown", this._$execute);
        }
    }

    /**
     * @description 共通初期イベント登録関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        this._$execute = this.execute.bind(this);

        Util.$initializeEnd();
    }

    /**
     * @description イベントを登録
     *
     * @param  {string} code
     * @param  {function} callback
     * @return {void}
     * @method
     * @public
     */
    add (code, callback)
    {
        this._$mapping.set(code, callback);
    }

    /**
     * @description イベントを削除
     *
     * @param  {string} code
     * @return {void}
     * @method
     * @public
     */
    delete (code)
    {
        this._$mapping.delete(code);
    }

    /**
     * @description 登録されているcallbackをコール
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    execute (event)
    {
        if (Util.$keyLock || !this._$active) {
            return ;
        }

        let code = Util.$generateShortcutKey(event.key, {
            "alt": Util.$altKey,
            "shift": Util.$shiftKey,
            "ctrl": Util.$ctrlKey
        });

        // オリジナル設定があれば上書き
        const originMapping = Util
            .$shortcutSetting
            .commandMapping
            .get(this.areaName);

        if (originMapping.has(code)) {

            code = originMapping.get(code);

        } else {

            const viewMapping = Util
                .$shortcutSetting
                .viewMapping
                .get(this.areaName);

            if (viewMapping.has(code)) {
                return ;
            }

        }

        if (!this._$mapping.has(code)) {
            return ;
        }

        Util.$endMenu();

        event.stopPropagation();
        event.preventDefault();

        // 条件が一致したら実行
        this
            ._$mapping
            .get(code)(code);
    }
}

Util.$keyboardCommand = new KeyboardCommand();

/**
 * @class
 * @extends {InputEvent}
 * @memberOf view.tool
 */
class ColorTool extends InputEvent
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @return {string}
     * @const
     * @static
     */
    static get FILL_DEFAULT_COLOR ()
    {
        return "#000000";
    }

    /**
     * @return {string}
     * @const
     * @static
     */
    static get STROKE_DEFAULT_COLOR ()
    {
        return "#000000";
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get STROKE_DEFAULT_SIZE ()
    {
        return 0;
    }

    /**
     * @description 初回起動設定
     *
     * @return {void}
     * @public
     */
    initialize ()
    {
        // コントラクターでセットしたイベントを削除
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        // 塗りのカラーElementのイベントと初期値をセット
        const fillColor = document.getElementById("fill-color");
        if (fillColor) {

            fillColor.value = localStorage
                .getItem(`${Util.PREFIX}@${fillColor.id}`) || ColorTool.FILL_DEFAULT_COLOR;

            fillColor
                .addEventListener("change", (event) =>
                {
                    const element = event.target;

                    localStorage
                        .setItem(
                            `${Util.PREFIX}@${element.id}`,
                            event.target.value
                        );
                });
        }

        // 線のカラーElementのイベントと初期値をセット
        const strokeColor = document.getElementById("stroke-color");
        if (strokeColor) {

            strokeColor.value = localStorage
                .getItem(`${Util.PREFIX}@${strokeColor.id}`) || ColorTool.STROKE_DEFAULT_COLOR;

            strokeColor
                .addEventListener("change", (event) =>
                {
                    const element = event.target;

                    localStorage
                        .setItem(
                            `${Util.PREFIX}@${element.id}`,
                            element.value
                        );
                });
        }

        // 線の太さのElementのイベントと初期値をセット
        const strokeSize = document.getElementById("stroke-size");
        if (strokeSize) {

            strokeSize.value = localStorage
                .getItem(`${Util.PREFIX}@${strokeSize.id}`) || ColorTool.STROKE_DEFAULT_SIZE;

            this.setInputEvent(strokeSize);
        }

        // end
        Util.$initializeEnd();
    }

    /**
     * @description 線のInput処理
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeStrokeSize (value)
    {
        value = Util.$clamp(value | 0, 0, 255);

        localStorage.setItem(`${Util.PREFIX}@stroke-size`, value);

        return value;
    }
}

Util.$colorTool = new ColorTool();

/**
 * @class
 * @memberOf view.tool
 */
class CommonTool extends ToolEvent
{
    /**
     * @description ツールのElementを管理するクラス
     *
     * @param {string} name
     * @constructor
     * @public
     */
    constructor (name)
    {
        super();

        /**
         * @type {string}
         * @private
         */
        this._$name = name;

        /**
         * @type {string}
         * @private
         */
        this._$cursor = "auto";

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pageX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pageY = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$offsetX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$offsetY = 0;

        // toolsに登録
        if (name) {

            Util
                .$tools
                .setTool(name, this);

            // 初期ElementになければPluginとして登録
            let element = document.getElementById(`tools-${name}`);
            if (!element) {

                const pluginTools = document
                    .getElementById("plugin-tools");

                if (pluginTools) {

                    const div = document.createElement("div");
                    div.id = `tools-${name}`;
                    div.classList.add("item");
                    div.dataset.mode = "tool";
                    div.dataset.name = name;

                    pluginTools.appendChild(div);

                    element = div;
                }

            }

            // Elementにイベントを追加
            if (element) {
                element
                    .addEventListener(EventType.MOUSE_DOWN, () =>
                    {
                        if (Util.$tools.activeTool) {
                            Util
                                .$tools
                                .activeTool
                                .dispatchEvent(EventType.END);
                        }

                        this.dispatchEvent(EventType.START);
                        Util.$tools.activeTool = this;
                    });
            }
        }
    }

    /**
     * @return {string}
     * @readonly
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @return {number}
     * @public
     */
    get pageX ()
    {
        return this._$pageX;
    }

    /**
     * @param  {number} page_x
     * @return {void}
     * @public
     */
    set pageX (page_x)
    {
        this._$pageX = page_x;
    }

    /**
     * @return {number}
     * @public
     */
    get pageY ()
    {
        return this._$pageY;
    }

    /**
     * @param  {number} page_y
     * @return {void}
     * @public
     */
    set pageY (page_y)
    {
        this._$pageY = page_y;
    }

    /**
     * @return {number}
     * @public
     */
    get offsetX ()
    {
        return this._$offsetX;
    }

    /**
     * @param  {number} offset_x
     * @return {void}
     * @public
     */
    set offsetX (offset_x)
    {
        this._$offsetX = offset_x;
    }

    /**
     * @return {number}
     * @public
     */
    get offsetY ()
    {
        return this._$offsetY;
    }

    /**
     * @param  {number} offset_y
     * @return {void}
     * @public
     */
    set offsetY (offset_y)
    {
        this._$offsetY = offset_y;
    }

    /**
     * @description ElementにアイコンとなるElementを追加
     *
     * @param  {Element} element
     * @return {void}
     * @method
     * @public
     */
    setIcon (element)
    {
        const parent = document
            .getElementById(`tools-${this._$name}`);

        const children = parent.children;
        while (children.length) {
            children[0].remove();
        }

        parent.appendChild(element);
    }

    /**
     * @param  {string} tip
     * @return {void}
     * @method
     * @public
     */
    setToolTip (tip)
    {
        const element = document
            .getElementById(`tools-${this._$name}`);

        if (element) {
            element.dataset.detail = `${tip}`;
        }
    }

    /**
     * @description マウスオーバー、ムーブ時のカーソルを指定
     *
     * @param  {string} [cursor="auto"]
     * @return {void}
     * @method
     * @public
     */
    setCursor (cursor = "auto")
    {
        this._$cursor = `${cursor}`;
    }
}

/**
 * @class
 * @memberOf view.tool
 */
class Project
{
    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // ファイル読み込み
        const loadElement = document
            .getElementById("tools-load");

        if (loadElement) {
            loadElement
                .addEventListener("click", (event) =>
                {
                    event.preventDefault();
                    this.open();
                });
        }

        const fileInput = document
            .getElementById("tools-load-file-input");

        if (fileInput) {
            fileInput
                .addEventListener("change", (event) =>
                {
                    const files = event.target.files;
                    for (let idx = 0; idx < files.length; ++idx) {
                        this.load(files[idx]);
                    }

                    // reset
                    event.target.value = "";
                });
        }

        const saveElement = document
            .getElementById("tools-save");

        if (saveElement) {
            saveElement
                .addEventListener("click", (event) =>
                {
                    event.preventDefault();
                    this.save();
                });
        }

        const exportElement = document
            .getElementById("tools-export");

        if (exportElement) {
            exportElement
                .addEventListener("click", (event) =>
                {
                    event.preventDefault();
                    this.publish();
                });
        }

        const languageElement = document
            .getElementById("language-setting");

        if (languageElement) {

            const language = localStorage
                .getItem(`${Util.PREFIX}@language-setting`);

            if (language) {
                const children = languageElement.children;
                for (let idx = 0; idx < children.length; ++idx) {
                    const node = children[idx];
                    if (node.value === language) {
                        node.selected = true;
                        break;
                    }
                }
            }

            languageElement
                .addEventListener("change", (event) =>
                {
                    const language = event.target.value;

                    const LanguageClass = Util.$languages.get(language);
                    Util.$currentLanguage = new LanguageClass();

                    localStorage
                        .setItem(`${Util.PREFIX}@language-setting`, language);

                    Util.$addModalEvent(document);
                });
        }
    }

    /**
     * @description 指定したフォーマットで書き出し
     *
     * @return {void}
     * @method
     * @public
     */
    publish ()
    {
        if (Util.$saveProgress.active) {
            return ;
        }

        Util.$saveProgress.start();

        // ダウンロードリンクを生成
        const anchor = document.getElementById("save-anchor");

        if (anchor.href) {
            URL.revokeObjectURL(anchor.href);
        }

        const type = document
            .getElementById("publish-type-setting")
            .value;

        switch (type) {

            case "json":
                Util.$saveProgress.createJson();
                setTimeout(() =>
                {
                    anchor.download = `${Util.$currentWorkSpace().name}.json`;
                    anchor.href     = URL.createObjectURL(new Blob(
                        [Publish.toJSON()],
                        { "type" : "application/json" }
                    ));
                    anchor.click();

                    Util.$saveProgress.end();
                }, 200);
                break;

            case "zlib":
                Publish.toZlib();
                break;

            case "webm":
                Publish.toWebM();
                break;

            case "gif-loop":
                Publish.toGIF();
                break;

            case "gif":
                Publish.toGIF(-1);
                break;

            case "png":
                Publish.toPng();
                break;

            case "apng-loop":
                Publish.toApng(true);
                break;

            case "apng":
                Publish.toApng(false);
                break;

            case "custom":
                if ("CustomPublish" in window) {
                    window
                        .CustomPublish
                        .execute(Publish.toObject());
                }
                Util.$saveProgress.end();
                break;

        }
    }

    /**
     * @description n2dファイルの読み込み処理、zipデータ解凍
     *
     * @param  {File} file
     * @return {void}
     * @public
     */
    load (file)
    {
        if (Util.$saveProgress.active) {
            return ;
        }

        Util.$saveProgress.start();

        file
            .arrayBuffer()
            .then((buffer) =>
            {
                Util.$saveProgress.zlibInflate();

                const uint8Array = new Uint8Array(buffer);
                Util.$unZlibWorker.postMessage({
                    "buffer": uint8Array,
                    "name"  : file.name.replace(".n2d", ""),
                    "type"  : "n2d"
                }, [uint8Array.buffer]);
            });
    }

    /**
     * @description プロジェクトデータをローカルから選択する
     *
     * @return {void}
     * @method
     * @public
     */
    open ()
    {
        document
            .getElementById("tools-load-file-input")
            .click();
    }

    /**
     * @description プロジェクトデータをローカルへ保存
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (Util.$saveProgress.active) {
            return ;
        }

        Util.$saveProgress.start();

        new Promise((resolve) =>
        {
            Util.$saveProgress.createJson();
            setTimeout(() =>
            {
                resolve({
                    "object": Util.$currentWorkSpace().toJSON(),
                    "type": "n2d"
                });
            }, 200);
        })
            .then((data) =>
            {
                Util.$saveProgress.zlibDeflate();
                if (Util.$zlibWorkerActive) {

                    Util.$zlibQueues.push(data);

                } else {

                    Util.$zlibWorkerActive = true;
                    Util.$zlibWorker.postMessage(data);

                }
            });
    }
}

Util.$project = new Project();

/**
 * @class
 * @memberOf view.tool
 */
class Publish
{
    /**
     * @return {object}
     * @method
     * @static
     */
    static toObject ()
    {
        const workSpace = Util.$currentWorkSpace();

        const stage = workSpace.stage;
        const libraries = workSpace._$libraries;

        const characters = [];

        // character publish
        for (let [id, instance] of libraries) {

            switch (true) {

                case id === 0: // root
                case instance.type !== "folder": // folder
                case instance.symbol !== "": // symbol instance
                case Util.$useIds.has(id): // use character
                    {
                        const object = instance.toPublish();
                        if (object.symbol) {
                            Util.$symbols.set(object.symbol, characters.length);
                        }

                        characters[id] = object;
                    }
                    break;

                default:
                    characters[id] = null;
                    break;

            }

        }

        let size = Util.$useIds.size;
        for (;;) {

            for (let [id, instance] of libraries) {

                if (characters[id]) {
                    continue;
                }

                if (!Util.$useIds.has(id)) {
                    continue;
                }

                const object = instance.toPublish();
                if (object.symbol) {
                    Util.$symbols.set(object.symbol, characters.length);
                }

                characters[id] = object;
            }

            if (size === Util.$useIds.size) {
                break;
            }

            // update
            size = Util.$useIds.size;
        }

        return {
            "stage": {
                "width": stage.width,
                "height": stage.height,
                "fps": stage.fps,
                "bgColor": stage.bgColor
            },
            "characters": characters
        };
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static toJSON ()
    {
        if (Util.$symbols.size) {
            Util.$symbols.clear();
        }

        const object   = Publish.toObject();
        object.symbols = Array.from(Util.$symbols);
        object.type    = "json";

        return JSON.stringify(object);
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static toZlib ()
    {
        if (Util.$symbols.size) {
            Util.$symbols.clear();
        }

        new Promise((resolve) =>
        {
            Util.$saveProgress.createJson();

            setTimeout(() =>
            {
                const object   = Publish.toObject();
                object.symbols = Array.from(Util.$symbols);

                resolve({
                    "object": JSON.stringify(object),
                    "type": "json"
                });

            }, 200);
        })
            .then((data) =>
            {
                Util.$saveProgress.zlibDeflate();

                if (Util.$zlibWorkerActive) {

                    Util.$zlibQueues.push(data);

                } else {

                    Util.$zlibWorkerActive = true;
                    Util.$zlibWorker.postMessage(data);

                }
            });

    }

    /**
     * @return {array}
     * @method
     * @static
     */
    static toWebM ()
    {
        Util.$saveProgress.encode();

        const canvas = document.getElementById("__next2d__").children[0];
        const stream = canvas.captureStream(
            document.getElementById("stage-fps").value | 0
        );

        const chunks   = [];
        const mimeType = "video/webm;codecs=h264";
        const recorder = new MediaRecorder(stream, { "mimeType" : mimeType });

        recorder.addEventListener("dataavailable", (event) =>
        {
            chunks.push(event.data);
        });

        recorder.addEventListener("stop", () =>
        {
            Util.$hidePreview();

            const anchor    = document.getElementById("save-anchor");
            anchor.download = `${Util.$currentWorkSpace().name}.webm`;
            anchor.href     = URL.createObjectURL(new Blob(chunks, { "type" : mimeType }));
            anchor.click();

            Util.$saveProgress.end();
        });

        const watch = function ()
        {
            if (!Util.$root.numChildren) {
                requestAnimationFrame(watch);
                return ;
            }

            if (Util.$root.currentFrame >= Util.$root.totalFrames) {
                return recorder.stop();
            }

            requestAnimationFrame(watch);
        };
        watch();

        Util.$showPreview();

        const element = document.getElementById("player-preview");
        element.style.display = "none";

        recorder.start(0);
    }

    /**
     * @param  {number} [repeat=0]
     * @return {void}
     * @method
     * @static
     */
    static toGIF (repeat = 0)
    {
        Util.$saveProgress.encode();

        const gif = new GIF({
            "repeat": repeat,
            "workerScript": "./assets/js/gif.worker.js"
        });

        gif.on("finished", (blob) =>
        {
            const anchor    = document.getElementById("save-anchor");
            anchor.download = `${Util.$currentWorkSpace().name}.gif`;
            anchor.href     = URL.createObjectURL(blob);
            anchor.click();

            Util.$saveProgress.end();
        });

        const watch = function ()
        {
            if (!Util.$root.numChildren) {
                requestAnimationFrame(watch);
                return ;
            }

            const canvas = document.getElementById("__next2d__").children[0];

            const cloneCanvas  = document.createElement("canvas");
            cloneCanvas.width  = canvas.width;
            cloneCanvas.height = canvas.height;

            const context = cloneCanvas.getContext("2d");
            context.drawImage(canvas, 0, 0, canvas.width, canvas.height);

            gif.addFrame(context.canvas, { "delay": 20 });

            if (Util.$root.currentFrame >= Util.$root.totalFrames) {
                Util.$hidePreview();
                gif.render();
                return;
            }

            requestAnimationFrame(watch);
        };
        watch();

        Util.$showPreview();

        const element = document.getElementById("player-preview");
        element.style.display = "none";
    }

    /**
     * @return {void}
     * @method
     * @static
     */
    static toPng ()
    {
        Util.$saveProgress.encode();

        const snapshot = () =>
        {
            if (!Util.$root.numChildren) {
                requestAnimationFrame(snapshot);
                return ;
            }

            const stage = Util.$root.stage;
            if (!stage) {
                requestAnimationFrame(snapshot);
                return ;
            }

            const player = stage._$player;
            if (player._$stopFlag) {
                requestAnimationFrame(snapshot);
                return ;
            }

            const canvas    = document.getElementById("__next2d__").children[0];
            const anchor    = document.getElementById("save-anchor");
            anchor.download = `${Util.$currentWorkSpace().name}.png`;
            anchor.href     = canvas.toDataURL();
            anchor.click();

            Util.$saveProgress.end();

            Util.$hidePreview();
        };
        snapshot();

        Util.$showPreview();

        const element = document.getElementById("player-preview");
        element.style.display = "none";
    }

    /**
     * @param  {boolean} [loop = true]
     * @return {void}
     * @method
     * @static
     */
    static toApng (loop = true)
    {
        Util.$saveProgress.encode();

        const buffer = [];
        let currentFrame = 0;
        const watch = () =>
        {
            const player = Util.$root.stage._$player;
            if (player._$stopFlag
                || !Util.$root.numChildren
                || currentFrame === Util.$root.currentFrame
            ) {
                requestAnimationFrame(watch);
                return ;
            }

            currentFrame = Util.$root.currentFrame;
            const canvas = document.getElementById("__next2d__").children[0];

            const cloneCanvas  = document.createElement("canvas");
            cloneCanvas.width  = canvas.width;
            cloneCanvas.height = canvas.height;

            canvas.toBlob((blob) =>
            {
                buffer.push(blob);

                if (buffer.length === Util.$root.totalFrames) {

                    Util.$hidePreview();

                    return new ApngEncoder(
                        buffer, canvas.width, canvas.height,
                        document.getElementById("stage-fps").value | 0,
                        loop
                    )
                        .encode()
                        .then((blob) =>
                        {
                            const anchor    = document.getElementById("save-anchor");
                            anchor.download = `${Util.$currentWorkSpace().name}.apng`;
                            anchor.href     = URL.createObjectURL(blob);
                            anchor.click();

                            Util.$saveProgress.end();
                        });

                }
            });

            if (Util.$root.currentFrame >= Util.$root.totalFrames) {
                return ;
            }

            requestAnimationFrame(watch);
        };
        watch();

        Util.$showPreview();

        const element = document.getElementById("player-preview");
        element.style.display = "none";
    }

}

/**
 * @class
 * @memberOf view.tool
 */
class SaveProgress
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$active = false;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$value = 0;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$timerId = -1;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @return {boolean}
     * @readonly
     * @public
     */
    get active ()
    {
        return this._$active;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const element = document.getElementById("save-progress-modal");
        if (element) {
            element.addEventListener("mousedown", (event) =>
            {
                this.moveStart(event);
            });
        }

        Util.$initializeEnd();
    }

    /**
     * @description マウス移動をセットアップ
     *
     * @param {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveStart (event)
    {
        event.stopPropagation();
        event.preventDefault();

        // 現在のポジションをセット
        this._$pageX = event.pageX;
        this._$pageY = event.pageY;

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description 移動処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        const element = document.getElementById("save-progress-modal");
        if (!element) {
            return ;
        }

        window.requestAnimationFrame(() =>
        {
            const left = element.offsetLeft + (event.pageX - this._$pageX);
            const top  = element.offsetTop  + (event.pageY - this._$pageY);

            element.setAttribute("style", `left: ${left}px; top: ${top}px`);

            // 現在のポジションをセット
            this._$pageX = event.pageX;
            this._$pageY = event.pageY;
        });
    }

    /**
     * @description 移動完了処理
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    mouseUp (event)
    {
        event.stopPropagation();
        event.preventDefault();

        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description プログレスバーを起動
     *
     * @return {void}
     * @method
     * @public
     */
    start ()
    {
        clearInterval(this._$timerId);

        const element = document.getElementById("save-progress-modal");
        if (!element) {
            return ;
        }

        // プログレスバーを初期化
        this.update(0);

        if (!element.classList.contains("fadeIn")) {
            element.setAttribute("class", "fadeIn");
        }

        element.setAttribute("style", "");
        const left = (window.innerWidth  - element.clientWidth)  / 2;
        const top  = (window.innerHeight - element.clientHeight) / 2;

        element.setAttribute("style", `left: ${left}px; top: ${top}px`);

        // アクティブ
        this._$active = true;
    }

    /**
     * @description JSON生成の待機
     *
     * @return {void}
     * @method
     * @public
     */
    createJson ()
    {
        clearInterval(this._$timerId);
        this.update(10,
            Util.$currentLanguage.replace("{{JSONを生成}}")
        );
    }

    /**
     * @description ファイルの生成待機
     *
     * @return {void}
     * @method
     * @public
     */
    createFile ()
    {
        clearInterval(this._$timerId);
        this.update(90,
            Util.$currentLanguage.replace("{{ファイルを生成}}")
        );
    }

    /**
     * @description N2Dファイルの読み込み待機
     *
     * @return {void}
     * @method
     * @public
     */
    loadN2D ()
    {
        clearInterval(this._$timerId);
        this.update(90,
            Util.$currentLanguage.replace("{{N2Dファイルの読み込み}}")
        );
    }

    /**
     * @description JSON読み込み待機
     *
     * @return {void}
     * @method
     * @public
     */
    loadJson ()
    {
        clearInterval(this._$timerId);
        this.update(90,
            Util.$currentLanguage.replace("{{JSONの読み込み}}")
        );
    }

    /**
     * @description zlib解凍の待機
     *
     * @return {void}
     * @method
     * @public
     */
    zlibInflate ()
    {
        clearInterval(this._$timerId);

        this.update(15,
            Util.$currentLanguage.replace("{{データを解凍中}}")
        );

        this._$timerId = setInterval(() =>
        {
            this.update(
                Math.min(80, this._$value + 1),
                Util.$currentLanguage.replace("{{データを解凍中}}")
            );
        }, 300);
    }

    /**
     * @description 各種エンコード待機
     *
     * @return {void}
     * @method
     * @public
     */
    encode ()
    {
        clearInterval(this._$timerId);

        this.update(15,
            Util.$currentLanguage.replace("{{エンコード}}")
        );

        this._$timerId = setInterval(() =>
        {
            this.update(
                Math.min(80, this._$value + 1),
                Util.$currentLanguage.replace("{{エンコード}}")
            );
        }, 300);
    }

    /**
     * @description zlib圧縮の待機
     *
     * @return {void}
     * @method
     * @public
     */
    zlibDeflate ()
    {
        clearInterval(this._$timerId);

        this.update(15,
            Util.$currentLanguage.replace("{{データを圧縮中}}")
        );

        this._$timerId = setInterval(() =>
        {
            this.update(
                Math.min(80, this._$value + 1),
                Util.$currentLanguage.replace("{{データを圧縮中}}")
            );
        }, 300);
    }

    /**
     * @description SWFの解析待機
     *
     * @return {void}
     * @method
     * @public
     */
    parseSWF ()
    {
        clearInterval(this._$timerId);

        this.update(15,
            Util.$currentLanguage.replace("{{SWFを解析中}}")
        );

        this._$timerId = setInterval(() =>
        {
            this.update(
                Math.min(80, this._$value + 1),
                Util.$currentLanguage.replace("{{SWFを解析中}}")
            );
        }, 300);
    }

    /**
     * @description 外部ファイルの読み込み待機
     *
     * @return {void}
     * @method
     * @public
     */
    loadFiles ()
    {
        this.update(5,
            Util.$currentLanguage.replace("{{外部ファイルの読み込み}}")
        );

        this._$timerId = setInterval(() =>
        {
            this.update(
                Math.min(90, this._$value + 1),
                Util.$currentLanguage.replace("{{外部ファイルの読み込み}}")
            );
        }, 300);
    }

    /**
     * @description バイナリデータ生成待機
     *
     * @return {void}
     * @method
     * @public
     */
    createBinary ()
    {
        clearInterval(this._$timerId);
        this.update(80,
            Util.$currentLanguage.replace("{{バイナリデータを生成}}")
        );
    }

    /**
     * @description ローカルのDBの起動待機
     *
     * @param  {number} value
     * @return {void}
     * @method
     * @public
     */
    launchDatabase (value)
    {
        clearInterval(this._$timerId);
        this.update(value,
            Util.$currentLanguage.replace("{{データベースを起動}}")
        );
    }

    /**
     * @description コミット待機
     *
     * @return {void}
     * @method
     * @public
     */
    commit ()
    {
        clearInterval(this._$timerId);
        this.update(95,
            Util.$currentLanguage.replace("{{データを保存中}}")
        );
    }

    /**
     * @description プログレスバーを終了
     *
     * @return {void}
     * @method
     * @public
     */
    end ()
    {
        clearInterval(this._$timerId);
        this.update(100,
            Util.$currentLanguage.replace("{{完了}}")
        );

        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        this._$timerId = -1;
        this._$active  = false;

        const element = document.getElementById("save-progress-modal");
        if (!element) {
            return ;
        }

        if (!element.classList.contains("fadeOut")) {
            setTimeout(() =>
            {
                element.setAttribute("class", "fadeOut");
            }, 1000);
        }
    }

    /**
     * @description プログレスバーの値を更新
     *
     * @param  {number} value
     * @param  {string} [state = ""]
     * @return {void}
     * @method
     * @public
     */
    update (value, state = "")
    {
        const element = document.getElementById("save-progress");
        if (!element) {
            return ;
        }

        this._$value  = value;
        element.value = `${value}`;

        // 状態を更新
        document
            .getElementById("progress-state")
            .textContent = state;
    }
}

Util.$saveProgress = new SaveProgress();

/**
 * @class
 * @memberOf view.tool
 */
class ShortcutSetting
{

    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {array}
         * @private
         */
        this._$names = [
            "screen",
            "timeline",
            "library"
        ];

        /**
         * @type {object}
         * @private
         */
        this._$default = {
            "screen": [
                {
                    "key": "v",
                    "text": "V",
                    "css": "tools-arrow",
                    "description": "{{選択ツール}}"
                },
                {
                    "key": "q",
                    "text": "Q",
                    "css": "tools-arrow-transform",
                    "description": "{{自由変形ツール}}"
                },
                {
                    "key": "a",
                    "text": "A",
                    "css": "tools-transform",
                    "description": "{{Shape変形ツール}}"
                },
                {
                    "key": "p",
                    "text": "P",
                    "css": "tools-pen",
                    "description": "{{ペンツール}}"
                },
                {
                    "key": "k",
                    "text": "K",
                    "css": "tools-bucket",
                    "description": "{{バケツツール}}"
                },
                {
                    "key": "r",
                    "text": "R",
                    "css": "tools-rectangle",
                    "description": "{{矩形ツール}}"
                },
                {
                    "key": "o",
                    "text": "O",
                    "css": "tools-circle",
                    "description": "{{楕円ツール}}"
                },
                {
                    "key": "rShift",
                    "text": "Shift + R",
                    "css": "tools-round-rect",
                    "description": "{{角丸矩形ツール}}"
                },
                {
                    "key": "t",
                    "text": "T",
                    "css": "tools-text",
                    "description": "{{テキストツール}}"
                },
                {
                    "key": "z",
                    "text": "Z",
                    "css": "tools-zoom",
                    "description": "{{ズームツール}}"
                },
                {
                    "key": "rCtrl",
                    "text": "Ctrl + R",
                    "css": "tools-load",
                    "description": "{{プロジェクトデータの読込}}"
                },
                {
                    "key": "sShiftCtrl",
                    "text": "Ctrl + Shift + S",
                    "css": "tools-save",
                    "description": "{{プロジェクトデータを保存}}"
                },
                {
                    "key": "EnterShiftCtrl",
                    "text": "Ctrl + Shift + Enter",
                    "css": "tools-export",
                    "description": "{{書き出し}}"
                },
                {
                    "key": "s",
                    "text": "S",
                    "css": "tools-setting",
                    "description": "{{設定}}"
                },
                {
                    "key": "ArrowUpShiftCtrl",
                    "text": "Ctrl + Shift + ArrowUp",
                    "css": "screen-front",
                    "description": "{{最前面}}"
                },
                {
                    "key": "ArrowUpCtrl",
                    "text": "Ctrl + ArrowUp",
                    "css": "screen-front-one",
                    "description": "{{ひとつ前面へ}}"
                },
                {
                    "key": "ArrowDownCtrl",
                    "text": "Ctrl + ArrowDown",
                    "css": "screen-menu-bottom",
                    "description": "{{ひとつ背面へ}}"
                },
                {
                    "key": "ArrowDownShiftCtrl",
                    "text": "Ctrl + Shift + ArrowDown",
                    "css": "screen-back",
                    "description": "{{最背面}}"
                },
                {
                    "key": "1",
                    "text": "1",
                    "css": "screen-position-left",
                    "description": "{{左揃え}}"
                },
                {
                    "key": "2",
                    "text": "2",
                    "css": "screen-position-center",
                    "description": "{{中央揃え(水平方向)}}"
                },
                {
                    "key": "3",
                    "text": "3",
                    "css": "screen-position-right",
                    "description": "{{右揃え}}"
                },
                {
                    "key": "4",
                    "text": "4",
                    "css": "screen-position-top",
                    "description": "{{上揃え}}"
                },
                {
                    "key": "5",
                    "text": "5",
                    "css": "screen-position-middle",
                    "description": "{{中央揃え(垂直方向)}}"
                },
                {
                    "key": "6",
                    "text": "6",
                    "css": "screen-position-bottom",
                    "description": "{{下揃え}}"
                },
                {
                    "key": "!Shift",
                    "text": "Shift + 1",
                    "css": "stage-position-left",
                    "description": "{{ステージ左揃え}}"
                },
                {
                    "key": "\"Shift",
                    "text": "Shift + 2",
                    "css": "stage-position-center",
                    "description": "{{ステージ中央揃え(水平方向)}}"
                },
                {
                    "key": "#Shift",
                    "text": "Shift + 3",
                    "css": "stage-position-right",
                    "description": "{{ステージ右揃え}}"
                },
                {
                    "key": "$Shift",
                    "text": "Shift + 4",
                    "css": "stage-position-top",
                    "description": "{{ステージ上揃え}}"
                },
                {
                    "key": "%Shift",
                    "text": "Shift + 5",
                    "css": "stage-position-middle",
                    "description": "{{ステージ中央揃え(垂直方向)}}"
                },
                {
                    "key": "&Shift",
                    "text": "Shift + 6",
                    "css": "stage-position-bottom",
                    "description": "{{ステージ下揃え}}"
                },
                {
                    "key": "dCtrl",
                    "text": "Ctrl + D",
                    "css": "screen-distribute-to-layers",
                    "description": "{{レイヤーに配分}}"
                },
                {
                    "key": "kCtrl",
                    "text": "Ctrl + K",
                    "css": "screen-distribute-to-keyframes",
                    "description": "{{キーフレームに配分}}"
                },
                {
                    "key": "iCtrl",
                    "text": "Ctrl + I",
                    "css": "screen-integrating-paths",
                    "description": "{{パスの結合}}"
                },
                {
                    "key": "pCtrl",
                    "text": "Ctrl + P",
                    "css": "screen-add-tween-curve-pointer",
                    "description": "{{カーブポインターの追加}}"
                },
                {
                    "key": "pShiftCtrl",
                    "text": "Ctrl + Shift + P",
                    "css": "screen-delete-tween-curve-pointer",
                    "description": "{{カーブポインターの削除}}"
                },
                {
                    "key": "mShift",
                    "text": "Shift + M",
                    "css": "screen-change-movie-clip",
                    "description": "{{MovieClipに変換}}"
                },
                {
                    "key": "rShiftCtrl",
                    "text": "Ctrl + Shift + R",
                    "css": "screen-ruler",
                    "description": "{{定規}}"
                }
            ],
            "timeline": [
                {
                    "key": "nShift",
                    "text": "Shift + N",
                    "css": "timeline-layer-normal",
                    "description": "{{通常レイヤー}}"
                },
                {
                    "key": "mShift",
                    "text": "Shift + M",
                    "css": "timeline-layer-mask",
                    "description": "{{マスクレイヤー}}"
                },
                {
                    "key": "gShift",
                    "text": "Shift + G",
                    "css": "timeline-layer-guide",
                    "description": "{{ガイドレイヤー}}"
                },
                {
                    "key": ";Ctrl",
                    "text": "Ctrl + +",
                    "css": "timeline-layer-add",
                    "description": "{{レイヤーを追加}}"
                },
                {
                    "key": "BackspaceCtrl",
                    "text": "Ctrl + Backspace",
                    "css": "timeline-layer-trash",
                    "description": "{{レイヤーを削除}}"
                },
                {
                    "key": "hShift",
                    "text": "Shift + H",
                    "css": "timeline-layer-light-all",
                    "description": "{{全てのレイヤーをハイライト}}"
                },
                {
                    "key": "dShift",
                    "text": "Shift + D",
                    "css": "timeline-layer-disable-all",
                    "description": "{{全てのレイヤーを非表示}}"
                },
                {
                    "key": "lShift",
                    "text": "Shift + L",
                    "css": "timeline-layer-lock-all",
                    "description": "{{全てのレイヤーをロック}}"
                },
                {
                    "key": "m",
                    "text": "M",
                    "css": "context-menu-tween-add",
                    "description": "{{モーショントゥイーンの追加}}"
                },
                {
                    "key": "mCtrl",
                    "text": "Ctrl + M",
                    "css": "context-menu-tween-delete",
                    "description": "{{モーショントゥイーンの削除}}"
                },
                {
                    "key": "s",
                    "text": "S",
                    "css": "timeline-script-add",
                    "description": "{{スクリプトを追加}}"
                },
                {
                    "key": "k",
                    "text": "K",
                    "css": "timeline-key-add",
                    "description": "{{キーフレームを追加}}"
                },
                {
                    "key": "kCtrl",
                    "text": "Ctrl + K",
                    "css": "timeline-key-delete",
                    "description": "{{キーフレームを削除}}"
                },
                {
                    "key": "e",
                    "text": "E",
                    "css": "timeline-empty-add",
                    "description": "{{空のキーフレームを追加}}"
                },
                {
                    "key": "f",
                    "text": "F",
                    "css": "timeline-frame-add",
                    "description": "{{フレームを追加}}"
                },
                {
                    "key": "fCtrl",
                    "text": "Ctrl + F",
                    "css": "timeline-frame-delete",
                    "description": "{{フレームを削除}}"
                },
                {
                    "key": "oCtrl",
                    "text": "Ctrl + O",
                    "css": "timeline-onion-skin",
                    "description": "{{オニオンスキン}}"
                },
                {
                    "key": "p",
                    "text": "P",
                    "css": "timeline-preview",
                    "description": "{{プレビューのON/OFF}}"
                },
                {
                    "key": "pCtrl",
                    "text": "Ctrl + P",
                    "css": "timeline-repeat",
                    "description": "{{ループ設定}}"
                },
                {
                    "key": "l",
                    "text": "L",
                    "css": "label-name",
                    "description": "{{フレームラベル}}"
                },
                {
                    "key": "z",
                    "text": "Z",
                    "css": "timeline-scale",
                    "description": "{{タイムライン幅の拡大・縮小}}"
                },
                {
                    "key": "lCtrl",
                    "text": "Ctrl + L",
                    "css": "context-menu-layer-clone",
                    "description": "{{レイヤーを複製}}"
                },
                {
                    "key": "ArrowLeftCtrl",
                    "text": "Ctrl + ArrowLeft",
                    "css": "context-menu-first-frame",
                    "description": "{{最初のフレームに移動}}"
                },
                {
                    "key": "ArrowRightCtrl",
                    "text": "Ctrl + ArrowRight",
                    "css": "context-menu-last-frame",
                    "description": "{{最後のフレームに移動}}"
                }
            ],
            "library": [
                {
                    "key": "mCtrl",
                    "text": "Ctrl + M",
                    "css": "library-menu-container-add",
                    "description": "{{新規MovieClip}}"
                },
                {
                    "key": "fCtrl",
                    "text": "Ctrl + F",
                    "css": "library-menu-folder-add",
                    "description": "{{新規フォルダー}}"
                },
                {
                    "key": "rCtrl",
                    "text": "Ctrl + R",
                    "css": "library-menu-file",
                    "description": "{{読み込み}}"
                },
                {
                    "key": "sShiftCtrl",
                    "text": "Ctrl + Shift + S",
                    "css": "library-menu-export",
                    "description": "{{書き出し}}"
                },
                {
                    "key": "Backspace",
                    "text": "Backspace",
                    "css": "library-menu-delete",
                    "description": "{{削除}}"
                },
                {
                    "key": "cCtrl",
                    "text": "Ctrl + C",
                    "css": "library-menu-copy",
                    "description": "{{コピー}}"
                },
                {
                    "key": "vCtrl",
                    "text": "Ctrl + V",
                    "css": "library-menu-paste",
                    "description": "{{ペースト}}"
                }
            ]
        };

        /**
         * @type {Map}
         * @private
         */
        this._$commandMapping = new Map([
            ["screen", new Map()],
            ["timeline", new Map()],
            ["library", new Map()],
            ["global", new Map()]
        ]);

        /**
         * @type {Map}
         * @private
         */
        this._$viewMapping = new Map([
            ["screen", new Map()],
            ["timeline", new Map()],
            ["library", new Map()],
            ["global", new Map()]
        ]);

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$active = false;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$selectNode = null;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$selectArea = "";

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$keydownEvent = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @return {Map}
     */
    get commandMapping ()
    {
        return this._$commandMapping;
    }

    /**
     * @return {Map}
     */
    get viewMapping ()
    {
        return this._$viewMapping;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const elementIds = [
            "shortcut-setting-screen",
            "shortcut-setting-timeline",
            "shortcut-setting-library",
            "shortcut-setting-reset",
            "shortcut-setting-save",
            "shortcut-setting-close"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            element.addEventListener("click", (event) =>
            {
                event.stopPropagation();
                event.preventDefault();

                this.executeFunction(event);
            });
        }

        // オリジナルのショートカットのマッピングを生成
        this.createShortcutMap();

        // イベント登録して、表示を更新
        for (let idx = 0; idx < this._$names.length; ++idx) {

            const name = this._$names[idx];

            const parent = document
                .getElementById(`shortcut-list-${name}`);

            if (!parent) {
                continue;
            }

            const mapping = this.viewMapping.get(name);

            const values = this._$default[name];
            for (let idx = 0; idx < values.length; ++idx) {

                const data = values[idx];

                const htmlTag = `
<div class="shortcut-item">
    <i class="${data.css}"></i>
    <div class="description">
        <span class="language" data-text="${data.description}">${Util.$currentLanguage.replace(data.description)}</span>
    </div>
    <div class="command" data-key="${data.key}" data-default-text="${data.text}">${data.text}</div>
</div>`;

                parent.insertAdjacentHTML("beforeend", htmlTag);

                const node = parent.lastElementChild;
                node.addEventListener("mousedown", (event) =>
                {
                    this.selectNode(event);
                });

                const cmdElement = node.lastElementChild;
                if (!mapping.has(cmdElement.dataset.key)) {
                    continue;
                }

                const object = mapping.get(cmdElement.dataset.key);
                cmdElement.dataset.map = object.map;
                cmdElement.textContent = object.text;
            }
        }

        // 登録用関数
        this._$keydownEvent = this.keydownEvent.bind(this);

        Util.$initializeEnd();
    }

    /**
     * @description 個別のショートカットをマッピング
     *
     * @return {void}
     * @method
     * @public
     */
    createShortcutMap ()
    {
        const data = localStorage.getItem(`${Util.PREFIX}@shortcut`);
        if (!data) {
            return ;
        }

        const object = JSON.parse(data);
        const keys = Object.keys(object);
        for (let idx = 0; idx < keys.length; ++idx) {

            const name = keys[idx];

            // リセット
            this.viewMapping.get(name).clear();
            this.commandMapping.get(name).clear();

            const values = object[name];
            for (let idx = 0; idx < values.length; ++idx) {

                const data = values[idx];

                this.viewMapping.get(name).set(data.key, {
                    "map": data.map,
                    "text": data.text
                });

                this.commandMapping.get(name).set(data.map, data.key);
            }
        }
    }

    /**
     * @description キーダウンイベントを受け取る
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    keydownEvent (event)
    {
        const element = document
            .getElementById("shortcut-setting-menu");

        if (element.classList.contains("fadeOut")) {
            Util.$useShortcutSetting = false;
            this._$active = false;
            window.removeEventListener("keydown", this._$keydownEvent);
            return ;
        }

        if (!this._$selectNode || !this._$selectArea) {
            return ;
        }

        const texts = [];
        if (Util.$shiftKey) {
            texts.push("Shift");
        }
        if (Util.$altKey) {
            texts.push("Alt");
        }
        if (Util.$ctrlKey) {
            texts.push("Ctrl");
        }

        switch (true) {

            case event.key === " ":
                texts.push(event.code);
                break;

            case event.key.length === 1:
                texts.push(event.key.toUpperCase());
                break;

            default:
                texts.push(event.key);
                break;

        }

        const cmdElement = this._$selectNode.lastElementChild;
        cmdElement.textContent = `${texts.join(" + ")}`;

        const key = Util.$generateShortcutKey(event.key, {
            "alt": Util.$altKey,
            "shift": Util.$shiftKey,
            "ctrl": Util.$ctrlKey
        });

        if (key !== cmdElement.dataset.key) {
            cmdElement.dataset.map  = key;
            cmdElement.dataset.text = cmdElement.textContent;
        } else {
            delete cmdElement.dataset.map;
            delete cmdElement.dataset.text;
        }
    }

    /**
     * @description 選択したElementをセット
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    selectNode (event)
    {
        if (this._$selectNode) {
            this
                ._$selectNode
                .classList
                .remove("shortcut-active");
        }

        this._$selectNode = event.target;

        this
            ._$selectNode
            .classList
            .add("shortcut-active");
    }

    /**
     * @description Elementのid名をキャメルケースに変換して関数を実行
     *              例) font-select => executeFontSelectがコールされる
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    executeFunction (event)
    {
        const names = event.target.id.split("-");

        let functionName = names
            .map((value) =>
            {
                return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
            })
            .join("");

        this[`execute${functionName}`](event);
    }

    /**
     * @description スクリーンエリアのショートカット情報を表示
     *
     * @return {void}
     * @method
     * @public
     */
    executeShortcutSettingScreen ()
    {
        document
            .getElementById("shortcut-setting-screen")
            .classList.add("shortcut-active");
        document
            .getElementById("shortcut-setting-timeline")
            .classList.remove("shortcut-active");
        document
            .getElementById("shortcut-setting-library")
            .classList.remove("shortcut-active");

        document
            .getElementById("shortcut-list-screen")
            .style.display = "";
        document
            .getElementById("shortcut-list-timeline")
            .style.display = "none";
        document
            .getElementById("shortcut-list-library")
            .style.display = "none";

        this._$selectArea = "screen";

        if (this._$selectNode) {
            this
                ._$selectNode
                .classList
                .remove("shortcut-active");
            this._$selectNode = null;
        }
    }

    /**
     * @description スクリーンエリアのショートカット情報を表示
     *
     * @return {void}
     * @method
     * @public
     */
    executeShortcutSettingTimeline ()
    {
        document
            .getElementById("shortcut-setting-screen")
            .classList.remove("shortcut-active");
        document
            .getElementById("shortcut-setting-timeline")
            .classList.add("shortcut-active");
        document
            .getElementById("shortcut-setting-library")
            .classList.remove("shortcut-active");

        document
            .getElementById("shortcut-list-screen")
            .style.display = "none";
        document
            .getElementById("shortcut-list-timeline")
            .style.display = "";
        document
            .getElementById("shortcut-list-library")
            .style.display = "none";

        this._$selectArea = "timeline";

        if (this._$selectNode) {
            this
                ._$selectNode
                .classList
                .remove("shortcut-active");
            this._$selectNode = null;
        }
    }

    /**
     * @description スクリーンエリアのショートカット情報を表示
     *
     * @return {void}
     * @method
     * @public
     */
    executeShortcutSettingLibrary ()
    {
        document
            .getElementById("shortcut-setting-screen")
            .classList.remove("shortcut-active");
        document
            .getElementById("shortcut-setting-timeline")
            .classList.remove("shortcut-active");
        document
            .getElementById("shortcut-setting-library")
            .classList.add("shortcut-active");

        document
            .getElementById("shortcut-list-screen")
            .style.display = "none";
        document
            .getElementById("shortcut-list-timeline")
            .style.display = "none";
        document
            .getElementById("shortcut-list-library")
            .style.display = "";

        this._$selectArea = "library";

        if (this._$selectNode) {
            this
                ._$selectNode
                .classList
                .remove("shortcut-active");
            this._$selectNode = null;
        }
    }

    /**
     * @description ショートカット情報を初期値に戻す
     *
     * @return {void}
     * @method
     * @public
     */
    executeShortcutSettingReset ()
    {
        // 初期化
        localStorage.removeItem(`${Util.PREFIX}@shortcut`);

        for (let idx = 0; idx < this._$names.length; ++idx) {

            const name = this._$names[idx];

            const children = document
                .getElementById(`shortcut-list-${name}`)
                .children;

            for (let idx = 0; idx < children.length; ++idx) {

                const node = children[idx];

                const cmdElement = node.lastElementChild;
                cmdElement.textContent = cmdElement.dataset.defaultText;
                if (!cmdElement.dataset.map) {
                    continue;
                }

                delete cmdElement.dataset.map;
                delete cmdElement.dataset.text;
            }

            this.viewMapping.get(name).clear();
            this.commandMapping.get(name).clear();
        }

        this.createShortcutMap();
    }

    /**
     * @description ショートカットの情報を保存
     *
     * @return {void}
     * @method
     * @public
     */
    executeShortcutSettingSave ()
    {
        // 初期化
        localStorage.removeItem(`${Util.PREFIX}@shortcut`);

        const object = {};
        for (let idx = 0; idx < this._$names.length; ++idx) {

            const name = this._$names[idx];

            const children = document
                .getElementById(`shortcut-list-${name}`)
                .children;

            for (let idx = 0; idx < children.length; ++idx) {

                const node = children[idx].lastElementChild;
                if (!node.dataset.map) {
                    continue;
                }

                if (!object[name]) {
                    object[name] = [];
                }

                object[name].push({
                    "key": node.dataset.key,
                    "map": node.dataset.map,
                    "text": node.textContent
                });
            }
        }

        localStorage
            .setItem(
                `${Util.PREFIX}@shortcut`,
                JSON.stringify(object)
            );

        this.createShortcutMap();
    }

    /**
     * @description ショートカットの設定画面を閉じる
     *
     * @return {void}
     * @method
     * @public
     */
    executeShortcutSettingClose ()
    {
        Util.$userSetting.show();

        if (this._$selectNode) {
            this
                ._$selectNode
                .classList
                .remove("shortcut-active");

            this._$selectNode = null;
            this._$selectArea = "";
        }
    }

    /**
     * @description 設定画面を表示
     *
     * @return {void}
     * @method
     * @public
     */
    show ()
    {
        const element = document
            .getElementById("shortcut-setting-menu");

        // 初期化
        if (this._$selectNode) {
            this
                ._$selectNode
                .classList
                .remove("shortcut-active");

            this._$selectNode = null;
            this._$selectArea = "";
        }

        this.executeShortcutSettingScreen();

        if (!this._$active) {
            Util.$useShortcutSetting = true;
            this._$active = true;
            window.addEventListener("keydown", this._$keydownEvent);
        }

        Util.$endMenu("shortcut-setting-menu");

        const userSetting = document
            .getElementById("user-setting");

        element.style.display = "";
        element.style.left    = `${userSetting.offsetLeft}px`;
        element.style.top     = `${userSetting.offsetTop}px`;

        element.setAttribute("class", "fadeIn");
    }
}

Util.$shortcutSetting = new ShortcutSetting();

/**
 * @class
 * @memberOf view.tool
 */
class Tools
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }

        /**
         * @description 選択中のツールオブジェクト
         * @type {CommonTool}
         * @default null
         * @private
         */
        this._$activeTool = null;

        /**
         * @description Toolクラス
         * @type {Map}
         * @private
         */
        this._$tools = new Map();

        /**
         * @description Toolクラス
         * @type {Map}
         * @private
         */
        this._$externalTools = new Map();
    }

    /**
     * @description 現在選択されているToolクラスを返します。
     *
     * @return {CommonTool}
     * @public
     */
    get activeTool ()
    {
        return this._$activeTool;
    }

    /**
     * @description 選択したToolクラスをセットします。
     *
     * @param  {CommonTool} tool
     * @return {void}
     * @public
     */
    set activeTool (tool)
    {
        this._$activeTool = tool;
    }

    /**
     * @description 初回起動設定
     *
     * @return {void}
     * @public
     */
    initialize ()
    {
        // コントラクターでセットしたイベントを削除
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        // ツールの初期起動
        // デフォルトツールクラス
        const defaultTools = [
            ArrowTool,
            ArrowTransformTool,
            TransformTool,
            RectangleTool,
            CircleTool,
            RoundRectTool,
            PenTool,
            BucketTool,
            TextTool,
            ZoomTool,
            HandTool
        ];

        // デフォルトツールを起動して、Mapに格納
        for (let idx = 0; idx < defaultTools.length; ++idx) {
            const DefaultToolClass = defaultTools[idx];
            const tool = new DefaultToolClass();
            this._$tools.set(tool.name, tool);
        }

        const element = document.getElementById("tools");
        if (element) {
            element
                .addEventListener("mousemove", (event) =>
                {
                    const activeTool = this.activeTool;
                    if (activeTool) {
                        event.tools = true;
                        activeTool.dispatchEvent(
                            EventType.MOUSE_MOVE,
                            event
                        );
                    }
                });

            element
                .addEventListener("mouseout", (event) =>
                {
                    Util.$setCursor("auto");

                    // 親のイベントを中止する
                    event.stopPropagation();
                });
        }

        // プロジェクトデータ関数の初期起動
        Util.$project.initialize();

        // ユーザー設定系の初期化
        Util.$userSetting.initialize();

        // end
        Util.$initializeEnd();
    }

    /**
     * @description 拡張ツールのクラスを登録する関数
     *
     * @param  {string} name
     * @param  {object} tool
     * @return {void}
     * @method
     * @public
     */
    setTool (name, tool)
    {
        this._$externalTools.set(name, tool);
    }

    /**
     * @description 拡張ツールの名前から取得
     *
     * @param  {string} name
     * @return {Tool|null}
     * @method
     * @public
     */
    getTool (name)
    {
        return this._$externalTools.has(name)
            ? this._$externalTools.get(name)
            : null;
    }

    /**
     * @description 名前からデフォルトToolクラスを取得
     *
     * @param  {string} name
     * @return {CommonTool}
     * @method
     * @public
     */
    getDefaultTool (name)
    {
        return this._$tools.get(name);
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    reset ()
    {
        const activeTool = this.activeTool;
        if (activeTool) {
            activeTool.dispatchEvent(EventType.END);
        }

        const tool = this.getDefaultTool("arrow");
        tool.dispatchEvent(EventType.START);
        this.activeTool = tool;
    }
}

Util.$tools = new Tools();

/**
 * @class
 * @memberOf view.tool
 */
class UserSetting
{
    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        const toolsSetting = document
            .getElementById("tools-setting");

        if (toolsSetting) {
            toolsSetting
                .addEventListener("click", (event) =>
                {
                    this.show(event);
                });
        }

        const object = this.getPublishSetting();

        const layerElement = document
            .getElementById("publish-layer-setting");

        if (layerElement) {
            layerElement
                .children[object.layer ? 1 : 0]
                .selected = true;

            layerElement
                .addEventListener("change", (event) =>
                {
                    const object = this.getPublishSetting();
                    object.layer = event.target.value === "1";

                    localStorage
                        .setItem(
                            `${Util.PREFIX}@user-publish-setting`,
                            JSON.stringify(object)
                        );

                });
        }

        const typeElement = document
            .getElementById("publish-type-setting");

        if (typeElement) {
            for (let idx = 0; idx < typeElement.children.length; ++idx) {

                const node = typeElement.children[idx];
                if (object.type !== node.value) {
                    continue;
                }

                node.selected = true;
                break;
            }

            typeElement
                .addEventListener("change", (event) =>
                {
                    const object = this.getPublishSetting();
                    object.type  = event.target.value;

                    localStorage
                        .setItem(
                            `${Util.PREFIX}@user-publish-setting`,
                            JSON.stringify(object)
                        );

                });
        }

        const modalElement = document
            .getElementById("modal-setting");

        if (modalElement) {

            if ("modal" in object) {
                modalElement.children[object.modal ? 0 : 1].selected = true;
            }

            modalElement
                .addEventListener("change", (event) =>
                {
                    const object = this.getPublishSetting();
                    object.modal = event.target.value === "1";

                    localStorage
                        .setItem(
                            `${Util.PREFIX}@user-publish-setting`,
                            JSON.stringify(object)
                        );

                });
        }

        const shortcutSetting = document
            .getElementById("shortcut-setting");

        if (shortcutSetting) {
            shortcutSetting
                .addEventListener("click", () =>
                {
                    Util.$shortcutSetting.show();
                });
        }
    }

    /**
     * @description 書き出し設定オブジェクトを返す
     *
     * @return {object}
     * @method
     * @public
     */
    getPublishSetting ()
    {
        const object = localStorage
            .getItem(`${Util.PREFIX}@user-publish-setting`);

        if (object) {
            return JSON.parse(object);
        }

        return {
            "layer": false,
            "type": "zlib"
        };
    }

    /**
     * @description ユーザー設定モーダルを表示
     *
     * @return {object}
     * @method
     * @public
     */
    show ()
    {
        const element = document
            .getElementById("user-setting");

        Util.$endMenu("user-setting");
        const toolsSetting = document
            .getElementById("tools-setting");

        element.style.display = "";
        element.style.left = `${toolsSetting.offsetLeft + 30}px`;
        element.style.top  = `${toolsSetting.offsetTop - element.clientHeight + 80}px`;

        element.setAttribute("class", "fadeIn");
    }
}

Util.$userSetting = new UserSetting();

/**
 * @class
 * @memberOf view.tool.default
 */
class BaseTool extends CommonTool
{
    /**
     * @description ツールのElementを管理するクラス
     *
     * @param {string} name
     * @constructor
     * @public
     */
    constructor (name)
    {
        super(name);
        this.initialize();
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @interface
     */
    // eslint-disable-next-line no-empty-function
    initialize () {}

    /**
     * @param {boolean} [active=true]
     * @method
     * @public
     */
    changeNodeEvent (active = true)
    {
        Util.$hitColor = null;

        const stageArea = document.getElementById("stage-area");
        if (stageArea) {
            const children = stageArea.children;
            for (let idx = 0; idx < children.length; ++idx) {

                const node = children[idx];
                if (node.dataset.shapePointer) {
                    node.remove();
                    --idx;
                    continue;
                }

                if (!node.dataset.child) {
                    continue;
                }

                node.style.pointerEvents = active ? "auto" : "none";

            }
        }
    }

    /**
     * @param  {object} object
     * @param  {number} x
     * @param  {number} y
     * @return {void}
     * @method
     * @public
     */
    createShape (object, x = 0, y = 0)
    {
        const scene   = Util.$currentWorkSpace().scene;
        const target  = Util.$timelineLayer.targetLayer;
        const layerId = target.dataset.layerId | 0;

        // ロック中のレイヤーの場合は何もしない
        const layer = scene.getLayer(layerId | 0);
        if (layer.lock) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const shape = workSpace.addLibrary(object);

        const frame = Util.$timelineFrame.currentFrame;

        // 挿入位置を取得
        const location = layer.adjustmentLocation(frame);

        const { Matrix } = window.next2d.geom;
        const concatenatedMatrix = Util.$sceneChange.concatenatedMatrix;

        const matrix = new Matrix(
            concatenatedMatrix[0], concatenatedMatrix[1], concatenatedMatrix[2],
            concatenatedMatrix[3], concatenatedMatrix[4], concatenatedMatrix[5]
        );
        matrix.invert();

        const localX = x * matrix.a + y * matrix.c + matrix.tx;
        const localY = x * matrix.b + y * matrix.d + matrix.ty;

        // pointer
        const character = new Character();
        character.libraryId  = shape.id;
        character.startFrame = location.startFrame;
        character.endFrame   = location.endFrame;
        character.setPlace(location.startFrame, {
            "frame": location.startFrame,
            "matrix": [1, 0, 0, 1, localX, localY],
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": [],
            "depth": layer._$characters.length
        });

        // Shapeをレイヤーに追加して再描画
        layer.addCharacter(character);

        // タイムラインを再描画
        layer.reloadStyle();

        // レイヤーの横スクロール幅を再計算
        Util.$timelineScroll.updateWidth();

        // ライブラリを再描画
        Util.$libraryController.reload();
    }

    /**
     * @param  {object} object
     * @param  {number} x
     * @param  {number} y
     * @return {void}
     * @public
     */
    createTextField (object, x = 0, y = 0)
    {
        const scene   = Util.$currentWorkSpace().scene;
        const target  = Util.$timelineLayer.targetLayer;
        const layerId = target.dataset.layerId | 0;

        const layer = scene.getLayer(layerId | 0);
        if (layer.lock) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const textField = workSpace.addLibrary(object);

        const frame = Util.$timelineFrame.currentFrame;

        // 挿入位置を取得
        const location = layer.adjustmentLocation(frame);

        const { Matrix } = window.next2d.geom;
        const concatenatedMatrix = Util.$sceneChange.concatenatedMatrix;

        const matrix = new Matrix(
            concatenatedMatrix[0], concatenatedMatrix[1], concatenatedMatrix[2],
            concatenatedMatrix[3], concatenatedMatrix[4], concatenatedMatrix[5]
        );
        matrix.invert();

        const localX = x * matrix.a + y * matrix.c + matrix.tx;
        const localY = x * matrix.b + y * matrix.d + matrix.ty;

        // pointer
        const character = new Character();
        character.libraryId  = textField.id;
        character.startFrame = location.startFrame;
        character.endFrame   = location.endFrame;
        character.setPlace(location.startFrame, {
            "frame": location.startFrame,
            "matrix": [1, 0, 0, 1, localX, localY],
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": [],
            "depth": layer._$characters.length
        });

        // レイヤーに追加
        layer.addCharacter(character);

        // タイムラインを再描画
        layer.reloadStyle();

        // レイヤーの横スクロール幅を再計算
        Util.$timelineScroll.updateWidth();

        // ライブラリを再描画
        Util.$libraryController.reload();
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    reloadScreen ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        Util
            .$currentWorkSpace()
            .scene
            .changeFrame(frame);
    }
}

/**
 * @class
 * @extends {BaseTool}
 * @memberOf view.tool.default
 */
class DrawTool extends BaseTool
{
    /**
     * @param {string} name
     * @constructor
     * @public
     */
    constructor (name)
    {
        super(name);
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // 専用カーソルを登録
        this.setCursor("crosshair");

        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor(this._$cursor);
            this.changeNodeEvent(false);
        });

        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            Util.$setCursor(this._$cursor);
            this.active = !!event.screen;
            if (event.screen) {
                this.mouseDown(event);
            }
        });

        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            Util.$setCursor(this._$cursor);
            if (event.screen && this.active) {

                // 親のイベントを中止する
                event.stopPropagation();

                this.mouseMove(event);
            }
        });

        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            Util.$setCursor(this._$cursor);

            // 親のイベントを中止する
            event.stopPropagation();

            if (event.screen) {

                Util.$timelineLayer.attachLayer();
                this.createCharacter();

                document
                    .getElementById("draw-rect")
                    .style.display = "none";

                Util.$tools.reset();
            }
        });
    }

    /**
     * @description 指定の座標に描画を行う
     *
     * @param  {string} name
     * @return {void}
     * @method
     * @public
     */
    createCharacter (name)
    {
        const element = document.getElementById("draw-rect");

        const { Graphics } =  window.next2d.display;

        const strokeSize = document
            .getElementById("stroke-size")
            .value | 0;

        const width  = (parseFloat(element.style.width)  + strokeSize) / Util.$zoomScale;
        const height = (parseFloat(element.style.height) + strokeSize) / Util.$zoomScale;
        if (width && height) {

            const workSpace = Util.$currentWorkSpace();
            workSpace.temporarilySaved();

            // draw
            const graphics = new Graphics();

            graphics
                .beginFill(document.getElementById("fill-color").value, 1);

            switch (name) {

                case "rectangle":
                    graphics.drawRect(0, 0, width, height);
                    break;

                case "circle":
                    graphics.drawEllipse(0, 0, width, height);
                    break;

                case "round-rect":
                    graphics.drawRoundRect(
                        0, 0, width, height,
                        Math.min(width, height) / 4
                    );
                    break;

            }
            graphics.endFill();

            const x  = (this.offsetX - Util.$offsetLeft) / Util.$zoomScale;
            const y  = (this.offsetY - Util.$offsetTop)  / Util.$zoomScale;
            const id = workSpace.nextLibraryId;

            this.createShape({
                "id": id,
                "type": InstanceType.SHAPE,
                "name": `Shape_${id}`,
                "symbol": "",
                "recodes": graphics._$recode ? graphics._$recode.slice(0) : [],
                "bounds": {
                    "xMin": 0,
                    "xMax": width,
                    "yMin": 0,
                    "yMax": height
                }
            }, x + strokeSize / 2, y + strokeSize / 2);

            if (strokeSize) {

                const graphics = new Graphics();
                graphics
                    .lineStyle(
                        strokeSize,
                        document.getElementById("stroke-color").value
                    );

                switch (name) {

                    case "rectangle":
                        graphics.drawRect(0, 0, width, height);
                        break;

                    case "circle":
                        graphics.drawEllipse(0, 0, width, height);
                        break;

                    case "round-rect":
                        graphics.drawRoundRect(
                            0, 0, width, height,
                            Math.min(width, height) / 4
                        );
                        break;

                }
                graphics.endLine();

                const offsetX = Math.abs(graphics._$xMax - graphics._$xMin) - width;
                const offsetY = Math.abs(graphics._$yMax - graphics._$yMin) - height;

                const x = this.offsetX - Util.$offsetLeft;
                const y = this.offsetY - Util.$offsetTop;

                const id = workSpace.nextLibraryId;

                this.createShape({
                    "id": id,
                    "type": InstanceType.SHAPE,
                    "name": `Shape_${id}`,
                    "symbol": "",
                    "recodes": graphics._$recode ? graphics._$recode.slice(0) : [],
                    "bounds": {
                        "xMin": -offsetX / 2,
                        "xMax": width + offsetX / 2,
                        "yMin": -offsetY / 2,
                        "yMax": height + offsetY / 2
                    }
                }, x + offsetX / 2, y + offsetY / 2);

            }

            // 再描画
            this.reloadScreen();
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        this.pageX = event.pageX;
        this.pageY = event.pageY;

        this.offsetX = event.offsetX;
        this.offsetY = event.offsetY;
        if (event.target.id !== "stage-area") {
            this.offsetX += event.target.offsetLeft;
            this.offsetY += event.target.offsetTop;
        }

        const element = document.getElementById("draw-rect");

        element.style.left    = `${event.pageX}px`;
        element.style.top     = `${event.pageY}px`;
        element.style.width   = "0px";
        element.style.height  = "0px";
        element.style.display = "";

        // fill color
        element.style.background = document.getElementById("fill-color").value;

        // stroke reset
        element.style.borderRadius = "";
        element.style.border       = "";

        const strokeSize = document.getElementById("stroke-size").value | 0;
        if (strokeSize) {
            element.style.borderRadius = `${strokeSize}px`;
            element.style.border       = `${strokeSize}px solid ${document.getElementById("stroke-color").value}`;
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        event.preventDefault();

        const x = event.pageX;
        const y = event.pageY;

        const element = document.getElementById("draw-rect");
        if (this.name === "circle") {
            element.style.borderRadius = "50%";
        }

        if (Util.$shiftKey) {

            const max = Math.max(
                Math.abs(x - this.pageX),
                Math.abs(y - this.pageY)
            );

            if (this.pageX < x) {
                element.style.left = `${this.pageX}px`;
            }
            if (this.pageY < y) {
                element.style.top = `${this.pageY}px`;
            }

            if (this.pageX > x) {
                this.offsetX = event.offsetX;
                element.style.left = `${this.pageX - max}px`;
            }
            if (this.pageY > y) {
                this.offsetY = event.offsetY;
                element.style.top = `${this.pageY - max}px`;
            }

            element.style.width  = `${max}px`;
            element.style.height = `${max}px`;

        } else {

            if (this.pageX > x) {
                this.offsetX = event.offsetX;
                element.style.left = `${x}px`;
            }
            if (this.pageY > y) {
                this.offsetY = event.offsetY;
                element.style.top = `${y}px`;
            }

            element.style.width  = `${Math.abs(x - this.pageX)}px`;
            element.style.height = `${Math.abs(y - this.pageY)}px`;
        }

        if (this.name === "round-rect") {
            const min = Math.min(
                parseFloat(element.style.width),
                parseFloat(element.style.height)
            );
            element.style.borderRadius = `${min / 8 | 0}px`;
        }
    }
}

/**
 * @class
 * @extends {BaseTool}
 * @memberOf view.tool.default
 */
class ArrowTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("arrow");

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$activeElement = "";

        /**
         * @type {array}
         * @private
         */
        this._$activeElements = [];
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        this.addEventListener(EventType.MOUSE_OVER, (event) =>
        {
            const target  = event.currentTarget;
            const layerId = target.dataset.layerId | 0;

            const lockElement = document
                .getElementById(`layer-lock-icon-${layerId}`);

            if (!lockElement
                || lockElement.classList.contains("icon-active")
            ) {
                return ;
            }

            Util.$setCursor("move");
        });

        this.addEventListener(EventType.MOUSE_OUT, () =>
        {
            Util.$setCursor("auto");
        });

        // コントローラーのプルダウンでライブラリの入れ替えを行った際のイベント
        this.addEventListener(EventType.CHANGE, (event) =>
        {
            this.changeCharacter(event);
        });

        // カーソルがスクリーンエリアから外れた時は非アクティブに
        this.addEventListener(EventType.MOUSE_LEAVE, () =>
        {
            this.active = false;
        });

        // 各種シーンによってのマウスダウンイベント
        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            this.active = false;
            switch (true) {

                case event.displayObject:
                    this.active = true;
                    this._$activeElement = ArrowTool.DISPLAY_OBJECT;
                    Util.$endMenu();
                    this.activateElement(event);
                    break;

                case event.screen:
                    this.active = true;
                    this._$activeElement = ArrowTool.SCREEN;
                    Util.$endMenu();
                    this.clear();
                    this.startRect(event);
                    break;

                case event.transform:
                    this.active = true;
                    this._$activeElement = ArrowTool.TRANSFORM;
                    Util.$endMenu();
                    this.startPosition(event);
                    break;

                case event.grid:
                    this.active = true;
                    this._$activeElement = ArrowTool.GRID;
                    Util.$endMenu();
                    this.startPosition(event);
                    break;

                default:
                    this._$activeElement = "";
                    break;

            }
        });

        // アクティブなエレメントに合わせたマウスムーブイベント
        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            if (!this.active) {
                return ;
            }

            // 親のイベントを中止する
            event.stopPropagation();
            event.preventDefault();

            switch (this._$activeElement) {

                case ArrowTool.DISPLAY_OBJECT:
                    this.moveDisplayObject(event);
                    break;

                case ArrowTool.SCREEN:
                    this.moveRect(event);
                    break;

                case ArrowTool.TRANSFORM:
                    this.moveTransform(event);
                    break;

                case ArrowTool.GRID:
                    this.moveGrid(event);
                    break;

                default:
                    break;

            }

        });

        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            if (!this._$activeElement) {
                return ;
            }

            switch (this._$activeElement) {

                case ArrowTool.SCREEN:
                    // 親のイベントを中止する
                    event.stopPropagation();
                    this.endRect();
                    break;

                case ArrowTool.DISPLAY_OBJECT:
                case ArrowTool.TRANSFORM:
                case ArrowTool.GRID:
                    break;

                default:
                    break;

            }

            // アクティブ判定を初期化
            this._$activeElement = "";

            // 連続セーブ防止フラグを初期化
            this._$saved = false;
        });

        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor(this._$cursor);
            this.changeNodeEvent();

            // 選択中のDisplayObjectがあればアクティブ化
            Util.$timelineLayer.activeCharacter();

            const element = document.getElementById("target-rect");
            if (element) {
                element.setAttribute("class", "arrow");
            }
        });

        // ツール終了時に初期化
        this.addEventListener(EventType.END, () =>
        {
            // 配列を初期化
            this.clearActiveElement();

            // スクリーンエリアの変形Elementを非表示に
            Util.$transformController.hide();
            Util.$gridController.hide();
            Util.$tweenController.clearPointer();

            // コントローラーエリアを初期化
            Util.$controller.default();
        });

        // シーン移動
        this.addEventListener(EventType.DBL_CLICK, (event) =>
        {
            if (event.screen && !this._$activeElements.length) {
                this.moveScene();
            }
        });

        // アクティブツールとして登録
        this.dispatchEvent(EventType.START);
        Util.$tools.activeTool = this;
    }

    /**
     * @description スクリーンで選択したElementの配列
     *
     * @return {array}
     * @readonly
     * @public
     */
    get activeElements ()
    {
        return this._$activeElements;
    }

    /**
     * @return {string}
     * @const
     * @static
     */
    static get SCREEN ()
    {
        return "screen";
    }

    /**
     * @return {string}
     * @const
     * @static
     */
    static get TRANSFORM ()
    {
        return "transform";
    }

    /**
     * @return {string}
     * @const
     * @static
     */
    static get DISPLAY_OBJECT ()
    {
        return "displayObject";
    }

    /**
     * @return {string}
     * @const
     * @static
     */
    static get GRID ()
    {
        return "grid";
    }

    /**
     * @description スクリーン、タイムライン、コントローラー全ての値を初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clear ()
    {
        // 配列を初期化
        this.clearActiveElement();

        // Shapeのポインターを初期化
        Util.$clearShapePointer();

        // スクリーンエリアの変形Elementを非表示に
        Util.$transformController.hide();
        Util.$gridController.hide();
        Util.$tweenController.clearPointer();

        // コントローラーエリアを初期化
        Util.$controller.default();

        // タイムラインエリアを初期化
        Util.$timelineLayer.clear();

        // 中心点を初期化
        Util.$referenceController.resetPointer();
    }

    /**
     * @description プロパティーの更新がある時はundo用にデータを内部保管する
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }

    /**
     * @description 選択中のDisplayObjectを非アクティブ化
     *
     * @return {void}
     * @method
     * @public
     */
    clearActiveElement ()
    {
        this._$activeElements.length = 0;
    }

    /**
     * @description 選択してるDisplayObjectをスクリーンから削除
     *
     * @return {void}
     * @method
     * @public
     */
    deleteDisplayObject ()
    {
        // 選択してるDisplayObjectがなければ終了
        const activeElements = this.activeElements;
        if (!activeElements.length) {
            return ;
        }

        this.save();

        const frame  = Util.$timelineFrame.currentFrame;
        const layers = new Map();
        const scene  = Util.$currentWorkSpace().scene;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];

            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            if (!layer) {
                continue;
            }

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            if (!character) {
                continue;
            }

            if (!layers.has(layer.id)) {
                layers.set(layer.id, {
                    "layer": layer,
                    "range": character.getRange(frame)
                });
            }

            character.remove(layer);
        }

        // 選択していたDisplayObjectをリセット
        this.clearActiveElement();

        // タイムラインを再構成
        for (const object of layers.values()) {

            const layer = object.layer;
            const range = object.range;

            const characters = layer.getActiveCharacter(range.startFrame);
            if (characters.length) {

                // 深度順に並び替え
                layer.sort(characters, frame);

                for (let idx = 0; idx < characters.length; ++idx) {
                    characters[idx].getPlace(frame).depth = idx;
                }

            } else {

                layer.addEmptyCharacter(
                    new EmptyCharacter({
                        "startFrame": range.startFrame,
                        "endFrame": range.endFrame
                    })
                );

            }

            layer.reloadStyle();
        }

        // 再描画
        this.reloadScreen();

        // 初期化
        this._$saved = false;
    }

    /**
     * @description 選択したDisplayObjectを配列に格納
     *              もし配列内に指定済みのDisplayObjectがあれば何もしない
     *
     * @param  {HTMLDivElement} element
     * @param  {boolean} [hit=false]
     * @return {boolean}
     * @method
     * @public
     */
    addElement (element, hit = false)
    {
        for (let idx = 0; idx < this._$activeElements.length; ++idx) {

            const target = this._$activeElements[idx];
            if (target.dataset.characterId === element.dataset.characterId) {

                if (Util.$shiftKey) {

                    Util
                        .$tweenController
                        .clearPointer();

                    // 服選択時は二度目の押下は対象外にする
                    this._$activeElements.splice(idx, 1);

                    // 複数選択ポインターを初期化
                    Util.$referenceController.pointer = null;

                } else {

                    this._$activeElements.splice(idx, 1, element);

                }

                return false;
            }
        }

        // 複数選択でなければ配列は初期化する
        if (!hit && !Util.$shiftKey) {
            // 配列を初期化
            this.clearActiveElement();
        } else {
            // 複数選択ポインターを初期化
            Util.$referenceController.pointer = null;
        }

        this._$activeElements.push(element);

        // tweenの設定があればポインターを配置
        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );

        if (character.hasTween(range.startFrame)) {
            Util
                .$tweenController
                .clearPointer()
                .relocationPointer();
        }

        return true;
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    activateElement (event)
    {
        let target = this.target;

        const layerId = target.dataset.layerId | 0;

        const workSpace = Util.$currentWorkSpace();

        const scene = workSpace.scene;
        const layer = scene.getLayer(layerId);

        // タイムラインでロック中のDisplayObjectは何もしない
        if (layer.lock) {
            return ;
        }

        // 現在の座標をセット
        this.pageX = event.pageX;
        this.pageY = event.pageY;

        // タイムラインのアクティブなElementを初期化
        Util.$timelineLayer.clear();

        const character = layer.getCharacter(
            target.dataset.characterId | 0
        );

        // 指定のDisplayObjectをクローンしてスクリーンに配置
        if (Util.$altKey) {

            const clone = character.clone();

            // クローンしたDisplayObjectを最前面にセット
            for (const [keyFrame, place] of clone._$places) {

                let depth = 0;
                const characters = layer.getActiveCharacter(keyFrame);
                for (let idx = 0; idx < characters.length; ++idx) {
                    depth = Math.max(characters[idx].getPlace(keyFrame).depth, depth);
                }

                place.depth = depth + 1;
            }

            // レイヤーにセット
            layer.addCharacter(clone);

            const frame = Util.$timelineFrame.currentFrame;

            // スクリーンに配置
            Util
                .$screen
                .appendCharacter(clone, frame, layer.id);

            target = document
                .getElementById(`character-${clone.id}`);

        }

        // アクティブ登録
        this.addElement(target);

        // コントローラーエリアの情報を更新
        this.updateControllerProperty();

        // Shapeは描画反映の判定で毎回ヒット判定を行う
        if (this._$activeElements.length === 1) {
            character.showShapeColor(event);
        }

        // 拡大縮小回転のElementのポイントを表示して再計算
        Util
            .$transformController
            .show()
            .relocation();

        // 9sliceのElementのポイントを表示して再計算
        Util
            .$gridController
            .show()
            .relocation();

        // 選択されたDisplayObjectが配置されてるタイムラインをアクティブに
        this.activeTimeline();
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    activeTimeline ()
    {
        // 初期化
        Util.$timelineLayer.clear();

        const frame = Util.$timelineFrame.currentFrame;

        // 複数選択可能にするため、擬似的にctrlキーをOnにする
        const cacheValue = Util.$ctrlKey;
        Util.$ctrlKey = this._$activeElements.length > 1;

        const scene = Util.$currentWorkSpace().scene;
        for (let idx = 0; idx < this._$activeElements.length; ++idx) {

            const element = this._$activeElements[idx];

            const layerId = element.dataset.layerId | 0;

            const layerElement = document
                .getElementById(`layer-id-${layerId}`);

            if (!Util.$timelineLayer.targetLayers.has(layerElement.id)) {
                Util.$timelineLayer.targetLayer = layerElement;
            }

            const layer = scene.getLayer(layerId);

            Util
                .$timelineLayer
                .addTargetFrame(layer, frame);
        }
        Util.$ctrlKey = cacheValue;
    }

    /**
     * @description コントローラーのプルダウン変更時のイベント関数
     *              指定されたライブラリ内のオブジェクトと切り替える
     *
     * @return {void}
     * @method
     * @public
     */
    changeCharacter (event)
    {
        if (this._$activeElements.length !== 1) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const target = this._$activeElements[0];

        const layerId = target.dataset.layerId | 0;
        const layer   = scene.getLayer(layerId);

        const characterId = target.dataset.characterId | 0;
        const character   = layer.getCharacter(characterId);

        // update
        character._$libraryId = event.target.value | 0;
        character.dispose();

        const instance = workSpace
            .getLibrary(character._$libraryId);

        if (instance.type === InstanceType.MOVIE_CLIP) {
            for (const place of character._$places.values()) {
                place.loop = Util.$getDefaultLoopConfig();
            }
        }

        const range = character.getRange(Util.$timelineFrame.currentFrame);
        if (character.hasTween(range.startFrame)) {
            Util
                .$tweenController
                .clearPointer()
                .relocationPointer();
        }

        const icon = document
            .getElementById("instance-type-name")
            .getElementsByTagName("i")[0];

        icon.setAttribute("class", `library-type-${instance.type}`);

        // スクリーンエリアのDisplayObjectを再描画
        this.reloadScreen();

        // アクティブなDisplayObjectの変形Elementを再計算
        Util
            .$transformController
            .show()
            .relocation();
    }

    /**
     * @description スクリーン上でマウスで選択した範囲のDisplayObjectを選択する起動関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    startRect (event)
    {
        this.pageX = event.pageX;
        this.pageY = event.pageY;

        const element = document.getElementById("stage-rect");
        element.style.left    = `${event.pageX}px`;
        element.style.top     = `${event.pageY}px`;
        element.style.width   = "0px";
        element.style.height  = "0px";
        element.style.display = "";
    }

    /**
     * @description スクリーン上でマウスで選択する範囲調整関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveRect (event)
    {
        const x = event.pageX;
        const y = event.pageY;

        const element = document.getElementById("stage-rect");

        if (this.pageX > x) {
            element.style.left = `${x}px`;
        }

        if (this.pageY > y) {
            element.style.top = `${y}px`;
        }

        element.style.width  = `${Math.abs(x - this.pageX)}px`;
        element.style.height = `${Math.abs(y - this.pageY)}px`;
    }

    /**
     * @description スクリーン上でマウスで選択する範囲の最終位置
     *
     * @return {void}
     * @method
     * @public
     */
    endRect ()
    {
        const element = document.getElementById("stage-rect");
        element.style.display = "none";

        const width   = parseFloat(element.style.width);
        const height  = parseFloat(element.style.height);
        if (!width || !height) {
            return ;
        }

        const left    = parseFloat(element.style.left);
        const top     = parseFloat(element.style.top);
        const right   = left + width;
        const bottom  = top  + height;

        const children = document
            .getElementById("stage-area")
            .children;

        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];
            switch (true) {

                case !node.dataset.child:
                case node.dataset.child === "tween":
                case node.dataset.preview === "true":
                case node.classList.contains("standard-point"):
                    continue;

                default:
                    break;

            }

            const rect = node.getBoundingClientRect();
            switch (true) {

                case rect.bottom < top:
                case rect.top    > bottom:
                case rect.right  < left:
                case rect.left   > right:
                    continue;

                default:
                    break;

            }

            const layerId = node.dataset.layerId | 0;

            const lockElement = document
                .getElementById(`layer-lock-icon-${layerId}`);

            if (lockElement.classList.contains("icon-active")) {
                continue;
            }

            this.addElement(node, true);
        }

        if (this._$activeElements.length) {
            this.updateControllerProperty();

            Util
                .$transformController
                .show()
                .relocation();

            this.activeTimeline();
        }
    }

    /**
     * @description マウスダウンした時の座標を保存
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    startPosition (event)
    {
        this.pageX = event.pageX;
        this.pageY = event.pageY;
    }

    /**
     * @description スクリーンエリアでの拡大縮小回転の分岐処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveGrid (event)
    {
        Util.$setCursor("move");

        event.preventDefault();

        const dx = (event.pageX - this.pageX) / Util.$zoomScale;
        const dy = (event.pageY - this.pageY) / Util.$zoomScale;

        let x = +document
            .getElementById("nine-slice-setting-x")
            .value;

        let y = +document
            .getElementById("nine-slice-setting-y")
            .value;

        let w = +document
            .getElementById("nine-slice-setting-w")
            .value;

        let h = +document
            .getElementById("nine-slice-setting-h")
            .value;

        switch (this.target.id) {

            case "grid-top-left":
                x += dx;
                w -= dx;
                y += dy;
                h -= dy;
                break;

            case "grid-top-right":
                w += dx;
                y += dy;
                break;

            case "grid-bottom-left":
                x += dx;
                w -= dx;
                h += dy;
                break;

            case "grid-bottom-right":
                w += dx;
                h += dy;
                break;

        }

        document
            .getElementById("nine-slice-setting-x")
            .value = `${x}`;

        document
            .getElementById("nine-slice-setting-y")
            .value = `${y}`;

        document
            .getElementById("nine-slice-setting-w")
            .value = `${w}`;

        document
            .getElementById("nine-slice-setting-h")
            .value = `${h}`;

        this.startPosition(event);

        Util
            .$gridController
            .updateShapeGrid(x, y, w, h);

        this.reloadScreen();
    }

    /**
     * @description スクリーンエリアでの拡大縮小回転の分岐処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveTransform (event)
    {
        Util.$setCursor("move");

        event.preventDefault();

        this.save();

        let reload = false;
        switch (this.target.id) {

            case "scale-top-left": // 左上
                {
                    const resultX = this.updateLeftScaleX(event);
                    const resultY = this.updateTopScaleY(event);
                    if (resultX || resultY) {
                        reload = true;
                        if (Util.$shiftKey) {
                            this.adjustmentScale(resultX, resultY);
                        }
                    }
                }
                break;

            case "scale-center-left": // 左中央
                if (this.updateLeftScaleX(event)) {
                    reload = true;
                }
                break;

            case "scale-bottom-left": // 左下
                {
                    const resultX = this.updateLeftScaleX(event);
                    const resultY = this.updateBottomScaleY(event);
                    if (resultX || resultY) {
                        reload = true;
                        if (Util.$shiftKey) {
                            this.adjustmentScale(resultX, resultY);
                        }
                    }
                }
                break;

            case "scale-center-bottom": // 中央下
                if (this.updateBottomScaleY(event)) {
                    reload = true;
                }
                break;

            case "scale-bottom-right": // 右下
                {
                    const resultX = this.updateRightScaleX(event);
                    const resultY = this.updateBottomScaleY(event);
                    if (resultX || resultY) {
                        reload = true;
                        if (Util.$shiftKey) {
                            this.adjustmentScale(resultX, resultY);
                        }
                    }
                }
                break;

            case "scale-center-right": // 中央右
                if (this.updateRightScaleX(event)) {
                    reload = true;
                }
                break;

            case "scale-top-right": // 右上
                {
                    const resultX = this.updateRightScaleX(event);
                    const resultY = this.updateTopScaleY(event);
                    if (resultX || resultY) {
                        reload = true;
                        if (Util.$shiftKey) {
                            this.adjustmentScale(resultX, resultY);
                        }
                    }
                }
                break;

            case "scale-center-top": // 中央上
                if (this.updateTopScaleY(event)) {
                    reload = true;
                }
                break;

            case "target-rotation": // 回転
                if (this.updateRotate(event)) {
                    reload = true;
                }
                break;

            case "reference-point": // 中心点
                this.updateReferencePoint(event);
                break;

            default:
                return ;

        }

        this.startPosition(event);
        if (reload) {
            this.reloadScreen();
        }

    }

    /**
     * @description マウスでの拡大縮小回転の時にShiftを押下してる時はロック時と同じく対比を固定
     *
     * @param  {number} x
     * @param  {number} y
     * @return {void}
     * @method
     * @public
     */
    adjustmentScale (x = 0, y = 0)
    {
        if (x !== y) {

            if (x) {

                const yScale = +document
                    .getElementById("transform-scale-y")
                    .value;

                Util
                    .$transformController
                    .updateScaleY((yScale + x) / 100);

            }

            if (y) {

                const xScale = +document
                    .getElementById("transform-scale-x")
                    .value;

                Util
                    .$transformController
                    .updateScaleX((xScale + y) / 100);

            }

        }
    }

    /**
     * @description マウスでの拡大縮小時の上部のx座標計算
     *              マウスが下に移動したら縮小、上に移動したら拡大
     *
     * @param  {MouseEvent} event
     * @return {number}
     * @method
     * @public
     */
    updateTopScaleY (event)
    {
        const updateScaleY = this.pageY - event.pageY;
        if (!updateScaleY) {
            return 0;
        }

        const yScale = +document
            .getElementById("transform-scale-y")
            .value;

        Util
            .$transformController
            .updateScaleY((yScale + updateScaleY) / 100);

        return updateScaleY;
    }

    /**
     * @description 回転処理、右に移動したら右回転、左に移動したら左回転
     *
     * @param  {MouseEvent} event
     * @return {number}
     * @method
     * @public
     */
    updateRotate (event)
    {
        const updateRotate = event.pageX - this.pageX;
        if (!updateRotate) {
            return 0;
        }

        const rotate = +document
            .getElementById("transform-rotate")
            .value;

        let value = rotate + updateRotate;
        value = Util.$clamp(
            (value | 0) % 360,
            TransformController.MIN_ROTATE,
            TransformController.MAX_ROTATE
        );
        if (0 > value) {
            value += 360;
        }

        Util
            .$transformController
            .updateRotate(value);

        return 1;
    }

    /**
     * @description 中心点を移動
     *
     * @param  {MouseEvent} event
     * @return {number}
     * @method
     * @public
     */
    updateReferencePoint (event)
    {
        const mouseX = (event.pageX - this.pageX) / Util.$zoomScale;
        const mouseY = (event.pageY - this.pageY) / Util.$zoomScale;

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;

        const element = document.getElementById("reference-point");
        if (activeElements.length > 1) {

            const point = Util
                .$referenceController
                .pointer;

            point.x += mouseX;
            point.y += mouseY;

            Util
                .$referenceController
                .setInputValue(point.x, point.y);

            element.style.left = `${element.offsetLeft + mouseX}px`;
            element.style.top  = `${element.offsetTop  + mouseY}px`;

        } else {

            const target  = activeElements[0];
            const layerId = target.dataset.layerId | 0;
            const scene   = Util.$currentWorkSpace().scene;
            const layer   = scene.getLayer(layerId);

            // 座標を更新
            const character = layer
                .getCharacter(target.dataset.characterId | 0);

            const frame = Util.$timelineFrame.currentFrame;
            const place = character.getPlace(frame);
            if (!place.point) {
                const bounds = character.getBounds();

                place.point = {
                    "x": place.matrix[4] + Math.abs(bounds.xMax - bounds.xMin) / 2,
                    "y": place.matrix[5] + Math.abs(bounds.yMax - bounds.yMin) / 2
                };
            }

            place.point.x += mouseX;
            place.point.y += mouseY;

            Util
                .$referenceController
                .setInputValue(place.point.x, place.point.y);

            const left = Util.$offsetLeft + place.point.x * Util.$zoomScale - element.offsetWidth  / 2;
            const top  = Util.$offsetTop  + place.point.y * Util.$zoomScale - element.offsetHeight / 2;

            element
                .setAttribute("style", `left: ${left}px; top: ${top}px;`);
        }
    }

    /**
     * @description マウスでの拡大縮小時の上部のy座標計算
     *              マウスが右に移動したら縮小、左に移動したら拡大
     *
     * @param  {MouseEvent} event
     * @return {number}
     * @method
     * @public
     */
    updateLeftScaleX (event)
    {
        const updateScaleX = this.pageX - event.pageX;
        if (!updateScaleX) {
            return 0;
        }

        const xScale = +document
            .getElementById("transform-scale-x")
            .value;

        Util
            .$transformController
            .updateScaleX((xScale + updateScaleX) / 100);

        return updateScaleX;
    }

    /**
     * @description マウスでの拡大縮小時の下部のy座標計算
     *              マウスが下に移動したら拡大、上に移動したら縮小なので、反転して計算する
     *
     * @param  {MouseEvent} event
     * @return {number}
     * @method
     * @public
     */
    updateBottomScaleY (event)
    {
        const updateScaleY = event.pageY - this.pageY;
        if (!updateScaleY) {
            return 0;
        }

        const yScale = +document
            .getElementById("transform-scale-y")
            .value;

        Util
            .$transformController
            .updateScaleY((yScale + updateScaleY) / 100);

        return updateScaleY;
    }

    /**
     * @description マウスでの拡大縮小時の下部のx座標計算
     *              マウスが右に移動したら拡大、左に移動したら縮小なので、反転して計算する
     *
     * @param  {MouseEvent} event
     * @return {number}
     * @method
     * @public
     */
    updateRightScaleX (event)
    {
        const updateScaleX = event.pageX - this.pageX;
        if (!updateScaleX) {
            return 0;
        }

        const xScale = +document
            .getElementById("transform-scale-x")
            .value;

        Util
            .$transformController
            .updateScaleX((xScale + updateScaleX) / 100);

        return updateScaleX;
    }

    /**
     * @description DisplayObjectのマウス移動処理関数
     *
     * @param  {MouseEvent} [event=null]
     * @return {void}
     * @method
     * @public
     */
    moveDisplayObject (event = null)
    {
        this.save();

        const scene = Util.$currentWorkSpace().scene;
        const frame = Util.$timelineFrame.currentFrame;

        const dx = event ? event.pageX - this.pageX : this.pageX;
        const dy = event ? event.pageY - this.pageY : this.pageY;

        const parentMatrix = Util.$sceneChange.concatenatedMatrix;

        const { Matrix } = next2d.geom;

        const matrix = new Matrix(
            parentMatrix[0], parentMatrix[1], parentMatrix[2],
            parentMatrix[3], parentMatrix[4], parentMatrix[5]
        );
        matrix.invert();

        let xMin = Number.MAX_VALUE;
        let yMin = Number.MAX_VALUE;
        for (let idx = 0; idx < this._$activeElements.length; ++idx) {

            const object  = this._$activeElements[idx];
            const element = document.getElementById(object.id);

            // ロックしている場合など、スクリーンにElementが存在しない場合はスキップ
            if (!element) {
                continue;
            }

            const layerId = element.dataset.layerId | 0;

            const layer = scene.getLayer(layerId);

            const character = layer
                .getCharacter(element.dataset.characterId | 0);

            // fixed logic
            this.initPlace(character, layerId, frame);

            const place  = character.getPlace(frame);
            const pointX = dx * matrix.a + dy * matrix.c;
            const pointY = dx * matrix.b + dy * matrix.d;

            place.matrix[4] += pointX / Util.$zoomScale;
            place.matrix[5] += pointY / Util.$zoomScale;

            // 中心点を更新
            const bounds = character.getBounds(parentMatrix);
            if (!place.point) {
                place.point = {
                    "x": Util.$sceneChange.offsetX + bounds.xMin + Math.abs(bounds.xMax - bounds.xMin) / 2,
                    "y": Util.$sceneChange.offsetY + bounds.yMin + Math.abs(bounds.yMax - bounds.yMin) / 2
                };
            } else {
                place.point.x += dx / Util.$zoomScale;
                place.point.y += dy / Util.$zoomScale;
            }

            let rectMatrix = null;
            if (Util.$sceneChange.length) {
                rectMatrix = Util.$multiplicationMatrix(
                    parentMatrix,
                    place.matrix
                );
            }

            const rectBounds = character.getBounds(rectMatrix);
            character.screenX = rectBounds.xMin;
            character.screenY = rectBounds.yMin;

            let divStyle = "position: absolute;";
            divStyle += `pointer-events: ${element.dataset.pointer};`;

            if (layer.maskId !== null) {
                const maskLayer = scene.getLayer(layer.maskId);
                if (maskLayer.lock && maskLayer._$characters.length) {

                    const matrix = Util.$sceneChange.concatenatedMatrix;

                    const maskCharacter = maskLayer._$characters[0];
                    maskCharacter.dispose();

                    const maskImage     = maskCharacter.draw(Util.$getCanvas());
                    const maskBounds    = maskCharacter.getBounds(matrix);

                    const maskSrc    = maskImage.toDataURL();
                    const maskWidth  = maskImage._$width  * Util.$zoomScale;
                    const maskHeight = maskImage._$height * Util.$zoomScale;

                    const x = (maskBounds.xMin - bounds.xMin) * Util.$zoomScale;
                    const y = (maskBounds.yMin - bounds.yMin) * Util.$zoomScale;

                    divStyle += `mask: url(${maskSrc}), none;`;
                    divStyle += `-webkit-mask: url(${maskSrc}), none;`;
                    divStyle += `mask-size: ${maskWidth}px ${maskHeight}px;`;
                    divStyle += `-webkit-mask-size: ${maskWidth}px ${maskHeight}px;`;
                    divStyle += "mask-repeat: no-repeat;";
                    divStyle += "-webkit-mask-repeat: no-repeat;";
                    divStyle += `mask-position: ${x}px ${y}px;`;
                    divStyle += `-webkit-mask-position: ${x}px ${y}px;`;

                    const image = character.draw(Util.$getCanvas());
                    divStyle += `mix-blend-mode: ${image.style.mixBlendMode};`;
                    divStyle += `filter: ${image.style.filter};`;

                }
            }

            const left = Util.$offsetLeft + (Util.$sceneChange.offsetX + bounds.xMin) * Util.$zoomScale;
            const top  = Util.$offsetTop  + (Util.$sceneChange.offsetY + bounds.yMin) * Util.$zoomScale;

            divStyle += `left: ${left}px;`;
            divStyle += `top: ${top}px;`;
            element.setAttribute("style", divStyle);

            // move resize rect
            xMin = Math.min(xMin, character.x);
            yMin = Math.min(yMin, character.y);

            // tweenの座標を再計算してポインターを再配置
            character.relocationTween(frame);
        }

        // 移動位置を更新
        if (event) {
            this.pageX = event.pageX;
            this.pageY = event.pageY;
        }

        document.getElementById("object-x").value = xMin;
        document.getElementById("object-y").value = yMin;

        // 複数選択している場合のポインターを更新
        if (this._$activeElements.length > 1) {
            const pointer = Util.$referenceController.pointer;
            pointer.x += dx;
            pointer.y += dy;
        }

        Util
            .$transformController
            .show()
            .relocation();

        Util
            .$gridController
            .show()
            .relocation();

        const element = document
            .getElementById("timeline-onion-skin");

        if (element && element.classList.contains("onion-skin-active")) {
            this.reloadScreen();
        }
    }

    /**
     * @description DisplayObjectのPlaceObjectがない時の処理関数
     *
     * @param  {Character} character
     * @param  {number} layer_id
     * @param  {number} frame
     * @return {void}
     * @public
     */
    initPlace (character, layer_id, frame)
    {
        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layer_id);

        let prevFrame = frame;
        while (prevFrame > 0) {

            const frameElement = layer.getChildren(prevFrame);
            if (frameElement
                && frameElement.dataset.frameState === "key-frame"
            ) {

                if (!character._$places.has(prevFrame)) {
                    character.setPlace(prevFrame,
                        character.getClonePlace(prevFrame)
                    );
                }

                break;
            }

            prevFrame--;
        }
    }

    /**
     * @description コントローラーの変形にあるInputの値を再計算して更新
     * @return {void}
     * @method
     * @public
     */
    updateControllerProperty ()
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        let character   = null;

        // 拡大縮小回転の範囲とポインターの情報を再取得
        let tx   = Number.MAX_VALUE;
        let ty   = Number.MAX_VALUE;
        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;
        for (let idx = 0; idx < this._$activeElements.length; ++idx) {

            const moveTarget = this._$activeElements[idx];

            const layerId = moveTarget.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            character = layer.getCharacter(
                moveTarget.dataset.characterId | 0
            );

            tx = Math.min(tx, character.x);
            ty = Math.min(ty, character.y);

            const bounds = character.getBounds();
            xMin = Math.min(xMin, bounds.xMin);
            xMax = Math.max(xMax, bounds.xMax);
            yMin = Math.min(yMin, bounds.yMin);
            yMax = Math.max(yMax, bounds.yMax);
        }

        const width  = Math.abs(xMax - xMin);
        const height = Math.abs(yMax - yMin);
        document.getElementById("object-width").value  = `${width}`;
        document.getElementById("object-height").value = `${height}`;
        document.getElementById("object-x").value = `${tx}`;
        document.getElementById("object-y").value = `${ty}`;

        // オブジェクト設定を表示して、Stage情報は非表示にする
        Util.$controller.showObjectSetting([
            "object-area"
        ]);
        Util.$controller.hideObjectSetting([
            "stage-setting",
            "fill-color-setting"
        ]);

        if (this._$activeElements.length > 1) {

            // 複数選択時は変形以外のコントローラーを非表示にする
            Util.$controller.hideObjectSetting([
                "object-setting",
                "color-setting",
                "blend-setting",
                "loop-setting",
                "filter-setting",
                "video-setting",
                "instance-setting",
                "text-setting",
                "nine-slice-setting",
                "sound-setting",
                "ease-setting"
            ]);

            // 複数選択時には選択中心位置に移動
            if (!Util.$referenceController.pointer) {
                Util.$referenceController.resetPointer();
            }

            document
                .getElementById("transform-scale-x")
                .value = 100;

            document
                .getElementById("transform-scale-y")
                .value = 100;

            document
                .getElementById("transform-rotate")
                .value = 0;

        } else {
            character.showController();
        }
    }

    /**
     * @description 親のMovieClipへシーン移動
     *
     * @return {void}
     * @method
     * @public
     */
    moveScene ()
    {
        const node = document
            .getElementById("scene-name-menu-list")
            .lastElementChild;

        if (node) {

            Util.$sceneChange.offsetX = +node.dataset.offsetX;
            Util.$sceneChange.offsetY = +node.dataset.offsetY;

            // アクティブな情報を削除
            Util.$activeCharacterIds.pop();
            Util.$sceneChange.matrix.pop();
            Util.$sceneChange.length--;

            // シーン移動
            Util.$sceneChange.execute(
                node.dataset.libraryId | 0
            );

            // リストから削除
            node.remove();
        }
    }
}

/**
 * @class
 * @extends {BaseTool}
 * @memberOf view.tool.default
 */
class ArrowTransformTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("arrow-transform");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        for (const name of tool._$events.keys()) {

            if (name === EventType.START || name === EventType.END) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            this.addEventListener(name, (event) =>
            {
                Util
                    .$tools
                    .getDefaultTool("arrow")
                    .dispatchEvent(name, event);
            });
        }

        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor(this._$cursor);
            this.changeNodeEvent();

            const element = document.getElementById("target-rect");
            if (element) {
                element.setAttribute("class", "");
            }

            // 選択中のDisplayObjectがあればアクティブ化
            Util.$timelineLayer.activeCharacter();

            // 強制的にアクティブ化
            this.active = true;

            // 変形ツールを再計算
            Util
                .$transformController
                .show()
                .relocation();
        });

        // ツール終了時に初期化
        this.addEventListener(EventType.END, () =>
        {
            /**
             * @type {ArrowTool}
             */
            const tool = Util.$tools.getDefaultTool("arrow");

            // 配列を初期化
            tool.clearActiveElement();

            // スクリーンエリアの変形Elementを非表示に
            Util.$transformController.hide();
            Util.$gridController.hide();
            Util.$tweenController.clearPointer();

            // コントローラーエリアを初期化
            Util.$controller.default();

            // 強制的に非アクティブ化
            this.active = false;
        });
    }
}
/**
 * @class
 * @extends {BaseTool}
 * @memberOf view.tool.default
 */
class BucketTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("bucket");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            this.setCursor();
            this.changeNodeEvent();
        });

        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            this.setCursor();

            // 親のイベントを中止する
            event.stopPropagation();

            if (event.displayObject) {
                this.mouseDown(event);
            }
        });

        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            this.setCursor();

            // 親のイベントを中止する
            event.stopPropagation();
        });

        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            this.setCursor();

            // 親のイベントを中止する
            event.stopPropagation();

            Util.$tools.reset();
        });
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    setCursor ()
    {
        const color = Util.$intToRGB(
            `0x${document.getElementById("fill-color").value.slice(1)}` | 0
        );
        Util.$setCursor(`url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="rgb(${color.R},${color.G},${color.B})" d="M24 19.007c0-3.167-1.409-6.771-2.835-9.301l-.006-.01-.014-.026c-.732-1.392-1.914-3.052-3.619-4.757-2.976-2.976-5.476-3.912-6.785-3.913-.413 0-.708.094-.859.245l-.654.654c-1.898-.236-3.42.105-4.294.982-.876.875-1.164 2.159-.792 3.524.242.893.807 1.891 1.752 2.836.867.867 2.062 1.684 3.615 2.327.488-.839 1.654-1.019 2.359-.315.586.586.584 1.533-.002 2.119s-1.533.589-2.121 0c-.229-.229-.366-.515-.416-.812-1.646-.657-3.066-1.534-4.144-2.612-.728-.728-1.289-1.528-1.664-2.349l-2.835 2.832c-.445.447-.685 1.064-.686 1.82.001 1.635 1.122 3.915 3.714 6.506 2.764 2.764 5.58 4.243 7.431 4.243.649 0 1.181-.195 1.548-.562l8.086-8.079c.911.875-.777 3.541-.777 4.65 0 1.104.896 1.999 2 1.998 1.104 0 1.998-.895 1.998-2zm-18.912-12.974c-.236-.978-.05-1.845.554-2.444.526-.53 1.471-.791 2.656-.761l-3.21 3.205zm9.138 2.341l-.03-.029c-1.29-1.291-3.802-4.354-3.095-5.062.715-.715 3.488 1.521 5.062 3.095.862.863 2.088 2.248 2.938 3.459-1.718-1.073-3.493-1.469-4.875-1.463zm-3.875 12.348c-.547-.082-1.5-.547-1.9-.928l7.086-7.086c.351.37 1.264.931 1.753 1.075l-6.939 6.939z"/></svg>'),auto`);
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        const element = event.target;
        if (element.dataset.instanceType === InstanceType.SHAPE) {

            const { Graphics } = window.next2d.display;

            const workSpace = Util.$currentWorkSpace();
            workSpace.temporarilySaved();

            const instance = workSpace.getLibrary(
                element.dataset.libraryId | 0
            );

            const color = Util.$intToRGB(
                `0x${document.getElementById("fill-color").value.slice(1)}` | 0
            );

            switch (instance._$recodes[instance._$recodes.length - 1]) {

                case Graphics.END_FILL:
                    instance._$recodes.splice(
                        instance._$recodes.length - 6,
                        6,
                        Graphics.FILL_STYLE,
                        color.R,
                        color.G,
                        color.B,
                        255,
                        Graphics.END_FILL
                    );
                    break;

                case Graphics.END_STROKE:
                    instance._$recodes.push(
                        Graphics.FILL_STYLE,
                        color.R,
                        color.G,
                        color.B,
                        255,
                        Graphics.END_FILL
                    );
                    break;

                default:
                    break;

            }

            instance.cacheClear();

            // 再描画
            this.reloadScreen();
        }
    }
}

/**
 * @class
 * @extends {DrawTool}
 * @memberOf view.tool.default
 */
class CircleTool extends DrawTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("circle");
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    createCharacter ()
    {
        super.createCharacter("circle");
    }
}

/**
 * @class
 * @extends {BaseTool}
 * @memberOf view.tool.default
 */
class HandTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("hand");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        this.setCursor("grab");

        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor(this._$cursor);
            this.changeNodeEvent(false);
        });

        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            Util.$setCursor(this._$cursor);

            if (!this.active) {
                return ;
            }

            // 画面をスクロール
            const element = document.getElementById("screen");
            element.scrollLeft += this.pageX - event.pageX;
            element.scrollTop  += this.pageY - event.pageY;

            // 値を更新
            this.pageX = event.pageX;
            this.pageY = event.pageY;
        });

        this.addEventListener(EventType.MOUSE_UP, () =>
        {
            this.active = false;
            this.setCursor("grab");
            Util.$setCursor(this._$cursor);
        });

        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            this.active = true;

            this.setCursor("grabbing");
            Util.$setCursor(this._$cursor);

            this.pageX = event.pageX;
            this.pageY = event.pageY;
        });
    }
}

/**
 * @class
 * @extends {BaseTool}
 * @memberOf view.tool.default
 */
class PenTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("pen");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            this.setCursor();
            this.changeNodeEvent(false);
        });

        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            this.setCursor();

            // 親のイベントを中止する
            event.stopPropagation();

            // ペンで追加したElementを削除
            this.clearPenPointer();

            // 初期座標をセット
            let offsetX = event.offsetX;
            let offsetY = event.offsetY;
            if (event.target.id !== "stage-area") {
                offsetX += event.target.offsetLeft;
                offsetY += event.target.offsetTop;
            }

            this.offsetX = offsetX;
            this.offsetY = offsetY;
        });

        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            this.setCursor();

            // 親のイベントを中止する
            event.stopPropagation();

            if (event.screen && this.active) {
                this.mouseMove(event);
            }
        });

        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            this.setCursor();

            // 親のイベントを中止する
            event.stopPropagation();

            this.mouseUp();
        });
    }

    /**
     * @description ペンで使用してるポインターelementを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clearPenPointer ()
    {
        const element  = document
            .getElementById("stage-area");

        for (let idx = 0; element.children.length > idx; ++idx) {

            const node = element.children[idx];
            if (!node.dataset.penPointer) {
                continue;
            }

            node.remove();
            --idx;
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    setCursor ()
    {
        const color = Util.$intToRGB(
            `0x${document.getElementById("stroke-color").value.slice(1)}` | 0
        );
        Util.$setCursor(`url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 24 24"><path fill="rgb(${color.R},${color.G},${color.B})" d="M1.438 16.875l5.688 5.689-7.126 1.436 1.438-7.125zm22.562-11.186l-15.46 15.46-5.688-5.689 15.459-15.46 5.689 5.689zm-4.839-2.017l-.849-.849-12.614 12.599.85.849 12.613-12.599z"/></svg>') 0 12, auto`);
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        const width = document.getElementById("stroke-size").value | 0;
        if (width) {

            event.preventDefault();

            let x = event.offsetX;
            let y = event.offsetY;
            if (event.target.id !== "stage-area") {
                x += event.target.offsetLeft;
                y += event.target.offsetTop;
            }

            const element = document.getElementById("stage-area");

            const div = document.createElement("div");
            div.dataset.penPointer = "true";
            div.classList.add("pen-pointer");

            div.style.width           = `${width}px`;
            div.style.height          = `${width}px`;
            div.style.left            = `${x}px`;
            div.style.top             = `${y}px`;
            div.style.backgroundColor = document.getElementById("stroke-color").value;
            div.style.borderRadius    = `${width / 2}px`;

            element.appendChild(div);
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        Util.$timelineLayer.attachLayer();
        const { Shape } = window.next2d.display;

        const thickness = document
            .getElementById("stroke-size").value | 0;

        const shape = new Shape();
        shape.graphics.lineStyle(
            thickness,
            document.getElementById("stroke-color").value
        );

        const x = this.offsetX - Util.$offsetLeft;
        const y = this.offsetY - Util.$offsetTop;
        shape.graphics.moveTo(0, 0);

        const element  = document.getElementById("stage-area");
        const children = element.children;
        for (let idx = 0; children.length > idx; ++idx) {

            const node = children[idx];
            if (!node.dataset.penPointer) {
                continue;
            }

            shape.graphics.lineTo(
                (node.offsetLeft - Util.$offsetLeft - x) / Util.$zoomScale,
                (node.offsetTop  - Util.$offsetTop  - y) / Util.$zoomScale
            );

            node.remove();
            --idx;
        }
        shape.graphics.endLine();

        const id = Util.$currentWorkSpace().nextLibraryId;
        const dx = (x + thickness) / 2 / Util.$zoomScale;
        const dy = (y + thickness) / 2 / Util.$zoomScale;
        this.createShape({
            "id": id,
            "type": InstanceType.SHAPE,
            "name": `Shape_${id}`,
            "symbol": "",
            "recodes": shape.graphics._$recode.slice(0),
            "bounds": {
                "xMin": shape.graphics._$xMin,
                "xMax": shape.graphics._$xMax,
                "yMin": shape.graphics._$yMin,
                "yMax": shape.graphics._$yMax
            }
        }, dx, dy);

        // 再描画
        this.reloadScreen();

        Util.$tools.reset();
    }
}

/**
 * @class
 * @extends {DrawTool}
 * @memberOf view.tool.default
 */
class RectangleTool extends DrawTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("rectangle");
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    createCharacter ()
    {
        super.createCharacter("rectangle");
    }
}

/**
 * @class
 * @extends {DrawTool}
 * @memberOf view.tool.default
 */
class RoundRectTool extends DrawTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("round-rect");
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    createCharacter ()
    {
        super.createCharacter("round-rect");
    }
}

/**
 * @class
 * @extends {BaseTool}
 * @memberOf view.tool.default
 */
class TextTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("text");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor("text");
            this.changeNodeEvent(false);
        });

        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            Util.$setCursor("text");

            // 親のイベントを中止する
            event.stopPropagation();

            if (event.screen) {
                this.mouseDown(event);
            }
        });

        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            Util.$setCursor("text");

            // 親のイベントを中止する
            event.stopPropagation();

            if (event.screen) {
                this.mouseMove(event);
            }
        });

        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            Util.$setCursor("text");

            if (event.screen) {
                // 親のイベントを中止する
                event.stopPropagation();

                // マウスアップ処理
                this.mouseUp();

                // 選択ツールに戻す
                Util.$tools.reset();
            }
        });
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        // オフセット値を調整
        let offsetX = event.offsetX;
        let offsetY = event.offsetY;
        if (event.target.id !== "stage-area") {
            offsetX += event.target.offsetLeft;
            offsetY += event.target.offsetTop;
        }

        // 初期座標をセット
        this.pageX   = event.pageX;
        this.pageY   = event.pageY;
        this.offsetX = offsetX;
        this.offsetY = offsetY;

        const element = document.getElementById("draw-text");
        element.style.left    = `${event.pageX}px`;
        element.style.top     = `${event.pageY}px`;
        element.style.width   = "0px";
        element.style.height  = "0px";
        element.style.display = "";
        element.style.border = "1px dashed gray";
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        event.preventDefault();

        const x = event.pageX;
        const y = event.pageY;

        const element = document.getElementById("draw-text");

        if (this.pageX > x) {
            this.offsetX = event.offsetX;
            element.style.left = `${x}px`;
        }
        if (this.pageY > y) {
            this.offsetY = event.offsetY;
            element.style.top = `${y}px`;
        }

        element.style.width  = `${Math.abs(x - this.pageX)}px`;
        element.style.height = `${Math.abs(y - this.pageY)}px`;
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        Util.$timelineLayer.attachLayer();

        const element = document.getElementById("draw-text");
        const workSpace = Util.$currentWorkSpace();
        workSpace.temporarilySaved();

        const x      = (this.offsetX - Util.$offsetLeft) / Util.$zoomScale;
        const y      = (this.offsetY - Util.$offsetTop)  / Util.$zoomScale;
        const width  = parseFloat(element.style.width)  / Util.$zoomScale;
        const height = parseFloat(element.style.height) / Util.$zoomScale;

        const id = workSpace.nextLibraryId;
        this.createTextField({
            "id": id,
            "type": InstanceType.TEXT,
            "name": `Text_${id}`,
            "symbol": "",
            "bounds": {
                "xMin": 0,
                "xMax": width,
                "yMin": 0,
                "yMax": height
            },
            "originBounds": {
                "xMin": 0,
                "xMax": width,
                "yMin": 0,
                "yMax": height
            }
        }, x, y);

        // 再描画
        this.reloadScreen();

        element.style.display = "none";
    }
}

/**
 * @class
 * @extends {BaseTool}
 * @memberOf view.tool.default
 */
class TransformTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("transform");

        /**
         * @type {HTMLDivElement}
         * @private
         */
        this._$element = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$deletePointer = null;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // 専用カーソルを登録
        this.setCursor(
            "url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"25\" height=\"25\" viewBox=\"0 0 48 48\"><path fill=\"white\" d=\"M27.8,39.7c-0.1,0-0.2,0-0.4-0.1c-0.2-0.1-0.4-0.3-0.6-0.5l-3.7-8.6l-4.5,4.2C18.5,34.9,18.3,35,18,35c-0.1,0-0.3,0-0.4-0.1C17.3,34.8,17,34.4,17,34l0-22c0-0.4,0.2-0.8,0.6-0.9C17.7,11,17.9,11,18,11c0.2,0,0.5,0.1,0.7,0.3l16,15c0.3,0.3,0.4,0.7,0.3,1.1c-0.1,0.4-0.5,0.6-0.9,0.7l-6.3,0.6l3.9,8.5c0.1,0.2,0.1,0.5,0,0.8c-0.1,0.2-0.3,0.5-0.5,0.6l-2.9,1.3C28.1,39.7,27.9,39.7,27.8,39.7z\"/><path fill=\"black\" d=\"M18,12l16,15l-7.7,0.7l4.5,9.8l-2.9,1.3l-4.3-9.9L18,34L18,12 M18,10c-0.3,0-0.5,0.1-0.8,0.2c-0.7,0.3-1.2,1-1.2,1.8l0,22c0,0.8,0.5,1.5,1.2,1.8C17.5,36,17.8,36,18,36c0.5,0,1-0.2,1.4-0.5l3.4-3.2l3.1,7.3c0.2,0.5,0.6,0.9,1.1,1.1c0.2,0.1,0.5,0.1,0.7,0.1c0.3,0,0.5-0.1,0.8-0.2l2.9-1.3c0.5-0.2,0.9-0.6,1.1-1.1c0.2-0.5,0.2-1.1,0-1.5l-3.3-7.2l4.9-0.4c0.8-0.1,1.5-0.6,1.7-1.3c0.3-0.7,0.1-1.6-0.5-2.1l-16-15C19,10.2,18.5,10,18,10L18,10z\"/></svg>') 6 6,auto"
        );

        // 開始イベント
        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor(this._$cursor);
            this.changeNodeEvent();

            this._$deletePointer = this.deletePointer.bind(this);
            window.addEventListener("keydown", this._$deletePointer);
        });

        // 終了イベント
        this.addEventListener(EventType.END, () =>
        {
            window.removeEventListener("keydown", this._$deletePointer);
        });

        // スクリーン上でのマウスダウンイベント
        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            Util.$setCursor(this._$cursor);
            switch (true) {

                case event.displayObject:
                    this._$element = null;
                    this.mouseDownForDisplayObject(event);
                    break;

                case event.shapePointer:
                    this.mouseDownForPointer(event);
                    break;

                default:
                    this._$element = null;
                    break;

            }
        });

        // スクリーン上でのダブルクリックイベント
        this.addEventListener(EventType.DBL_CLICK, (event) =>
        {
            Util.$setCursor(this._$cursor);

            // 親のイベントを中止する
            event.stopPropagation();

            switch (true) {

                case event.shapePointer:
                    this.addCurvePointer(event);
                    break;

                case event.screen:
                    this.addPointer(event);
                    break;

                default:
                    break;

            }
        });

        // スクリーン上でのマウスアップイベント
        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            Util.$setCursor(this._$cursor);

            // 親のイベントを中止する
            event.stopPropagation();
        });

        // スクリーン上でのマウスムーブイベント
        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            Util.$setCursor(this._$cursor);
            if (this.active) {

                // 親のイベントを中止する
                event.stopPropagation();

                this.movePointer(event);
            }
        });
    }

    /**
     * @description Shapeの新しいポインター追加関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    addPointer (event)
    {
        // アクティブなポインターがあれば初期化
        this.clearActivePointer();

        const frame = Util.$timelineFrame.currentFrame;

        let target = null;
        let minDistance = Number.MAX_VALUE;

        const children = document
            .getElementById("stage-area")
            .children;

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        let px = event.offsetX;
        let py = event.offsetY;
        if (event.target.id !== "stage-area") {

            const layerId     = event.target.dataset.layerId | 0;
            const characterId = event.target.dataset.characterId | 0;
            const layer       = scene.getLayer(layerId);
            const character   = layer.getCharacter(characterId);

            px = character.screenX + Util.$offsetLeft + event.offsetX;
            py = character.screenY + Util.$offsetTop  + event.offsetY;
        }

        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];
            if (!node.dataset.shapePointer) {
                continue;
            }

            if (node.dataset.curve === "true") {
                continue;
            }

            const distance = Math.sqrt(
                Math.pow(node.offsetLeft - px, 2)
                + Math.pow(node.offsetTop - py, 2)
            );

            if (minDistance > distance) {
                target = node;
            }
            minDistance = Math.min(minDistance, distance);
        }

        if (!target) {
            return ;
        }

        const instance = workSpace.getLibrary(
            target.dataset.libraryId | 0
        );
        if (!instance) {
            return ;
        }

        const targets  = [];
        const position = target.dataset.position | 0;

        for (let idx = position + 1; idx < children.length; ++idx) {

            const node = children[idx];
            if (node.dataset.curve === "true") {
                continue;
            }

            targets.push(node);
            break;
        }

        if (!targets.length) {

            for (let idx = 0; idx < children.length; ++idx) {

                const node = children[idx];
                if (!node.dataset.shapePointer) {
                    continue;
                }

                if (node.dataset.curve === "true") {
                    continue;
                }

                targets.push(node);
                break;
            }

        }

        for (let idx = position - 1; ; --idx) {

            const node = children[idx];
            if (!node.dataset.shapePointer) {
                break;
            }

            if (node.dataset.curve === "true") {
                continue;
            }

            targets.push(node);
            break;
        }

        if (targets.length === 1) {
            for (let idx = children.length - 1; ; --idx) {

                const node = children[idx];
                if (!node.dataset.shapePointer) {
                    break;
                }

                if (node.dataset.curve === "true") {
                    continue;
                }

                targets.push(node);
                break;
            }
        }

        let nextTarget = null;
        minDistance = Number.MAX_VALUE;
        for (let idx = 0; idx < targets.length; ++idx) {

            const node = targets[idx];

            const distance = Math.sqrt(
                Math.pow(node.offsetLeft - px, 2)
                + Math.pow(node.offsetTop - py, 2)
            );

            if (minDistance > distance) {
                nextTarget = node;
            }
            minDistance = Math.min(minDistance, distance);
        }

        const { Graphics } = window.next2d.display;
        const layerId      = target.dataset.layerId | 0;
        const characterId  = target.dataset.characterId | 0;
        const layer        = scene.getLayer(layerId);
        const character    = layer.getCharacter(characterId);
        const matrix       = character.getPlace(frame).matrix;

        const xScale = Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale = Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        const index     = target.dataset.index | 0;
        const nextIndex = nextTarget.dataset.index | 0;
        if (nextIndex > index) {

            instance._$recodes.splice(index + 2, 0,
                Graphics.LINE_TO,
                (px - Util.$offsetLeft - character.screenX + instance._$bounds.xMin) / xScale,
                (py - Util.$offsetTop  - character.screenY + instance._$bounds.yMin) / yScale
            );

        } else {

            instance._$recodes.splice(nextIndex + 2, 0,
                Graphics.LINE_TO,
                (px - Util.$offsetLeft - character.screenX + instance._$bounds.xMin) / xScale,
                (py - Util.$offsetTop  - character.screenY + instance._$bounds.yMin) / yScale
            );

        }

        // pointer remove
        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];
            if (!node.dataset.shapePointer) {
                continue;
            }

            if (node.dataset.curve === "true") {
                continue;
            }

            node.remove();
            --idx;
        }

        const bounds = instance.reloadBounds(
            Util.$hitColor ? Util.$hitColor.width | 0 : 0
        );
        instance._$bounds.xMin = bounds.xMin;
        instance._$bounds.xMax = bounds.xMax;
        instance._$bounds.yMin = bounds.yMin;
        instance._$bounds.yMax = bounds.yMax;
        instance.cacheClear();

        scene.changeFrame(frame);

        if (character) {
            const matrix = character.getPlace(frame).matrix;
            instance.createPointer(matrix, layerId, characterId);
        }
    }

    /**
     * @description 指定したポインターのカーブポインター追加関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    addCurvePointer (event)
    {
        // アクティブなポインターがあれば初期化
        this.clearActivePointer();

        const { Graphics } = window.next2d.display;

        const workSpace = Util.$currentWorkSpace();

        const element = event.target;
        const curve   = element.dataset.curve === "true";
        if (!curve) {

            const type        = element.dataset.type | 0;
            const index       = element.dataset.index | 0;
            const layerId     = element.dataset.layerId | 0;
            const characterId = element.dataset.characterId | 0;

            const instance = workSpace.getLibrary(
                element.dataset.libraryId | 0
            );

            switch (type) {

                case Graphics.LINE_TO:
                    {
                        workSpace
                            .temporarilySaved();

                        instance._$recodes[index - 1] = Graphics.CURVE_TO;

                        const tx = instance._$recodes[index    ];
                        const ty = instance._$recodes[index + 1];
                        instance._$recodes.splice(index + 2, 0, tx, ty);

                        instance._$recodes[index    ] += 20;
                        instance._$recodes[index + 1] += 20;

                        instance.cacheClear();

                        const frame = Util.$timelineFrame.currentFrame;

                        workSpace
                            .scene
                            .changeFrame(frame);

                        instance.createPointer(event.matrix, layerId, characterId);
                    }
                    break;

                case Graphics.CURVE_TO:
                    {
                        workSpace
                            .temporarilySaved();

                        instance._$recodes[index - 3] = Graphics.CUBIC;

                        const tx = instance._$recodes[index    ];
                        const ty = instance._$recodes[index + 1];
                        instance._$recodes.splice(index + 2, 0, tx, ty);

                        instance._$recodes[index    ] += 20;
                        instance._$recodes[index + 1] += 20;

                        instance.cacheClear();

                        const frame = Util.$timelineFrame.currentFrame;
                        Util.$currentWorkSpace().scene.changeFrame(frame);

                        instance.createPointer(event.matrix, layerId, characterId);
                    }
                    break;

            }
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    clearActivePointer ()
    {
        const { Graphics } = window.next2d.display;

        const stageArea = document
            .getElementById("stage-area");

        // アクティブなポインターがあれば初期化
        const element = this._$element;
        if (element) {

            element.style.backgroundColor = "";

            const position = element.dataset.position | 0;
            const type     = element.dataset.type | 0;
            const curve    = element.dataset.curve === "true";
            switch (type) {

                case Graphics.CURVE_TO:
                    if (curve) {
                        stageArea.children[position + 1].style.backgroundColor = "";
                    } else {
                        stageArea.children[position - 1].style.backgroundColor = "";
                    }
                    break;

                case Graphics.CUBIC:
                    if (curve) {
                        for (let idx = 1; idx < 3; ++idx) {
                            const element = stageArea.children[position + idx];
                            element.style.backgroundColor = "";
                            if (element.dataset.curve !== "true") {
                                if (idx === 1) {
                                    stageArea.children[position - 1].style.backgroundColor = "";
                                }
                                break;
                            }
                        }
                    } else {
                        stageArea.children[position - 1].style.backgroundColor = "";
                        stageArea.children[position - 2].style.backgroundColor = "";
                    }
                    break;

            }
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDownForPointer (event)
    {
        Util
            .$currentWorkSpace()
            .temporarilySaved();

        const { Graphics } = window.next2d.display;

        const stageArea = document
            .getElementById("stage-area");

        // アクティブなポインターがあれば初期化
        this.clearActivePointer();

        const target   = this.target;
        this._$element = target;

        // ターゲットなるポインターの現在のxy座標をセット
        this.pageX = event.pageX - target.offsetLeft;
        this.pageY = event.pageY - target.offsetTop;

        const element = this.target;
        element.style.backgroundColor = Util.$shapePointerColor;

        const position = element.dataset.position | 0;
        const type     = element.dataset.type | 0;
        const curve    = element.dataset.curve === "true";

        switch (type) {

            case Graphics.CURVE_TO:
                if (curve) {
                    stageArea
                        .children[position + 1]
                        .style
                        .backgroundColor = Util.$shapeLinkedPointerColor;
                } else {
                    stageArea
                        .children[position - 1]
                        .style
                        .backgroundColor = Util.$shapeLinkedPointerColor;
                }
                break;

            case Graphics.CUBIC:
                if (curve) {
                    for (let idx = 1; idx < 3; ++idx) {

                        const element = stageArea.children[position + idx];
                        element
                            .style
                            .backgroundColor = Util.$shapeLinkedPointerColor;

                        if (element.dataset.curve !== "true") {
                            if (idx === 1) {
                                stageArea
                                    .children[position - 1]
                                    .style
                                    .backgroundColor = Util.$shapeLinkedPointerColor;
                            }
                            break;
                        }
                    }
                } else {
                    stageArea
                        .children[position - 1]
                        .style
                        .backgroundColor = Util.$shapeLinkedPointerColor;

                    stageArea
                        .children[position - 2]
                        .style
                        .backgroundColor = Util.$shapeLinkedPointerColor;
                }
                break;

        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDownForDisplayObject (event)
    {
        const target = this.target;
        if (target.dataset.instanceType !== InstanceType.SHAPE) {
            return ;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        // スクリーンを初期化
        tool.clear();

        const frame = Util.$timelineFrame.currentFrame;

        const workSpace   = Util.$currentWorkSpace();
        const layerId     = target.dataset.layerId | 0;
        const characterId = target.dataset.characterId | 0;

        const layer     = workSpace.scene.getLayer(layerId);
        const character = layer.getCharacter(characterId);
        const instance  = workSpace.getLibrary(target.dataset.libraryId | 0);
        const matrix    = character.getPlace(frame).matrix;

        const cacheColor = Util.$hitColor;
        instance.setHitColor(event.offsetX, event.offsetY, matrix);
        if (Util.$hitColor) {
            instance.createPointer(matrix, layerId, characterId);
        } else {
            Util.$hitColor = cacheColor;
        }
    }

    /**
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    movePointer (event)
    {
        const element = this.target;
        if (element.dataset.shapePointer !== "true") {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace.getLibrary(
            element.dataset.libraryId | 0
        );
        if (!instance) {
            Util.$clearShapePointer();
            return ;
        }

        event.preventDefault();

        const frame = Util.$timelineFrame.currentFrame;

        const layerId     = element.dataset.layerId | 0;
        const characterId = element.dataset.characterId | 0;

        const scene       = workSpace.scene;
        const layer       = scene.getLayer(layerId);
        const character   = layer.getCharacter(characterId);
        const matrix      = character.getPlace(frame).matrix;

        const x = event.pageX - this.pageX;
        const y = event.pageY - this.pageY;

        const angle  = Math.atan2(matrix[1], matrix[0]) * Util.$Rad2Deg;
        const scaleX = Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const scaleY = Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        let tx = (x - element.offsetLeft) / scaleX;
        let ty = (y - element.offsetTop)  / scaleY;
        if (angle) {
            const rad = (360 - angle) * (Math.PI / 180);
            tx *= Math.cos(rad);
            ty *= Math.sin(rad);
        }

        const index = element.dataset.index | 0;
        instance._$recodes[index    ] += tx / Util.$zoomScale;
        instance._$recodes[index + 1] += ty / Util.$zoomScale;

        const syncId = element.dataset.syncId | 0;
        if (syncId) {
            instance._$recodes[syncId    ] += tx / Util.$zoomScale;
            instance._$recodes[syncId + 1] += ty / Util.$zoomScale;
        }

        element.style.left = `${x}px`;
        element.style.top  = `${y}px`;

        const bounds = instance.reloadBounds(
            Util.$hitColor ? Util.$hitColor.width | 0 : 0
        );
        instance._$bounds.xMin = bounds.xMin;
        instance._$bounds.xMax = bounds.xMax;
        instance._$bounds.yMin = bounds.yMin;
        instance._$bounds.yMax = bounds.yMax;
        instance.cacheClear();

        scene.changeFrame(frame);
    }

    /**
     * @description ポインターを削除
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    deletePointer (event)
    {
        Util.$setCursor(this._$cursor);

        if (Util.$keyLock || event.key !== "Backspace") {
            return ;
        }

        // 親のイベントを中止する
        event.stopPropagation();

        const stageArea = document.getElementById("stage-area");

        let count = 0;
        const children = stageArea.children;
        for (let idx = 0; children.length > idx; ++idx) {

            const node = children[idx];
            if (!node.dataset.shapePointer) {
                continue;
            }

            if (node.dataset.curve === "false") {
                count++;
            }
        }

        const element = this._$element;
        if (!element) {
            return ;
        }

        const curve = element.dataset.curve === "true";
        if (!element.dataset.syncId && (count > 2 || curve)) {

            const workSpace = Util.$currentWorkSpace();
            workSpace.temporarilySaved();

            const { Graphics } = window.next2d.display;

            const instance  = workSpace.getLibrary(
                element.dataset.libraryId | 0
            );

            const index = element.dataset.index | 0;
            const type  = element.dataset.type | 0;
            switch (type) {

                case Graphics.MOVE_TO:
                    break;

                case Graphics.LINE_TO:
                    instance._$recodes.splice(index - 1, 3);
                    break;

                case Graphics.CUBIC:
                    {
                        let deletePos = index;
                        for (;;) {
                            if (instance._$recodes[--deletePos] === Graphics.CUBIC) {
                                break;
                            }
                        }

                        if (curve) {

                            instance._$recodes[deletePos] = Graphics.CURVE_TO;
                            instance._$recodes.splice(index, 2);

                        } else {

                            instance._$recodes.splice(deletePos, 7);

                        }
                    }
                    break;

                case Graphics.CURVE_TO:
                    {
                        let deletePos = index;
                        for (;;) {
                            if (instance._$recodes[--deletePos] === Graphics.CURVE_TO) {
                                break;
                            }
                        }

                        if (curve) {

                            instance._$recodes[deletePos] = Graphics.LINE_TO;
                            instance._$recodes.splice(index, 2);

                        } else {

                            instance._$recodes.splice(deletePos, 5);

                        }
                    }
                    break;

            }

            const bounds = instance.reloadBounds(
                Util.$hitColor ? Util.$hitColor.width | 0 : 0
            );
            instance._$bounds.xMin = bounds.xMin;
            instance._$bounds.xMax = bounds.xMax;
            instance._$bounds.yMin = bounds.yMin;
            instance._$bounds.yMax = bounds.yMax;
            instance.cacheClear();

            // reload
            const frame = Util.$timelineFrame.currentFrame;

            const scene = workSpace.scene;
            scene.changeFrame(frame);

            const layerId     = element.dataset.layerId | 0;
            const characterId = element.dataset.characterId | 0;
            const layer       = scene.getLayer(layerId);
            const character   = layer.getCharacter(characterId);
            if (character) {
                const matrix = character.getPlace(frame).matrix;
                instance.createPointer(matrix, layerId, characterId);
            }
        }
    }
}

/**
 * @class
 * @extends {BaseTool}
 * @memberOf view.tool.default
 */
class ZoomTool extends BaseTool
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("zoom");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // 専用カーソルを登録
        this.setCursor(
            "url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"17\" height=\"17\" viewBox=\"0 0 24 24\"><path d=\"M13 10h-3v3h-2v-3h-3v-2h3v-3h2v3h3v2zm8.172 14l-7.387-7.387c-1.388.874-3.024 1.387-4.785 1.387-4.971 0-9-4.029-9-9s4.029-9 9-9 9 4.029 9 9c0 1.761-.514 3.398-1.387 4.785l7.387 7.387-2.828 2.828zm-12.172-8c3.859 0 7-3.14 7-7s-3.141-7-7-7-7 3.14-7 7 3.141 7 7 7z\"/></svg>') 6 6,auto"
        );

        this.addEventListener(EventType.START, () =>
        {
            Util.$setCursor(this._$cursor);
            this.changeNodeEvent(false);
        });

        this.addEventListener(EventType.MOUSE_DOWN, (event) =>
        {
            this.startRect(event);
        });

        this.addEventListener(EventType.MOUSE_MOVE, (event) =>
        {
            this.moveRect(event);
        });

        this.addEventListener(EventType.MOUSE_UP, (event) =>
        {
            this.execute(event);
        });
    }

    /**
     * @description ズーム範囲設定を起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    startRect (event)
    {
        this.active = true;
        Util.$setCursor(this._$cursor);

        this.pageX = event.pageX;
        this.pageY = event.pageY;

        const element = document.getElementById("stage-rect");
        element.style.left    = `${event.pageX}px`;
        element.style.top     = `${event.pageY}px`;
        element.style.width   = "0px";
        element.style.height  = "0px";
        element.style.display = "";
    }

    /**
     * @description ズーム範囲設定の矩形を描画
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveRect (event)
    {
        Util.$setCursor(this._$cursor);
        if (!this.active) {
            return ;
        }

        const x = event.pageX;
        const y = event.pageY;

        const element = document.getElementById("stage-rect");

        if (this.pageX > x) {
            element.style.left = `${x}px`;
        }

        if (this.pageY > y) {
            element.style.top = `${y}px`;
        }

        element.style.width  = `${Math.abs(x - this.pageX)}px`;
        element.style.height = `${Math.abs(y - this.pageY)}px`;
    }

    /**
     * @description ズーム範囲でズームを実行
     *
     * @return {void}
     * @method
     * @public
     */
    execute ()
    {
        this.active = false;
        Util.$setCursor(this._$cursor);

        const element = document.getElementById("stage-rect");
        element.style.display = "none";

        const width   = parseFloat(element.style.width);
        const height  = parseFloat(element.style.height);
        if (!width || !height) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();

        const scale = Math.max(
            workSpace.stage.width / width,
            workSpace.stage.height / height,
            Util.$zoomScale
        );

        Util.$zoomScale = 0;
        Util.$screenZoom.execute(scale);

        // アクティブなツールがあれば終了
        if (Util.$tools.activeTool) {
            Util
                .$tools
                .activeTool
                .dispatchEvent(EventType.END);
        }

        const tool = Util.$tools.getDefaultTool("zoom");
        tool.dispatchEvent(EventType.START);
        Util.$tools.activeTool = tool;
    }
}

/**
 * コントローラーの各項目の共有クラス
 * Shared class for each item in the controller
 *
 * @class
 * @memberOf view.controller
 */
class BaseController
{
    /**
     * @param {string} [name=""]
     * @constructor
     * @public
     */
    constructor (name = "")
    {
        /**
         * @type {string}
         * @private
         */
        this._$name = name;

        /**
         * @description 自動セーブの判定フラグ
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pointX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pointY = 0;

        /**
         * @description フォーカスされたかの判定変数
         * @type {boolean}
         * @default false
         * @private
         */
        this._$focus = false;

        /**
         * @description ロック時のInputの値を管理する変数
         *
         * @type {number}
         * @default null
         * @private
         */
        this._$currentValue = null;

        /**
         * @description 指定されたInputElement
         *
         * @type {HTMLInputElement}
         * @default null
         * @private
         */
        this._$currentTarget = null;

        /**
         * @description ロックがOnの時の対象InputElement
         *
         * @type {HTMLInputElement}
         * @default null
         * @private
         */
        this._$lockTarget = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description コントローラーの共通の初期起動関数
     *              Common initial startup functions for controllers.
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        // コントローラー部分の表示非表示イベントを登録
        if (this.name) {
            const element = document
                .getElementById(`${this.name}-setting-title`);

            if (element) {
                element
                    .addEventListener("mousedown", () =>
                    {
                        this.clickTitle();
                    });
            }
        }

        Util.$initializeEnd();
    }

    /**
     * @description Inputにフォーカスされた時に変数を初期化する
     *              Initialize variables when Input is focused
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    focusIn (event)
    {
        this._$focus        = true;
        this._$currentValue = +event.target.value;
        Util.$keyLock       = true;
    }

    /**
     * @description Inputにフォーカス終了した時にロックを解放する
     *              Release lock when focus ends on Input
     *
     * @return {void}
     * @method
     * @public
     */
    focusOut ()
    {
        this._$focus         = false;
        this._$currentValue  = null;
        this._$currentTarget = null;
        this._$lockTarget    = null;
        Util.$keyLock        = false;
    }

    /**
     * @description Inputが数値の場合マウス動作終了関数
     *              Mouse operation end function if Input is numeric
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseOut (event)
    {
        event.stopPropagation();

        if (this._$focus || !this._$currentTarget) {
            Util.$setCursor("auto");
            event.target.style.cursor = "";
        }
    }

    /**
     * @description 数値のInputElementの場合はマウスで値を変更可能
     *              状態に合わせてカーソルや変数を初期化する
     *              For numeric InputElement, values can be changed with the mouse
     *              Initialize cursors and variables according to state
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        // Inputモードなら何もしない
        if (this._$focus) {
            return ;
        }

        event.preventDefault();

        // 初期化
        this._$saved         = false;
        this._$pointX        = event.screenX;
        this._$currentTarget = event.target;
        this._$currentValue  = +event.target.value;

        Util.$setCursor("ew-resize");

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description マウスアップ処理、移動イベントなどを削除して初期化
     *              Delete and initialize mouse-up process, move events, etc.
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        Util.$setCursor("auto");

        if (this._$currentTarget) {
            this._$currentTarget.style.cursor = "";
            this._$currentTarget.focus();
        }
    }

    /**
     * @description マウスで数値の加算減算を行う
     *              Add and subtract numbers with the mouse
     *
     * @param  {MouseEvent} event
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event, reload = true)
    {
        if (this._$focus || !this._$currentTarget) {
            return ;
        }

        window.requestAnimationFrame(() =>
        {
            if (this._$focus || !this._$currentTarget) {
                return ;
            }

            event.preventDefault();

            Util.$setCursor("ew-resize");

            const diff = event.screenX - this._$pointX;

            let currentValue = +this._$currentTarget.value;
            if (isNaN(currentValue)) {
                currentValue = 0;
            }

            // clampで補正された値をセット
            this._$currentTarget.value = this.executeFunction(
                this._$currentTarget.id,
                currentValue + diff
            );

            this._$currentValue = +this._$currentTarget.value;
            if (this._$lockTarget) {
                // clampで補正された値をセット
                this._$lockTarget.value = this.executeFunction(
                    this._$lockTarget.id,
                    +this._$lockTarget.value + diff
                );
            }

            this._$pointX = event.screenX;

            if (reload) {
                this.reloadScreen();
            }
        });
    }

    /**
     * @description スクリーンエリアで変更があったElementを再描画
     *              Redraw Element with changes in screen area
     *
     * @return {void}
     * @method
     * @public
     */
    reloadScreen ()
    {
        const workSpace = Util.$currentWorkSpace();
        if (!workSpace) {
            return ;
        }

        const scene = workSpace.scene;
        if (!scene) {
            return ;
        }

        scene.changeFrame(Util.$timelineFrame.currentFrame);
    }

    /**
     * @description Inputが数値の場合マウス動作で加算減算できればカーソルを変化させる
     *              If Input is a number, the cursor is changed if it can be added and subtracted by mouse movement.
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseOver (event)
    {
        event.stopPropagation();

        switch (true) {

            case this._$focus:
            case this._$currentTarget !== null:
            case this._$currentValue !== null:
                return ;

            default:
                Util.$setCursor("ew-resize");
                event.target.style.cursor = "ew-resize";
                break;

        }
    }

    /**
     * @description 各項目の表示/非表示の処理
     *              Show/Hide each item
     *
     * @return {void}
     * @method
     * @public
     */
    clickTitle ()
    {
        const element = document
            .getElementById(`${this.name}-setting-view-area`);

        const icon = document
            .getElementById(`${this.name}-setting-title`)
            .getElementsByTagName("i")[0];

        if (element.style.display === "none") {
            element.style.display = "";
            icon.setAttribute("class", "active");
        } else {
            element.style.display = "none";
            icon.setAttribute("class", "disable");
        }
    }

    /**
     * @description Elementのid名をキャメルケースに変換して関数を実行
     *              例) font-select => changeFontSelectがコールされる
     *              valueはstringで渡すので、コール先の関数内で変換とバリデーションを行う必要がある
     *
     *              DOMの場合は最後の文字列にIDが付与されるので、関数が存在しない時は最後の文字列を外す
     *              例) sound-volume-1 => changeSoundVolumeがコールされる
     *
     *              Convert Element's id name to CamelCase and execute function
     *              e.g.) font-select => changeFontSelect is called
     *              Since value is passed as a string, conversion and validation must be performed in the calling function
     *
     *              In the case of DOM, the ID is assigned to the last string, so if the function does not exist, remove the last string.
     *              e.g.) sound-volume-1 => changeSoundVolume is called
     *
     * @param  {string} name
     * @param  {string|number|Event} value
     * @return {*}
     * @method
     * @public
     */
    executeFunction (name, value)
    {
        this.save();

        const names = name.split("-");

        let functionName = names
            .map((value) =>
            {
                return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
            })
            .join("");

        if (!(`change${functionName}` in this)) {

            // 最後の文字を削除
            names.pop();

            functionName = names
                .map((value) => {
                    return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
                })
                .join("");
        }

        return this[`change${functionName}`](value);
    }

    /**
     * @description Input入力終了時の処理関数
     *              Processing function at the end of Input input
     *
     * @param  {Event|KeyboardEvent} event
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    finishInput (event, reload = true)
    {
        // Enterを押下したら、focusoutイベントを発火させる
        if (event.key === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        // focusoutなら更新関数を実行
        if (event.type === "focusout") {

            this._$currentTarget = event.target;

            // Inputの値を更新
            const value = this.executeFunction(
                event.target.id,
                event.target.value
            );

            // ロックしたInputの値を更新
            if (this._$lockTarget) {
                this._$lockTarget.value = this.executeFunction(
                    this._$lockTarget.id,
                    +this._$lockTarget.value + value - this._$currentValue
                );
            }

            event.target.value  = value;
            this._$currentValue = value;

            this.focusOut();

            // スクリーンを再描画
            if (reload) {
                this.reloadScreen();
            }
        }
    }

    /**
     * @description プロパティーの更新がある時はundo用にデータを内部保管する
     *              Store data internally for undo when there are property updates
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        // 保存中ならスキップ
        if (this._$saved) {
            return ;
        }

        this._$saved = true;

        const workSpace = Util.$currentWorkSpace();
        if (!workSpace) {
            return ;
        }

        workSpace.temporarilySaved();
    }

    /**
     * @description 指定のelementにchangeイベントを登録する
     *              Register a change event to the specified element.
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setChangeEvent (element)
    {
        if (!element) {
            return ;
        }

        element
            .addEventListener("change", (event) =>
            {
                this._$currentTarget = event.target;

                this.executeFunction(
                    event.target.id,
                    event.target.value
                );

                this._$currentTarget = null;

                // スクリーンを再描画
                this.reloadScreen();
            });
    }

    /**
     * @description Inputのelementに各種コントローラーで利用するイベントを登録
     *              Register events used by various controllers in the element of Input
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setInputEvent (element)
    {
        if (!element) {
            return ;
        }

        element.addEventListener("mouseover", (event) =>
        {
            this.mouseOver(event);
        });
        element.addEventListener("mouseout", (event) =>
        {
            this.mouseOut(event);
        });
        element.addEventListener("mousedown", (event) =>
        {
            this.mouseDown(event);
        });
        element.addEventListener("focusin", (event) =>
        {
            this.focusIn(event);
        });
        element.addEventListener("focusout",  (event) =>
        {
            this.finishInput(event);
        });
        element.addEventListener("keypress",  (event) =>
        {
            this.finishInput(event);
        });
    }

    /**
     * @description 指定のelementにclickイベントを登録する
     *              Register a click event to the specified element.
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setClickEvent (element)
    {
        if (!element) {
            return ;
        }

        element
            .addEventListener("click", (event) =>
            {
                this._$currentTarget = event.target;

                this.executeFunction(
                    event.target.id,
                    event.target.value
                );

                this._$currentTarget = null;

                // スクリーンを再描画
                this.reloadScreen();
            });
    }

    /**
     * @description タイトル表示用の変数
     *              Variables for title display
     *
     * @member {string}
     * @default ""
     * @readonly
     * @public
     */
    get name ()
    {
        return this._$name;
    }
}

/**
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class GradientFilterController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor (name)
    {
        super(name);

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$currentPointer = null;

        /**
         * @type {CanvasRenderingContext2D}
         * @default null
         * @private
         */
        this._$drawGradientContext = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMoveGradientColorPointer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUpGradientColorPointer = null;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get GRADIENT_CANVAS_WIDTH ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get GRADIENT_CANVAS_HEIGHT ()
    {
        return 30;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_GRADIENT_POINTER ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_GRADIENT_POINTER ()
    {
        return 255;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        // 内部描画用のcontext
        const canvas  = document.createElement("canvas");
        canvas.width  = GradientFilterController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio;
        canvas.height = GradientFilterController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio;
        this._$drawGradientContext = canvas.getContext("2d");
    }

    /**
     * @description filterの指定グラデーションカラーの値を更新
     *
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    changeGradientColor (value)
    {
        if (!this._$currentTarget) {
            return value;
        }

        const filterId = this._$currentTarget.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return value;
        }

        if (this._$currentPointer) {

            const filter = this._$filters.get(filterId).filter;
            const index  = this._$currentPointer.dataset.index | 0;
            filter._$colors[index] = `0x${value.slice(1)}` | 0;

            this._$currentPointer.dataset.color = value;
            this
                ._$currentPointer
                .getElementsByTagName("i")[0]
                .style.backgroundColor = value;

            this.updateFilterGradientCanvas(filter);

            this.disposeCharacterImage();

            this.reloadScreen();
        }

        return value;
    }

    /**
     * @description filterのグラデーション透明度を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeGradientAlpha (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_ALPHA,
            FilterController.MAX_ALPHA
        );

        if (!this._$currentTarget) {
            return value;
        }

        const filterId = this._$currentTarget.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return value;
        }

        if (this._$currentPointer) {
            const filter = this._$filters.get(filterId).filter;
            const index  = this._$currentPointer.dataset.index | 0;
            filter._$alphas[index] = value;

            this._$currentPointer.dataset.alpha = value;

            this.updateFilterGradientCanvas(filter);

            this.disposeCharacterImage();

            this.reloadScreen();
        }

        return value;
    }

    /**
     * @description GradientGlowFilterの設定項目をコントローラーに追加
     *              Added GradientGlowFilter configuration item to controller
     *
     * @param  {GradientGlowFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    addGradientGlowFilter (filter = null, reload = true)
    {
        const element = document.getElementById("filter-setting-list");
        if (!element) {
            return ;
        }

        const id = this.createFilter(GradientGlowFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = `
${FilterHTML.createHeaderHTML(id, "GradientGlow")}

        <div class="filter-view-area-right">

            <div class="filter-container">
                ${FilterHTML.createBlurX(id, filter.blurX)}
                ${FilterHTML.createStrength(id, filter.strength)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createBlurY(id, filter.blurY)}
                ${FilterHTML.createAngle(id, filter.angle)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createDistance(id, filter.distance)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createGradientColorPalette(id)}
            </div>
            
            <div class="filter-container">
                ${FilterHTML.createGradientColor(id)}
                ${FilterHTML.createGradientAlpha(id)}
            </div>
            
            <div class="filter-container">
                ${FilterHTML.createKnockout(id)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createBevelType(id)}
                ${FilterHTML.createQuality(id)}
            </div>
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // グラデーションコントロール用のcanvas
        const canvas  = document.getElementById(`gradient-canvas-${id}`);
        canvas.width  = FilterController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio;
        canvas.height = FilterController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio;

        canvas.style.width  = `${FilterController.GRADIENT_CANVAS_WIDTH}px`;
        canvas.style.height = `${FilterController.GRADIENT_CANVAS_HEIGHT}px`;

        filter.context = canvas.getContext("2d");

        // 共有イベント処理
        this.setCommonEvent(id);

        // 保存データの場合はcheckboxの値を更新
        if (filter.knockout) {
            document
                .getElementById(`knockout-${id}`)
                .checked = true;
        }

        const inputIds = [
            `blurX-${id}`,
            `blurY-${id}`,
            `strength-${id}`,
            `angle-${id}`,
            `gradientAlpha-${id}`,
            `distance-${id}`
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const clickIds = [
            `knockout-${id}`
        ];

        for (let idx = 0; idx < clickIds.length; ++idx) {
            this.setClickEvent(
                document.getElementById(clickIds[idx])
            );
        }

        const changeIds = [
            `gradientColor-${id}`,
            `type-${id}`,
            `quality-${id}`
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(changeIds[idx])
            );
        }

        // ポインターを追加
        for (let idx = 0; idx < filter.ratios.length; ++idx) {

            const ratio = filter.ratios[idx];
            const color = `#${filter.colors[idx].toString(16).padStart(6, "0")}`;
            const alpha = filter.alphas[idx];

            this.addFilterGradientColorPointer(id, idx, ratio, color, alpha);

        }

        // ポインター追加イベント
        this.setCreateGradientColorPointerEvent(id);

        // canvasを更新
        this.updateFilterGradientCanvas(filter);

        // 内部キャッシュを削除
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(
            document.getElementById(`filter-id-${id}`)
        );
    }

    /**
     * @description GradientBevelFilterの設定項目をコントローラーに追加
     *              Added GradientBevelFilter configuration item to controller
     *
     * @param  {GradientBevelFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    addGradientBevelFilter (filter = null, reload = true)
    {
        const element = document.getElementById("filter-setting-list");
        if (!element) {
            return ;
        }

        const id = this.createFilter(GradientBevelFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = `
${FilterHTML.createHeaderHTML(id, "GradientBevel")}

        <div class="filter-view-area-right">

            <div class="filter-container">
                ${FilterHTML.createBlurX(id, filter.blurX)}
                ${FilterHTML.createStrength(id, filter.strength)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createBlurY(id, filter.blurY)}
                ${FilterHTML.createAngle(id, filter.angle)}
            </div>
            
            <div class="filter-container">
                ${FilterHTML.createDistance(id, filter.distance)}
            </div>
            
            <div class="filter-container">
                ${FilterHTML.createGradientColorPalette(id)}
            </div>
            
            <div class="filter-container">
                ${FilterHTML.createGradientColor(id)}
                ${FilterHTML.createGradientAlpha(id)}
            </div>
            
            <div class="filter-container">
                ${FilterHTML.createKnockout(id)}
            </div>

            <div class="filter-container">                
                ${FilterHTML.createBevelType(id)}
                ${FilterHTML.createQuality(id)}
            </div>
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        const canvas  = document.getElementById(`gradient-canvas-${id}`);
        canvas.width  = GradientFilterController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio;
        canvas.height = GradientFilterController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio;

        canvas.style.width  = `${GradientFilterController.GRADIENT_CANVAS_WIDTH}px`;
        canvas.style.height = `${GradientFilterController.GRADIENT_CANVAS_HEIGHT}px`;

        filter.context = canvas.getContext("2d");

        // 共有イベント処理
        this.setCommonEvent(id);

        // 保存データの場合はcheckboxの値を更新
        if (filter.knockout) {
            document
                .getElementById(`knockout-${id}`)
                .checked = true;
        }

        const inputIds = [
            `blurX-${id}`,
            `blurY-${id}`,
            `strength-${id}`,
            `angle-${id}`,
            `gradientAlpha-${id}`,
            `distance-${id}`
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const clickIds = [
            `knockout-${id}`
        ];

        for (let idx = 0; idx < clickIds.length; ++idx) {
            this.setClickEvent(
                document.getElementById(clickIds[idx])
            );
        }

        const changeIds = [
            `gradientColor-${id}`,
            `type-${id}`,
            `quality-${id}`
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(changeIds[idx])
            );
        }

        // ポインターを追加
        for (let idx = 0; idx < filter.ratios.length; ++idx) {

            const ratio = filter.ratios[idx];
            const color = `#${filter.colors[idx].toString(16).padStart(6, "0")}`;
            const alpha = filter.alphas[idx];

            this.addFilterGradientColorPointer(id, idx, ratio, color, alpha);

        }

        // ポインター追加イベント
        this.setCreateGradientColorPointerEvent(id);

        // canvasを更新
        this.updateFilterGradientCanvas(filter);

        // 内部キャッシュを削除
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(
            document.getElementById(`filter-id-${id}`)
        );
    }

    /**
     * @description グラデーションのポインターを追加
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    addGradientColorPointer (event)
    {
        const filterId = event.target.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return ;
        }

        const filter = this._$filters.get(filterId).filter;

        const index = filter.ratios.length;
        const ratio = event.offsetX;
        const color = document.getElementById(`gradientColor-${filterId}`).value;
        const alpha = document.getElementById(`gradientAlpha-${filterId}`).value | 0;

        filter.ratios.push(ratio);
        filter.colors.push(`0x${color.slice(1)}` | 0);
        filter.alphas.push(alpha);

        this.addFilterGradientColorPointer(
            filterId, index, ratio, color, alpha
        );

        // グラデーションレビューの更新
        this.updateFilterGradientCanvas(filter);

        // 再描画用に画像のキャッシュを削除
        this.disposeCharacterImage();

        // 再描画
        this.reloadScreen();
    }

    /**
     * @description グラデーションのポインター追加イベンち
     *
     * @param  {number} id
     * @return {void}
     * @method
     * @public
     */
    setCreateGradientColorPointerEvent (id)
    {
        const element = document
            .getElementById(`color-pointer-list-${id}`);

        if (!element) {
            return ;
        }

        element.addEventListener("mousedown", (event) =>
        {
            this.addGradientColorPointer(event);
        });
    }

    /**
     * @description グラデーションのcanvasを更新
     *
     * @param  {GradientBevelFilter|GradientGlowFilter} filter
     * @return {void}
     * @method
     * @public
     */
    updateFilterGradientCanvas (filter)
    {
        const context = this._$drawGradientContext;

        // clear
        context.clearRect(0, 0,
            GradientFilterController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            GradientFilterController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );

        const object = filter.adjustment();

        context.beginPath();

        const length = object.ratios.length;
        const x1 = Math.ceil(object.ratios[length - 1] * 255 * window.devicePixelRatio);
        const gradient = context.createLinearGradient(0, 0, x1, 0);

        for (let idx = 0; idx < length; ++idx) {
            const obj = Util.$intToRGB(object.colors[idx]);
            gradient.addColorStop(
                object.ratios[idx],
                `rgba(${obj.R}, ${obj.G}, ${obj.B}, ${object.alphas[idx]})`
            );
        }

        context.fillStyle = gradient;
        context.rect(0, 0,
            GradientFilterController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            GradientFilterController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );

        context.fill();

        filter.context.clearRect(0, 0,
            GradientFilterController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            GradientFilterController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );
        filter.context.drawImage(context.canvas, 0, 0);
    }

    /**
     * @description グラデーションのポインターを追加
     *
     * @param  {number} id
     * @param  {number} index
     * @param  {number} ratio
     * @param  {string} color
     * @param  {number} alpha
     * @return {void}
     * @method
     * @public
     */
    addFilterGradientColorPointer (id, index, ratio, color, alpha)
    {
        const element = document
            .getElementById(`color-pointer-list-${id}`);

        const htmlTag = `
<div class="color-pointer" style="left: ${ratio - 4}px;" data-filter-id="${id}" data-index="${index}" data-color="${color}" data-alpha="${alpha}">
    <div class="color-pointer-triangle"></div>
    <div class="color-pointer-rect">
        <i class="pointer-color" style="background-color: ${color}"></i>
    </div>
</div>
`;

        element.insertAdjacentHTML("beforeend", htmlTag);

        const pointer = element.lastElementChild;

        pointer.addEventListener("mousedown", (event) =>
        {
            this.mouseDownGradientColorPointer(event);
        });

        if (index) {
            pointer.addEventListener("dblclick", (event) =>
            {
                this.removeGradientColorPointer(event);
            });
        }

        // 初期値は最後に生成されたポインターのElement
        this._$currentPointer = pointer;
    }

    /**
     * @description グラデーションのカラーポインターを削除
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    removeGradientColorPointer (event)
    {
        const filterId = event.target.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return ;
        }

        const element = document
            .getElementById(`color-pointer-list-${filterId}`);

        if (2 >= element.children.length ) {
            return ;
        }

        const index  = event.target.dataset.index | 0;
        const filter = this._$filters.get(filterId).filter;

        filter.ratios.splice(index, 1);
        filter.colors.splice(index, 1);
        filter.alphas.splice(index, 1);

        // remove
        event.target.remove();

        // 削除したindexの差分の補完
        for (let idx = index; idx < element.children.length; ++idx) {

            const child = element.children[idx];
            const index = (child.dataset.index | 0) - 1;

            child.dataset.index = `${index}`;
        }

        super.focusOut();

        // グラデーションプレビューを更新
        this.updateFilterGradientCanvas(filter);

        // 再描画用に画像のキャッシュを削除
        this.disposeCharacterImage();

        // 再描画
        this.reloadScreen();
    }

    /**
     * @description グラデーションのカラーポインターを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDownGradientColorPointer (event)
    {
        // 親のイベントを中止
        event.stopPropagation();

        // 初期化
        this._$saved          = false;
        this._$pointX         = event.screenX;
        this._$currentTarget  = event.target;
        this._$currentPointer = event.target;

        const filterId = event.target.dataset.filterId;

        document
            .getElementById(`gradientColor-${filterId}`)
            .value = event.target.dataset.color;

        document
            .getElementById(`gradientAlpha-${filterId}`)
            .value = event.target.dataset.alpha;

        if (!this._$mouseMoveGradientColorPointer) {
            this._$mouseMoveGradientColorPointer =
                this.mouseMoveGradientColorPointer.bind(this);
        }

        if (!this._$mouseUpGradientColorPointer) {
            this._$mouseUpGradientColorPointer =
                this.mouseUpGradientColorPointer.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMoveGradientColorPointer);
        window.addEventListener("mouseup", this._$mouseUpGradientColorPointer);
    }

    /**
     * @description グラデーションのカラーポインターの移動処理
     *
     * @return {void}
     * @method
     * @public
     */
    mouseMoveGradientColorPointer (event)
    {
        const element = this._$currentTarget;
        if (!element) {
            return ;
        }

        const index = element.dataset.index | 0;
        if (index) {
            window.requestAnimationFrame(() =>
            {
                event.preventDefault();

                const filterId = element.dataset.filterId | 0;
                if (!this._$filters.has(filterId)) {
                    return ;
                }

                const currentPoint = parseFloat(
                    element.style.left
                );

                const value = Util.$clamp(
                    currentPoint + (event.screenX - this._$pointX) + 4,
                    GradientFilterController.MIN_GRADIENT_POINTER,
                    GradientFilterController.MAX_GRADIENT_POINTER
                );

                element.style.left = `${value - 4}px`;

                const filter = this._$filters.get(filterId).filter;
                filter._$ratios[index] = value;

                if (this._$pointX) {
                    this._$pointX = event.screenX;
                }

                // グラデーションプレビューを更新
                this.updateFilterGradientCanvas(filter);

                // 再描画用にキャッシュをクリア
                this.disposeCharacterImage();

                // 再描画
                this.reloadScreen();
            });
        }
    }

    /**
     * @description グラデーションのカラーポインターの移動を終了、イベントも削除
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUpGradientColorPointer ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMoveGradientColorPointer);
        window.removeEventListener("mouseup", this._$mouseUpGradientColorPointer);
        Util.$setCursor("auto");

        // 設定を初期化
        super.focusOut();
    }
}

/**
 * @class
 * @memberOf view
 */
class View
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const element = document.getElementById("view");
        if (element) {
            element.addEventListener("mousedown", (event) =>
            {
                this.mouseDown(event);
            });
        }

        Util.$initializeEnd();
    }

    /**
     * @description Viewエリアを
     *
     * @param {MouseEvent} event
     * @method
     * @public
     */
    mouseDown (event)
    {
        // 左クリック以外はスキップ
        if (event.button) {
            return ;
        }

        Util.$endMenu();
    }
}

Util.$view = new View();

/**
 * @class
 * @extends {InputEvent}
 * @memberOf view.screen
 */
class BaseScreen extends InputEvent
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 共通初期イベント登録関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        Util.$initializeEnd();
    }

    /**
     * @description Elementのid名をキャメルケースに変換して関数を実行
     *              例) font-select => executeFontSelectがコールされる
     *
     * @param  {string} name
     * @return {void}
     * @method
     * @public
     */
    executeFunction (name)
    {
        // メニューを終了
        Util.$endMenu();

        const names = name.split("-");

        let functionName = names
            .map((value) =>
            {
                return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
            })
            .join("");

        this[`execute${functionName}`]();
    }
}

/**
 * @class
 * @memberOf view.screen
 */
class ChangeMovieClip extends BaseScreen
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [];
    }

    execute ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        this.save();

        const workSpace = Util.$currentWorkSpace();

        const scene = workSpace.scene;
        const frame = Util.$timelineFrame.currentFrame;

        const id = workSpace.nextLibraryId;

        const instance = workSpace.addLibrary(
            Util
                .$libraryController
                .createInstance(
                    InstanceType.MOVIE_CLIP, `MovieClip_${id}`, id
                )
        );

        // MovieClipに指定したDisplayObjectを登録
        const newLayer = new Layer();
        instance.setLayer(0, newLayer);

        const x = +document.getElementById("object-x").value;
        const y = +document.getElementById("object-y").value;
        const w = +document.getElementById("object-width").value;
        const h = +document.getElementById("object-height").value;

        const dx = x + w / 2;
        const dy = y + h / 2;

        const layers = new Map();
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];
            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            const range = character.getRange(frame);
            if (!layers.has(layer.id)) {
                layers.set(layer.id, {
                    "layer": layer,
                    "range": range
                });
            }

            const cloneCharacter = new Character();
            cloneCharacter.libraryId = character.libraryId;

            const place = character.getPlace(range.startFrame);

            const clonePlace = {
                "frame": 1,
                "matrix": place.matrix.slice(),
                "colorTransform": place.colorTransform.slice(),
                "blendMode": place.blendMode,
                "filter": place.filter.slice(),
                "loop": Util.$getDefaultLoopConfig(),
                "depth": newLayer._$characters.length
            };

            if (place.loop) {
                clonePlace.loop = place.loop;
            }

            cloneCharacter.setPlace(1, clonePlace);

            cloneCharacter.x -= dx;
            cloneCharacter.y -= dy;

            newLayer.addCharacter(cloneCharacter);

            // 削除
            character.remove(layer);
        }

        // 各レイヤーを再描画
        for (const object of layers.values()) {

            const layer = object.layer;
            const range = object.range;

            const characters = layer.getActiveCharacter(range.startFrame);
            if (characters.length) {

                // 深度順に並び替え
                layer.sort(characters, frame);

                for (let idx = 0; idx < characters.length; ++idx) {
                    characters[idx].getPlace(frame).depth = idx;
                }

            } else {

                layer.addEmptyCharacter(
                    new EmptyCharacter({
                        "startFrame": range.startFrame,
                        "endFrame": range.endFrame
                    })
                );

            }

            layer.reloadStyle();
        }

        // 選択中のelementを初期化
        tool.clearActiveElement();

        const character = new Character();
        character.libraryId = instance.id;
        character.endFrame  = frame + 1;

        character.setPlace(frame, {
            "frame": frame,
            "matrix": [1, 0, 0, 1, dx / Util.$zoomScale, dy / Util.$zoomScale],
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": [],
            "depth": 0,
            "loop": Util.$getDefaultLoopConfig()
        });

        const layer = new Layer();
        layer.addCharacter(character);
        scene.addLayer(layer);

        // 前方に空のキーフレームを追加
        if (frame > 1) {
            layer.addEmptyCharacter(new EmptyCharacter({
                "startFrame": 1,
                "endFrame": frame
            }));
        }

        layer.reloadStyle();

        // 再描画
        this.reloadScreen();

        // 初期化
        this._$saved = false;
    }
}
/**
 * @class
 * @extends {BaseScreen}
 * @memberOf view.screen
 */
class SceneChange extends BaseScreen
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$length = 0;

        /**
         * @type {array}
         * @private
         */
        this._$matrix = [];

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$offsetX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$offsetY = 0;
    }

    /**
     * @description 親のmatrix
     *
     * @member   {array}
     * @method
     * @public
     */
    get matrix ()
    {
        return this._$matrix;
    }

    /**
     * @description 親オブジェクトの結合された変換マトリックス
     *
     * @return {Float32Array}
     * @readonly
     * @method
     * @public
     */
    get concatenatedMatrix ()
    {
        let matrix = new Float32Array([1, 0, 0, 1, 0, 0]);
        for (let idx = 0; this._$matrix.length > idx; ++idx) {
            matrix = Util.$multiplicationMatrix(
                matrix,
                this._$matrix[idx]
            );
        }
        return matrix;
    }

    /**
     * @description 親の座標に合わせるx座標
     *
     * @member {number}
     * @method
     * @public
     */
    get offsetX ()
    {
        return this._$offsetX;
    }
    set offsetX (offset_x)
    {
        this._$offsetX = offset_x;
    }

    /**
     * @description 親の座標に合わせるy座標
     *
     * @member {number}
     * @method
     * @public
     */
    get offsetY ()
    {
        return this._$offsetY;
    }
    set offsetY (offset_y)
    {
        this._$offsetY = offset_y;
    }

    /**
     * @description メニューの配列数を返す
     *
     * @member   {number}
     * @method
     * @public
     */
    get length ()
    {
        return this._$length;
    }
    set length (length)
    {
        this._$length = length;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();
    }

    /**
     * @description パラメーターを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clear ()
    {
        this._$offsetX       = 0;
        this._$offsetY       = 0;
        this._$matrix.length = 0;
        this._$length        = 0;
    }

    /**
     * @description リスト表示の再読み込み
     *
     * @param  {number} [library_id=-1]
     * @return {void}
     * @method
     * @public
     */
    reload (library_id = -1)
    {
        const element = document
            .getElementById("scene-name-menu-list");

        if (!element) {
            return ;
        }

        while (element.children.length) {
            element.children[0].remove();
        }

        // 値を初期化
        this.clear();

        // シーン名をリストに追加
        Util
            .$currentWorkSpace()
            .root
            .addSceneName();

        // シーン移動
        if (library_id > -1) {
            Util.$sceneChange.execute(library_id);
        }
    }

    /**
     * @description 指定のMovieClipを表示
     *
     * @param  {number} library_id
     * @return {void}
     * @method
     * @public
     */
    execute (library_id)
    {
        // 現在のプロジェクト
        const workSpace = Util.$currentWorkSpace();

        // ライブラリから指定のMovieClipを取得
        const scene = workSpace.getLibrary(library_id);
        const frame = scene.currentFrame;

        // 指定のMovieClipのフレーム
        Util.$timelineFrame.currentFrame = frame;

        // タイムラインのマーカーを移動
        Util.$timelineMarker.move();

        // 上部のタイムラインの位置を補正
        const base = document
            .getElementById("timeline-controller-base");

        // 表示画面の中心
        const moveX = (frame - 1) * (Util.$timelineTool.timelineWidth + 1);
        if (moveX > base.offsetWidth / 2) {
            Util
                .$timelineLayer
                .moveTimeLine(moveX - base.offsetWidth / 2);
        }

        // シーンの入れ替え
        workSpace.scene = scene;
    }
}

Util.$sceneChange = new SceneChange();

/**
 * @class
 * @memberOf view.screen
 */
class Screen extends BaseScreen
{
    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document.getElementById("screen");
        if (element) {

            element.addEventListener("contextmenu", (event) =>
            {
                Util.$screenMenu.show(event);
            });

            element.addEventListener("dragover", (event) =>
            {
                event.preventDefault();
            });

            element.addEventListener("drop", (event) =>
            {
                event.preventDefault();
                event.stopPropagation();
                this.drop(event);
            });

            element.addEventListener("mousedown", (event) =>
            {
                if (event.button) {
                    return ;
                }

                Util.$canCopyLayer = false;

                Util.$endMenu();

                const activeTool = Util.$tools.activeTool;
                if (activeTool) {
                    event.screen = true;
                    activeTool.dispatchEvent(
                        EventType.MOUSE_DOWN,
                        event
                    );
                }
            });

            element.addEventListener("dblclick", (event) =>
            {
                const activeTool = Util.$tools.activeTool;
                if (activeTool) {
                    event.screen = true;
                    activeTool.dispatchEvent(
                        EventType.DBL_CLICK,
                        event
                    );
                }
            });

            element.addEventListener("mouseleave", (event) =>
            {
                const activeTool = Util.$tools.activeTool;
                if (activeTool) {
                    event.screen = true;
                    activeTool.dispatchEvent(
                        EventType.MOUSE_LEAVE,
                        event
                    );
                }

                document.getElementById("stage-rect").style.display = "none";
                document.getElementById("draw-rect").style.display  = "none";
                Util.$setCursor("auto");
            });

            element.addEventListener("mousewheel", (event) =>
            {
                const delta = event.deltaX || event.deltaY;
                if (!delta) {
                    return ;
                }

                if (event.ctrlKey && !event.metaKey // windows
                    || !event.ctrlKey && event.metaKey // mac
                ) {

                    event.preventDefault();

                    window.requestAnimationFrame(() => {
                        Util.$screenZoom.execute(delta / 2 / 100 * -1);
                    });

                    return false;

                }

            }, { "passive" : false });

            element.addEventListener("scroll", (event) =>
            {
                // 定規を再配置
                if (Util.$screenRuler.state === "hide") {
                    return ;
                }

                event.preventDefault();
                Util.$screenRuler.reload();

                return false;
            });

            element.addEventListener("mousemove", (event) =>
            {
                const activeTool = Util.$tools.activeTool;
                if (activeTool) {
                    event.screen = true;
                    window.requestAnimationFrame(() =>
                    {
                        activeTool.dispatchEvent(
                            EventType.MOUSE_MOVE,
                            event
                        );
                    });
                }
            });

            element.addEventListener("mouseup", (event) =>
            {
                const activeTool = Util.$tools.activeTool;
                if (activeTool) {
                    event.screen = true;
                    activeTool.dispatchEvent(
                        EventType.MOUSE_UP,
                        event
                    );
                }
            });
        }
    }

    /**
     * @description ライブラリからのドロップ処理
     *
     * @param  {DragEvent} event
     * @return {void}
     * @method
     * @public
     */
    drop (event)
    {
        const activeInstances = Util
            .$libraryController
            .activeInstances;

        if (!activeInstances.size) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        // レイヤーをアタッチ
        Util.$timelineLayer.attachLayer();
        const targetLayer = Util.$timelineLayer.targetLayer;

        // ロックレイヤーならスキップ
        const layerId = targetLayer.dataset.layerId | 0;
        const layer = scene.getLayer(layerId);
        if (layer.lock) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;

        this.save();

        // 選択したアイテムを指定レイヤーに登録
        const soundIds    = [];
        const instanceIds = [];
        for (const libraryId of activeInstances.keys()) {

            const instance = workSpace.getLibrary(libraryId);
            if (!instance || instance.id === scene.id) {
                continue;
            }

            switch (instance.type) {

                case InstanceType.SOUND:
                    soundIds.push(libraryId);
                    break;

                case InstanceType.FOLDER:
                    instance.getInstanceIds(instanceIds);
                    break;

                default:
                    instanceIds.push(libraryId);
                    break;

            }

        }

        // サウンドを登録
        if (soundIds.length) {

            if (!scene.hasSound(frame)) {
                scene.setSound(frame, []);
            }

            const sounds = scene.getSound(frame);
            for (let idx = 0; idx < soundIds.length; ++idx) {

                const instance = workSpace.getLibrary(soundIds[idx]);

                sounds.push({
                    "characterId": instance.id,
                    "name":        instance.name,
                    "volume":      100,
                    "autoPlay":    false,
                    "loopCount":   0
                });

            }

            // 表示を更新
            Util.$soundController.setIcon(frame);
            Util.$soundController.createSoundElements();
        }

        // tweenが設定されて入れば終了
        const activeCharacter = layer.getActiveCharacter(frame);
        if (activeCharacter.length) {
            const character = activeCharacter[0];
            const range = character.getRange(frame);
            if (character.hasTween(range.startFrame)) {
                return ;
            }
        }

        if (instanceIds.length) {

            // 座標
            const x = (event.offsetX - Util.$offsetLeft) / Util.$zoomScale;
            const y = (event.offsetY - Util.$offsetTop)  / Util.$zoomScale;

            const { Matrix } = window.next2d.geom;
            const concatenatedMatrix = Util.$sceneChange.concatenatedMatrix;

            const matrix = new Matrix(
                concatenatedMatrix[0], concatenatedMatrix[1], concatenatedMatrix[2],
                concatenatedMatrix[3], concatenatedMatrix[4], concatenatedMatrix[5]
            );
            matrix.invert();

            const localX = x * matrix.a + y * matrix.c + matrix.tx;
            const localY = x * matrix.b + y * matrix.d + matrix.ty;

            // スクリーンにアイテムを配置
            const location   = layer.adjustmentLocation(frame);
            const endFrame   = location.endFrame;
            const startFrame = location.startFrame;
            for (let idx = 0; idx < instanceIds.length; ++idx) {

                const libraryId = instanceIds[idx];

                // 前か後ろに同じDisplayObjectがあれば統合する
                const join = {
                    "start": null,
                    "end": null
                };

                // レイヤー内のDisplayObjectをチェック
                const characters = layer._$characters;
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];
                    if (character.libraryId !== libraryId) {
                        continue;
                    }

                    switch (true) {

                        case startFrame > 1 && character.endFrame === startFrame:
                            join.start = character;
                            break;

                        case character.startFrame === endFrame:
                            join.end = character;
                            break;

                    }
                }

                const instance = workSpace.getLibrary(libraryId);
                const place = {
                    "frame": location.startFrame,
                    "matrix": [1, 0, 0, 1, localX, localY],
                    "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                    "blendMode": "normal",
                    "filter": [],
                    "depth": layer._$characters.length
                };

                // MovieClipの場合はループ設定
                if (instance.type === InstanceType.MOVIE_CLIP) {
                    place.loop = Util.$getDefaultLoopConfig();
                }

                let character = null;
                if (join.start) {
                    character = join.start;
                    character.endFrame = endFrame;
                }

                if (join.end) {

                    if (character) {

                        character.endFrame = join.end.endFrame;

                        for (let [frame, place] of join.end._$places) {
                            character.setPlace(frame, place);
                        }

                        for (let [frame, tween] of join.end._$tween) {
                            character.setTween(frame, tween);
                        }

                        layer.deleteCharacter(join.end.id);

                    } else {

                        character = join.end;
                        character.startFrame = startFrame;

                    }
                }

                // new character
                if (!character) {

                    character = new Character();
                    character.libraryId  = libraryId;
                    character.startFrame = startFrame;
                    character.endFrame   = endFrame;
                    character.setPlace(startFrame, place);

                    // added
                    layer.addCharacter(character);

                } else {

                    // add place
                    character.setPlace(startFrame, place);

                }

                // ドロップ位置補正
                let dx = 0;
                let dy = 0;
                if (instance.type === InstanceType.MOVIE_CLIP) {
                    const bounds = instance.getBounds([1, 0, 0, 1, 0, 0]);
                    dx = bounds.xMin;
                    dy = bounds.yMin;
                }

                const bounds = character.getBounds();
                let width = bounds.xMax - bounds.xMin;
                if (!width) {
                    width = 10;
                }

                let height = bounds.yMax - bounds.yMin;
                if (!height) {
                    height = 10;
                }

                dx += width  / 2;
                dy += height / 2;

                place.matrix[4] -= dx;
                place.matrix[5] -= dy;

                const matrixBounds = character.getBounds(concatenatedMatrix);
                const tx = Util.$sceneChange.offsetX + matrixBounds.xMin;
                const ty = Util.$sceneChange.offsetY + matrixBounds.yMin;
                const w  = Math.ceil(Math.abs(matrixBounds.xMax - matrixBounds.xMin)) / 2;
                const h  = Math.ceil(Math.abs(matrixBounds.yMax - matrixBounds.yMin)) / 2;

                // 中心点をセット
                place.point = {
                    "x": tx + w,
                    "y": ty + h
                };

            }

            // レイヤーの横スクロール幅を再計算
            Util.$timelineScroll.updateWidth();

            // タイムラインの表示を再計算
            layer.reloadStyle();

            // 描画リセット
            this.reloadScreen();
        }

        // 初期化
        this._$saved = false;
    }

    /**
     * @description オニオンスライス起動時に前後のフレームのDisplayObjectを半透明で配置
     *
     * @param  {Character} character
     * @param  {number} layer_id
     * @param  {MovieClip} [parent=null]
     * @return {void}
     * @method
     * @public
     */
    appendOnionCharacter (character, layer_id, parent = null)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = parent || workSpace.scene;

        // create div
        const div = document.createElement("div");
        div.dataset.child   = "true";
        div.dataset.preview = "true";

        const matrix = Util.$sceneChange.concatenatedMatrix;
        const bounds = character.getBounds(matrix);

        // create image
        const context = character._$context;
        character._$context = null;
        const image = character.draw(Util.$getCanvas());
        div.appendChild(image);
        character._$context = context;

        image.style.width  = `${image._$width  * Util.$zoomScale}px`;
        image.style.height = `${image._$height * Util.$zoomScale}px`;
        image.style.left   = `${character.offsetX}px`;
        image.style.top    = `${character.offsetY}px`;

        let divStyle = "";

        // mask attach
        const layer = scene.getLayer(layer_id);
        if (layer.maskId !== null) {

            const maskLayer = scene.getLayer(layer.maskId);
            if (!maskLayer) {
                layer.maskId = null;
            }

            if (maskLayer && maskLayer.lock
                && maskLayer._$characters.length
            ) {

                const maskCharacter = maskLayer._$characters[0];
                maskCharacter.dispose();

                const maskImage  = maskCharacter.draw(Util.$getCanvas());
                const maskBounds = maskCharacter.getBounds(matrix);

                const x = (maskBounds.xMin - bounds.xMin) * Util.$zoomScale;
                const y = (maskBounds.yMin - bounds.yMin) * Util.$zoomScale;

                const maskSrc    = maskImage.toDataURL();
                const maskWidth  = maskImage._$width  * Util.$zoomScale;
                const maskHeight = maskImage._$height * Util.$zoomScale;

                divStyle += `mask: url(${maskSrc}), none;`;
                divStyle += `-webkit-mask: url(${maskSrc}), none;`;
                divStyle += `mask-size: ${maskWidth}px ${maskHeight}px;`;
                divStyle += `-webkit-mask-size: ${maskWidth}px ${maskHeight}px;`;
                divStyle += "mask-repeat: no-repeat;";
                divStyle += "-webkit-mask-repeat: no-repeat;";
                divStyle += `mask-position: ${x}px ${y}px;`;
                divStyle += `-webkit-mask-position: ${x}px ${y}px;`;
                divStyle += `mix-blend-mode: ${image.style.mixBlendMode};`;
                divStyle += `filter: ${image.style.filter};`;

            }
        }

        divStyle += "position: absolute;";
        divStyle += "pointer-events: none;";
        divStyle += "opacity: 0.25;";

        let tx = Util.$offsetLeft + (Util.$sceneChange.offsetX + bounds.xMin) * Util.$zoomScale;
        let ty = Util.$offsetTop  + (Util.$sceneChange.offsetY + bounds.yMin) * Util.$zoomScale;

        divStyle += `left: ${tx}px;`;
        divStyle += `top: ${ty}px;`;

        div.setAttribute("style", divStyle);

        document
            .getElementById("stage-area")
            .appendChild(div);
    }

    /**
     * @description 現在のフレームに配置されたDisplayObjectを配置
     *
     * @param  {Character} character
     * @param  {number}    frame
     * @param  {number}    layer_id
     * @param  {string}    [event="auto"]
     * @param  {MovieClip} [parent_scene=null]
     * @param  {number}    [alpha=1]
     * @return {void}
     * @method
     * @public
     */
    appendCharacter (
        character, frame, layer_id,
        event = "auto", parent_scene = null, alpha = 1
    ) {

        const workSpace = Util.$currentWorkSpace();
        const scene     = parent_scene || workSpace.scene;

        // setup
        const place    = character.getPlace(frame);
        const instance = workSpace.getLibrary(character.libraryId);
        if (!instance) {
            return ;
        }

        let doUpdate = character.libraryId === Util.$changeLibraryId;
        switch (instance.type) {

            case InstanceType.MOVIE_CLIP:
                if (instance.totalFrame > 1 && character._$currentFrame !== frame) {
                    doUpdate = true;
                    character._$currentFrame = frame;
                }
                break;

            case InstanceType.VIDEO:
                if (character._$currentFrame !== frame) {
                    doUpdate = true;
                    character._$currentFrame = frame;
                }
                break;

            default:
                break;

        }

        if (place !== character._$currentPlace) {

            if (character._$currentPlace) {

                // check matrix
                const nextMatrix    = place.matrix;
                const currentMatrix = character._$currentPlace.matrix;
                switch (true) {

                    case nextMatrix[0] !== currentMatrix[0]:
                    case nextMatrix[1] !== currentMatrix[1]:
                    case nextMatrix[2] !== currentMatrix[2]:
                    case nextMatrix[3] !== currentMatrix[3]:
                        doUpdate = true;
                        break;

                    default:
                        character._$screenX += -currentMatrix[4] + nextMatrix[4];
                        character._$screenY += -currentMatrix[5] + nextMatrix[5];
                        break;
                }

                // check color transform
                if (!doUpdate) {
                    const nextColorTransform    = place.colorTransform;
                    const currentColorTransform = character._$currentPlace.colorTransform;
                    switch (true) {

                        case nextColorTransform[0] !== currentColorTransform[0]:
                        case nextColorTransform[1] !== currentColorTransform[1]:
                        case nextColorTransform[2] !== currentColorTransform[2]:
                        case nextColorTransform[3] !== currentColorTransform[3]:
                        case nextColorTransform[4] !== currentColorTransform[4]:
                        case nextColorTransform[5] !== currentColorTransform[5]:
                        case nextColorTransform[6] !== currentColorTransform[6]:
                        case nextColorTransform[7] !== currentColorTransform[7]:
                            doUpdate = true;
                            break;

                        default:
                            break;
                    }
                }

                // check blend mode
                if (!doUpdate
                    && place.blendMode !== character._$currentPlace.blendMode
                ) {
                    doUpdate = true;
                }

                // check filter
                if (!doUpdate) {

                    if (character._$currentPlace.filter.length !== place.filter.length) {
                        doUpdate = true;
                    }

                    if (!doUpdate) {

                        for (let idx = 0; idx < place.filter.length; ++idx) {

                            const nextFilter    = place.filter[idx];
                            const currentFilter = character._$currentPlace[idx];

                            if (!nextFilter || !currentFilter) {
                                doUpdate = true;
                                break;
                            }

                            if (currentFilter.constructor !== nextFilter.constructor) {
                                doUpdate = true;
                                break;
                            }

                            if (!currentFilter.isSame(nextFilter)) {
                                doUpdate = true;
                                break;
                            }

                        }
                    }
                }
            }

            // update
            character._$currentPlace = place;
        }

        // cache delete
        if (doUpdate) {
            character.dispose();
        }

        const div = document.createElement("div");

        const canvas = character.draw(Util.$getCanvas());
        div.appendChild(canvas);

        div.id = `character-${character.id}`;
        div.dataset.characterId  = `${character.id}`;
        div.dataset.layerId      = `${layer_id}`;
        div.dataset.instanceType = `${instance.type}`;
        div.dataset.libraryId    = `${character.libraryId}`;
        div.dataset.child        = "true";
        div.dataset.pointer      = `${event}`;

        if (parent_scene) {
            div.dataset.preview = "true";
        }

        let divStyle = "position: absolute;";
        divStyle += `pointer-events: ${event};`;
        if (1 > alpha) {
            divStyle += `opacity: ${alpha};`;
        }

        div.addEventListener("mouseover", (event) =>
        {
            // 親のイベントを中止する
            event.stopPropagation();

            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                event.displayObject = true;
                activeTool.dispatchEvent(
                    EventType.MOUSE_OVER,
                    event
                );
            }
        });

        div.addEventListener("mouseout", (event) =>
        {
            // 親のイベントを中止する
            event.stopPropagation();

            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                event.displayObject = true;
                activeTool.dispatchEvent(
                    EventType.MOUSE_OUT,
                    event
                );
            }
        });

        div.addEventListener("mousedown", (event) =>
        {
            if (event.button) {
                return ;
            }

            // 親のイベントを中止する
            event.stopPropagation();

            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                event.displayObject = true;
                activeTool.dispatchEvent(
                    EventType.MOUSE_DOWN,
                    event
                );
            }
        });

        const matrix = Util.$sceneChange.concatenatedMatrix;
        const bounds = character.getBounds(matrix);

        let width = (bounds.xMax - bounds.xMin) * Util.$zoomScale;
        if (!width) {
            width = 10;
        }

        let height = (bounds.yMax - bounds.yMin) * Util.$zoomScale;
        if (!height) {
            height = 10;
        }

        divStyle += `width: ${Math.ceil(width)}px;`;
        divStyle += `height: ${Math.ceil(height)}px;`;

        let tx = Util.$offsetLeft + (Util.$sceneChange.offsetX + bounds.xMin) * Util.$zoomScale;
        let ty = Util.$offsetTop  + (Util.$sceneChange.offsetY + bounds.yMin) * Util.$zoomScale;

        divStyle += `left: ${tx}px;`;
        divStyle += `top: ${ty}px;`;

        let canvasStyle = canvas.getAttribute("style");
        canvasStyle += `width: ${canvas._$width * Util.$zoomScale}px;`;
        canvasStyle += `height: ${canvas._$height * Util.$zoomScale}px;`;
        if (character.offsetX) {
            canvasStyle += `left: ${character.offsetX * Util.$zoomScale}px;`;
        }
        if (character.offsetY) {
            canvasStyle += `top: ${character.offsetY * Util.$zoomScale}px;`;
        }
        canvas.setAttribute("style", canvasStyle);

        // mask attach
        const layer = scene.getLayer(layer_id);
        if (layer.maskId !== null) {

            const maskLayer = scene.getLayer(layer.maskId);
            if (!maskLayer) {
                layer.maskId = null;
            }

            if (maskLayer && maskLayer.lock && maskLayer._$characters.length) {

                const maskCharacter = maskLayer._$characters[0];
                maskCharacter.dispose();

                const maskImage  = maskCharacter.draw(Util.$getCanvas());
                const maskBounds = maskCharacter.getBounds(matrix);

                const x = (maskBounds.xMin - bounds.xMin) * Util.$zoomScale;
                const y = (maskBounds.yMin - bounds.yMin) * Util.$zoomScale;

                const maskSrc    = maskImage.toDataURL();
                const maskWidth  = maskImage._$width  * Util.$zoomScale;
                const maskHeight = maskImage._$height * Util.$zoomScale;

                divStyle += `mask: url(${maskSrc}), none;`;
                divStyle += `-webkit-mask: url(${maskSrc}), none;`;
                divStyle += `mask-size: ${maskWidth}px ${maskHeight}px;`;
                divStyle += `-webkit-mask-size: ${maskWidth}px ${maskHeight}px;`;
                divStyle += "mask-repeat: no-repeat;";
                divStyle += "-webkit-mask-repeat: no-repeat;";
                divStyle += `mask-position: ${x}px ${y}px;`;
                divStyle += `-webkit-mask-position: ${x}px ${y}px;`;
                divStyle += `mix-blend-mode: ${canvas.style.mixBlendMode};`;
                divStyle += `filter: ${canvas.style.filter};`;

            }
        }

        div.setAttribute("style", divStyle);
        switch (instance._$type) {

            case InstanceType.MOVIE_CLIP:
                div.addEventListener("dblclick", (event) =>
                {
                    this.changeScene(event);
                });
                break;

            case InstanceType.TEXT:
                {
                    const borderDiv = document.createElement("div");

                    borderDiv.style.width  = `${width  - 2}px`;
                    borderDiv.style.height = `${height - 2}px`;
                    borderDiv.style.pointerEvents = "none";

                    borderDiv.style.position = "absolute";
                    borderDiv.style.left     = "0px";
                    borderDiv.style.top      = "0px";

                    borderDiv.style.border = instance._$border
                        ? "1px solid gray"
                        : "1px dashed gray";

                    div.appendChild(borderDiv);

                    div.addEventListener("dblclick", (event) =>
                    {
                        this.selectText(event);
                    });
                }
                break;

        }

        document
            .getElementById("stage-area")
            .appendChild(div);
    }

    /**
     * @description 指定したテキストを選択状態に
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    selectText (event)
    {
        // 親のイベントを中止する
        event.stopPropagation();

        // ツールをリセット
        Util.$tools.reset();

        const children = document
            .getElementById("stage-area")
            .children;

        for (let idx = 0; idx < children.length; ++idx) {
            children[idx].style.pointerEvents = "none";
        }

        const element = event.currentTarget;
        element.style.pointerEvents = "";

        const canvas = element.firstChild;
        canvas.remove();

        const textarea = window.document.createElement("textarea");
        element.style.display = "none";
        element.parentNode.appendChild(textarea);

        const workSpace   = Util.$currentWorkSpace();
        const scene       = workSpace.scene;
        const layerId     = element.dataset.layerId | 0;
        const layer       = scene.getLayer(layerId);
        const characterId = element.dataset.characterId | 0;
        const character   = layer.getCharacter(characterId);
        const instance    = workSpace.getLibrary(character.libraryId);

        textarea.value = instance._$text;

        textarea.style.border = instance._$border
            ? "1px solid gray"
            : "1px dashed gray";

        textarea.style.fontSize      = `${instance._$size}px`;
        textarea.style.fontFamily    = instance._$font;
        textarea.style.width         = `${parseFloat(canvas.style.width) - 4}px`;
        textarea.style.height        = `${parseFloat(canvas.style.height)}px`;
        textarea.style.position      = "absolute";
        textarea.style.left          = element.style.left;
        textarea.style.top           = element.style.top;
        textarea.style.pointerEvents = "auto";

        if (!instance._$border) {
            textarea.style.backgroundColor = "transparent";
        }

        // set params
        textarea.dataset.characterId = `${character.id}`;
        textarea.dataset.layerId     = `${layer_id}`;
        textarea.dataset.libraryId   = `${character.libraryId}`;
        textarea.dataset.child       = "true";

        if (!instance._$multiline) {
            textarea.addEventListener("keydown", (event) =>
            {
                if (event.key === "Enter") {
                    event.preventDefault();
                    return false;
                }
            });
        }

        textarea.addEventListener("focusin", () =>
        {
            Util.$keyLock = true;
        });

        textarea.addEventListener("focusout", (event) =>
        {
            const element     = event.target;
            const workSpace   = Util.$currentWorkSpace();
            const scene       = workSpace.scene;
            const layerId     = element.dataset.layerId | 0;
            const layer       = scene.getLayer(layerId);
            const characterId = element.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);
            const instance    = workSpace.getLibrary(character.libraryId);

            // update
            instance._$text = element.value;

            // clear
            character.dispose();
            Util.$keyLock     = false;

            const children = document
                .getElementById("stage-area")
                .children;

            for (let idx = 0; idx < children.length; ++idx) {
                const node = children[idx];
                node.style.pointerEvents = "";
            }

            const frame = Util.$timelineFrame.currentFrame;
            scene.changeFrame(frame);

        });

        textarea.focus();
    }

    /**
     * @description 指定のMovieClipに移動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    changeScene (event)
    {
        // 親のイベントを中止する
        event.stopPropagation();

        const target = event.currentTarget;

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                target.dataset.layerId | 0
            );

        const characterId = target.dataset.characterId | 0;
        const character   = layer.getCharacter(characterId);

        // アクティブなDisplayObjectのIDを格納
        Util.$activeCharacterIds.push(characterId);

        // シーン名をリストに追加(fixed logic)
        Util
            .$currentWorkSpace()
            .scene
            .addSceneName(true);

        // 調整用のxy座標(fixed logic)
        const matrix = Util.$sceneChange.concatenatedMatrix;

        const x  = character.x;
        const y  = character.y;
        const dx = x * matrix[0] + y * matrix[2] + matrix[4];
        const dy = x * matrix[1] + y * matrix[3] + matrix[5];

        Util.$sceneChange.offsetX = dx;
        Util.$sceneChange.offsetY = dy;

        const frame = Util.$timelineFrame.currentFrame;
        const place = character.getPlace(frame);
        Util.$sceneChange.matrix.push(place.matrix);

        // シーン移動
        Util.$sceneChange.execute(
            target.dataset.libraryId | 0
        );
    }

    /**
     * @description ステージに配置したelementを削除
     *              Delete elements placed on stage
     *
     * @return {void}
     * @method
     * @public
     */
    clearStageArea ()
    {
        const stageArea = document.getElementById("stage-area");
        if (!stageArea) {
            return ;
        }

        let idx = 0;
        while (stageArea.children.length > idx) {

            const node = stageArea.children[idx];

            // 中心点や回転などのelementは削除しない
            if (!node.dataset.child) {
                idx++;
                continue;
            }

            node.remove();
        }
    }
}

Util.$screen = new Screen();

/**
 * @class
 * @extends {KeyboardCommand}
 * @memberOf view.screen
 */
class ScreenKeyboardCommand extends KeyboardCommand
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("screen");

        /**
         * @type {string}
         * @default "close"
         * @private
         */
        this._$state = "close";

        /**
         * @type {CommonTool}
         * @default null
         * @private
         */
        this._$prevTool = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$activeTool = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endHandTool = null;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document
            .getElementById("screen");

        if (element) {

            element.addEventListener("mouseleave", () =>
            {
                this.active = false;
            });

            element.addEventListener("mouseover", () =>
            {
                if (!this.active) {
                    this.active = true;
                }
            });

            element.addEventListener("mouseup", () =>
            {
                if (!this.active) {
                    this.active = true;
                }
            });
        }

        this._$endHandTool = this.endHandTool.bind(this);

        // ハンドツール
        this.add(" ", this.startHandTool.bind(this));

        // 初期のショートカット
        const keys = [
            "v", // Arrow
            "q", // Arrow Transform
            "a", // Shape Transform
            "p", // Pen
            "t", // Text
            "k", // Bucket
            "o", // Circle
            "r", // Rectangle
            "z"  // Zoom
        ];
        this._$activeTool = this.activeTool.bind(this);
        for (let idx = 0; idx < keys.length; ++idx) {
            this.add(keys[idx], this._$activeTool);
        }

        this.add(
            Util.$generateShortcutKey("r", { "shift": true }),
            this._$activeTool
        );

        // ユーザー設定
        this.add("s", this.userSetting.bind(this));

        // 指定したDisplayObjectを移動
        const arrows = [
            "ArrowRight",
            "ArrowLeft",
            "ArrowUp",
            "ArrowDown"
        ];

        for (let idx = 0; idx < arrows.length; ++idx) {
            const key = arrows[idx];
            this.add(key, this.executeMoveDisplayObject);
            this.add(
                Util.$generateShortcutKey(key, { "shift": true }),
                this.executeMoveDisplayObject
            );
        }

        // プロジェクトファイルを読み込む
        this.add(Util.$generateShortcutKey("r", { "ctrl": true }), () =>
        {
            Util.$shiftKey = false;
            Util.$ctrlKey  = false;
            Util.$altKey   = false;
            Util.$project.open();
        });

        // プロジェクトデータを書き出し
        this.add(
            Util.$generateShortcutKey("s", { "ctrl": true, "shift": true }),
            Util.$project.save
        );

        // 選択中のDisplayObjectを削除
        this.add("Backspace", this.deleteDisplayObject);

        // 選択中のtweenのカーブポインターを削除
        this.add(Util.$generateShortcutKey("p", { "ctrl": true, "shift": true }), () =>
        {
            Util.$tweenController.deleteCurvePointer();
        });

        // 最前面
        this.add(Util.$generateShortcutKey("ArrowUp", { "ctrl": true, "shift": true }), () =>
        {
            Util.$screenMenu.changeDepth("up");
        });

        // ひとつ前面へ
        this.add(Util.$generateShortcutKey("ArrowUp", { "ctrl": true }), () =>
        {
            Util.$screenMenu.changeDepthOne("up");
        });

        // 最背面
        this.add(Util.$generateShortcutKey("ArrowDown", { "ctrl": true, "shift": true }), () =>
        {
            Util.$screenMenu.changeDepth("down");
        });

        // ひとつ背面へ
        this.add(Util.$generateShortcutKey("ArrowDown", { "ctrl": true }), () =>
        {
            Util.$screenMenu.changeDepthOne("down");
        });

        // 左揃え
        this.add("1", () =>
        {
            Util.$screenMenu.alignment("left");
        });

        // ステージ基準の左揃え
        this.add(Util.$generateShortcutKey("!", { "shift": true }), () =>
        {
            Util.$screenMenu.alignment("left", "stage");
        });

        // 中央揃え(水平方向)
        this.add("2", () =>
        {
            Util.$screenMenu.alignment("center");
        });

        // ステージ基準の中央揃え(水平方向)
        this.add(Util.$generateShortcutKey("\"", { "shift": true }), () =>
        {
            Util.$screenMenu.alignment("center", "stage");
        });

        // 右揃え
        this.add("3", () =>
        {
            Util.$screenMenu.alignment("right");
        });

        // ステージ基準の右揃え
        this.add(Util.$generateShortcutKey("#", { "shift": true }), () =>
        {
            Util.$screenMenu.alignment("right", "stage");
        });

        // 上揃え
        this.add("4", () =>
        {
            Util.$screenMenu.alignment("top");
        });

        // ステージ基準の上揃え
        this.add(Util.$generateShortcutKey("$", { "shift": true }), () =>
        {
            Util.$screenMenu.alignment("top", "stage");
        });

        // 中央揃え(垂直方向)
        this.add("5", () =>
        {
            Util.$screenMenu.alignment("middle");
        });

        // ステージ基準の中央揃え(垂直方向)
        this.add(Util.$generateShortcutKey("%", { "shift": true }), () =>
        {
            Util.$screenMenu.alignment("middle", "stage");
        });

        // 下揃え
        this.add("6", () =>
        {
            Util.$screenMenu.alignment("bottom");
        });

        // ステージ基準の下揃え
        this.add(Util.$generateShortcutKey("&", { "shift": true }), () =>
        {
            Util.$screenMenu.alignment("bottom", "stage");
        });

        // レイヤーに配分
        this.add(Util.$generateShortcutKey("d", { "ctrl": true }), () =>
        {
            Util
                .$screenMenu
                .executeScreenDistributeToLayers();
        });

        // キーフレームに配分
        this.add(Util.$generateShortcutKey("k", { "ctrl": true }), () =>
        {
            Util
                .$screenMenu
                .executeScreenDistributeToKeyframes();
        });

        // Shapeの結合
        this.add(Util.$generateShortcutKey("i", { "ctrl": true }), () =>
        {
            Util
                .$screenMenu
                .executeScreenIntegratingPaths();
        });

        // カーブポインターを追加
        this.add(Util.$generateShortcutKey("p", { "ctrl": true }), () =>
        {
            Util.$tweenController.addCurvePinter();
        });

        // MovieClipに変換
        this.add(Util.$generateShortcutKey("m", { "shift": true }), () =>
        {
            Util.$screenMenu.executeScreenChangeMovieClip();
        });

        // 選択中のDisplayObjectをコピー
        this.add(Util.$generateShortcutKey("c", { "ctrl": true }), () =>
        {
            Util.$screenMenu.copyDisplayObject();
        });

        // コピーしたDisplayObjectをペースト
        this.add(Util.$generateShortcutKey("v", { "ctrl": true }), () =>
        {
            Util.$screenMenu.pasteDisplayObject();
        });

        // ロックされていないDisplayObjectを全て選択
        this.add(Util.$generateShortcutKey("a", { "ctrl": true }), () =>
        {
            this.allDisplayObjectSelect();
        });

        // ロックされていないDisplayObjectを全て選択
        this.add(Util.$generateShortcutKey("r", { "ctrl": true, "shift": true }), () =>
        {
            Util.$screenRuler.show();
        });
    }

    /**
     * @description ロックされていないDisplayObjectを全て選択
     *
     * @return {void}
     * @method
     * @public
     */
    allDisplayObjectSelect ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        // 選択中のDisplayObjectを全て解放
        tool.activeElements.length = 0;

        const scene = Util.$currentWorkSpace().scene;
        const frame = Util.$timelineFrame.currentFrame;

        for (const layer of scene._$layers.values()) {
            if (layer.lock) {
                continue;
            }

            const characters = layer.getActiveCharacter(frame);
            for (let idx = 0; idx < characters.length; ++idx) {

                const character = characters[idx];

                const element = document
                    .getElementById(`character-${character.id}`);

                if (!element) {
                    continue;
                }

                tool.activeElements.push(element);
            }

        }

        // コントローラーエリアの表示を更新
        tool.updateControllerProperty();

        // 拡大縮小回転のElementのポイントを表示して再計算
        Util
            .$transformController
            .show()
            .relocation();

        // 9sliceのElementのポイントを表示して再計算
        Util
            .$gridController
            .show()
            .relocation();

        // 選択されたDisplayObjectが配置されてるタイムラインをアクティブに
        tool.activeTimeline();
    }

    /**
     * @description 選択中のDisplayObjectを削除
     *
     * @return {void}
     * @method
     * @public
     */
    deleteDisplayObject ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.deleteDisplayObject();
    }

    /**
     * @description ユーザー設定画面を表示
     *
     * @return {void}
     * @method
     * @public
     */
    userSetting ()
    {
        const element = document
            .getElementById("user-setting");

        if (this._$state === "show"
            || element.classList.contains("fadeIn")
        ) {

            this._$state = "close";
            Util.$endMenu();

        } else {

            this._$state = "show";
            Util.$userSetting.show();

        }

    }

    /**
     * @description アローツールをアクティブに
     *
     * @param  {string} code
     * @return {void}
     * @method
     * @public
     */
    activeTool (code)
    {
        let name = "";
        switch (code) {

            case "v":
                name = "arrow";
                break;

            case "q":
                name = "arrow-transform";
                break;

            case "a":
                name = "transform";
                break;

            case "p":
                name = "pen";
                break;

            case "t":
                name = "text";
                break;

            case "z":
                name = "zoom";
                break;

            case "k":
                name = "bucket";
                break;

            case "r":
                name = "rectangle";
                break;

            case "o":
                name = "circle";
                break;

            case "rShift":
                name = "round-rect";
                break;

            default:
                break;

        }

        if (name) {
            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                activeTool.dispatchEvent(EventType.END);
            }

            const tool = Util.$tools.getDefaultTool(name);
            tool.dispatchEvent(EventType.START);
            Util.$tools.activeTool = tool;
        }

    }

    /**
     * @description ハンドツールを起動
     *
     * @return {void}
     * @method
     * @public
     */
    startHandTool ()
    {
        if (Util.$tools.activeTool.name === "hand") {
            return ;
        }

        // 直前のツールをキャッシュ
        this._$prevTool = Util.$tools.activeTool;
        if (this._$prevTool) {
            this._$prevTool.dispatchEvent(EventType.END);
        }

        // ハンドツールを起動
        const tool = Util.$tools.getDefaultTool("hand");
        tool.dispatchEvent(EventType.START);
        Util.$tools.activeTool = tool;

        // 選択ツールを中止
        Util.$tools.getDefaultTool("arrow").endRect();

        // 終了イベントを設定
        window.addEventListener("keyup", this._$endHandTool);
    }

    /**
     * @description ハンドツールを終了
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    endHandTool (event)
    {
        if (event.key !== " ") {
            return ;
        }

        // イベントを削除
        window.removeEventListener("keyup", this._$endHandTool);

        const tool = Util.$tools.getDefaultTool("hand");
        tool.dispatchEvent(EventType.END);

        if (this._$prevTool) {

            // 前のツールに戻す
            this._$prevTool.dispatchEvent(EventType.START);
            Util.$tools.activeTool = this._$prevTool;

            // 初期化
            this._$prevTool = null;

        } else {

            Util.$tools.reset();

        }
    }

    /**
     * @description 右に移動
     *
     * @param  {string} code
     * @return {void}
     * @method
     * @public
     */
    executeMoveDisplayObject (code)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        if (!tool.activeElements.length) {
            return ;
        }

        switch (code) {

            case "ArrowRight":
            case "ArrowRightShift":
                tool.pageX = Util.$shiftKey ? 10 : 1;
                tool.pageY = 0;
                break;

            case "ArrowLeft":
            case "ArrowLeftShift":
                tool.pageX = Util.$shiftKey ? -10 : -1;
                tool.pageY = 0;
                break;

            case "ArrowUp":
            case "ArrowUpShift":
                tool.pageX = 0;
                tool.pageY = Util.$shiftKey ? -10 : -1;
                break;

            case "ArrowDown":
            case "ArrowDownShift":
                tool.pageX = 0;
                tool.pageY = Util.$shiftKey ? 10 : 1;
                break;

            default:
                return;

        }

        tool.moveDisplayObject();
        tool._$saved = false;
    }
}

Util.$screenKeyboardCommand = new ScreenKeyboardCommand();

/**
 * @class
 * @memberOf view.screen
 */
class ScreenMenu extends BaseScreen
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @description 表示非表示の状態変数、初期値は非表示
         * @type {string}
         * @default "hide"
         * @private
         */
        this._$state = "hide";

        /**
         * @type {array}
         * @private
         */
        this._$copyDisplayObjects = [];

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$copyWorkSpaceId = -1;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$copyFrame = -1;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "screen-front",
            "screen-front-one",
            "screen-back-one",
            "screen-back",
            "screen-position-left",
            "screen-position-right",
            "screen-position-center",
            "screen-position-top",
            "screen-position-middle",
            "screen-position-bottom",
            "stage-position-left",
            "stage-position-right",
            "stage-position-center",
            "stage-position-top",
            "stage-position-middle",
            "stage-position-bottom",
            "screen-distribute-to-layers",
            "screen-distribute-to-keyframes",
            "screen-integrating-paths",
            "screen-add-tween-curve-pointer",
            "screen-delete-tween-curve-pointer",
            "screen-change-movie-clip",
            "screen-preview",
            "screen-ruler"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document
                .getElementById(elementIds[idx]);

            if (!element) {
                continue;
            }

            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event.target.id);
            });
        }

        const overHideElementIds = [
            "screen-distribute-to-layers",
            "screen-distribute-to-keyframes",
            "screen-integrating-paths",
            "screen-add-tween-curve-pointer",
            "screen-delete-tween-curve-pointer",
            "screen-change-movie-clip",
            "screen-preview",
            "screen-ruler"
        ];
        for (let idx = 0; idx < overHideElementIds.length; ++idx) {

            const element = document
                .getElementById(overHideElementIds[idx]);

            if (!element) {
                continue;
            }

            element.addEventListener("mouseover", () =>
            {
                // サブメニューを全て非表示
                this.hideSubMenu();
            });
        }

        const overViewElementIds = [
            "screen-order",
            "screen-align"
        ];

        for (let idx = 0; idx < overViewElementIds.length; ++idx) {

            const element = document
                .getElementById(overViewElementIds[idx]);

            if (!element) {
                continue;
            }

            element.addEventListener("mouseover", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // 対象のサブメニューを表示
                this.showSubMenu(event);

            });
        }
    }

    /**
     * @description サブメニューを非表示
     *
     * @param  {string} [id=""]
     * @return {void}
     * @method
     * @public
     */
    hideSubMenu (id = "")
    {
        const overElementIds = [
            "screen-order-menu",
            "screen-align-menu"
        ];

        for (let idx = 0; idx < overElementIds.length; ++idx) {

            const elementId = overElementIds[idx];
            if (id && id === elementId) {
                continue;
            }

            const element = document.getElementById(elementId);
            if (!element) {
                continue;
            }

            if (!element.classList.contains("fadeIn")) {
                continue;
            }
            element.setAttribute("class", "fadeOut");
        }

    }

    /**
     * @description サブメニューを表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    showSubMenu (event)
    {
        const target = event.target;

        const id = `${target.id}-menu`;

        const element = document.getElementById(id);
        if (!element) {
            return ;
        }

        // 対象以外のサブメニューを全て非表示
        this.hideSubMenu(id);

        const parent = document.getElementById("screen-menu");
        element.style.left = `${parent.offsetLeft + parent.clientWidth - 5}px`;
        element.style.top  = `${parent.offsetTop + 20}px`;

        element.setAttribute("class", "fadeIn");
    }

    /**
     * @description コピーしたDisplayObjectをペースト
     *
     * @return {void}
     * @method
     * @public
     */
    copyDisplayObject ()
    {
        // 初期化
        this.clearCopy();

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        // 選択中のDisplayObject
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        // コピー元のワークスペースのIDをセット
        this._$copyWorkSpaceId = Util.$activeWorkSpaceId;
        this._$copyFrame       = Util.$timelineFrame.currentFrame;

        // DisplayObjectをクローンして配列に格納
        const scene = Util.$currentWorkSpace().scene;
        const length = tool.activeElements.length;
        for (let idx = 0; idx < length; ++idx) {
            const element = activeElements[idx];
            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            this._$copyDisplayObjects.push(
                new Character(JSON.parse(JSON.stringify(
                    character.toObject()
                )))
            );
        }
    }

    /**
     * @description コピー情報を初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clearCopy ()
    {
        this._$copyFrame = -1;
        this._$copyWorkSpaceId = -1;
        this._$copyDisplayObjects.length = 0;
    }

    /**
     * @description 選択したDisplayObjectをコピー
     *
     * @return {void}
     * @method
     * @public
     */
    pasteDisplayObject ()
    {
        if (this._$copyWorkSpaceId === -1) {
            return;
        }

        // コピーしてるものがなければ終了
        if (!this._$copyDisplayObjects.length) {
            return;
        }

        const fromWorkSpace = Util.$workSpaces[this._$copyWorkSpaceId];
        const toWorkSpace   = Util.$currentWorkSpace();
        if (!fromWorkSpace) {
            return ;
        }

        // レイヤーを選択してなければ終了
        let targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            Util.$timelineLayer.attachLayer();
            targetLayer = Util.$timelineLayer.targetLayer;
        }

        const layer = toWorkSpace
            .scene
            .getLayer(
                targetLayer.dataset.layerId | 0
            );

        // ワークスペースが異なる場合は依存するライブラリを移動する
        if (this._$copyWorkSpaceId !== Util.$activeWorkSpaceId) {

            // コピー元が存在するかチェック
            for (let idx = 0; this._$copyDisplayObjects.length > idx; ++idx) {

                const character = this._$copyDisplayObjects[idx];

                // コピー元がなければ初期化して終了
                if (fromWorkSpace.getLibrary(character.libraryId)) {
                    continue;
                }

                this._$copyWorkSpaceId = -1;
                this._$copyDisplayObjects.length = 0;

                return ;
            }

            // 状態保存
            this.save();

            // 初期化
            Util.$confirmModal.clear();

            // 同一名のアイテムがライブラリにあるか確認
            const mapping = Util.$confirmModal._$mapping;
            for (let idx = this._$copyDisplayObjects.length - 1; idx > -1; --idx) {

                const character = this._$copyDisplayObjects[idx];

                const libraryId = character.libraryId;

                // 既に複製したアイテムなら処理を短縮
                if (mapping.has(libraryId)) {

                    // コピー元のidのインクリメント防止でobjectから複製を生成
                    const activeWorkSpaceId = Util.$activeWorkSpaceId;
                    Util.$activeWorkSpaceId = this._$copyWorkSpaceId;

                    const cloneCharacter = new Character(JSON.parse(JSON.stringify(
                        character.toObject()
                    )));
                    Util.$activeWorkSpaceId = activeWorkSpaceId;

                    // コピー先の情報をセット
                    cloneCharacter.libraryId = mapping.get(libraryId);
                    cloneCharacter._$id      = toWorkSpace._$characterId++;

                    Util
                        .$confirmModal
                        .pasteDisplayObject(
                            layer, cloneCharacter, this._$copyFrame
                        );

                    continue;
                }

                // コピー元のアイテムがなければスキップ
                const instance  = fromWorkSpace.getLibrary(libraryId);
                if (!instance) {
                    continue;
                }

                const path = instance
                    .getPathWithWorkSpace(fromWorkSpace);

                if (toWorkSpace._$nameMap.has(path)) {
                    Util.$confirmModal.files.push({
                        "file": instance,
                        "character": character,
                        "layer": layer,
                        "path": path,
                        "copyFrame": this._$copyFrame,
                        "workSpaceId": this._$copyWorkSpaceId,
                        "type": "copy"
                    });
                    continue;
                }

                // ライブラリへアイテムを複製
                let clone = null;
                if (instance.type === InstanceType.MOVIE_CLIP) {

                    clone = Util
                        .$confirmModal
                        .cloneMovieClip(this._$copyWorkSpaceId, instance);

                } else {

                    const activeWorkSpaceId = Util.$activeWorkSpaceId;
                    Util.$activeWorkSpaceId = this._$copyWorkSpaceId;

                    clone = instance.clone();
                    Util.$activeWorkSpaceId = activeWorkSpaceId;

                }

                // 新しいIDを付与
                clone._$id = toWorkSpace.nextLibraryId;

                // 重複管理
                mapping.set(instance.id, clone.id);

                // Elementを追加
                Util
                    .$libraryController
                    .createInstance(
                        clone.type,
                        clone.name,
                        clone.id,
                        clone.symbol
                    );

                // 内部データに追加
                toWorkSpace._$libraries.set(clone.id, clone);

                // フォルダ内にあればフォルダを生成
                if (clone.folderId) {
                    Util
                        .$confirmModal
                        .createFolder(
                            this._$copyWorkSpaceId, clone
                        );
                }

                // コピー元のidのインクリメント防止でobjectから複製を生成
                const activeWorkSpaceId = Util.$activeWorkSpaceId;
                Util.$activeWorkSpaceId = this._$copyWorkSpaceId;

                const cloneCharacter = new Character(JSON.parse(JSON.stringify(
                    character.toObject()
                )));
                Util.$activeWorkSpaceId = activeWorkSpaceId;

                // コピー先の情報をセット
                cloneCharacter.libraryId = clone.id;
                cloneCharacter._$id      = toWorkSpace._$characterId++;

                Util
                    .$confirmModal
                    .pasteDisplayObject(
                        layer, cloneCharacter, this._$copyFrame
                    );
            }

            // ライブラリの再読み込み
            Util.$libraryController.reload();

        } else {

            // コピー元が存在するかチェック
            for (let idx = 0; this._$copyDisplayObjects.length > idx; ++idx) {

                const character = this._$copyDisplayObjects[idx];

                // コピー元がなければ初期化して終了
                if (toWorkSpace.getLibrary(character.libraryId)) {
                    continue;
                }

                this._$copyWorkSpaceId = -1;
                this._$copyDisplayObjects.length = 0;

                return ;
            }

            // 状態保存
            this.save();

            // コピーを実行
            for (let idx = this._$copyDisplayObjects.length - 1; idx > -1; --idx) {
                // コピー元を複製して指定レイヤーに追加
                const character = this._$copyDisplayObjects[idx];

                Util
                    .$confirmModal
                    .pasteDisplayObject(
                        layer, character.clone(), this._$copyFrame
                    );
            }
        }

        // レイヤーを再構成
        layer.reloadStyle();

        // 確認モーダルを表示
        if (Util.$confirmModal.files.length) {
            Util.$confirmModal.show();
        } else {
            Util.$confirmModal.clear();
        }

        // 再描画
        this.reloadScreen();

        // 初期化
        this._$saved = false;

        // リセット
        super.focusOut();
    }

    /**
     * @description Playerでのプレビュー
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPreview ()
    {
        Util.$showPreview();
    }

    /**
     * @description 選択したDisplayObjectをレイヤーに分割
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenDistributeToLayers ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        this.save();

        const characters = [];

        const frame  = Util.$timelineFrame.currentFrame;
        const layers = new Map();
        const scene  = Util.$currentWorkSpace().scene;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];

            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            if (!layer) {
                continue;
            }

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            if (!character) {
                continue;
            }

            const range = character.getRange(frame);
            if (!layers.has(layer.id)) {
                layers.set(layer.id, {
                    "layer": layer,
                    "range": range
                });
            }

            // キーフレーム情報をキャッシュ
            const place = character.getPlace(range.startFrame);
            place.depth = 0;

            characters.push({
                "libraryId": character.libraryId,
                "place": place,
                "startFrame": range.startFrame,
                "endFrame": range.endFrame
            });

            // 現在のレイヤーから削除
            character.remove(layer);
        }

        // タイムラインを再構成
        for (const object of layers.values()) {

            const layer = object.layer;
            const range = object.range;

            const characters = layer.getActiveCharacter(range.startFrame);
            if (characters.length) {

                // 深度順に並び替え
                layer.sort(characters, frame);

                for (let idx = 0; idx < characters.length; ++idx) {
                    characters[idx].getPlace(frame).depth = idx;
                }

            } else {

                layer.addEmptyCharacter(
                    new EmptyCharacter({
                        "startFrame": range.startFrame,
                        "endFrame": range.endFrame
                    })
                );

            }

            layer.reloadStyle();
        }

        // 選択をクリア
        Util.$timelineLayer.clear();

        // 複数選択準備
        const ctrlKey = Util.$ctrlKey;
        Util.$ctrlKey = true;

        // レイヤーを追加して配置
        for (let idx = 0; idx < characters.length; ++idx) {

            const object = characters[idx];

            const character = new Character();
            character.libraryId  = object.libraryId;
            character.startFrame = object.startFrame;
            character.endFrame   = object.endFrame;
            character.setPlace(object.startFrame, object.place);

            const layer = new Layer();
            layer.addCharacter(character);

            if (object.startFrame > 1) {
                layer.addEmptyCharacter(new EmptyCharacter({
                    "startFrame": 1,
                    "endFrame": object.startFrame
                }));
            }

            // シーンに追加
            scene.addLayer(layer);

            // アクティブ設定
            Util.$timelineLayer.activeLayer(
                document.getElementById(`layer-id-${layer.id}`)
            );
        }

        // 再描画
        this.reloadScreen();

        // 選択の再計算
        Util.$timelineLayer.activeCharacter();

        // 初期化
        Util.$ctrlKey = ctrlKey;
        this._$saved  = false;
    }

    /**
     * @description 選択したDisplayObjectをキーフレームに分割
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenDistributeToKeyframes ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        this.save();

        const scene = Util.$currentWorkSpace().scene;

        let frame = Util.$timelineFrame.currentFrame;

        const layers = new Map();
        for (const element of activeElements.values()) {

            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            if (!layers.has(layer.id)) {
                layers.set(layer.id, {
                    "range": character.getRange(frame),
                    "characters": []
                });
            }

            layers
                .get(layer.id)
                .characters
                .push(character);
        }

        for (const [layerId, object] of layers) {

            let characters = object.characters;
            if (characters.length === 1) {
                continue;
            }

            const layer = scene.getLayer(layerId);
            const range = object.range;

            // フレームで配置されてるDisplayObject
            const activeCharacters = layer.getActiveCharacter(frame);

            const rangeFrame = range.endFrame - range.startFrame;
            switch (true) {

                // レイヤーに配置されたDisplayObjectの数と選択した数が一致しない場合は補正
                case characters.length !== activeCharacters.length:
                    {
                        const indexes = new Map();

                        // 指定フレームに配置されたDisplayObjectを分割
                        const splits = [];
                        for (let idx = 0; idx < activeCharacters.length; ++idx) {

                            const character = activeCharacters[idx];

                            const index = characters.indexOf(character);

                            const splitCharacter = character.split(layer,
                                range.startFrame, range.endFrame
                            );

                            if (index > -1) {
                                indexes.set(splitCharacter.id, index);
                            }

                            splits.push(splitCharacter);
                        }

                        // 後方のDisplayObjectを後方に移動
                        for (let idx = 0; idx < layer._$characters.length; ++idx) {

                            const character = layer._$characters[idx];

                            if (range.endFrame > character.endFrame) {
                                continue;
                            }

                            if (character.startFrame > range.startFrame) {

                                character.move(characters.length);

                            } else {

                                const places = new Map();
                                for (const [keyFrame, place] of character._$places) {

                                    if (keyFrame > range.startFrame) {
                                        place.frame = keyFrame + characters.length;
                                    }

                                    places.set(place.frame, place);

                                }

                                character._$places  = places;
                                character.endFrame += characters.length;
                            }
                        }

                        // 空のフレームも移動
                        for (let idx = 0; layer._$emptys.length > idx; ++idx) {

                            const emptyCharacter = layer._$emptys[idx];

                            if (range.startFrame > emptyCharacter.startFrame) {
                                continue;
                            }

                            emptyCharacter.move(characters.length);
                        }

                        // レンジ幅を後方に移動
                        frame = range.endFrame;
                        range.startFrame = range.endFrame;
                        range.endFrame  += characters.length;

                        // 分割したDisplayObjectを分割対象か配置を判定
                        const newCharacters = [];
                        for (let idx = 0; idx < splits.length; ++idx) {

                            const character = splits[idx];

                            // 分割対象なら移動して終了
                            if (indexes.has(character.id)) {

                                // キーフレームを移動
                                character.setPlace(
                                    range.startFrame,
                                    character.getPlace(character.startFrame)
                                );
                                character.deletePlace(character.startFrame);

                                // フレーム情報を更新
                                character.startFrame = range.startFrame;
                                character.endFrame   = range.endFrame;

                                // レイヤーに登録して配列へ格納
                                layer.addCharacter(character);
                                newCharacters.push(character);

                            } else {

                                // 分割対象外であれば、前方のDisplayObjectを結合
                                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                                    const child = layer._$characters[idx];

                                    if (child.libraryId !== character.libraryId) {
                                        continue;
                                    }

                                    if (child.endFrame !== character.startFrame) {
                                        continue;
                                    }

                                    for (const [keyFrame, place] of character._$places) {
                                        child.setPlace(keyFrame, place);
                                    }

                                    child.endFrame = character.endFrame;
                                    break;
                                }

                            }
                        }

                        // 対象配列を上書き
                        characters = newCharacters;
                    }
                    break;

                // フレーム数がレンジ幅以上の場合は、後方のフレームを後方へ移動
                case characters.length > rangeFrame:
                    {
                        const moveFrame  = characters.length - rangeFrame;

                        for (let idx = 0; layer._$characters.length > idx; ++idx) {

                            const character = layer._$characters[idx];
                            if (range.endFrame >= character.endFrame) {
                                continue;
                            }

                            if (character.startFrame > range.endFrame) {

                                // レンジ幅より先で開始する単独DisplayObjectは単純な横移動
                                character.move(moveFrame);

                            } else {

                                // 開始位置が前方で、終了位置が後方のDisplayObjectはレンジ幅の対象だけ移動
                                const places = new Map();
                                for (const [keyFrame, place] of character._$places) {

                                    if (keyFrame >= range.endFrame) {
                                        place.frame = keyFrame + moveFrame;
                                    }

                                    places.set(place.frame, place);

                                }

                                character._$places  = places;
                                character.endFrame += moveFrame;
                            }
                        }

                        // 空のフレームも移動
                        for (let idx = 0; layer._$emptys.length > idx; ++idx) {

                            const emptyCharacter = layer._$emptys[idx];
                            if (range.endFrame >= emptyCharacter.endFrame) {
                                continue;
                            }

                            emptyCharacter.move(moveFrame);
                        }

                        // レンジ幅も更新
                        range.endFrame += moveFrame;
                    }
                    break;

                // 分割するフレーム数がレンジ以下の場合は、後方のフレームを前方へ移動
                case rangeFrame > characters.length:
                    {
                        const moveFrame = rangeFrame - characters.length;

                        for (let idx = 0; layer._$characters.length > idx; ++idx) {

                            const character = layer._$characters[idx];
                            if (range.endFrame > character.endFrame) {
                                continue;
                            }

                            if (character.startFrame > range.endFrame) {

                                // レンジ幅より先で開始する単独DisplayObjectは単純な横移動
                                character.move(-moveFrame);

                            } else {

                                const places = new Map();
                                for (const [keyFrame, place] of character._$places) {

                                    if (keyFrame >= range.endFrame) {
                                        place.frame = keyFrame - moveFrame;
                                    }

                                    places.set(place.frame, place);

                                }

                                character._$places  = places;
                                character.endFrame -= moveFrame;
                            }

                        }

                        // 空のフレームも移動
                        for (let idx = 0; layer._$emptys.length > idx; ++idx) {

                            const emptyCharacter = layer._$emptys[idx];
                            if (range.startFrame > emptyCharacter.startFrame) {
                                continue;
                            }

                            emptyCharacter.move(-moveFrame);
                        }

                        // レンジ幅も更新
                        range.endFrame -= moveFrame;
                    }
                    break;

                default:
                    break;

            }

            // 昇順
            // eslint-disable-next-line no-loop-func
            characters.sort((a, b) =>
            {
                const aDepth = a.getPlace(frame).depth;
                const bDepth = b.getPlace(frame).depth;
                switch (true) {

                    case aDepth > bDepth:
                        return 1;

                    case aDepth < bDepth:
                        return -1;

                    default:
                        return 0;

                }
            });

            let keyFrame = range.startFrame;
            for (let idx = 0; idx < characters.length; ++idx) {

                let character = characters[idx];

                // キーフレームが複数ある場合は分割
                if (character._$places.size !== 1) {
                    character = character.split(
                        layer,
                        range.startFrame,
                        range.endFrame
                    );
                    layer.addCharacter(character);
                }

                const place = character.getPlace(frame);

                let end = false;
                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                    const child = layer._$characters[idx];

                    // 同一のobjectならスキップ
                    if (child.id === character.id) {
                        continue;
                    }

                    // 同一のアイテムでないならスキップ
                    if (child.libraryId !== character.libraryId) {
                        continue;
                    }

                    if (child.endFrame !== keyFrame) {
                        continue;
                    }

                    // 分割したDisplayObjectをレイヤーから削除
                    layer.deleteCharacter(character.id);

                    // 既存のDisplayObjectと連結
                    child.endFrame = keyFrame + 1;
                    child.setPlace(keyFrame, place);

                    end = true;
                    break;
                }

                // 前方に同一のDisplayObjectがあれば結合して終了
                if (end) {
                    keyFrame++;
                    continue;
                }

                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                    const child = layer._$characters[idx];

                    // 同一のobjectならスキップ
                    if (child.id === character.id) {
                        continue;
                    }

                    // 同一のアイテムでないならスキップ
                    if (child.libraryId !== character.libraryId) {
                        continue;
                    }

                    if (child.startFrame !== keyFrame + 1) {
                        continue;
                    }

                    // 分割したDisplayObjectをレイヤーから削除
                    layer.deleteCharacter(character.id);

                    // 既存のDisplayObjectと連結
                    child.startFrame = keyFrame;
                    child.setPlace(keyFrame, place);

                    end = true;
                    break;
                }

                // 後方に同一のDisplayObjectがあれば結合して終了
                if (end) {
                    keyFrame++;
                    continue;
                }

                // 前後方に同一のDisplayObjectがなければ自身の情報を上書き
                character.startFrame = keyFrame;
                character.endFrame   = keyFrame + 1;
                character.deletePlace(place.frame);
                character.setPlace(keyFrame, place);

                keyFrame++;
            }

            // タイムラインを再構成
            layer.reloadStyle();
        }

        // 再描画
        this.reloadScreen();

        this._$saved = false;
    }

    /**
     * @description 選択したShapeのパスを統合
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenIntegratingPaths ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        this.save();

        const workSpace = Util.$currentWorkSpace();

        const scene = workSpace.scene;
        const frame = Util.$timelineFrame.currentFrame;

        let baseShape     = null;
        let baseCharacter = null;

        let index = 0;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];
            if (element.dataset.instanceType !== InstanceType.SHAPE) {
                continue;
            }

            const instance = workSpace.getLibrary(
                element.dataset.libraryId | 0
            );

            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            const { Graphics } = window.next2d.display;
            if (!baseShape) {

                baseCharacter = character;

                baseShape = instance;
                for (let idx = 0; baseShape._$recodes.length > idx;) {

                    switch (baseShape._$recodes[idx++]) {

                        case Graphics.BEGIN_PATH:
                            break;

                        case Graphics.MOVE_TO:
                            idx += 2;
                            break;

                        case Graphics.LINE_TO:
                            idx += 2;
                            break;

                        case Graphics.CURVE_TO:
                            idx += 4;
                            break;

                        case Graphics.CUBIC:
                            idx += 6;
                            break;

                        case Graphics.FILL_STYLE:
                        case Graphics.GRADIENT_FILL:
                        case Graphics.STROKE_STYLE:
                        case Graphics.GRADIENT_STROKE:
                            index = idx - 1;
                            break;

                        case Graphics.CLOSE_PATH:
                        case Graphics.END_STROKE:
                        case Graphics.END_FILL:
                            break;

                        default:
                            break;

                    }

                    if (index) {
                        break;
                    }
                }

                continue;
            }

            const tx = baseCharacter.screenX
                - baseShape._$bounds.xMin
                - character.screenX;

            const ty = baseCharacter.screenY
                - baseShape._$bounds.yMin
                - character.screenY;

            const matrix  = character.getPlace(frame).matrix;
            const recodes = [];

            let done = false;
            for (let idx = 0; instance._$recodes.length > idx;) {

                switch (instance._$recodes[idx++]) {

                    case Graphics.BEGIN_PATH:
                        break;

                    case Graphics.MOVE_TO:
                        {
                            const x = instance._$recodes[idx++];
                            const y = instance._$recodes[idx++];
                            recodes.push(
                                Graphics.MOVE_TO,
                                x * matrix[0] + y * matrix[2] - tx,
                                x * matrix[1] + y * matrix[3] - ty
                            );
                        }
                        break;

                    case Graphics.LINE_TO:
                        {
                            const x = instance._$recodes[idx++];
                            const y = instance._$recodes[idx++];
                            recodes.push(
                                Graphics.LINE_TO,
                                x * matrix[0] + y * matrix[2] - tx,
                                x * matrix[1] + y * matrix[3] - ty
                            );
                        }
                        break;

                    case Graphics.CURVE_TO:
                        {
                            const cx = instance._$recodes[idx++];
                            const cy = instance._$recodes[idx++];
                            const x  = instance._$recodes[idx++];
                            const y  = instance._$recodes[idx++];
                            recodes.push(
                                Graphics.CURVE_TO,
                                cx * matrix[0] + cy * matrix[2] - tx,
                                cx * matrix[1] + cy * matrix[3] - ty,
                                x  * matrix[0] + y  * matrix[2] - tx,
                                x  * matrix[1] + y  * matrix[3] - ty
                            );
                        }
                        break;

                    case Graphics.CUBIC:
                        {
                            const ctx1 = instance._$recodes[idx++];
                            const cty1 = instance._$recodes[idx++];
                            const ctx2 = instance._$recodes[idx++];
                            const cty2 = instance._$recodes[idx++];
                            const x    = instance._$recodes[idx++];
                            const y    = instance._$recodes[idx++];
                            recodes.push(
                                Graphics.CUBIC,
                                ctx1 * matrix[0] + cty1 * matrix[2] - tx,
                                ctx1 * matrix[1] + cty1 * matrix[3] - ty,
                                ctx2 * matrix[0] + cty2 * matrix[2] - tx,
                                ctx2 * matrix[1] + cty2 * matrix[3] - ty,
                                x * matrix[0] + y * matrix[2] - tx,
                                x * matrix[1] + y * matrix[3] - ty
                            );
                        }
                        break;

                    case Graphics.FILL_STYLE:
                    case Graphics.GRADIENT_FILL:
                    case Graphics.STROKE_STYLE:
                    case Graphics.GRADIENT_STROKE:
                        done = true;

                        Array
                            .prototype
                            .splice
                            .apply(
                                baseShape._$recodes,
                                [index, 0].concat(recodes)
                            );

                        index += recodes.length;
                        break;

                    case Graphics.CLOSE_PATH:
                    case Graphics.END_STROKE:
                    case Graphics.END_FILL:
                        break;

                    default:
                        break;

                }

                if (done) {
                    break;
                }
            }
        }

        if (baseShape) {

            const bounds = baseShape.reloadBounds();
            baseShape._$bounds.xMin = bounds.xMin;
            baseShape._$bounds.xMax = bounds.xMax;
            baseShape._$bounds.yMin = bounds.yMin;
            baseShape._$bounds.yMax = bounds.yMax;
            baseShape.cacheClear();

            this.reloadScreen();
        }

        this._$saved = false;
    }

    /**
     * @description 選択中のDisplayObjectをMovieClipに格納
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenChangeMovieClip ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const element = document.getElementById("change-movie-clip");
        if (!element) {
            return ;
        }

        Util.$endMenu("change-movie-clip");

        if (!element.classList.contains("fadeIn")) {
            element.setAttribute("class", "fadeIn");
        }
    }

    /**
     * @description 定規機能のOn/Off
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenRuler ()
    {
        Util.$screenRuler.show();
    }

    /**
     * @description tweenのカーブポイントを追加
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenAddTweenCurvePointer ()
    {
        Util.$tweenController.addCurvePinter();
    }

    /**
     * @description tweenのカーブポイントを削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenDeleteTweenCurvePointer ()
    {
        Util.$tweenController.deleteCurvePointer();
    }

    /**
     * @description 指定したDisplayObjectを最前面に移動
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenFront ()
    {
        this.changeDepth("up");
    }

    /**
     * @description 指定したDisplayObjectを最背面に移動
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenBack ()
    {
        this.changeDepth("down");
    }

    /**
     * @description 指定したDisplayObjectをひとつ前面に移動
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenFrontOne ()
    {
        this.changeDepthOne("up");
    }

    /**
     * @description 指定したDisplayObjectをひとつ背面に移動
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenBackOne ()
    {
        this.changeDepthOne("down");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で左揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeStagePositionLeft ()
    {
        this.alignment("left", "stage");
    }

    /**
     * @description 指定したDisplayObjectを左揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPositionLeft ()
    {
        this.alignment("left");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で中央揃え(水平方向)
     *
     * @return {void}
     * @method
     * @public
     */
    executeStagePositionCenter ()
    {
        this.alignment("center", "stage");
    }

    /**
     * @description 指定したDisplayObjectを中央揃え(水平方向)
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPositionCenter ()
    {
        this.alignment("center");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で右揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeStagePositionRight ()
    {
        this.alignment("right", "stage");
    }

    /**
     * @description 指定したDisplayObjectを右揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPositionRight ()
    {
        this.alignment("right");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で上揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeStagePositionTop ()
    {
        this.alignment("top", "stage");
    }

    /**
     * @description 指定したDisplayObjectを上揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPositionTop ()
    {
        this.alignment("top");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で中央揃え(垂直方向)
     *
     * @return {void}
     * @method
     * @public
     */
    executeStagePositionMiddle ()
    {
        this.alignment("middle", "stage");
    }

    /**
     * @description 指定したDisplayObjectを中央揃え(垂直方向)
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPositionMiddle ()
    {
        this.alignment("middle");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で下揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeStagePositionBottom ()
    {
        this.alignment("bottom", "stage");
    }

    /**
     * @description 指定したDisplayObjectを下揃え
     *
     * @return {void}
     * @method
     * @public
     */
    executeScreenPositionBottom ()
    {
        this.alignment("bottom");
    }

    /**
     * @description 選択したDisplayObjectを選択した矩形で整列
     *
     * @param  {string} align
     * @param  {string} [mode="rect"]
     * @return {void}
     * @method
     * @public
     */
    alignment (align, mode = "rect")
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length
            || mode === "rect" && 2 > activeElements.length
        ) {
            return ;
        }

        this.save();

        // 現在のプロジェクト
        const workSpace = Util.$currentWorkSpace();

        // 初期値
        let x = 0;
        let y = 0;
        let w = 0;
        let h = 0;
        if (mode === "rect") {

            const element = document
                .getElementById("target-rect");

            x = element.offsetLeft - Util.$offsetLeft - Util.$sceneChange.offsetX;
            y = element.offsetTop  - Util.$offsetTop  - Util.$sceneChange.offsetY;
            w = element.offsetWidth;
            h = element.offsetHeight;

        } else {

            const children = document
                .getElementById("scene-name-menu-list")
                .children;

            let count = 0;
            for (let idx = 0; idx < children.length; ++idx) {

                const node = children[idx];
                if (node.dataset.parent === "false") {
                    continue;
                }

                count++;
            }

            if (!count) {
                const stage = workSpace.stage;
                w = stage.width;
                h = stage.height;
            }

        }

        const matrix = Util.$sceneChange.concatenatedMatrix;

        const frame = Util.$timelineFrame.currentFrame;
        const scene = workSpace.scene;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];

            const layer = scene.getLayer(element.dataset.layerId | 0);
            if (!layer || layer.lock || layer.disable) {
                continue;
            }

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            const place = character.getPlace(frame);
            if (!place.point) {
                const bounds = character.getBounds(matrix);
                const tx = Util.$sceneChange.offsetX + bounds.xMin;
                const ty = Util.$sceneChange.offsetY + bounds.yMin;
                const w  = Math.ceil(Math.abs(bounds.xMax - bounds.xMin)) / 2;
                const h  = Math.ceil(Math.abs(bounds.yMax - bounds.yMin)) / 2;

                place.point = {
                    "x": tx + w,
                    "y": ty + h
                };
            }

            // 現時点のxy座標をキャッシュ
            const currentX = place.matrix[4];
            const currentY = place.matrix[5];

            // 表示領域をセット
            const bounds = character.getBounds(matrix);
            const width  = Math.abs(bounds.xMax - bounds.xMin);
            const height = Math.abs(bounds.yMax - bounds.yMin);
            switch (align) {

                case "left":
                    place.matrix[4] = currentX - bounds.xMin + x;
                    break;

                case "right":
                    place.matrix[4] = currentX - bounds.xMin + x + w - width;
                    break;

                case "center":
                    place.matrix[4] = currentX - bounds.xMin + x + w / 2 - width / 2;
                    break;

                case "top":
                    place.matrix[5] = currentY - bounds.yMin + y;
                    break;

                case "bottom":
                    place.matrix[5] = currentY - bounds.yMin + y + h - height;
                    break;

                case "middle":
                    place.matrix[5] = currentY - bounds.yMin + y + h / 2 - height / 2;
                    break;

            }

            // elementを移動
            const characterElement = document
                .getElementById(`character-${character.id}`);

            const afterBounds = character.getBounds(matrix);
            const left = Util.$offsetLeft + (Util.$sceneChange.offsetX + afterBounds.xMin) * Util.$zoomScale;
            const top  = Util.$offsetTop  + (Util.$sceneChange.offsetY + afterBounds.yMin) * Util.$zoomScale;
            characterElement.style.top  = `${top}px`;
            characterElement.style.left = `${left}px`;

            // DisplayObjectの座標を修正
            character.screenX = afterBounds.xMin;
            character.screenY = afterBounds.yMin;

            // 移動した分だけ中心点も移動
            const point = place.point;
            point.x += place.matrix[4] - currentX;
            point.y += place.matrix[5] - currentY;
        }

        // 選択範囲を再計算
        Util.$transformController.relocation();

        // 初期化
        this._$saved = false;
    }

    /**
     * @param  {string} [mode="up"]
     * @return {void}
     * @public
     */
    changeDepthOne (mode = "up")
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        this.save();

        const scene = Util.$currentWorkSpace().scene;

        const frame = Util.$timelineFrame.currentFrame;

        const layers = new Map();
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];

            const layer = scene.getLayer(element.dataset.layerId | 0);

            if (!layers.has(layer.id)) {
                layers.set(layer.id, []);
            }

            layers.get(layer.id).push(
                layer.getCharacter(element.dataset.characterId | 0)
            );
        }

        for (const [layerId, values] of layers) {

            const layer = scene.getLayer(layerId);
            const characters = layer.getActiveCharacter(frame);
            if (1 >= characters.length) {
                continue;
            }

            // 降順
            characters.sort((a, b) =>
            {
                const aDepth = a.getPlace(frame).depth;
                const bDepth = b.getPlace(frame).depth;
                switch (true) {

                    case aDepth > bDepth:
                        return -1;

                    case aDepth < bDepth:
                        return 1;

                    default:
                        return 0;

                }
            });

            if (values.length > 1) {

                if (mode === "up") {

                    // 降順
                    values.sort((a, b) =>
                    {
                        const aDepth = a.getPlace(frame).depth;
                        const bDepth = b.getPlace(frame).depth;
                        switch (true) {

                            case aDepth > bDepth:
                                return -1;

                            case aDepth < bDepth:
                                return 1;

                            default:
                                return 0;

                        }
                    });

                } else {

                    // 昇順
                    values.sort((a, b) =>
                    {
                        const aDepth = a.getPlace(frame).depth;
                        const bDepth = b.getPlace(frame).depth;
                        switch (true) {

                            case aDepth > bDepth:
                                return 1;

                            case aDepth < bDepth:
                                return -1;

                            default:
                                return 0;

                        }
                    });

                }

            }

            let minDepth = 0;
            let maxDepth = characters.length - 1;
            for (let idx = 0; idx < values.length; ++idx) {

                const character = values[idx];

                const place = character.getPlace(frame);

                if (mode === "up") {

                    if (place.depth >= maxDepth) {
                        --maxDepth;
                        continue;
                    }

                    place.depth++;

                    const index = characters.indexOf(character);
                    characters[index - 1].getPlace(frame).depth--;

                } else {

                    if (minDepth >= place.depth) {
                        ++minDepth;
                        continue;
                    }

                    place.depth--;

                    const index = characters.indexOf(character);
                    characters[index + 1].getPlace(frame).depth++;

                }

                // 降順
                characters.sort((a, b) =>
                {
                    const aDepth = a.getPlace(frame).depth;
                    const bDepth = b.getPlace(frame).depth;
                    switch (true) {

                        case aDepth > bDepth:
                            return -1;

                        case aDepth < bDepth:
                            return 1;

                        default:
                            return 0;

                    }
                });

            }
        }

        // 再描画
        this.reloadScreen();

        // 初期化
        this._$saved = false;
    }

    /**
     * @param  {string} [mode="up"]
     * @return {void}
     * @public
     */
    changeDepth (mode = "up")
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        this.save();

        const scene = Util.$currentWorkSpace().scene;

        const frame = Util.$timelineFrame.currentFrame;

        const layers = new Map();
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];

            const layer = scene.getLayer(element.dataset.layerId | 0);

            if (!layers.has(layer.id)) {
                layers.set(layer.id, []);
            }

            layers.get(layer.id).push(
                layer.getCharacter(element.dataset.characterId | 0)
            );
        }

        for (const [layerId, values] of layers) {

            const layer = scene.getLayer(layerId);

            const characters = layer.getActiveCharacter(frame);
            if (1 >= characters.length) {
                continue;
            }

            // 降順
            characters.sort((a, b) =>
            {
                const aDepth = a.getPlace(frame).depth;
                const bDepth = b.getPlace(frame).depth;
                switch (true) {

                    case aDepth > bDepth:
                        return -1;

                    case aDepth < bDepth:
                        return 1;

                    default:
                        return 0;

                }
            });

            // 降順
            if (values.length > 1) {

                if (mode === "up") {

                    // 降順
                    values.sort((a, b) =>
                    {
                        const aDepth = a.getPlace(frame).depth;
                        const bDepth = b.getPlace(frame).depth;
                        switch (true) {

                            case aDepth > bDepth:
                                return -1;

                            case aDepth < bDepth:
                                return 1;

                            default:
                                return 0;

                        }
                    });

                } else {

                    // 昇順
                    values.sort((a, b) =>
                    {
                        const aDepth = a.getPlace(frame).depth;
                        const bDepth = b.getPlace(frame).depth;
                        switch (true) {

                            case aDepth > bDepth:
                                return 1;

                            case aDepth < bDepth:
                                return -1;

                            default:
                                return 0;

                        }
                    });
                }

            }

            const ignoreMap = new Map();

            let minDepth = 0;
            let maxDepth = characters.length - 1;
            for (let idx = 0; idx < values.length; ++idx) {

                const value = values[idx];

                const place = value.getPlace(frame);

                if (mode === "up") {

                    if (place.depth >= maxDepth) {
                        --maxDepth;
                        continue;
                    }

                    place.depth = maxDepth--;

                    ignoreMap.set(value.id, true);

                    let depth = maxDepth;
                    for (let idx = 0; characters.length > idx; ++idx) {

                        const character = characters[idx];
                        if (ignoreMap.has(character.id)) {
                            continue;
                        }

                        character.getPlace(frame).depth = depth--;
                        if (depth === -1) {
                            break;
                        }
                    }

                } else {

                    if (minDepth >= place.depth) {
                        ++minDepth;
                        continue;
                    }

                    place.depth = minDepth++;

                    ignoreMap.set(value.id, true);

                    let depth = minDepth;
                    for (let idx = characters.length - 1; idx > -1; --idx) {

                        const character = characters[idx];
                        if (ignoreMap.has(character.id)) {
                            continue;
                        }

                        character.getPlace(frame).depth = depth++;
                        if (depth === characters.length) {
                            break;
                        }
                    }
                }
            }
        }

        // 再描画
        this.reloadScreen();

        // 初期化
        this._$saved = false;
    }

    /**
     * @description スクリーンエリアのメニューモーダルを表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    show (event)
    {
        Util.$endMenu("screen-menu");

        const element = document.getElementById("screen-menu");

        const height = element.clientHeight / 2 + 15;

        element.style.left = `${event.pageX + 5}px`;
        element.style.top  = `${event.pageY - height}px`;

        if (15 > element.offsetTop) {
            element.style.top = "10px";
        }

        if (event.pageY + height > window.innerHeight) {
            const moveY = window.innerHeight - (event.pageY + height - 15);
            element.style.top = `${element.offsetTop + moveY}px`;
        }

        element.setAttribute("class", "fadeIn");
    }
}

Util.$screenMenu = new ScreenMenu();

/**
 * @class
 * @memberOf view.screen
 */
class ScreenRuler extends BaseScreen
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {string}
         * @default "hide"
         * @private
         */
        this._$state = "hide";

        /**
         * @type {array}
         * @private
         */
        this._$elementIds = [
            "ruler-top",
            "ruler-left"
        ];

        /**
         * @type {number}
         * @default 5
         * @private
         */
        this._$size = ScreenRuler.DEFAULT_SIZE;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$target = null;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$mode = "";
    }

    /**
     * @member {number}
     * @const
     */
    static get DEFAULT_SIZE ()
    {
        return 5;
    }

    /**
     * @description 定規の表示状態を返す
     *
     * @member {string}
     * @readonly
     * @public
     */
    get state ()
    {
        return this._$state;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        document
            .documentElement
            .style
            .setProperty(
                "--ruler-size",
                `${ScreenRuler.DEFAULT_SIZE - 1}px`
            );

        for (let idx = 0; idx < this._$elementIds.length; ++idx) {

            const element = document
                .getElementById(this._$elementIds[idx]);

            if (!element) {
                continue;
            }

            element.addEventListener("mousedown", (event) =>
            {
                event.stopPropagation();
                event.preventDefault();

                this.executeFunction(event.target.id);
            });

        }
    }

    /**
     * @description ボーダーの移動処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        if (!this._$target) {
            return ;
        }

        window.requestAnimationFrame(() =>
        {
            if (!this._$target) {
                return ;
            }

            event.stopPropagation();
            event.preventDefault();

            if (this._$mode === "x") {
                this._$target.style.left = `${event.offsetX}px`;
            } else {
                this._$target.style.top = `${event.offsetY}px`;
            }
        });
    }

    /**
     * @description ボーダーの設置完了処理
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    mouseUp (event)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.changeNodeEvent();

        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        this.save();

        const workSpace = Util.$currentWorkSpace();
        const screen = document.getElementById("screen");
        if (event.target.dataset.removeZone === "true") {

            // プロジェクトから削除
            if (this._$mode === "x") {

                const index = Array.from(
                    screen.getElementsByClassName("ruler-border-x")
                ).indexOf(this._$target);

                workSpace._$rulerX.splice(index, 1);

            } else {

                const index = Array.from(
                    screen.getElementsByClassName("ruler-border-y")
                ).indexOf(this._$target);

                workSpace._$rulerY.splice(index, 1);

            }
            this._$target.remove();

        } else {

            // プロジェクトに登録
            if (this._$mode === "x") {

                const index = Array.from(
                    screen.getElementsByClassName("ruler-border-x")
                ).indexOf(this._$target);

                workSpace._$rulerX[index] = (this._$target.offsetLeft - Util.$offsetLeft) / Util.$zoomScale;

            } else {

                const index = Array.from(
                    screen.getElementsByClassName("ruler-border-y")
                ).indexOf(this._$target);

                workSpace._$rulerY[index] = (this._$target.offsetTop - Util.$offsetTop) / Util.$zoomScale;
            }

        }

        // アクティブ制御
        this.changeNodeEvent(true);

        // 初期化
        this._$move   = "";
        this._$target = null;
        this._$saved  = false;
    }

    /**
     * @description 定規で定義した線のアクティブ制御
     *
     * @param  {boolean} [active=true]
     * @return {void}
     * @method
     * @public
     */
    changeNodeEvent (active = true)
    {
        const screen = document.getElementById("screen");
        if (!screen) {
            return ;
        }

        const rulerArrayX = screen
            .getElementsByClassName("ruler-border-x");

        for (let idx = 0; idx < rulerArrayX.length; ++idx) {
            rulerArrayX[idx].style.pointerEvents = active ? "" : "none";
        }

        const rulerArrayY = screen
            .getElementsByClassName("ruler-border-y");

        for (let idx = 0; idx < rulerArrayY.length; ++idx) {
            rulerArrayY[idx].style.pointerEvents = active ? "" : "none";
        }
    }

    /**
     * @description スクリーンのスクロールに合わせてバーを配置
     *
     * @return {void}
     * @method
     * @public
     */
    reload ()
    {
        if (this._$state === "hide") {
            return ;
        }

        const screen = document.getElementById("screen");
        if (!screen) {
            return ;
        }

        const stageArea = document.getElementById("stage-area");
        if (!stageArea) {
            return ;
        }

        let leftStyle = "";
        leftStyle += `height: ${stageArea.offsetHeight}px;`;
        leftStyle += `left: ${screen.scrollLeft}px;`;
        document
            .getElementById("ruler-left")
            .setAttribute("style", leftStyle);

        let topStyle = "";
        topStyle += `width: ${stageArea.offsetWidth}px;`;
        topStyle += `top: ${screen.scrollTop}px;`;

        document
            .getElementById("ruler-top")
            .setAttribute("style", topStyle);
    }

    /**
     * @description 定規の上部バーの表示管理
     *
     * @return {void}
     * @method
     * @public
     */
    executeRulerTop ()
    {
        const stageArea = document.getElementById("stage-area");
        if (!stageArea) {
            return ;
        }

        this._$mode   = "y";
        this._$target =  this.createBorderY();

        document
            .getElementById("screen")
            .prepend(this._$target);

        Util
            .$currentWorkSpace()
            ._$rulerY
            .unshift(this._$target.offsetTop - Util.$offsetTop);

        this.setupMove();
    }

    /**
     * @description Y軸の線を追加
     *
     * @return {HTMLDivElement}
     * @method
     * @public
     */
    createBorderY ()
    {
        const stageArea = document.getElementById("stage-area");
        if (!stageArea) {
            return ;
        }

        const div = document.createElement("div");
        div.setAttribute("style", `width: ${stageArea.offsetWidth}px;`);
        div.setAttribute("class", "ruler-border-y");
        div.addEventListener("mousedown", (event) =>
        {
            event.stopPropagation();
            event.preventDefault();

            this._$target = event.target;
            this._$mode   = "y";

            this.setupMove();
        });

        return div;
    }

    /**
     * @description 定規の左バーの表示管理
     *
     * @return {void}
     * @method
     * @public
     */
    executeRulerLeft ()
    {
        const stageArea = document.getElementById("stage-area");
        if (!stageArea) {
            return ;
        }

        this._$mode   = "x";
        this._$target =  this.createBorderX();

        document
            .getElementById("screen")
            .prepend(this._$target);

        Util
            .$currentWorkSpace()
            ._$rulerX
            .unshift(this._$target.offsetLeft - Util.$offsetLeft);

        this.setupMove();
    }

    /**
     * @description Y軸の線を追加
     *
     * @return {HTMLDivElement}
     * @method
     * @public
     */
    createBorderX ()
    {
        const stageArea = document.getElementById("stage-area");
        if (!stageArea) {
            return ;
        }

        const div = document.createElement("div");
        div.setAttribute("style", `height: ${stageArea.offsetHeight}px;`);
        div.setAttribute("class", "ruler-border-x");
        div.addEventListener("mousedown", (event) =>
        {
            event.stopPropagation();
            event.preventDefault();

            this._$target = event.target;
            this._$mode   = "x";

            this.setupMove();
        });

        return div;
    }

    /**
     * @description x座標の移動開始処理
     *
     * @return {void}
     * @method
     * @public
     */
    setupMove ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();
        tool.changeNodeEvent(false);

        // アクティブ制御
        this.changeNodeEvent(false);

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description 現在のサイズで定規の幅を再構成
     *
     * @return {void}
     * @method
     * @public
     */
    rebuild ()
    {
        // 要素を全て削除
        this.removeAll();

        this._$size = ScreenRuler.DEFAULT_SIZE * Util.$zoomScale;

        document
            .documentElement
            .style
            .setProperty(
                "--ruler-size",
                `${this._$size - 1}px`
            );

        if (this._$state === "show") {

            const stage     = document.getElementById("stage");
            const stageArea = document.getElementById("stage-area");

            // 上の定規を生成
            this.createRuler(
                document.getElementById("ruler-top"),
                stage.offsetLeft,
                stageArea.offsetWidth
            );

            // 左の定規を生成
            this.createRuler(
                document.getElementById("ruler-left"),
                stage.offsetTop,
                stageArea.offsetHeight
            );

            // 現在の表示に合わせてバーを設置
            this.reload();
        }

        // ボーダーを配置
        this.createBorder();
    }

    /**
     * @description 縦横線を構成
     *
     * @return {void}
     * @method
     * @public
     */
    createBorder ()
    {
        const workSpace = Util.$currentWorkSpace();

        const screen = document.getElementById("screen");

        // x座標の線を生成
        for (let idx = workSpace._$rulerX.length - 1; idx > -1; --idx) {

            const left = workSpace._$rulerX[idx];

            const div = this.createBorderX();
            div.style.left = `${Util.$offsetLeft + left * Util.$zoomScale}px`;

            screen.prepend(div);
        }

        // y座標の線を生成
        for (let idx = workSpace._$rulerY.length - 1; idx > -1; --idx) {

            const top = workSpace._$rulerY[idx];

            const div = this.createBorderY();
            div.style.top = `${Util.$offsetTop + top * Util.$zoomScale}px`;

            screen.prepend(div);
        }
    }

    /**
     * @description 定規を生成
     *
     * @param  {HTMLDivElement} element
     * @param  {number} offset_size
     * @param  {number} length
     * @return {void}
     * @method
     * @public
     */
    createRuler (element, offset_size, length)
    {
        const size = this._$size;
        const baseWidth = size >= ScreenRuler.DEFAULT_SIZE ? 50 : 200;
        const baseRange = size >= ScreenRuler.DEFAULT_SIZE ? 10 : 40;
        const range = size * baseRange;

        const offset   = offset_size / Util.$zoomScale | 0;
        const fraction = offset % baseWidth;

        // 差分を生成
        const diff = fraction / ScreenRuler.DEFAULT_SIZE;
        if (diff) {
            const left = document.createElement("div");
            left.setAttribute("class", "vertical-main");

            const header = document.createElement("div");
            left.appendChild(header);
            header.setAttribute("class", "vertical-header");

            const meter = document.createElement("div");
            left.appendChild(meter);
            meter.setAttribute("class", "vertical-meter");

            for (let idx = 0; diff > idx; ++idx) {
                const line = document.createElement("div");
                line.setAttribute("class", idx % 2 === 0
                    ? "vertical-line"
                    : "vertical-line-pointer"
                );
                meter.appendChild(line);
            }

            element.appendChild(left);
        }

        length = length / range | 0;
        let number  = offset - fraction;
        for (let px = 0; length > px; ++px) {

            const main = document.createElement("div");
            main.setAttribute("class", "vertical-main");

            const header = document.createElement("div");
            main.appendChild(header);
            header.setAttribute("class", "vertical-header");
            header.textContent = `${Math.abs(number)}`;

            const meter = document.createElement("div");
            main.appendChild(meter);
            meter.setAttribute("class", "vertical-meter");

            for (let idx = 0; baseRange > idx; ++idx) {
                const line = document.createElement("div");
                line.setAttribute("class", idx % 2 === 0
                    ? "vertical-line"
                    : "vertical-line-pointer"
                );
                meter.appendChild(line);
            }

            number -= baseWidth;
            element.appendChild(main);
        }
    }

    /**
     * @description 定規を表示にする
     *
     * @return {void}
     * @method
     * @public
     */
    show ()
    {
        if (this._$state === "show") {
            this.hide();
            return ;
        }

        // プロジェクト情報として補完
        const workSpace = Util.$currentWorkSpace();
        workSpace._$ruler = true;

        // 状態を更新
        this._$state = "show";

        // 表示に合わせて再構成
        this.rebuild();
    }

    /**
     * @description 定規を非表示にする
     *
     * @return {void}
     * @method
     * @public
     */
    hide ()
    {
        if (this._$state === "hide") {
            return ;
        }

        // プロジェクト情報として補完
        const workSpace = Util.$currentWorkSpace();
        workSpace._$ruler = false;

        // 初期化
        this.clear();

        // ボーダーだけ生成
        this.createBorder();
    }

    /**
     * @description 設定を初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clear ()
    {
        // 状態を更新
        this._$state = "hide";

        // 要素を全て削除
        this.removeAll();
    }

    /**
     * @description 定規の要素を全て削除
     *
     * @return {void}
     * @method
     * @public
     */
    removeAll ()
    {
        // elementを削除して非表示にする
        for (let idx = 0; this._$elementIds.length > idx; ++idx) {

            const element = document
                .getElementById(this._$elementIds[idx]);

            if (!element) {
                continue;
            }

            while (element.firstChild) {
                element.firstChild.remove();
            }

            element.setAttribute("style", "display: none;");
        }

        const screen = document.getElementById("screen");
        if (!screen) {
            return ;
        }

        const rulerArrayX = screen
            .getElementsByClassName("ruler-border-x");

        while (rulerArrayX.length) {
            rulerArrayX[0].remove();
        }

        const rulerArrayY = screen
            .getElementsByClassName("ruler-border-y");

        while (rulerArrayY.length) {
            rulerArrayY[0].remove();
        }
    }
}

Util.$screenRuler = new ScreenRuler();

/**
 * @class
 * @memberOf view.screen
 */
class ScreenTab
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$dropTab = null;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;
    }

    /**
     * @description タブエリアの起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    run ()
    {
        // 読込がWorkSpaceがあればタブのElementを追加
        for (let idx = 0; idx < Util.$workSpaces.length; ++idx) {
            this.createElement(Util.$workSpaces[idx], idx);
        }

        // タブの追加ボタン
        const button = document
            .getElementById("view-tab-add");

        if (button) {
            button.addEventListener("click", (event) =>
            {
                this.addTab(event);
            });
        }

        // タブの一覧ボタン
        const tabList = document.getElementById("view-tab-list");
        if (tabList) {
            tabList.addEventListener("mousedown", (event) =>
            {
                this.showTabList(event);
            });
        }
    }

    /**
     * @description タブの一覧をモーダルで表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    showTabList (event)
    {
        // 親のイベントを中止
        event.stopPropagation();

        const element = document.getElementById("tab-name-menu");
        if (element.classList.contains("fadeIn")) {
            return Util.$endMenu();
        }

        Util.$endMenu("tab-name-menu");

        const target = event.currentTarget;
        element.style.left = `${target.offsetLeft + target.offsetWidth}px`;
        element.style.top  = `${target.offsetTop + 25}px`;
        element.setAttribute("class", "fadeIn");
    }

    /**
     * @description スクリーンエリアのタブを追加
     *
     * @param  {WorkSpace} work_space
     * @param  {number}    id
     * @return {void}
     * @method
     * @public
     */
    createElement (work_space, id)
    {
        if (!work_space.name) {
            work_space.name = `Untitled-${id + 1}`;
        }

        // スクリーンエリアにタブのElementを追加
        const element = document
            .getElementById("view-tab-area");

        if (!element) {
            return ;
        }

        element
            .insertAdjacentHTML("beforeend", `
<div draggable="true" id="tab-id-${id}" data-tab-id="${id}" class="tab">
    <p id="tab-text-id-${id}" data-tab-id="${id}" data-detail="{{タブの移動・名前を変更}}" data-shortcut-key="ArrowLeftCtrl" data-shortcut-text="Ctrl + ◀︎ or ▶" data-area="global">${work_space.name}</p>
    <input type="text" id="tab-input-id-${id}" data-tab-id="${id}" value="${work_space.name}">
    <i id="tab-delete-id-${id}" data-tab-id="${id}" data-detail="{{プロジェクトを閉じる}}"></i>
</div>`);

        const div = document.getElementById(`tab-id-${id}`);

        // モーダル表示を登録
        Util.$addModalEvent(div);

        div
            .classList
            .add(Util.$activeWorkSpaceId === id ? "active" : "disable");

        div.addEventListener("mousedown", (event) =>
        {
            this.activeTab(event);
        });

        // ドロップでタブを移動する
        div.addEventListener("dragstart", (event) =>
        {
            this.dragStart(event);
        });

        div.addEventListener("dragover", (event) =>
        {
            this.dragOver(event);
        });

        div.addEventListener("dragleave", (event) =>
        {
            this.dragLeave(event);
        });

        div.addEventListener("drop", (event) =>
        {
            this.drop(event);
        });

        // 削除アイコンに削除関数を登録
        document
            .getElementById(`tab-delete-id-${id}`)
            .addEventListener("click", (event) =>
            {
                this.deleteTab(event);
            });

        // タイトルインプットタグをコントロールする関数を追加
        document
            .getElementById(`tab-text-id-${id}`)
            .addEventListener("dblclick", (event) =>
            {
                this.editStart(event);
            });

        // inputタグは非表示にする
        const input = document
            .getElementById(`tab-input-id-${id}`);

        if (input) {
            input.style.display = "none";

            input.addEventListener("focusout", (event) =>
            {
                this.editEnd(event);
            });
            input.addEventListener("keypress", (event) =>
            {
                this.editEnd(event);
            });
        }

        // タブ一覧にElementを追加
        document
            .getElementById("tab-name-menu-list")
            .insertAdjacentHTML("beforeend", `
<div id="tab-menu-id-${id}" data-tab-id="${id}">${work_space.name}</div>`);

        // マウスイベントでアクティブになるよう関数を登録
        const menu = document
            .getElementById(`tab-menu-id-${id}`);

        if (menu) {
            menu.addEventListener("mousedown", (event) =>
            {
                this.activeTab(event, true);
            });
        }
    }

    /**
     * @description ドロップ先のElementとドラッグしたElementを入れ替える
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    drop (event)
    {
        // 親のイベントを中止
        event.preventDefault();

        this.save();

        // スタイルを削除
        event
            .currentTarget
            .classList
            .remove("drop-target");

        const nextElement = event
            .currentTarget
            .nextElementSibling;

        document
            .getElementById("view-tab-area")
            .insertBefore(
                this._$dropTab,
                this._$dropTab === nextElement
                    ? event.currentTarget
                    : nextElement
            );

        // 初期化
        this._$dropTab = null;
        this._$saved   = false;
    }

    /**
     * @description ヒットしたElementから抜けたスタイルを削除
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    dragLeave (event)
    {
        // 親のイベントを中止
        event.preventDefault();

        event
            .currentTarget
            .classList
            .remove("drop-target");
    }

    /**
     * @description ドラッグしたElementがヒットしたElementにスタイルを追加
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    dragOver (event)
    {
        // 親のイベントを中止
        event.preventDefault();

        event
            .currentTarget
            .classList
            .add("drop-target");
    }

    /**
     * @description ドラッグスタート関数、ドラッグするElementを変数に格納
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    dragStart (event)
    {
        // モーダルを非表示にする
        Util.$endMenu();

        // ドラッグするElementを変数に格納
        this._$dropTab = event.currentTarget;
    }

    /**
     * @description タブのリスト移動した時
     *
     * @param  {MouseEvent} event
     * @param  {boolean} move_tab
     * @return {void}
     * @method
     * @public
     */
    activeTab (event, move_tab = false)
    {
        // モーダルを非表示にする
        Util.$endMenu();

        // アクティブなタブを非アクティブな状態に
        const activeElement = document
            .getElementById(`tab-id-${Util.$activeWorkSpaceId}`);

        if (activeElement) {
            activeElement
                .classList
                .remove("active");

            activeElement
                .classList
                .add("disable");
        }

        // 非アクティブなタブをアクティブな状態に
        const tabId = event.currentTarget.dataset.tabId | 0;

        const tab = document
            .getElementById(`tab-id-${tabId}`);
        if (tab) {
            tab
                .classList
                .remove("disable");

            tab
                .classList
                .add("active");

            // 指定したタブを左端に移動
            if (move_tab) {
                const area = document
                    .getElementById("view-tab-area");

                tab.remove();
                area.prepend(tab);
            }
        }

        // 対象のWorkSpaceに切り替える
        if (Util.$activeWorkSpaceId !== tabId) {
            Util.$changeWorkSpace(tabId);
        }
    }

    /**
     * @description タブの削除関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    deleteTab (event)
    {
        event.preventDefault();

        const message = Util.$currentLanguage.replace(
            "{{プロジェクトが保存されていない場合、" +
            "このタブのプロジェクトデータを復旧する事はできません。" +
            "タブを削除しますか？}}"
        );

        // 削除前に警告を表示
        if (!window.confirm(message)) {
            return ;
        }

        // 作業スペースを削除
        const tabId = event.currentTarget.dataset.tabId | 0;

        const deleteWorkSpace = Util.$workSpaces[tabId];
        Util.$workSpaces[tabId] = null;

        document
            .getElementById(`tab-id-${tabId}`)
            .remove();

        document
            .getElementById(`tab-menu-id-${tabId}`)
            .remove();

        // ライブラリタブのプレビュー表示を削除
        const previewElement = document
            .getElementById("library-preview-area");

        while (previewElement.children.length) {
            previewElement.children[0].remove();
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();

        // タブが0になった場合は空のタブを追加する
        const parent = document.getElementById("view-tab-area");
        if (!parent.children.length) {

            // reset
            Util.$workSpaces.length = 0;
            Util.$activeWorkSpaceId = 0;

            // new WorkSpace
            const workSpace = new WorkSpace();
            Util.$workSpaces.push(workSpace);

            // create tab
            this.createElement(workSpace, 0);

            // start
            deleteWorkSpace.stop();
            workSpace.run();

            const element = parent.children[0];
            element.setAttribute("class", "tab active");

        } else {

            // アクティブなタブを削除する場合は、左端のタブをアクティブにする
            if (Util.$activeWorkSpaceId === tabId) {

                const element = parent.children[0];
                element.setAttribute("class", "tab active");

                deleteWorkSpace.stop();

                Util.$activeWorkSpaceId = element.dataset.tabId | 0;

                Util.$currentWorkSpace().run();
            }

        }
    }

    /**
     * @description タブのタイトル編集を開始
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    editStart (event)
    {
        Util.$keyLock = true;

        const element = event.currentTarget;
        const tabId   = element.dataset.tabId | 0;

        const input = document
            .getElementById(`tab-input-id-${tabId}`);

        if (input.style.display === "none") {

            input.style.width     = `${element.offsetWidth}px`;
            input.style.display   = "";
            element.style.display = "none";
            input.focus();

            const parent = document
                .getElementById(`tab-id-${tabId}`);

            parent.draggable = false;
        }
    }

    /**
     * @description タブのタイトル編集を終了する関数
     *
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    editEnd (event)
    {
        if (event.key === "Enter") {
            event.target.blur();
            return ;
        }

        if (event.type === "focusout") {

            this.save();

            const element = event.currentTarget;
            element.style.display = "none";

            const tabId = element.dataset.tabId | 0;

            const p = document
                .getElementById(`tab-text-id-${tabId}`);

            const menu = document.getElementById(`tab-menu-id-${tabId}`);
            const workSpace = Util.$workSpaces[tabId];

            workSpace.name   = element.value;
            menu.textContent = element.value;
            p.textContent    = element.value;
            p.style.display  = "";

            const parent = document
                .getElementById(`tab-id-${tabId}`);

            parent.draggable = true;

            this._$saved = false;
        }
    }

    /**
     * @description タブ追加関数、WorkSpaceクラスを作成して、タブのElementを追加する
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    addTab (event)
    {
        Util.$endMenu();

        // 親のイベントを中止
        event.stopPropagation();

        this.save();

        const id = Util.$workSpaces.length;
        const workSpace = new WorkSpace();

        Util.$workSpaces.push(workSpace);
        this.createElement(workSpace, id);

        this._$saved = false;
    }

    /**
     * @description undo用にデータを内部保管する
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }
}

Util.$screenTab = new ScreenTab();

/**
 * @class
 * @extends {BaseScreen}
 * @memberOf view.screen
 */
class ScreenZoom extends BaseScreen
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$currentValue = 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_LEVEL ()
    {
        return 0.25;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_LEVEL ()
    {
        return 5;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document
            .getElementById("screen-scale");

        if (element) {
            this.setInputEvent(element);
        }
    }

    /**
     * @description ズームのスケールのInput処理
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeScreenScale (value)
    {
        value = Util.$clamp(value | 0,
            ScreenZoom.MIN_LEVEL * 100,
            ScreenZoom.MAX_LEVEL * 100
        );

        this.execute(
            (value - this._$currentValue) / 100
        );

        this._$currentValue = value;

        return value;
    }

    /**
     * @param  {number} delta
     * @return {void}
     * @public
     */
    execute (delta)
    {
        Util.$zoomScale += delta;
        Util.$zoomScale = Math.min(
            ScreenZoom.MAX_LEVEL,
            Math.max(ScreenZoom.MIN_LEVEL, Util.$zoomScale)
        );

        document
            .getElementById("screen-scale")
            .value = `${Util.$zoomScale * 100 | 0}`;

        const workSpace = Util.$currentWorkSpace();

        // ズームした幅と高さを算出
        const width  = workSpace.stage.width  * Util.$zoomScale;
        const height = workSpace.stage.height * Util.$zoomScale;

        // 対象Element
        const screen    = document.getElementById("screen");
        const stageArea = document.getElementById("stage-area");
        const stage     = document.getElementById("stage");

        const scaleX = screen.scrollLeft / screen.scrollWidth;
        const scaleY = screen.scrollTop  / screen.scrollHeight;

        const stageAreaWidth  = width  + window.screen.width;
        const stageAreaHeight = height + window.screen.height;

        // 値を更新
        stage.style.width      = `${width}px`;
        stage.style.height     = `${height}px`;
        stageArea.style.width  = `${stageAreaWidth}px`;
        stageArea.style.height = `${stageAreaHeight}px`;

        screen.scrollLeft = screen.scrollWidth * scaleX;
        screen.scrollTop  = screen.scrollHeight * scaleY;

        // DisplayObjectのキャッシュを全て削除
        const frame = Util.$timelineFrame.currentFrame;
        const scene = workSpace.scene;
        for (const layer of scene._$layers.values()) {

            const characters = layer.getActiveCharacter(frame);
            for (let idx = 0; idx < characters.length; ++idx) {
                characters[idx].dispose();
            }

        }

        // 定規を再構成
        Util.$rebuildRuler();

        // 再描画
        scene.changeFrame(frame);
    }
}

Util.$screenZoom = new ScreenZoom();

/**
 * @class
 * @extends {InputEvent}
 * @memberOf view.timeline
 */
class BaseTimeline extends InputEvent
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 共通初期イベント登録関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        Util.$initializeEnd();
    }

    /**
     * @description スクリーンエリアで変更があったElementを再描画
     *
     * @return {void}
     * @method
     * @public
     */
    reloadScreen ()
    {
        const frame = Util.$timelineFrame.currentFrame;

        Util
            .$currentWorkSpace()
            .scene
            .changeFrame(frame);
    }

    /**
     * @description Elementのid名をキャメルケースに変換して関数を実行
     *              例) font-select => executeFontSelectがコールされる
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    executeFunction (event)
    {
        const names = event.target.id.split("-");

        let functionName = names
            .map((value) =>
            {
                return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
            })
            .join("");

        this[`execute${functionName}`](event);
    }
}

/**
 * @class
 * @extends {BaseTimeline}
 * @memberOf view.timeline
 */
class JavaScriptEditor extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {Editor}
         * @default null
         * @private
         */
        this._$editor = null;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$active = false;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$frame = -1;

        /**
         * @type {MovieClip}
         * @default null
         * @private
         */
        this._$scene = null;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$screenX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$screenY = 0;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get SCRIPT_MODAL_WIDTH ()
    {
        return 620;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get SCRIPT_MODAL_HEIGHT ()
    {
        return 450;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get SCRIPT_MODAL_BAR_HEIGHT ()
    {
        return 25;
    }

    /**
     * @description モーダルがアクティブかを返します。
     *
     * @return {boolean}
     * @readonly
     * @public
     */
    get active ()
    {
        return this._$active;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        // JavaScriptの編集エディターを起動
        this.createEditor();

        const elementIds = [
            "editor-hide-icon",
            "editor-bar"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document
                .getElementById(elementIds[idx]);

            if (!element) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // メニューを終了
                Util.$endMenu("editor-modal");

                // id名で関数を実行
                this.executeFunction(event);
            });
        }

        document
            .documentElement
            .style
            .setProperty("--script-modal-width", `${JavaScriptEditor.SCRIPT_MODAL_WIDTH}px`);

        document
            .documentElement
            .style
            .setProperty("--script-modal-height", `${JavaScriptEditor.SCRIPT_MODAL_HEIGHT}px`);

        document
            .documentElement
            .style
            .setProperty("--script-modal-bar-height", `${JavaScriptEditor.SCRIPT_MODAL_BAR_HEIGHT}px`);

    }

    /**
     * @description JavaScriptの編集エディターを起動
     *
     * @return {void}
     * @method
     * @public
     */
    createEditor ()
    {
        if (!("ace" in window)) {
            return ;
        }

        this._$editor = ace.edit("editor");
        this._$editor.setOptions({
            "enableBasicAutocompletion": true,
            "enableSnippets": true,
            "enableLiveAutocompletion": true
        });
        this._$editor.setTheme("ace/theme/monokai");
        this._$editor.session.setMode("ace/mode/javascript");

        const words = [
            { "word": "next2d", "meta": "window.next2d" },
            { "word": "toString",  "value": "toString()",  "meta": "common method" },
            { "word": "namespace", "meta": "common property" }
        ];

        const level1 = Object.keys(window.next2d);
        for (let idx = 1; idx < level1.length; ++idx) {

            const name = level1[idx];
            words.push({
                "word": `next2d.${name}`,
                "meta": `next2d.${name}`
            });

            const level2 = Object.keys(window.next2d[name]);
            for (let idx = 0; idx < level2.length; ++idx) {

                const className = level2[idx];
                words.push(
                    {
                        "word": className,
                        "meta": `next2d.${name}.${className}`
                    }
                );

                const Class = window.next2d[name][className];

                const staticMethods = Object.getOwnPropertyDescriptors(Class);
                const staticNames   = Object.getOwnPropertyNames(Class);
                for (let idx = 0; idx < staticNames.length; ++idx) {

                    const name = staticNames[idx];
                    switch (name) {

                        case "length":
                        case "prototype":
                        case "toString":
                        case "namespace":
                        case "name":
                            continue;

                        default:
                            break;

                    }

                    const object = staticMethods[name];
                    if ("value" in object) {

                        const args = object
                            .value
                            .toString()
                            .replace(/ |\n/g, "")
                            .split("{")[0]
                            .split("(")[1];

                        words.push({
                            "word": name,
                            "value": `${name}()`,
                            "meta": `${className}.${name}(${args}`
                        });

                    } else {

                        words.push({
                            "word": name,
                            "meta": `${className}.${name}`
                        });

                    }

                }

                const publicMethods = Object.getOwnPropertyDescriptors(Class.prototype);
                const publicNames   = Object.getOwnPropertyNames(Class.prototype);
                for (let idx = 0; idx < publicNames.length; ++idx) {

                    const name = publicNames[idx];
                    switch (name) {

                        case "constructor":
                        case "toString":
                        case "namespace":
                        case "name":
                            continue;

                        default:
                            break;

                    }

                    if (name.indexOf("_$") > -1) {
                        continue;
                    }

                    const object = publicMethods[name];
                    if ("value" in object) {

                        const args = object
                            .value
                            .toString()
                            .replace(/ |\n/g, "")
                            .split("{")[0]
                            .split("(")[1];

                        words.push({
                            "word": name,
                            "value": `${name}()`,
                            "meta": `${className}.${name}(${args}`
                        });

                    } else {

                        words.push({
                            "word": name,
                            "meta": `${className}.${name}`
                        });

                    }
                }
            }
        }

        ace
            .require("ace/ext/language_tools")
            .addCompleter({
                // eslint-disable-next-line no-unused-vars
                "getCompletions": (editor, session, pos, prefix, callback) =>
                {
                    callback(null, words.map((object) =>
                    {
                        return {
                            "caption": object.word,
                            "value":   object.value || object.word,
                            "meta":    object.meta,
                            "score":   0
                        };
                    }));
                }
            });

        //要素のリサイズイベント取得
        const resizeObserver = new ResizeObserver((entries) =>
        {
            entries.forEach((entry) =>
            {
                const element = entry.target;

                const modalWidth = parseFloat(document
                    .documentElement
                    .style
                    .getPropertyValue("--script-modal-width"));

                const modalHeight = parseFloat(document
                    .documentElement
                    .style
                    .getPropertyValue("--script-modal-height"));

                if (modalWidth !== element.clientWidth) {
                    document
                        .documentElement
                        .style
                        .setProperty("--script-modal-width", `${element.clientWidth}px`);
                }

                if (modalHeight !== element.clientHeight) {
                    document
                        .documentElement
                        .style
                        .setProperty("--script-modal-height",
                            `${element.clientHeight + JavaScriptEditor.SCRIPT_MODAL_BAR_HEIGHT}px`);
                }
            });

            this._$editor.resize();

        });

        const element = document.getElementById("editor-modal");
        if (element) {
            resizeObserver.observe(element);
        }
    }

    /**
     * @description JavaScriptの編集エディターを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeTimelineScriptAdd (event)
    {
        this.show(event);
    }

    /**
     * @description JavaScriptの編集エディターを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuScriptAdd (event)
    {
        this.show(event);
    }

    /**
     * @description JavaScriptの編集エディターを起動
     *
     * @return {void}
     * @method
     * @public
     */
    executeEditorHideIcon ()
    {
        this.hide();
    }

    /**
     * @description JavaScriptの編集エディターを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeEditorBar (event)
    {
        // 現在の座標位置をセット
        this._$screenX = event.screenX;
        this._$screenY = event.screenY;

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description エディターを移動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        window.requestAnimationFrame(() =>
        {
            const element = document
                .getElementById("editor-modal");

            element.style.left = `${parseFloat(element.style.left) + (event.screenX - this._$screenX)}px`;
            element.style.top  = `${parseFloat(element.style.top)  + (event.screenY - this._$screenY)}px`;

            this._$screenX = event.screenX;
            this._$screenY = event.screenY;
        });
    }

    /**
     * @description マウスアップイベント。登録してるイベントを削除
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);
        Util.$setCursor("auto");
    }

    /**
     * @description JavaScriptの編集エディターを起動表示
     *
     * @param  {MouseEvent} [event=null]
     * @param  {number} [frame=0]
     * @param  {MovieClip} [scene=null]
     * @return {void}
     * @method
     * @public
     */
    show (event = null, frame = 0, scene = null)
    {
        Util.$keyLock = true;
        this._$active = true;

        // 追加対象のフレーム番号をセット
        this._$frame = frame || Util.$timelineFrame.currentFrame;

        // reset
        this._$editor.setValue("", -1);

        scene = scene || Util.$currentWorkSpace().scene;
        if (scene.hasAction(this._$frame)) {
            this._$editor.setValue(scene.getAction(this._$frame), -1);
        }

        document
            .getElementById("editor-title")
            .textContent = `${scene.name} / frame[${this._$frame}]`;

        const element = document.getElementById("editor-modal");
        if (event) {
            element.style.display = "";
            element.style.left = `${event.pageX + 5}px`;
            element.style.top  = `${event.pageY - element.clientHeight / 2}px`;
        }

        if (isNaN(parseFloat(element.style.left))) {
            element.style.left = "200px";
            element.style.top  = `${300 - element.clientHeight / 2}px`;
        }

        element.setAttribute("class", "fadeIn");
        Util.$endMenu("editor-modal");

        this._$editor.focus();
    }

    /**
     * @description JavaScriptの編集エディターの編集内容を保存して非表示
     *
     * @return {void}
     * @method
     * @public
     */
    hide ()
    {
        this.save();

        // 初期化
        this._$editor.setValue("", 0);
        this._$frame  = -1;
        this._$scene  = null;
        this._$active = false;
        Util.$keyLock = false;
        Util.$endMenu();
    }

    /**
     * @description 編集したjavaScriptの内容を保存
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (this._$frame === -1) {
            return ;
        }

        const leftFrame = Util.$timelineHeader.leftFrame;
        if (leftFrame > this._$frame) {
            return ;
        }

        const index  = this._$frame - leftFrame;
        const parent = document
            .getElementById("timeline-header")
            .children[index];

        const element = parent.children[TimelineHeader.ACTION_INDEX];
        const script  = this._$editor.getValue(0);

        const scene = this._$scene || Util.$currentWorkSpace().scene;
        if (script) {
            scene.setAction(this._$frame, script.trim());
            if (!this._$scene
                && !element.classList.contains("frame-border-box-action")
            ) {
                element.setAttribute("class", "frame-border-box-action");
            }
        } else {
            scene.deleteAction(this._$frame);
            if (!this._$scene) {
                element.setAttribute("class", "frame-border-box");
            }
        }
    }
}

Util.$javaScriptEditor = new JavaScriptEditor();

/**
 * @class
 * @memberOf view.timeline
 */
class TimelineAdjustment extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pointY = 0;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get TIMELINE_DEFAULT_SIZE ()
    {
        return 280;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get TIMELINE_MIN_SIZE ()
    {
        return 150;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        document
            .documentElement
            .style
            .setProperty(
                "--timeline-height",
                `${TimelineAdjustment.TIMELINE_DEFAULT_SIZE}px`
            );

        const element = document.getElementById("timeline-adjustment");
        if (element) {
            element.addEventListener("mousedown", (event) =>
            {
                this.mouseDown(event);
            });
        }
    }

    /**
     * @description コントローラーのサイズ変更イベントを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        event.preventDefault();

        this._$pointY = event.screenY;

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description コントローラーのサイズ変更処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        Util.$setCursor("row-resize");

        window.requestAnimationFrame(() =>
        {
            const diff = this._$pointY - event.screenY;

            const value = document
                .documentElement
                .style
                .getPropertyValue("--timeline-height")
                .split("px")[0] | 0;

            const height = Math.max(
                TimelineAdjustment.TIMELINE_MIN_SIZE,
                value + diff
            );

            document
                .documentElement
                .style
                .setProperty(
                    "--timeline-height",
                    `${height}px`
                );

            Util.$currentWorkSpace()._$timelineHeight = height;

            this._$pointY = event.screenY;

            // タイムラインを再構成
            Util.$timelineLayer.updateClientSize();

            // マーカーのボーダーの座標をセット
            Util.$timelineMarker.setMarkerPosition();
        });
    }

    /**
     * @description コントローラーのサイズ変更イベントを終了
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        // 高さを更新後のレイヤーを再構成
        Util.$timelineLayer.moveTimeLine();

        Util.$setCursor("auto");

        // タイムラインを再構成
        Util.$timelineLayer.updateClientSize();
    }
}

Util.$timelineAdjustment = new TimelineAdjustment();

/**
 * @class
 * @extends {BaseTimeline}
 * @memberOf view.timeline
 */
class TimelineFrame extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pointX = 0;

        /**
         * @description ロック時のInputの値を管理する変数
         *
         * @type {number}
         * @default null
         * @private
         */
        this._$currentValue = null;

        /**
         * @description 指定されたInputElement
         *
         * @type {HTMLInputElement}
         * @default null
         * @private
         */
        this._$currentTarget = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;
    }

    /**
     * @description 現在のフレーム番号を返却する
     *
     * @return {number}
     * @public
     */
    get currentFrame ()
    {
        const element = document.getElementById("current-frame");
        return element ? element.value | 0 : 1;
    }

    /**
     * @description 指定フレームをセット
     *
     * @param  {number} frame
     * @return {void}
     * @public
     */
    set currentFrame (frame)
    {
        const element = document.getElementById("current-frame");
        if (element) {
            const scene = Util.$currentWorkSpace().scene;
            const totalFrame = scene
                ? scene.totalFrame + TimelineScroll.FRAME_COUNT - 2
                : TimelineScroll.FRAME_COUNT - 2;
            element.value = `${Math.max(1, Math.min(frame, totalFrame)) | 0}`;
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document.getElementById("current-frame");

        if (element) {

            element.addEventListener("mouseover", (event) =>
            {
                this.mouseOver(event);
            });
            element.addEventListener("mouseout", (event) =>
            {
                this.mouseOut(event);
            });
            element.addEventListener("mousedown", (event) =>
            {
                this.mouseDown(event);
            });
            element.addEventListener("focusin", (event) =>
            {
                this.focusIn(event);
            });
            element.addEventListener("focusout",  (event) =>
            {
                this.finishInput(event);
            });
            element.addEventListener("keypress",  (event) =>
            {
                this.finishInput(event);
            });
        }
    }

    /**
     * @description Inputにフォーカスされた時に変数を初期化する
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    focusIn (event)
    {
        super.focusIn();
        this._$currentValue  = +event.target.value;
        this._$currentTarget = event.target;
    }

    /**
     * @description Inputにフォーカス終了した時にロックを解放する
     *
     * @return {void}
     * @method
     * @public
     */
    focusOut ()
    {
        super.focusOut();
        this._$currentValue  = null;
        this._$currentTarget = null;
    }

    /**
     * @description Inputが数値の場合マウス動作で加算減算できればカーソルを変化させる
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseOver (event)
    {
        event.stopPropagation();

        switch (true) {

            case this._$focus:
            case this._$currentTarget !== null:
            case this._$currentValue !== null:
                return ;

            default:
                Util.$setCursor("ew-resize");
                event.target.style.cursor = "ew-resize";
                break;

        }
    }

    /**
     * @description Inputが数値の場合マウス動作終了関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseOut (event)
    {
        event.stopPropagation();

        if (this._$focus || !this._$currentTarget) {
            Util.$setCursor("auto");
            event.target.style.cursor = "";
        }
    }

    /**
     * @description 数値のInputElementの場合はマウスで値を変更可能
     *              状態に合わせてカーソルや変数を初期化する
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseDown (event)
    {
        // Inputモードなら何もしない
        if (this._$focus) {
            return ;
        }

        event.preventDefault();

        // 初期化
        this._$pointX        = event.screenX;
        this._$currentTarget = event.target;
        this._$currentValue  = +event.target.value;

        Util.$setCursor("ew-resize");

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // 選択中のレイヤーを初期化
        Util.$timelineLayer.clear();

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        Util.$setCursor("auto");

        if (this._$currentTarget) {
            this._$currentTarget.style.cursor = "";
            this._$currentTarget.focus();
        }
    }

    /**
     * @description マウスで数値の加算減算を行う
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @public
     */
    mouseMove (event)
    {
        if (this._$focus || !this._$currentTarget) {
            return ;
        }

        window.requestAnimationFrame(() =>
        {
            if (this._$focus || !this._$currentTarget) {
                return ;
            }

            event.preventDefault();

            Util.$setCursor("ew-resize");

            const diff = event.screenX - this._$pointX;

            let currentValue = +this._$currentTarget.value;
            if (isNaN(currentValue)) {
                currentValue = 1;
            }

            // clampで補正された値をセット
            const scene = Util.$currentWorkSpace().scene;
            const totalFrame = scene.totalFrame + TimelineScroll.FRAME_COUNT - 2;
            const frame = Math.max(1, Math.min(currentValue + diff, totalFrame));

            this._$currentTarget.value = `${frame}`;
            this._$currentValue        = frame;
            this._$pointX              = event.screenX;

            // タイムラインの座標の補正
            this.moveTimeline();

            // 再描画
            this.reloadScreen();
        });
    }

    /**
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    finishInput (event)
    {
        // Enterを押下したら、focusoutイベントを発火させる
        if (event.key === "Enter") {
            event.currentTarget.blur();
            return ;
        }

        // focusoutなら更新関数を実行
        if (event.type === "focusout") {

            // Inputの値を更新
            const scene = Util.$currentWorkSpace().scene;
            const totalFrame = scene.totalFrame + TimelineScroll.FRAME_COUNT - 2;
            event.target.value = `${Math.max(1, Math.min(event.target.value | 0, totalFrame))}`;

            // タイムラインの座標の補正
            this.moveTimeline();

            // 初期化
            this.focusOut();

            // 再描画
            this.reloadScreen();
        }
    }

    /**
     * @description フレームに合わせてタイムラインの座標を移動させる
     *
     * @return {void}
     * @method
     * @public
     */
    moveTimeline ()
    {
        const element = document
            .getElementById("timeline-controller-base");

        if (!element) {
            return ;
        }

        const timelineWidth = Util.$timelineTool.timelineWidth;
        const currentFrame  = Util.$timelineFrame.currentFrame;
        const moveFrame     = Util.$timelineHeader.scrollX / timelineWidth | 0;

        // タイムラインの座標修正
        const deltaX = (currentFrame - moveFrame) * (timelineWidth + 1);
        if (0 >= deltaX || deltaX > element.clientWidth) {
            Util.$timelineHeader.scrollX = (currentFrame - 1) * timelineWidth;
        }

        // ヘッダーを再構成
        Util.$timelineHeader.rebuild();

        // マーカーを移動
        Util.$timelineMarker.move();

        // 各レイヤーを再描画
        Util.$timelineLayer.moveTimeLine();
    }
}

Util.$timelineFrame = new TimelineFrame();

/**
 * @class
 * @extends {BaseTimeline}
 * @memberOf view.timeline
 */
class TimelineHeader extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$width = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$scrollX = 0;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$targetElement = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$deleteIcon = null;
    }

    /**
     * @description ヘッダーフレームのマーカーアイコンのindex番号
     *
     * @member {number}
     * @static
     * @const
     */
    static get MARKER_INDEX ()
    {
        return 1;
    }

    /**
     * @description ヘッダーフレームのスクリプトアイコンのindex番号
     *
     * @member {number}
     * @static
     * @const
     */
    static get ACTION_INDEX ()
    {
        return 2;
    }

    /**
     * @description ヘッダーフレームのサウンドアイコンのindex番号
     *
     * @member {number}
     * @static
     * @const
     */
    static get SOUND_INDEX ()
    {
        return 3;
    }

    /**
     * @description ヘッダーのclientWidthを格納
     *
     * @member {number}
     * @readonly
     * @public
     */
    get width ()
    {
        return this._$width;
    }

    /**
     * @description ヘッダータイムラインのスクロールx座標
     *
     * @return {number}
     * @readonly
     * @public
     */
    get scrollX ()
    {
        return this._$scrollX;
    }

    /**
     * @description 画面左端のフレーム番号を返す
     *
     * @return {number}
     * @readonly
     * @public
     */
    get leftFrame ()
    {
        if (!Util.$timelineTool.timelineWidth) {
            Util.$timelineTool.timelineWidth =
                Util.$timelineTool.DEFAULT_TIMELINE_WIDTH;
        }

        return 1 + this._$scrollX / Util.$timelineTool.timelineWidth | 0;
    }

    /**
     * @description ヘッダータイムラインのスクロールx座標
     *
     * @param  {number} scroll_x
     * @return {void}
     * @public
     */
    set scrollX (scroll_x)
    {
        this._$scrollX = Math.max(0, Math.min(scroll_x, Util.$timelineScroll.maxX)) | 0;
        Util.$timelineScroll.x = this._$scrollX;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        if (!this._$deleteIcon) {
            this._$deleteIcon = this.deleteIcon.bind(this);
        }

        // 上部のタイムラインの動作イベント
        const element = document
            .getElementById("timeline-controller-base");

        if (element) {
            element.addEventListener("wheel", (event) =>
            {
                // 全てのイベントを停止
                event.stopPropagation();
                event.preventDefault();

                if (Util.$altKey) {

                    const deltaY = event.deltaY | 0;
                    if (!deltaY) {
                        return false;
                    }

                    // タイムラインの幅をスケール
                    window.requestAnimationFrame(() =>
                    {
                        Util.$timelineTool.timelineWidth = Util.$clamp(
                            Util.$timelineTool.timelineWidth + deltaY,
                            5,
                            240
                        );
                    });

                } else {

                    const delta = (event.deltaX || event.deltaY) | 0;
                    if (!delta) {
                        return false;
                    }

                    // 1フレーム目より以前には移動しない
                    if (!this._$scrollX && 0 > delta) {
                        return false;
                    }

                    // 最大値より右側には移動しない
                    if (this._$scrollX >= Number.MAX_VALUE) {
                        return false;
                    }

                    window.requestAnimationFrame(() =>
                    {
                        this.scrollX = Util.$clamp(
                            this._$scrollX + delta, 0, Number.MAX_VALUE
                        );

                        // ヘッダーを再構築
                        this.rebuild();

                        // マーカーを移動
                        Util.$timelineMarker.move();

                        // レイヤーのタイムラインを再描画
                        Util.$timelineLayer.moveTimeLine();
                    });
                }

            }, { "passive" : false });

            element
                .addEventListener("mouseleave", () =>
                {
                    this.clearParams();
                    window.removeEventListener("keydown", this._$deleteIcon);
                });

            element
                .addEventListener("mouseover", () =>
                {
                    window.addEventListener("keydown", this._$deleteIcon);
                });
        }
    }

    /**
     * @description ヘッダーの表示幅の値をセット
     *
     * @return {void}
     * @method
     * @public
     */
    setWidth ()
    {
        const element = document.getElementById("timeline-controller-base");
        if (element) {
            this._$width = element.clientWidth | 0;
        }
    }

    /**
     * @description 現在の画面サイズに合わせてヘッダーのDOMを再構成
     *
     * @return {void}
     * @method
     * @public
     */
    rebuild ()
    {
        // 描画エリアのサイズをセット
        const element = document
            .getElementById("timeline-header");

        if (!element) {
            return ;
        }

        const scene = Util.$currentWorkSpace().scene;
        if (!scene) {
            return ;
        }

        // 初期値をセット
        if (!Util.$timelineTool.timelineWidth) {
            Util.$timelineTool.timelineWidth =
                Util.$timelineTool.DEFAULT_TIMELINE_WIDTH;
        }

        const timelineWidth = Util.$timelineTool.timelineWidth;
        const elementCount  = this.width / (timelineWidth + 1) | 0;

        // elementが空なら初期処理を実行
        if (!element.children.length) {
            for (let idx = 0; elementCount >= idx; ++idx) {
                this.createElement(element, idx + 1);
            }
        }

        // 画面幅以上にelement数があれば削除
        if (element.children.length + 1 > elementCount) {
            const index = elementCount + 1;
            while (element.children.length > index) {
                element.children[index].remove();
            }
        }

        // 画面幅のelement数が多ければ再登録
        if (elementCount > element.children.length) {

            let frame = element
                .lastElementChild
                .dataset
                .frame | 0;

            const length = elementCount - element.children.length;
            for (let idx = 1; length >= idx; ++idx) {
                this.createElement(element, frame++);
            }
        }

        const fps = document
            .getElementById("stage-fps")
            .value | 0;

        let frame = this.leftFrame;
        let sec   = Math.max(1, (frame / 24 | 0) + 1);

        const children = element.children;
        const length   = children.length;
        for (let idx = 0; length > idx; ++idx) {

            const currentFrame = frame + idx;

            const node = children[idx];
            const nodeFrame = node.dataset.frame | 0;
            if (nodeFrame !== currentFrame) {
                node.setAttribute("data-frame", `${currentFrame}`);
            }

            const nodeChildren = node.children;
            const nodeLength   = nodeChildren.length;
            for (let idx = 0; nodeLength > idx; ++idx) {

                const child = nodeChildren[idx];

                const childFrame = child.dataset.frame | 0;
                if (childFrame !== currentFrame) {
                    child.setAttribute("data-frame", `${currentFrame}`);
                }

                switch (idx) {

                    case 0:
                        if (currentFrame % 5 === 0) {
                            if (!child.classList.contains("frame-border-end")) {
                                child.setAttribute("class", "frame-border-end");
                            }
                        } else {
                            if (!child.classList.contains("frame-border")) {
                                child.setAttribute("class", "frame-border");
                            }
                        }

                        if (currentFrame % fps === 0 && fps > 4) {
                            const value = sec++ + "s";
                            if (!child.innerHTML || child.innerHTML !== value) {
                                child.innerHTML = value;
                            }
                        } else {
                            if (child.innerHTML) {
                                child.innerHTML = "";
                            }
                        }
                        break;

                    // label
                    case TimelineHeader.MARKER_INDEX:
                        if (scene.hasLabel(currentFrame)) {
                            if (!child.classList.contains("frame-border-box-marker")) {
                                child.setAttribute("class", "frame-border-box-marker");
                            }
                        } else {
                            if (!child.classList.contains("frame-border-box")) {
                                child.setAttribute("class", "frame-border-box");
                            }
                        }
                        break;

                    // script
                    case TimelineHeader.ACTION_INDEX:
                        if (scene.hasAction(currentFrame)) {
                            if (!child.classList.contains("frame-border-box-action")) {
                                child.setAttribute("class", "frame-border-box-action");
                            }
                        } else {
                            if (!child.classList.contains("frame-border-box")) {
                                child.setAttribute("class", "frame-border-box");
                            }
                        }
                        break;

                    // sound
                    case TimelineHeader.SOUND_INDEX:
                        if (scene.hasSound(currentFrame)) {
                            if (!child.classList.contains("frame-border-box-sound")) {
                                child.setAttribute("class", "frame-border-box-sound");
                            }
                        } else {
                            if (!child.classList.contains("frame-border-box")) {
                                child.setAttribute("class", "frame-border-box");
                            }
                        }
                        break;

                    case 4:
                        if (currentFrame % 5 === 0) {
                            const value = `${currentFrame}`;
                            if (!child.innerHTML || child.innerHTML !== value) {
                                child.innerHTML = value;
                            }
                        } else {
                            if (child.innerHTML) {
                                child.innerHTML = "";
                            }
                        }
                        break;

                    default:
                        break;

                }
            }
        }
    }

    /**
     * @description ヘッダーelementを生成
     *
     * @param  {HTMLDivElement} parent
     * @param  {number} [frame=1]
     * @return {void}
     * @method
     * @public
     */
    createElement (parent, frame = 1)
    {
        const htmlTag = `
<div class="frame-header-parent" data-frame="${frame}">
    <div class="frame-sec ${frame % 5 === 0 ? "frame-border-end" : "frame-border"}" data-frame="${frame}"></div>
    <div class="frame-border-box" data-type="marker" data-frame="${frame}"></div>
    <div class="frame-border-box" data-type="action" data-frame="${frame}"></div>
    <div class="frame-border-box" data-type="sound" data-frame="${frame}"></div>
    <div class="frame-number" data-frame="${frame}">${frame % 5 === 0 ? frame : ""}</div>
</div>
`;
        parent.insertAdjacentHTML("beforeend", htmlTag);

        const element = parent.lastElementChild;
        element.addEventListener("mousedown", (event) =>
        {
            if (event.button) {
                return ;
            }

            Util.$endMenu();

            this.moveMarker(event);
        });

        // アイコンにdrag/dropイベントを登録
        for (let idx = 0; idx < 3; ++idx) {

            const child = element.children[1 + idx];
            if (!child) {
                continue;
            }

            child.addEventListener("mousedown", (event) =>
            {
                this.dragIcon(event);
            });

            child.addEventListener("dragover", (event) =>
            {
                event.preventDefault();
            });

            child.addEventListener("drop", (event) =>
            {
                this.dropIcon(event);
            });
        }
    }

    /**
     * @description クラスで利用する変数を初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clearParams ()
    {
        this._$targetElement = null;
    }

    /**
     * @description ラベル・スクリプト・サウンドのアイコンを移動開始関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    dragIcon (event)
    {
        const target = event.target;
        if (target.classList.contains("frame-border-box")) {
            return ;
        }

        // 全てのイベントを中止
        event.stopPropagation();

        // setup
        target.draggable     = true;
        this._$targetElement = target;
    }

    /**
     * @description 指定したアイコンを削除する
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     */
    deleteIcon (event)
    {
        if (Util.$keyLock) {
            return ;
        }

        if (event.key !== "Backspace") {
            return ;
        }

        if (!this._$targetElement) {
            return ;
        }

        this.save();

        const frame = this._$targetElement.dataset.frame | 0;
        const scene = Util.$currentWorkSpace().scene;
        const type  = this._$targetElement.dataset.type;
        switch (type) {

            case "marker":
                scene.deleteLabel(frame);
                break;

            case "action":
                scene.deleteAction(frame);
                break;

            case "sound":
                scene.deleteSound(frame);
                break;

            default:
                break;

        }

        // スタイルの変更して初期化
        this
            ._$targetElement
            .setAttribute("class", "frame-border-box");

        this._$targetElement = null;

        // 初期化
        super.focusOut();
    }

    /**
     * @description ラベル・スクリプト・サウンドのアイコンを移動処理関数
     *
     * @param  {DragEvent} event
     * @return {void}
     * @method
     * @public
     */
    dropIcon (event)
    {
        if (!this._$targetElement) {
            return ;
        }

        event.preventDefault();
        this._$targetElement.draggable = false;

        const target = event.target;

        const dragFrame = this._$targetElement.dataset.frame | 0;
        const dropFrame = target.dataset.frame | 0;

        // フレームが異なれば処理を行う
        if (dragFrame !== dropFrame) {

            this.save();

            const scene = Util.$currentWorkSpace().scene;
            const type  = this._$targetElement.dataset.type;

            // 表示を追加
            let targetElement = null;
            const parent = target.parentElement;
            switch (type) {

                case "marker":
                    targetElement = parent.children[1];
                    scene.setLabel(dropFrame, scene.getLabel(dragFrame));
                    break;

                case "action":
                    targetElement = parent.children[2];
                    scene.setAction(dropFrame, scene.getAction(dragFrame));
                    break;

                case "sound":
                    targetElement = parent.children[3];
                    scene.setSound(dropFrame, scene.getSound(dragFrame));
                    break;

                default:
                    break;

            }

            // 複製でない時は削除する
            if (!Util.$altKey) {
                this.deleteIcon({ "key": "Backspace" });
            }

            if (targetElement) {
                this._$targetElement = targetElement;
                targetElement
                    .setAttribute("class", `frame-border-box-${type}`);
            }
        }

        // 初期化
        super.focusOut();
    }

    /**
     * @description ヘッダーのフレーム枠をマウスダウンした時の処置
     *
     * @param  {Event} event
     * @return {void}
     * @public
     */
    moveMarker (event)
    {
        // 全てのイベント停止
        event.stopPropagation();

        // 変数を初期化
        this.clearParams();

        // フレームを更新
        Util.$timelineFrame.currentFrame = event.target.dataset.frame | 0;

        // マーカーを移動
        Util.$timelineMarker.move();

        // 移動先の音声設定を生成
        Util.$soundController.createSoundElements();

        // マーカーの移動を有効化
        Util.$timelineMarker.startMarker();

        // 再描画
        this.reloadScreen();
    }
}

Util.$timelineHeader = new TimelineHeader();

/**
 * @class
 * @memberOf view.timeline
 */
class TimelineHighlight
{
    /**
     * @description ランダムにカラーを返す
     *
     * @return {string}
     * @static
     */
    static get color ()
    {
        const colors = [
            "#ef857d",
            "#ffedab",
            "#a3d6cc",
            "#8d93c8",
            "#e3acae",
            "#ea5550",
            "#00947a",
            "#4d4398",
            "#915da3",
            "#ed6d35",
            "#bd6856",
            "#72640c",
            "#98605e",
            "#6c3524",
            "#f8f4e6",
            "#6a1917",
            "#7f1184",
            "#00afcc",
            "#e3e548",
            "#af0082",
            "#0073a8",
            "#e4007f"
        ];

        const index = Math.random() * colors.length | 0;
        return colors[index];
    }
}

/**
 * @class
 * @extends {KeyboardCommand}
 * @memberOf view.timeline
 */
class TimelineKeyboardCommand extends KeyboardCommand
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("timeline");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document
            .getElementById("timeline");

        if (element) {

            element.addEventListener("mouseleave", () =>
            {
                this.active = false;
            });

            element.addEventListener("mouseover", () =>
            {
                if (!this.active) {
                    this.active = true;
                }
            });

            element.addEventListener("mouseup", () =>
            {
                if (!this.active) {
                    this.active = true;
                }
            });
        }

        // レイヤー追加コマンド
        this.add(Util.$generateShortcutKey("+", { "ctrl": true }), () =>
        {
            Util.$timelineTool.executeTimelineLayerAdd();
        });
        this.add(Util.$generateShortcutKey(";", { "ctrl": true }), () =>
        {
            Util.$timelineTool.executeTimelineLayerAdd();
        });

        // レイヤの削除コマンド
        this.add(Util.$generateShortcutKey("Backspace", { "ctrl": true }), () =>
        {
            Util.$timelineTool.executeTimelineLayerTrash();
        });

        // フレームに設定されてるDisplayObjectを削除
        this.add("Backspace", () =>
        {
            Util.$timelineLayer.removeFrame();
        });

        // レイヤーの上下移動
        this.add("ArrowDown", this.selectLayer);
        this.add("ArrowUp", this.selectLayer);

        // タイムラインの左右移動
        this.add("ArrowLeft", this.moveFrame);
        this.add("ArrowRight", this.moveFrame);

        // フレーム追加コマンド
        this.add("f", () =>
        {
            Util.$timelineTool.executeTimelineFrameAdd();
        });
        this.add(Util.$generateShortcutKey("f", { "ctrl": true }), () =>
        {
            Util.$timelineTool.executeTimelineFrameDelete();
        });

        // キーフレーム追加コマンド
        this.add("k", () =>
        {
            Util.$timelineTool.executeTimelineKeyAdd();
        });
        this.add(Util.$generateShortcutKey("k", { "ctrl": true }), () =>
        {
            Util.$timelineTool.executeTimelineKeyDelete();
        });

        // ラベルへのフォーカス
        this.add("l", () =>
        {
            document.getElementById("label-name").focus();
        });

        // 空のキーフレームを追加
        this.add("e", () =>
        {
            Util.$timelineTool.executeTimelineEmptyAdd();
        });

        // JavaScriptのモーダルを起動
        this.add("s", () =>
        {
            Util.$javaScriptEditor.show();
        });

        // 選択肢たフレームのDisplayObjectのプロパティーに切り替え
        this.add("v", this.activePropertyTab);

        // ズームへのフォーカス
        this.add("z", () =>
        {
            document.getElementById("timeline-scale").focus();
        });

        // プレビュー機能のOn/Off
        this.add("p", Util.$timelineTool.executeTimelinePreview);

        // オニオンスキンを起動
        this.add("o", () => {
            Util
                .$timelineTool
                .executeTimelineOnionSkin();
        });

        // tweenを起動
        this.add("m", () =>
        {
            Util
                .$timelineMenu
                .executeContextMenuTweenAdd();
        });

        // tweenを削除
        this.add(Util.$generateShortcutKey("m", { "ctrl": true }), () =>
        {
            Util
                .$timelineMenu
                .executeContextMenuTweenDelete();
        });

        // レイヤの削除コマンド
        this.add(Util.$generateShortcutKey("h", { "shift": true }), () =>
        {
            Util
                .$timelineTool
                .executeTimelineLayerLightAll();
        });

        // レイヤー全てをロック
        this.add(Util.$generateShortcutKey("l", { "shift": true }), () =>
        {
            Util
                .$timelineTool
                .executeTimelineLayerLockAll();
        });

        // レイヤー全てを非表示に
        this.add(Util.$generateShortcutKey("d", { "shift": true }), () =>
        {
            Util
                .$timelineTool
                .executeTimelineLayerDisableAll();
        });

        // レイヤーをノーマルモードに
        this.add(Util.$generateShortcutKey("n", { "shift": true }), () =>
        {
            Util
                .$timelineLayerMenu
                .executeTimelineLayerNormal();
        });

        // レイヤーをマスクモードに
        this.add(Util.$generateShortcutKey("m", { "shift": true }), () =>
        {
            Util
                .$timelineLayerMenu
                .executeTimelineLayerMask();
        });

        // レイヤーをガイドモードに
        this.add(Util.$generateShortcutKey("g", { "shift": true }), () =>
        {
            Util
                .$timelineLayerMenu
                .executeTimelineLayerGuide();
        });

        // 選択中のDisplayObjectをコピー
        this.add(Util.$generateShortcutKey("c", { "ctrl": true }), () =>
        {
            Util.$screenMenu.copyDisplayObject();
            return false;
        });

        // コピーしたDisplayObjectをペースト
        this.add(Util.$generateShortcutKey("v", { "ctrl": true }), () =>
        {
            Util.$screenMenu.pasteDisplayObject();
            return false;
        });

        // コピーしたDisplayObjectをペースト
        this.add(Util.$generateShortcutKey("l", { "ctrl": true }), () =>
        {
            Util.$timelineMenu.executeContextMenuLayerCopy();
            Util.$timelineMenu.executeContextMenuLayerPaste();
        });

        // フレーム1に移動
        this.add(Util.$generateShortcutKey("ArrowLeft", { "ctrl": true }), () =>
        {
            Util.$timelineMenu.executeContextMenuFirstFrame();
        });

        // 最終フレームに移動
        this.add(Util.$generateShortcutKey("ArrowRight", { "ctrl": true }), () =>
        {
            Util.$timelineMenu.executeContextMenuLastFrame();
        });

        // キーフレームに変換
        this.add("F6", () =>
        {
            Util.$timelineMenu.executeContextMenuKeyFrameChange();
        });

        // 空のキーフレームに変換
        this.add("F7", () =>
        {
            Util.$timelineMenu.executeContextMenuKeyFrameChange();
        });
    }

    /**
     * @description 選択肢たフレームのDisplayObjectのプロパティーに切り替え
     *
     * @return {void}
     * @method
     * @public
     */
    activePropertyTab ()
    {
        // タブの切り替え
        document
            .getElementById("controller-tab-area")
            .children[0].click();
    }

    /**
     * @description 左右キーでフレームを移動
     *
     * @param  {string} code
     * @return {void}
     * @method
     * @public
     */
    moveFrame (code)
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const index = code
            ? code === "ArrowRight" ? 1 : -1
            : 0;

        const frame = Math.max(1, Util.$timelineFrame.currentFrame + index);

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();

        // フレーム移動前にラベルの情報を更新する
        Util.$timelineLayer.changeLabel(frame); // fixed logic

        // フレーム移動
        Util.$timelineLayer.moveFrame(frame);
        Util.$timelineLayer.activeLayer(targetLayer);
    }

    /**
     * @description 上下キーで選択レイヤーを操作
     *
     * @param  {string} code
     * @return {void}
     * @method
     * @public
     */
    selectLayer (code)
    {
        let element = null;

        const parent = document
            .getElementById("timeline-content");

        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {

            if (code === "ArrowDown") {

                // 一番上のレイヤーを選択
                element = parent.firstElementChild;
                Util.$timelineScroll.execute(
                    0,
                    -Util.$timelineScroll.y
                );

            } else {

                // 一番下のレイヤーを選択
                element = parent.lastElementChild;
                Util.$timelineScroll.execute(
                    0,
                    Util.$timelineLayer.clientHeight
                );

            }

        } else {

            if (code === "ArrowDown") {

                element = targetLayer.nextElementSibling;
                if (!element) {
                    return ;
                }

                if (element.offsetTop + element.offsetHeight
                    > window.innerHeight
                ) {
                    Util.$timelineScroll.execute(
                        0,
                        Util.$timelineTool.timelineHeight
                    );
                }

            } else {

                element = targetLayer.previousElementSibling;
                if (!element) {
                    return ;
                }

                if (parent.offsetTop > element.offsetTop) {
                    Util.$timelineScroll.execute(
                        0,
                        -Util.$timelineTool.timelineHeight
                    );
                }

            }

        }

        Util
            .$timelineLayer
            .activeLayer(element);
    }
}

Util.$timelineKeyboardCommand = new TimelineKeyboardCommand();

/**
 * @class
 * @extends {BaseTimeline}
 * @memberOf view.timeline
 */
class TimelineLayer extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {Map}
         * @private
         */
        this._$targetFrames = new Map();

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$activeKeyEvent = false;

        /**
         * @type {Map}
         * @private
         */
        this._$targetLayers = new Map();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$clientX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$clientY = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$clientHeight = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$scrollIndex = 0;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$moveLayerId = -1;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$clickTimerId = -1;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$selectLayerId = -1;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$destLayer = null;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$timerId = -1;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$exitLayer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$executeMoveLayer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$moveLayer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endInput = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$moveTargetGroup = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endTargetGroup = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$multiSelect = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endMultiSelect = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$clearClickParam = null;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$disableState = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$lightState = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$lockState = false;
    }

    /**
     * @description レイヤー表示枠の幅
     *
     * @member {number}
     * @public
     */
    get clientWidth ()
    {
        return this._$clientWidth;
    }
    set clientWidth (client_width)
    {
        this._$clientWidth = client_width | 0;
        Util.$timelineScroll.updateWidth();
    }

    /**
     * @description レイヤー表示枠の高さ
     *
     * @member {number}
     * @public
     */
    get clientHeight ()
    {
        return this._$clientHeight;
    }
    set clientHeight (client_height)
    {
        this._$clientHeight = client_height | 0;
        Util.$timelineScroll.updateHeight();
    }

    /**
     * @description 選択中の全てのフレームElementを返す
     *
     * @return {Map}
     * @public
     */
    get targetFrames ()
    {
        return this._$targetFrames;
    }

    /**
     * @description 選択中のフレームElementを返す
     *
     * @return {HTMLDivElement|null}
     * @public
     */
    get targetFrame ()
    {
        return this.targetFrames.size
            ? this.targetFrames.values().next().value[0]
            : null;
    }

    /**
     * @description 選択中の全てのレイヤーElementを返す
     *
     * @return {Map}
     * @public
     */
    get targetLayers ()
    {
        return this._$targetLayers;
    }

    /**
     * @description 選択中のレイヤーElementを返す
     *
     * @return {HTMLDivElement|null}
     * @public
     */
    get targetLayer ()
    {
        return this.targetLayers.size
            ? this.targetLayers.values().next().value
            : null;
    }

    /**
     * @description 選択したレイヤーのElementをセット
     *
     * @param  {HTMLDivElement} layer
     * @return {void}
     * @public
     */
    set targetLayer (layer)
    {
        switch (true) {

            case Util.$ctrlKey:
                if (layer) {
                    if (this.targetLayers.has(layer.id)) {

                        // アクティブな時は非アクティブにして選択リストから削除
                        layer
                            .classList
                            .remove("active");

                        this.targetLayers.delete(layer.id);
                    } else {

                        // アクティブ表示
                        layer
                            .classList
                            .add("active");

                        this.targetLayers.set(layer.id, layer);
                    }

                }
                break;

            case Util.$shiftKey:
                if (layer) {
                    const baseLayer = this.targetLayer;
                    if (!baseLayer || baseLayer.id === layer.id) {
                        return ;
                    }

                    this.clearActiveLayers();
                    this.clearActiveFrames();

                    const children = Array.from(
                        document.getElementById("timeline-content").children
                    );

                    const baseIndex   = children.indexOf(baseLayer);
                    const targetIndex = children.indexOf(layer);

                    const min = Math.min(baseIndex, targetIndex);
                    const max = Math.max(baseIndex, targetIndex);

                    this.targetLayers.set(
                        baseLayer.id,
                        baseLayer
                    );

                    for (let idx = min; idx <= max; ++idx) {

                        const targetLayer = children[idx];

                        // アクティブな時は非アクティブにして選択リストから削除
                        targetLayer
                            .classList
                            .add("active");

                        if (this.targetLayers.has(targetLayer.id)) {
                            continue;
                        }

                        this.targetLayers.set(targetLayer.id, targetLayer);

                    }
                }
                break;

            default:
                // 選択中の全てのElementを非アクティブに
                this.clearActiveLayers();
                this.clearActiveFrames();

                if (layer) {

                    // アクティブ表示
                    layer
                        .classList
                        .add("active");

                    this.targetLayers.set(layer.id, layer);
                }

                break;

        }
    }

    /**
     * @description 指定したレイヤーのフレームElementをアクティブ化
     *
     * @param  {Layer} layer
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    addTargetFrame (layer, frame)
    {

        if (!this.targetFrames.has(layer.id)) {
            this.targetFrames.set(layer.id, []);
        }

        const frames = this.targetFrames.get(layer.id);

        frames.push(frame);

        // アクティブ表示
        const element = layer.getChildren(frame);
        if (element) {
            element
                .classList
                .add("frame-active");
        }
    }

    /**
     * @description レイヤーコントローラーの表示アイコンのパラメーターを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clearClickParam ()
    {
        window.removeEventListener("mouseup", this._$clearClickParam);

        this._$disableState = false;
        this._$lightState   = false;
        this._$lockState    = false;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const timeline = document
            .getElementById("timeline");

        if (timeline) {
            timeline.addEventListener("mouseover", () =>
            {
                Util.$setCursor("auto");
            });
        }

        const element = document
            .getElementById("timeline-content");

        if (element) {
            element.addEventListener("wheel", (event) =>
            {
                const deltaY = event.deltaY | 0;
                if (!deltaY) {
                    return false;
                }

                event.stopPropagation();
                event.preventDefault();

                if (!Util.$altKey) {

                    window.requestAnimationFrame(() =>
                    {
                        Util.$timelineScroll.execute(0, deltaY);
                    });

                } else {

                    window.requestAnimationFrame(() =>
                    {
                        Util.$timelineTool.timelineWidth = Util.$clamp(
                            Util.$timelineTool.timelineWidth + deltaY,
                            5,
                            240
                        );
                    });

                }
            }, { "passive" : false });
        }

        // フレーム移動のElementを非表示
        this.hideTargetGroup();
    }

    /**
     * @description 現在の表示領域の高さでタイムラインを再構成
     *
     * @return {void}
     * @method
     * @public
     */
    updateClientSize ()
    {
        const element = document
            .getElementById("timeline-content");

        // 表示枠の高さを更新
        if (element) {

            const controllerWidth = window.innerWidth - (document
                .documentElement
                .style
                .getPropertyValue("--controller-width")
                .split("px")[0] | 0) - 338;

            // 変化があれば更新
            if (this.clientWidth !== controllerWidth) {
                this.clientWidth = controllerWidth;
                Util.$timelineScroll.updateWidth();
            }

            if (this.clientHeight !== element.clientHeight) {
                this.clientHeight = element.clientHeight;
                Util.$timelineScroll.updateHeight();
            }
        }
    }

    /**
     * @description レイヤーのy軸のポジションの値を更新
     *
     * @param {number} [delta_y = 0]
     * @method
     * @public
     */
    updateScrollY (delta_y = 0)
    {
        const workSpace = Util.$currentWorkSpace();
        if (!workSpace) {
            return ;
        }

        const scene = workSpace.scene;
        if (!scene) {
            return ;
        }

        const maxHeight = scene._$layers.size * Util.$timelineTool.timelineHeight;

        const before = this.scrollY;
        if (this.clientHeight > maxHeight) {

            this.scrollY = 0;

        } else {

            // 移動範囲があれば実行
            const stopCount = this.clientHeight / Util.$timelineTool.timelineHeight | 0;
            this.scrollY = Math.max(0, Math.min(
                this.scrollY + delta_y,
                (scene._$layers.size - stopCount) * Util.$timelineTool.timelineHeight
            ));

        }

        // 変化があれば再描画
        if (before !== this.scrollY) {
            this.moveTimeLine();
        }
    }

    /**
     * @description タイムラインで選択したレイヤに設置されたDisplayObjectをアクティブ化する
     *
     * @return {void}
     * @method
     * @public
     */
    activeCharacter ()
    {
        if (!this.targetLayers.size) {
            return ;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        // 選択中のDisplayObjectを初期化
        tool.clearActiveElement();

        Util
            .$transformController
            .hide();

        Util
            .$gridController
            .hide();

        const frame = Util.$timelineFrame.currentFrame;
        const scene = Util.$currentWorkSpace().scene;

        // 複数選択ようにshiftキーをonにする
        const cacheValue = Util.$shiftKey;
        Util.$shiftKey   = true;

        // アクティブ判定
        for (const layerId of this.targetFrames.keys()) {

            const layer = scene.getLayer(layerId);
            const characters = layer.getActiveCharacter(frame);
            for (let idx = 0; idx < characters.length; ++idx) {

                const character = characters[idx];

                const characterElement = document
                    .getElementById(`character-${character.id}`);

                if (!characterElement) {
                    continue;
                }

                tool.addElement(characterElement, true);
            }
        }

        // shiftキーを元の値に戻す
        Util.$shiftKey = cacheValue;

        // コントローラーエリアを初期化
        Util.$controller.default();
        if (tool.activeElements.length) {

            // コントローラーエリアの表示を更新
            tool.updateControllerProperty();

            // 拡大縮小回転のElementのポイントを表示して再計算
            Util
                .$transformController
                .show()
                .relocation();

            // 9sliceのElementのポイントを表示して再計算
            Util
                .$gridController
                .show()
                .relocation();

        } else {

            Util
                .$tweenController
                .clearPointer();

        }

    }

    /**
     * @description タイムラインの全てのアクティブElementを非アクティブ化
     *              外部クラスからコールされる想定
     *
     * @return {void}
     * @method
     * @public
     */
    clear ()
    {
        this.clearActiveLayers();
        this.clearActiveFrames();
    }

    /**
     * @description タイムラインの全てのElementを削除
     *
     * @return {void}
     * @method
     * @public
     */
    removeAll ()
    {
        const element = document.getElementById("timeline-content");
        if (!element) {
            return ;
        }

        while (element.firstChild) {
            element.firstChild.remove();
        }
    }

    /**
     * @description タイムラインにレイヤーを追加する
     *
     * @param  {number} layer_id
     * @return {void}
     * @method
     * @public
     */
    create (layer_id)
    {
        const workSpace = Util.$currentWorkSpace();
        if (!workSpace) {
            return ;
        }

        const element = document
            .getElementById("timeline-content");

        if (!element) {
            return ;
        }

        let parent = document
            .getElementById(`frame-scroll-id-${layer_id}`);

        // イベント登録は初回だけ
        if (!parent) {

            element.insertAdjacentHTML("beforeend", `
<div class="timeline-content-child" id="layer-id-${layer_id}" data-layer-id="${layer_id}">

    <div class="timeline-layer-controller">
        <i class="timeline-exit-icon" id="timeline-exit-icon-${layer_id}" data-layer-id="${layer_id}"></i>
        <i class="timeline-exit-in-icon" id="timeline-exit-in-icon-${layer_id}" data-layer-id="${layer_id}"></i>
        <i class="timeline-layer-icon" id="layer-icon-${layer_id}" data-layer-id="${layer_id}" data-detail="{{レイヤー変更(ダブルクリック)}}"></i>
        <i class="timeline-mask-icon" id="layer-mask-icon-${layer_id}" data-layer-id="${layer_id}" data-detail="{{レイヤー変更(ダブルクリック)}}"></i>
        <i class="timeline-mask-in-icon" id="layer-mask-in-icon-${layer_id}" data-layer-id="${layer_id}"></i>
        <i class="timeline-guide-icon" id="layer-guide-icon-${layer_id}" data-layer-id="${layer_id}" data-detail="{{レイヤー変更(ダブルクリック)}}"></i>
        <i class="timeline-guide-in-icon" id="layer-guide-in-icon-${layer_id}" data-layer-id="${layer_id}" data-detail="{{レイヤー変更(ダブルクリック)}}"></i>
        <div class="view-text" id="layer-name-${layer_id}" data-layer-id="${layer_id}">layer_${layer_id}</div>
        <input type="text" class="view-text-input" id="layer-name-input-${layer_id}" data-layer-id="${layer_id}" value="layer_${layer_id}" style="display: none;">
        <i class="timeline-layer-light-one icon-disable" id="layer-light-icon-${layer_id}" data-click-type="light" data-layer-id="${layer_id}" data-detail="{{レイヤーをハイライト}}"></i>
        <i class="timeline-layer-disable-one icon-disable" id="layer-disable-icon-${layer_id}" data-click-type="disable" data-layer-id="${layer_id}" data-detail="{{レイヤーを非表示}}"></i>
        <i class="timeline-layer-lock-one icon-disable" id="layer-lock-icon-${layer_id}" data-click-type="lock" data-layer-id="${layer_id}" data-detail="{{レイヤーをロック}}"></i>
    </div>

    <div class="timeline-frame-controller" id="frame-scroll-id-${layer_id}"></div>
</div>
`);

            // レイヤー名の変更イベントを登録
            document
                .getElementById(`layer-name-${layer_id}`)
                .addEventListener("dblclick", (event) =>
                {
                    this.showInput(event);
                });

            // レイヤー切り替えイベントを登録
            document
                .getElementById(`layer-icon-${layer_id}`)
                .addEventListener("dblclick", (event) =>
                {
                    this.showLayerMenu(event);
                });

            // ガイドアイコン
            const guideIcon = document
                .getElementById(`layer-guide-icon-${layer_id}`);

            guideIcon.addEventListener("dblclick", (event) =>
            {
                this.showLayerMenu(event);
            });
            guideIcon.addEventListener("mouseover", (event) =>
            {
                this.exitLayer(event);
            });
            guideIcon.addEventListener("mouseout", (event) =>
            {
                this.endExitLayer(event);
            });

            // マスクアイコン
            const maskIcon = document
                .getElementById(`layer-mask-icon-${layer_id}`);

            maskIcon.addEventListener("dblclick", (event) =>
            {
                this.showLayerMenu(event);
            });
            maskIcon.addEventListener("mouseover", (event) =>
            {
                this.exitLayer(event);
            });
            maskIcon.addEventListener("mouseout", (event) =>
            {
                this.endExitLayer(event);
            });

            // グループから外すexitアイコン
            const exitIcon = document
                .getElementById(`timeline-exit-icon-${layer_id}`);

            exitIcon.addEventListener("mouseover", (event) =>
            {
                this.exitLayer(event);
            });
            exitIcon.addEventListener("mouseout", (event) =>
            {
                this.endExitLayer(event);
            });

            const exitInIcon = document
                .getElementById(`timeline-exit-in-icon-${layer_id}`);

            exitInIcon.addEventListener("mouseover", (event) =>
            {
                this.exitLayer(event);
            });
            exitInIcon.addEventListener("mouseout", (event) =>
            {
                this.endExitLayer(event);
            });

            // レイヤーの説明モーダルを登録
            const layer = document.getElementById(`layer-id-${layer_id}`);
            Util.$addModalEvent(layer);

            // レイヤー全体のイベント
            layer.addEventListener("mousedown", (event) =>
            {
                this.selectLayer(event);
            });

            const layerController = layer
                .getElementsByClassName("timeline-layer-controller")[0];

            // レイヤーのコントロール部分へ、レイヤー移動イベントを登録する
            layerController.addEventListener("mouseover", (event) =>
            {
                this.activeMoveLayer(event);
            });
            layerController.addEventListener("mouseout", (event) =>
            {
                this.inactiveMoveLayer(event);
            });
            layerController.addEventListener("contextmenu", (event) =>
            {
                this.showLayerMenu(event);
            });

            // レイヤーの横移動イベント
            const frameController = layer
                .getElementsByClassName("timeline-frame-controller")[0];

            frameController.addEventListener("wheel", (event) =>
            {
                let deltaY = event.deltaY | 0;
                let deltaX = event.deltaX | 0;

                // shift押下時は強制的に横スクールに切り替える
                if (Util.$shiftKey) {
                    deltaX = event.deltaY | 0;
                    deltaY = 0;
                }

                if (!deltaX || deltaY > 0) {
                    return false;
                }

                // 全てのイベントを停止
                event.stopPropagation();
                event.preventDefault();

                const scrollX = Util.$timelineHeader.scrollX;

                // 1フレーム目より以前には移動しない
                if (!scrollX && 0 > deltaX) {
                    return false;
                }

                window.requestAnimationFrame(() =>
                {
                    Util.$timelineHeader.scrollX = Util.$clamp(
                        scrollX + deltaX, 0, Number.MAX_VALUE
                    );

                    // ヘッダーを再構築
                    Util.$timelineHeader.rebuild();

                    // マーカーを移動
                    Util.$timelineMarker.move();

                    // レイヤーのタイムラインを再描画
                    this.moveTimeLine();
                });

            }, { "passive" : false });

            // タイムラインプレビュー機能
            frameController.addEventListener("mouseover", (event) =>
            {
                this.showLayerPreview(event);
            });
            frameController.addEventListener("mouseout", () =>
            {
                this.hideLayerPreview();
            });

            frameController.addEventListener("mousedown", (event) =>
            {
                this.selectFrame(event);
            });

            frameController.addEventListener("dblclick", (event) =>
            {
                this.selectRange(event);
            });

            // ハイライトアイコン
            const lightIcon = document
                .getElementById(`layer-light-icon-${layer_id}`);

            lightIcon.addEventListener("mousedown", (event) =>
            {
                this.clickLight(event);
            });
            lightIcon.addEventListener("mouseover", (event) =>
            {
                if (this._$lightState) {
                    this.clickLight(event);
                }
            });

            // 表示・非表示アイコン
            const disableIcon = document
                .getElementById(`layer-disable-icon-${layer_id}`);

            disableIcon.addEventListener("mousedown", (event) =>
            {
                this.clickDisable(event);
            });
            disableIcon.addEventListener("mouseover", (event) =>
            {
                if (this._$disableState) {
                    this.clickDisable(event);
                }
            });

            // ロックアイコン
            const lockIcon = document
                .getElementById(`layer-lock-icon-${layer_id}`);

            lockIcon.addEventListener("mousedown", (event) =>
            {
                this.clickLock(event);
            });
            lockIcon.addEventListener("mouseover", (event) =>
            {
                if (this._$lockState) {
                    this.clickLock(event);
                }
            });

            // スクロールエリア
            const frameElement = document
                .getElementById(`frame-scroll-id-${layer_id}`);

            frameElement.addEventListener("contextmenu", (event) =>
            {
                Util.$timelineMenu.show(event);
            });
        }

        this.rebuild(layer_id);
    }

    /**
     * @description 現在の画面サイズに合わせてヘッダーのDOMを再構成
     *
     * @return {void}
     * @method
     * @public
     */
    rebuild (layer_id)
    {
        const element = document
            .getElementById(`frame-scroll-id-${layer_id}`);

        if (!element) {
            return ;
        }

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layer_id);

        if (!layer) {
            return ;
        }

        const timelineWidth = Util.$timelineTool.timelineWidth;
        const elementCount  = Util.$timelineHeader.width / (timelineWidth + 1) | 0;

        // elementが空なら初期処理を実行
        if (!element.children.length) {

            for (let idx = 0; elementCount >= idx; ++idx) {
                this.createElement(element, layer_id, idx + 1);
            }
            // 初期化
            layer._$children = [];
        }

        // 画面幅以上にelement数があれば削除
        if (element.children.length > elementCount + 1) {

            const index = elementCount + 1;
            while (element.children.length > index) {
                element.children[index].remove();
            }

            // 初期化
            layer._$children = [];
        }

        // 画面幅のelement数が多ければ再登録
        if (elementCount > element.children.length) {

            let frame = element
                .lastElementChild
                .dataset
                .frame | 0;

            const length = elementCount - element.children.length;
            for (let idx = 0; length >= idx; ++idx) {
                this.createElement(element, layer_id, ++frame);
            }

            // 初期化
            layer._$children = [];
        }

        if (!layer._$children.length) {
            layer._$children = Array.from(element.children);
        }

        let frame = Util.$timelineHeader.leftFrame;
        for (let idx = 0; layer._$children.length > idx; ++idx) {

            const currentFrame = frame + idx;

            const node = layer._$children[idx];
            node.setAttribute("data-frame", `${currentFrame}`);
            node.setAttribute("data-frame-state", "empty");
            node.setAttribute("class", currentFrame % 5 !== 0
                ? "frame"
                : "frame frame-pointer"
            );
        }

        // 再配置
        layer.reloadStyle();
    }

    /**
     * @description レイヤーのelementを生成
     *
     * @param  {HTMLDivElement} parent
     * @param  {number} layer_id
     * @param  {number} [frame=1]
     * @return {void}
     * @method
     * @public
     */
    createElement (parent, layer_id, frame = 1)
    {
        parent
            .insertAdjacentHTML("beforeend", `<div class="${frame % 5 !== 0 ? "frame" : "frame frame-pointer"}" data-frame-state="empty" data-layer-id="${layer_id}" data-frame="${frame}"></div>`);
    }

    /**
     * @description 指定しているフレームのDisplayObjectを削除
     *
     * @return {void}
     * @method
     * @public
     */
    removeFrame ()
    {
        const targetLayer = this.targetLayer;
        if (!targetLayer) {
            return ;
        }

        this.save();

        let reload = false;
        const frame = Util.$timelineFrame.currentFrame;
        const scene = Util.$currentWorkSpace().scene;
        const targetFrames = this.targetFrames;
        for (const layerId of targetFrames.keys()) {

            const layer = scene.getLayer(layerId);

            const characters = layer.getActiveCharacter(frame);
            if (!characters.length) {
                continue;
            }

            reload = true;
            let range = null;
            for (let idx = 0; idx < characters.length; ++idx) {

                const character = characters[idx];

                if (!range) {
                    range = character.getRange(frame);
                }

                character.remove(layer);
            }

            layer.addEmptyCharacter(
                new EmptyCharacter({
                    "startFrame": range.startFrame,
                    "endFrame": range.endFrame
                })
            );

            layer.reloadStyle();
        }

        // 選択中にフレームを解放
        this.clearActiveFrames();

        // スクリーンのDisplayObjectをアクティブ化
        this.activeCharacter();

        if (reload) {
            this.reloadScreen();
        }

        // 初期化
        super.focusOut();
    }

    /**
     * @description レイヤー指定がない場合は一番上のレイヤーを強制的に選択
     *              レイヤーが0の時はレイヤーを強制的に追加する
     *
     * @return {void}
     * @method
     * @public
     */
    attachLayer ()
    {
        if (!this.targetLayer) {

            const scene = Util
                .$currentWorkSpace()
                .scene;

            let targetLayer = document
                .getElementById("timeline-content")
                .children[0];

            // レイヤーがない時は強制的に追加
            if (!targetLayer) {

                scene.addLayer();

                targetLayer = document
                    .getElementById("timeline-content")
                    .children[0];
            }

            const shift = Util.$shiftKey;
            const ctrl  = Util.$ctrlKey;

            Util.$shiftKey = false;
            Util.$ctrlKey  = false;

            // セット
            this.targetLayer = targetLayer;

            // マーカーのあるフレームを選択
            const layer = scene.getLayer(
                targetLayer.dataset.layerId | 0
            );

            this.addTargetFrame(
                layer, Util.$timelineFrame.currentFrame
            );

            Util.$shiftKey = shift;
            Util.$ctrlKey  = ctrl;
        }
    }

    /**
     * @description マスクやガイドなどのグルーピングされたレイヤーを抜ける処理
     *
     * @return {void}
     * @method
     * @public
     */
    exitLayer (event)
    {
        if (this._$moveLayerId === -1) {
            return ;
        }

        const layerId = event.target.dataset.layerId | 0;

        let element = document
            .getElementById(`layer-id-${layerId}`);

        const children = Array.from(
            document.getElementById("timeline-content").children
        );

        const scene = Util.$currentWorkSpace().scene;
        const index = children.indexOf(element);
        const node  = children[index + 1];
        if (node) {
            const layer = scene
                .getLayer(node.dataset.layerId | 0);

            switch (layer.mode) {

                // 最終行じゃない時は何もしない
                case LayerMode.MASK_IN:
                case LayerMode.GUIDE_IN:
                    return ;

                default:
                    break;

            }
        }

        // 最終行の場合はフラグをOnにする
        this._$exitLayer = element;

        document
            .getElementById(`timeline-exit-icon-${layerId}`)
            .style.opacity = "1";
        document
            .getElementById(`timeline-exit-in-icon-${layerId}`)
            .style.opacity = "1";
    }

    /**
     * @description グルーピングされたレイヤーを抜ける処理を解除
     *
     * @return {void}
     * @method
     * @public
     */
    endExitLayer (event)
    {
        if (this._$moveLayerId === -1) {
            return ;
        }

        this._$exitLayer = null;

        const layerId = event.target.dataset.layerId | 0;
        document
            .getElementById(`timeline-exit-icon-${layerId}`)
            .style.opacity = "0";
        document
            .getElementById(`timeline-exit-in-icon-${layerId}`)
            .style.opacity = "0";
    }

    /**
     * @description タイムラインのハイライトのOn/Off
     *
     * @return {void}
     * @method
     * @public
     */
    clickLight (event)
    {
        if (event.button) {
            return ;
        }

        Util.$endMenu();

        event.stopPropagation();

        this._$lightState = true;
        if (!this._$clearClickParam) {
            this._$clearClickParam = this.clearClickParam.bind(this);
        }
        window.addEventListener("mouseup", this._$clearClickParam);

        this.changeType(event.target, "light");
    }

    /**
     * @description タイムラインのロックのOn/Off
     *
     * @return {void}
     * @method
     * @public
     */
    clickLock (event)
    {
        if (event.button) {
            return ;
        }

        Util.$endMenu();

        event.stopPropagation();

        this._$lockState = true;
        if (!this._$clearClickParam) {
            this._$clearClickParam = this.clearClickParam.bind(this);
        }
        window.addEventListener("mouseup", this._$clearClickParam);

        this.changeType(event.target, "lock");
        Util
            .$transformController
            .show()
            .relocation();
    }

    /**
     * @description タイムラインの表示・非表示のOn/Off
     *
     * @return {void}
     * @method
     * @public
     */
    clickDisable (event)
    {
        if (event.button) {
            return ;
        }

        Util.$endMenu();

        event.stopPropagation();

        this._$disableState = true;
        if (!this._$clearClickParam) {
            this._$clearClickParam = this.clearClickParam.bind(this);
        }
        window.addEventListener("mouseup", this._$clearClickParam);

        this.changeType(event.target, "disable");

        // スクリーンエリアの変形Elementを表示
        Util
            .$transformController
            .show();

        // Shapeのポインターを初期化
        Util.$clearShapePointer();

        // 再描画
        this.reloadScreen();
    }

    /**
     * @description タイムラインのアイコン押下処理
     *
     * @param  {HTMLDivElement} element
     * @param  {string} type
     * @return {void}
     * @method
     * @public
     */
    changeType (element, type)
    {
        const layerId = element.dataset.layerId | 0;

        const layerElement = document
            .getElementById(`layer-id-${layerId}`);

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layerId);

        layer[type] = !layer[type];
        if (layer[type]) {

            element
                .classList
                .remove("icon-disable");

            if (type === "light") {

                element
                    .classList
                    .add("light-icon-active");

                layerElement
                    .style
                    .borderBottom = `1px solid ${layer.color}`;

            } else {

                element
                    .classList
                    .add("icon-active");

                layerElement
                    .classList
                    .add(`${type}-active`);

            }

        } else {

            element
                .classList
                .add("icon-disable");

            if (type === "light") {

                element
                    .classList
                    .remove("light-icon-active");

                layerElement.style.borderBottom = "";

            } else {

                element
                    .classList
                    .remove("icon-active");

                layerElement
                    .classList
                    .remove(`${type}-active`);

            }

        }

        if (type === "lock") {
            this.reloadScreen();
        }
    }

    /**
     * @description レイヤー変更メニューモーダルを表示
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    showLayerMenu (event)
    {
        // 他のイベント全て中止
        event.preventDefault();
        event.stopPropagation();

        const layerId = event.target.dataset.layerId | 0;

        // 選択してないレイヤーメニュー上の場合は再選択
        const targetLayers = Util.$timelineLayer.targetLayers;
        if (!targetLayers.has(`layer-id-${layerId}`)) {
            this.targetLayer = document
                .getElementById(`layer-id-${layerId}`);

        }

        Util.$timelineLayerMenu.show(event);
    }

    /**
     * @description InputElementを表示
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    showInput (event)
    {
        // 他のイベント全て中止
        event.stopPropagation();

        Util.$keyLock = true;

        const layerId = event.target.dataset.layerId | 0;

        const input = document
            .getElementById(`layer-name-input-${layerId}`);

        // Input Elementに値をセットして表示
        input.value = event.target.textContent;
        input.style.display = "";
        input.focus();

        // 表示Elementは非表示
        event.target.style.display = "none";

        // 関数がなければ変数にセット
        if (!this._$endInput) {
            this._$endInput = this.endInput.bind(this);
        }

        // 入力終了イベントを登録
        input.addEventListener("focusout", this._$endInput);
        input.addEventListener("keypress", this._$endInput);
    }

    /**
     * @description 入力終了処理
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    endInput (event)
    {
        if (event.key === "Enter") {
            event.target.blur();
            return ;
        }

        if (event.type !== "focusout") {
            return ;
        }

        // undo用に保存
        this.save();

        // 他のイベント全て中止
        event.stopPropagation();

        const input = event.target;
        const layerId = input.dataset.layerId | 0;

        // レイヤーデータを更新
        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layerId);

        layer.name = input.value;

        // 表示用のElementを表示
        const viewElement = document
            .getElementById(`layer-name-${layerId}`);
        viewElement.textContent   = input.value;
        viewElement.style.display = "";

        // Input Elementを非表示にしてイベントを削除
        input.style.display = "none";
        input.removeEventListener("focusout", this._$endInput);
        input.removeEventListener("keypress", this._$endInput);

        // 初期化
        super.focusOut();
    }

    /**
     * @description レイヤーの移動処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveLayer (event)
    {
        Util.$setCursor("grabbing");

        window.requestAnimationFrame(() =>
        {
            const parent = document
                .getElementById("timeline-content");

            if (event.pageY + 20 > window.innerHeight) {
                parent.scrollTop += event.pageY + 20 - window.innerHeight;
            }

            if (parent.scrollTop > 0 && parent.offsetTop > event.pageY - 8) {
                parent.scrollTop +=  event.pageY - parent.offsetTop - 8;
            }

        });
    }

    /**
     * @description レイヤーの移動を終了する
     *
     * @return {void}
     * @method
     * @public
     */
    executeMoveLayer ()
    {
        window.removeEventListener("mousemove", this._$moveLayer);
        window.removeEventListener("mouseup", this._$executeMoveLayer);

        let exitLayer = null;
        const scene = Util.$currentWorkSpace().scene;
        if (this._$exitLayer) {

            exitLayer = scene.getLayer(
                this._$exitLayer.dataset.layerId | 0
            );

            // valid
            switch (exitLayer.mode) {

                case LayerMode.MASK_IN:
                    // 選択中のレイヤーに親のマスクがあったら初期化して中止
                    for (const layer of this.targetLayers.values()) {
                        if (layer.id !== exitLayer.maskId) {
                            continue;
                        }

                        // 初期化して処理を中止
                        this._$moveLayerId = -1;
                        this._$destLayer   = null;
                        this._$exitLayer   = null;
                        Util.$setCursor("auto");
                        return ;
                    }
                    break;

                case LayerMode.GUIDE_IN:
                    // 選択中のレイヤーに親のガイドがあったら初期化して中止
                    for (const layer of this.targetLayers.values()) {
                        if (layer.id !== exitLayer.guideId) {
                            continue;
                        }

                        // 初期化して処理を中止
                        this._$moveLayerId = -1;
                        this._$destLayer   = null;
                        this._$exitLayer   = null;
                        Util.$setCursor("auto");
                        return ;
                    }
                    break;

                default:
                    break;

            }

            document
                .getElementById(`timeline-exit-icon-${exitLayer.id}`)
                .style.opacity = "0";
            document
                .getElementById(`timeline-exit-in-icon-${exitLayer.id}`)
                .style.opacity = "0";

            this._$destLayer = this._$exitLayer;
        }

        if (this._$destLayer) {

            // 非アクティブへ
            this._$destLayer.classList.remove("move-target");

            // 移動先
            const destLayer = scene.getLayer(
                this._$destLayer.dataset.layerId | 0
            );

            /**
             * 移動先がマスクかマスク対象かガイドかガイド対象レイヤーで
             * 移動対象にマスクレイヤーが含まれる場合
             * もしくは、ガイドレイヤーが含まれる場合は処理を中止する
             */
            if (exitLayer === null) {
                switch (destLayer.mode) {

                    case LayerMode.MASK:
                    case LayerMode.MASK_IN:
                    case LayerMode.GUIDE:
                    case LayerMode.GUIDE_IN:
                        for (const layer of this.targetLayers.values()) {

                            const moveLayer = scene.getLayer(
                                layer.dataset.layerId | 0
                            );

                            switch (moveLayer.mode) {

                                case LayerMode.MASK:
                                case LayerMode.GUIDE:

                                    // 初期化して処理を中止
                                    this._$moveLayerId = -1;
                                    this._$destLayer   = null;
                                    this._$exitLayer   = null;
                                    Util.$setCursor("auto");
                                    return ;

                                default:
                                    break;

                            }

                        }
                        break;

                    default:
                        break;

                }
            }

            // 移動前の状態を保存
            this.save();

            // 親Element
            const element = document
                .getElementById("timeline-content");

            // 複数レイヤーの時は降順に並び替え
            const selectLayers = Array.from(this.targetLayers.values());
            if (selectLayers.length > 1) {

                // マスク対象かガイド対象が含まれているかチェック
                // 含まれている場合で、親Elementが含まれている場合は移動の対象外にする
                for (let idx = 0; idx < selectLayers.length; ++idx) {

                    const layerElement = selectLayers[idx];
                    const layer = scene.getLayer(
                        layerElement.dataset.layerId | 0
                    );

                    switch (layer.mode) {

                        case LayerMode.MASK_IN:
                            {
                                // 親Element
                                const element = document
                                    .getElementById(`layer-id-${layer.maskId}`);

                                const index = selectLayers.indexOf(element);
                                if (index > -1) {
                                    selectLayers.splice(idx, 1);
                                    --idx;
                                }
                            }
                            break;

                        case LayerMode.GUIDE_IN:
                            {
                                // 親Element
                                const element = document
                                    .getElementById(`layer-id-${layer.guideId}`);

                                const index = selectLayers.indexOf(element);
                                if (index > -1) {
                                    selectLayers.splice(idx, 1);
                                    --idx;
                                }
                            }
                            break;

                        default:
                            break;

                    }

                }

                // 降順に並び替え
                const children = Array.from(element.children);
                selectLayers.sort((a, b) =>
                {
                    const aIndex = children.indexOf(a);
                    const bIndex = children.indexOf(b);

                    switch (true) {

                        case aIndex > bIndex:
                            return -1;

                        case aIndex < bIndex:
                            return 1;

                        default:
                            return 0;

                    }
                });
            }

            // 移動開始
            const relationLayers = [];
            for (let idx = 0; idx < selectLayers.length; ++idx) {

                const layer = selectLayers[idx];

                const moveLayer = scene.getLayer(
                    layer.dataset.layerId | 0
                );

                switch (destLayer.mode) {

                    case LayerMode.MASK:
                    case LayerMode.MASK_IN:

                        if (!exitLayer) {

                            // 移動先がマスクか、マスクの対象の時は
                            // マスクIDを紐付けて、アイコンを変更
                            moveLayer.maskId = destLayer.maskId === null
                                ? destLayer.id
                                : destLayer.maskId;

                            moveLayer.mode = LayerMode.MASK_IN;
                            moveLayer.showIcon();

                        } else {

                            if (exitLayer.maskId !== null
                                && exitLayer.maskId === moveLayer.maskId
                            ) {
                                // マスク外に移動するので通常レイヤーに更新
                                moveLayer.maskId = null;
                                moveLayer.mode   = LayerMode.NORMAL;
                                moveLayer.showIcon();
                            }

                        }
                        break;

                    // 移動先がガイドか、ガイドの対象の時
                    case LayerMode.GUIDE:
                    case LayerMode.GUIDE_IN:

                        if (!exitLayer) {

                            // 移動先がガイドか、ガイドの対象の時は
                            // ガイドIDを紐付けて、アイコンを変更
                            moveLayer.guideId = destLayer.guideId === null
                                ? destLayer.id
                                : destLayer.guideId;

                            moveLayer.mode = LayerMode.GUIDE_IN;
                            moveLayer.showIcon();

                        } else {

                            if (exitLayer.guideId !== null
                                && exitLayer.guideId === moveLayer.guideId
                            ) {
                                // マスク外に移動するので通常レイヤーに更新
                                moveLayer.guideId = null;
                                moveLayer.mode    = LayerMode.NORMAL;
                                moveLayer.showIcon();
                            }

                        }

                        break;

                    default:

                        switch (moveLayer.mode) {

                            case LayerMode.MASK_IN:
                                // マスクの外に出る場合はマスク表示を無効化する
                                moveLayer.maskId = null;
                                moveLayer.mode = LayerMode.NORMAL;
                                moveLayer.showIcon();
                                break;

                            case LayerMode.GUIDE_IN:
                                // ガイドの外に出る場合はガイド表示を無効化する
                                moveLayer.guideId = null;
                                moveLayer.mode = LayerMode.NORMAL;
                                moveLayer.showIcon();
                                break;

                            default:
                                break;

                        }

                        break;

                }

                if (relationLayers.length) {
                    relationLayers.length = 0;
                }

                // 移動するレイヤーが親マスクの場合は
                // マスク対象のレイヤーも一緒に移動する
                switch (moveLayer.mode) {

                    case LayerMode.MASK:
                        {

                            const children = Array.from(element.children);
                            let index = children.indexOf(layer);
                            for (;;) {

                                const child = children[++index];
                                if (!child) {
                                    break;
                                }

                                const layer = scene.getLayer(
                                    child.dataset.layerId | 0
                                );

                                // マスク対象がなくなったら終了
                                if (layer.mode !== LayerMode.MASK_IN) {
                                    break;
                                }

                                relationLayers.unshift(child);
                            }
                        }
                        break;

                    case LayerMode.GUIDE:
                        {
                            const children = Array.from(element.children);
                            let index = children.indexOf(layer);
                            for (;;) {

                                const child = children[++index];
                                if (!child) {
                                    break;
                                }

                                const layer = scene.getLayer(
                                    child.dataset.layerId | 0
                                );

                                // マスク対象がなくなったら終了
                                if (layer.mode !== LayerMode.GUIDE_IN) {
                                    break;
                                }

                                relationLayers.unshift(child);
                            }
                        }
                        break;

                    default:
                        break;

                }

                // 指定したレイヤーの下部に移動
                element
                    .insertBefore(layer, this._$destLayer.nextElementSibling);

                // マスク、ガイドに紐ずくElementも一緒に移動する
                if (relationLayers.length) {

                    for (let idx = 0; idx < relationLayers.length; ++idx) {

                        element
                            .insertBefore(
                                relationLayers[idx],
                                layer.nextElementSibling
                            );

                    }
                }
            }

            // 並び替えたElementをもとに内部Objectも並び替える
            const layers = [];
            const children = element.children;
            for (let idx = 0; idx < children.length; ++idx) {
                layers.push(
                    scene.getLayer(children[idx].dataset.layerId | 0)
                );
            }

            // レイヤーオブジェクトを初期化
            scene.clearLayer();
            for (let idx = 0; idx < layers.length; ++idx) {
                const layer = layers[idx];
                scene.setLayer(layer.id, layer);
            }

            this.reloadScreen();

        } else {

            // 初回選択出ない時はアクティブ判定を行う
            if (this._$moveLayerId !== this._$selectLayerId) {

                const element = document
                    .getElementById(`layer-id-${this._$moveLayerId}`);

                this.activeLayer(element);

            }

        }

        // 初期化
        super.focusOut();
        this._$selectLayerId = -1;
        this._$moveLayerId   = -1;
        this._$destLayer     = null;
        this._$exitLayer     = null;
        Util.$setCursor("auto");
    }

    /**
     * @description レイヤーの移動先となるレイヤーを変数にセットしてアクティブ表示にする
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    activeMoveLayer (event)
    {
        this._$destLayer = null;
        if (this._$moveLayerId === -1) {
            return ;
        }

        // 他のイベントを中止
        event.stopPropagation();

        // 選択中のレイヤーでなければ移動対象として認識させる
        const element = event.currentTarget.parentNode;
        if (!this.targetLayers.has(element.id)) {

            this._$destLayer = element;
            element.classList.add("move-target");

        }
    }

    /**
     * @description レイヤーの移動先となるレイヤーを変数から削除して非アクティブにする
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    inactiveMoveLayer (event)
    {
        if (this._$moveLayerId === -1 || !this._$destLayer) {
            return ;
        }

        // 他のイベントを中止
        event.stopPropagation();

        // 非アクティブに
        this._$destLayer.classList.remove("move-target");
        this._$destLayer = null;
    }

    /**
     * @description レイヤーのタイムラインの移動処理
     *
     * @return {void}
     * @method
     * @public
     */
    moveTimeLine ()
    {
        const scene = Util.$currentWorkSpace().scene;
        if (!scene) {
            return ;
        }

        const clientHeight = this.clientHeight;

        const scrollY = Util.$timelineScroll.y;
        const startIndex = scrollY / Util.$timelineTool.timelineHeight | 0;

        // 全てのElementの位置を揃える
        let idx   = 0;
        let count = 0;
        for (const layer of scene._$layers.values()) {

            // 非表示領域にあれば非表示にしてスキップ
            if (startIndex > idx) {

                if (layer.display !== "none") {

                    const element = document
                        .getElementById(`layer-id-${layer.id}`);

                    if (element) {
                        layer.display = element.style.display = "none";
                    }
                }

                idx++;
                continue;
            }

            if (layer.display === "none") {

                const element = document
                    .getElementById(`layer-id-${layer.id}`);

                if (element) {
                    layer.display = element.style.display = "";
                }
            }

            // レイヤー個別のタイムラインを再描画
            this.rebuild(layer.id);

            if (Util.$timelineTool.timelineHeight * ++count > clientHeight) {
                break;
            }

            idx++;
        }

        // 選択中のフレームをアクティブ表示に
        this.moveActiveFrame();
    }

    /**
     * @description タイムラインのフレーム内容をプレビュー表示する
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    showLayerPreview (event)
    {
        if (!Util.$timelineTool.preview) {
            return ;
        }

        const layerId = event.target.dataset.layerId | 0;
        const element = event.target;
        window.requestAnimationFrame(() =>
        {
            const workSpace = Util.$currentWorkSpace();
            const frame = element.dataset.frame | 0;
            const layer = workSpace.scene.getLayer(layerId);

            const currentFrame = Util.$currentFrame;
            Util.$currentFrame = frame;

            const characters = layer.getActiveCharacter(frame);
            if (characters.length) {

                clearTimeout(this._$timerId);

                layer.sort(characters, frame);

                const preview = document
                    .getElementById("timeline-preview-modal");

                const { Sprite, BitmapData } = window.next2d.display;
                const { Matrix, ColorTransform } = window.next2d.geom;

                const sprite = new Sprite();

                let xMin = Number.MAX_VALUE;
                let xMax = -Number.MAX_VALUE;
                let yMin = Number.MAX_VALUE;
                let yMax = -Number.MAX_VALUE;

                // reset
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    const range  = character.getRange(frame);
                    const place  = character.getPlace(frame);

                    const instance = workSpace
                        .getLibrary(character.libraryId)
                        .createInstance(place, range);

                    instance.transform.matrix = new Matrix(
                        place.matrix[0], place.matrix[1],
                        place.matrix[2], place.matrix[3],
                        place.matrix[4], place.matrix[5]
                    );
                    instance.transform.colorTransform = new ColorTransform(
                        place.colorTransform[0], place.colorTransform[1],
                        place.colorTransform[2], place.colorTransform[3],
                        place.colorTransform[4], place.colorTransform[5],
                        place.colorTransform[6], place.colorTransform[7]
                    );

                    const bounds = workSpace
                        .getLibrary(character.libraryId)
                        .getBounds(place.matrix, place, range);

                    xMin = Math.min(xMin, bounds.xMin);
                    xMax = Math.max(xMax, bounds.xMax);
                    yMin = Math.min(yMin, bounds.yMin);
                    yMax = Math.max(yMax, bounds.yMax);

                    sprite.addChild(instance);
                }

                const width  = Math.ceil(Math.abs(xMax - xMin));
                const height = Math.ceil(Math.abs(yMax - yMin));
                const scale  = Math.min(120 / width, 120 / height);
                const ratio  = window.devicePixelRatio;

                const bitmapData = new BitmapData(
                    width  * scale * ratio,
                    height * scale * ratio,
                    true, 0
                );

                const matrix = new Matrix(
                    ratio, 0, 0, ratio,
                    -xMin * ratio,
                    -yMin * ratio
                );

                matrix.scale(scale, scale);
                bitmapData.draw(sprite, matrix);

                const context = bitmapData.drawFromCanvas(Util.$getCanvas());

                // player側のメモリを解放
                bitmapData.dispose();

                while (preview.children.length) {
                    const node = preview.children[0];
                    Util.$poolCanvas(node);
                    node.remove();
                }

                let style = "";
                style += `left: ${event.pageX + 10}px;`;
                style += `top: ${event.pageY - preview.offsetHeight - 10}px;`;
                style += `background-color: ${document.getElementById("stage-bgColor").value};`;
                preview.setAttribute("style", style);

                const canvas = context.canvas;

                canvas.style.width  = `${bitmapData.width  / ratio}px`;
                canvas.style.height = `${bitmapData.height / ratio}px`;
                preview.appendChild(canvas);

                if (!preview.classList.contains("fadeIn")) {
                    preview.setAttribute("class", "fadeIn");
                }
            }

            Util.$currentFrame = currentFrame;
        });
    }

    /**
     * @description タイムラインのフレーム内容をプレビュー表示する
     *
     * @return {void}
     * @method
     * @public
     */
    hideLayerPreview ()
    {
        if (!document
            .getElementById("timeline-preview")
            .classList
            .contains("timeline-preview-active")
        ) {
            return ;
        }

        const preview = document
            .getElementById("timeline-preview-modal");

        if (!preview.classList.contains("fadeOut")) {
            this._$timerId = setTimeout(() =>
            {
                if (!preview.classList.contains("fadeOut")) {
                    preview.setAttribute("class", "fadeOut");
                }
            }, 1000);
        }
    }

    /**
     * @description 選択したレイヤーの操作、アクティブなら移動を可能に
     *              非アクティブならアクティブ化する。
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    selectLayer (event)
    {
        if (event.button || Util.$keyLock) {
            return ;
        }

        // 親のイベントを中止
        event.stopPropagation();

        // メニューモーダルを終了
        Util.$endMenu();

        const element = event.currentTarget;
        if (!element.classList.contains("active")) {
            this.activeLayer(element);
        }

        if (!this._$moveLayer) {
            this._$moveLayer = this.moveLayer.bind(this);
        }

        if (!this._$executeMoveLayer) {
            this._$executeMoveLayer = this.executeMoveLayer.bind(this);
        }

        this._$moveLayerId = element.dataset.layerId | 0;

        window.addEventListener("mousemove", this._$moveLayer);
        window.addEventListener("mouseup", this._$executeMoveLayer);
    }

    /**
     * @description 選択したレイヤーをアクティブにする
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    activeLayer (element)
    {
        // 初期化
        this.clearActiveFrames();

        // 選択したレイヤーをアクティブ化
        this.targetLayer = element;

        // 選択したレイヤーのIDを変数に格納
        this._$selectLayerId = element.dataset.layerId | 0;

        // アクティブ表示
        const scene = Util.$currentWorkSpace().scene;
        const frame = Util.$timelineFrame.currentFrame;
        for (const layerElement of this.targetLayers.values()) {

            const layerId = layerElement.dataset.layerId | 0;

            // 編集へセット
            const layer = scene.getLayer(layerId);

            // 選択したレイヤーのフレームを初期化してセット
            this.targetFrames.delete(layerId);
            this.addTargetFrame(layer, frame);
        }

        // マーカーを現在のフレームの位置に移動
        Util.$timelineMarker.move();

        // スクリーンのDisplayObjectをアクティブ化
        this.activeCharacter();
    }

    /**
     * @description タイムラインのレンジでグループ選択にする
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    selectRange (event)
    {
        // 選択のタイマーを停止
        clearTimeout(this._$clickTimerId);

        // 親のイベントを中止
        event.stopPropagation();

        // メニューモーダルを終了
        Util.$endMenu();

        const target = event.target;

        const frame = Util.$timelineFrame.currentFrame;
        const layerId = target.dataset.layerId | 0;

        // 選択したフレームElementをMapに登録
        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layerId);

        let character = null;

        const characters = layer.getActiveCharacter(frame);
        if (characters.length) {
            character = characters[0];
        }

        if (!character) {
            character = layer.getActiveEmptyCharacter(frame);
        }

        if (!character) {
            return ;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();

        // fixed logic
        this.targetLayer = document
            .getElementById(`layer-id-${layerId}`);

        const range = character.getRange(frame);
        for (let frame = range.startFrame; range.endFrame > frame; ++frame) {
            this.addTargetFrame(layer, frame);
        }

        this.moveFrame(frame);
    }

    /**
     * @description タイムラインの選択したフレームをアクティブにする
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    selectFrame (event)
    {
        if (event.button) {
            return ;
        }

        // 親のイベントを中止
        event.stopPropagation();

        // メニューモーダルを終了
        Util.$endMenu();

        const preview = document
            .getElementById("timeline-preview-modal");

        if (!preview.classList.contains("fadeOut")) {
            preview.setAttribute("class", "fadeOut");
        }

        // toolにframeを表示
        const target = event.target;
        const frame  = target.dataset.frame | 0;

        this.changeLabel(frame);

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        // 選択中のレイヤーID
        const layerId = target.dataset.layerId | 0;

        // フレームを選択中か判定
        let isActive = false;
        if (this.targetFrames.has(layerId)) {
            const frames = this.targetFrames.get(layerId);
            isActive = frames.indexOf(frame) > -1;
        }

        if (isActive) {

            // 最初に選択したレイヤーのフレーム番号の配列
            const firstFrames = this.targetFrames.values().next().value;
            if (!firstFrames.length) {
                return ;
            }

            // タイマーを中止
            clearTimeout(this._$clickTimerId);

            this._$clickTimerId = window.setTimeout(() =>
            {
                const targetLayer = this.targetLayer;
                if (!targetLayer) {
                    return ;
                }

                // レイヤーを配列化
                const children = Array.from(
                    document.getElementById("timeline-content").children
                );

                // 一番左上のelementを算出
                let index = children.indexOf(this.targetLayer);
                if (this.targetFrames.size > 1) {
                    for (const layerId of this.targetFrames.keys()) {
                        const layerElement =  document
                            .getElementById(`layer-id-${layerId}`);

                        if (!layerElement) {
                            continue;
                        }

                        index = Math.min(index, children.indexOf(layerElement));
                    }
                }

                let frame = Number.MAX_VALUE;
                for (let idx = 0; idx < firstFrames.length; ++idx) {
                    frame = Math.min(frame, firstFrames[idx]);
                }

                // 左上のelementを基準に選択範囲を生成
                const layer = Util
                    .$currentWorkSpace()
                    .scene
                    .getLayer(
                        targetLayer.dataset.layerId | 0
                    );

                const leftElement = layer.getChildren(frame);

                const parent = document
                    .getElementById("timeline-content");

                const width = firstFrames.length
                    * (Util.$timelineTool.timelineWidth + 1) - 5;

                this._$clientX = leftElement.offsetLeft;
                this._$clientY = leftElement.offsetTop - parent.scrollTop;

                const element = document
                    .getElementById("target-group");

                let style = `width: ${width}px;`;
                style += `height: ${this.targetFrames.size * Util.$timelineTool.timelineHeight - 5}px;`;
                style += `left: ${this._$clientX}px;`;
                style += `top: ${this._$clientY}px;`;
                element.setAttribute("style", style);

                element.dataset.frame = `${frame}`;
                element.dataset.index = `${index}`;

                const size = Util.$timelineTool.timelineWidth + 1;
                for (;;) {
                    if (this._$clientX + size > event.clientX) {
                        break;
                    }
                    this._$clientX += size;
                }
                for (;;) {
                    if (this._$clientY + 30 > event.clientY) {
                        break;
                    }
                    this._$clientY += 30;
                }

                if (!this._$endTargetGroup) {
                    this._$endTargetGroup = this.endTargetGroup.bind(this);
                }

                if (!this._$moveTargetGroup) {
                    this._$moveTargetGroup = this.moveTargetGroup.bind(this);
                }

                window.addEventListener("mousemove", this._$moveTargetGroup);
                window.addEventListener("mouseup", this._$endTargetGroup);
            }, 200);

        } else {

            // 初期化
            if (!Util.$ctrlKey) {
                tool.clear();
            }

            // fixed logic
            this.targetLayer = document
                .getElementById(`layer-id-${layerId}`);

            // 選択したフレームElementをMapに登録
            const layer = Util
                .$currentWorkSpace()
                .scene
                .getLayer(layerId);

            this.addTargetFrame(layer, frame);

            if (!this._$multiSelect) {
                this._$multiSelect = this.multiSelect.bind(this);
            }

            if (!this._$endMultiSelect) {
                this._$endMultiSelect = this.endMultiSelect.bind(this);
            }

            window.addEventListener("mousemove", this._$multiSelect);
            window.addEventListener("mouseup", this._$endMultiSelect);

            // フレームを移動
            this.moveFrame(frame);
        }
    }

    /**
     * @description フレームを移動に合わせてラベルの値を表示・更新する
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    changeLabel (frame)
    {
        // ラベル情報更新して初期化
        const element = document.getElementById("label-name");
        if (!element) {
            return ;
        }

        element.blur();
        element.value = "";

        // labelがあればセット
        const scene = Util.$currentWorkSpace().scene;
        if (scene.hasLabel(frame)) {
            element.value = scene.getLabel(frame);
        }
    }

    /**
     * @description フレームを移動
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    moveFrame (frame)
    {
        if (Util.$timelineFrame.currentFrame !== frame) {

            // フレームを移動
            Util.$timelineFrame.currentFrame = frame;

            const timelineWidth = Util.$timelineTool.timelineWidth;
            const leftFrame     = Util.$timelineHeader.leftFrame;
            const elementCount  = Util.$timelineHeader.width / (timelineWidth + 1) | 0;
            switch (true) {

                case leftFrame > frame:
                case frame > leftFrame + elementCount - 1:
                    Util.$timelineHeader.scrollX = (frame - 1) * timelineWidth;
                    Util.$timelineHeader.rebuild();
                    this.moveTimeLine();
                    break;

                default:
                    break;

            }

            // マーカーを移動
            Util.$timelineMarker.move();

            // 移動先の音声設定を生成
            Util.$soundController.createSoundElements();

            // 再描画
            this.reloadScreen();
        }

        // 再描画後にアクティブ判定を行う
        this.activeCharacter();
    }

    /**
     * @description 選択したフレームの移動表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveTargetGroup (event)
    {
        window.requestAnimationFrame(() =>
        {
            const element = document
                .getElementById("target-group");

            const targetLayer = this.targetLayer;
            if (!targetLayer) {
                return ;
            }

            const scrollElement = document.getElementById(
                `frame-scroll-id-${targetLayer.dataset.layerId}`
            );

            const timelineWidth = Util.$timelineTool.timelineWidth;
            const size = timelineWidth + 1;

            const frame = element.dataset.frame | 0;
            const index = element.dataset.index | 0;

            // 右に移動
            if (event.clientX - this._$clientX > size) {

                // 右端まできたらタイムラインを移動
                if (element.offsetLeft + element.offsetWidth + size >
                    scrollElement.offsetLeft + scrollElement.offsetWidth
                ) {

                    const base = document
                        .getElementById("timeline-controller-base");

                    // 移動可能であれば右にタイムラインを移動
                    if (event.pageX > base.offsetLeft + base.offsetWidth) {

                        Util.$timelineHeader.scrollX += timelineWidth;
                        Util.$timelineHeader.rebuild();
                        Util.$timelineLayer.moveTimeLine();

                        element.dataset.frame = `${frame + 1}`;
                    }

                    return ;
                }

                element.style.left = `${element.offsetLeft + size}px`;

                element.dataset.frame = `${frame + 1}`;

                this._$clientX += size;

                return ;
            }

            // 左に移動
            if (this._$clientX - event.clientX > size) {

                // 左端まできたらタイムラインを移動
                if (scrollElement.offsetLeft > element.offsetLeft - size) {

                    const base = document
                        .getElementById("timeline-controller-base");

                    // 移動可能であれば左にタイムラインを移動
                    if (Util.$timelineHeader.scrollX > 0 && base.offsetLeft > event.pageX) {

                        Util.$timelineHeader.scrollX -= timelineWidth;
                        Util.$timelineHeader.rebuild();
                        Util.$timelineLayer.moveTimeLine();

                        element.dataset.frame = `${frame - 1}`;

                    }

                    return ;
                }

                element.style.left = `${element.offsetLeft - size}px`;

                element.dataset.frame = `${frame - 1}`;

                this._$clientX -= size;

                return ;
            }

            // 下に移動
            if (event.clientY - this._$clientY > Util.$timelineTool.timelineHeight - 1) {

                const parent = document
                    .getElementById("timeline-content");

                const height = Math.min(
                    parent.children.length * Util.$timelineTool.timelineHeight,
                    parent.offsetHeight
                );

                if (element.offsetTop + element.offsetHeight + Util.$timelineTool.timelineHeight
                    > parent.offsetTop + height
                ) {

                    // 移動可能であれば下にタイムラインを移動
                    if (Util.$timelineScroll.maxY >= Util.$timelineScroll.y + Util.$timelineTool.timelineHeight) {

                        element.dataset.index = `${index + 1}`;
                        Util.$timelineScroll.execute(0, Util.$timelineTool.timelineHeight);

                    }

                    return ;
                }

                element.style.top = `${element.offsetTop + Util.$timelineTool.timelineHeight}px`;

                element.dataset.index = `${index + 1}`;

                this._$clientY += Util.$timelineTool.timelineHeight - 1;

                return ;
            }

            // 上に移動
            if (this._$clientY - event.clientY > 0) {

                const parent = document
                    .getElementById("timeline-content");

                if (parent.offsetTop > element.offsetTop - Util.$timelineTool.timelineHeight) {

                    // 移動可能であれば上にタイムラインを移動
                    if (Util.$timelineScroll.y > 0) {

                        element.dataset.index = `${index - 1}`;
                        Util.$timelineScroll.execute(0, -Util.$timelineTool.timelineHeight);

                    }

                    return ;
                }

                element.style.top = `${element.offsetTop - Util.$timelineTool.timelineHeight}px`;

                element.dataset.index = `${index - 1}`;

                this._$clientY -= Util.$timelineTool.timelineHeight - 1;
            }
        });
    }

    /**
     * @description 選択したフレームの移動処理
     *
     * @return {void}
     * @method
     * @public
     */
    endTargetGroup ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$moveTargetGroup);
        window.removeEventListener("mouseup", this._$endTargetGroup);

        // 選択elementを非表示
        this.hideTargetGroup();

        const targetLayer = this.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const targetGroup = document
            .getElementById("target-group");

        const distFrame = targetGroup.dataset.frame | 0;
        let index       = targetGroup.dataset.index | 0;

        const children = Array.from(
            document.getElementById("timeline-content").children
        );

        // 移動をしてなければ中止
        const selectLayerId = children[index].dataset.layerId | 0;
        const targetLayerId = targetLayer.dataset.layerId | 0;

        // 選択したフレームで一番若いフレーム番号
        const frame = Util.$timelineTool.getFirstFrame();

        // 移動してなければスキップ
        if (selectLayerId === targetLayerId && frame === distFrame) {
            return ;
        }

        this.save();

        let frames = null;
        const scene = Util.$currentWorkSpace().scene;
        for (const [layerId, values] of this.targetFrames) {

            // 移動先の終了フレーム
            const endFrame = distFrame + values.length;

            if (!frames) {
                frames = values.slice();
                if (frames.length > 1) {
                    frames.sort((a, b) =>
                    {
                        const aFrame = a | 0;
                        const bFrame = b | 0;

                        // 昇順
                        switch (true) {

                            case aFrame > bFrame:
                                return 1;

                            case aFrame < bFrame:
                                return -1;

                            default:
                                return 0;

                        }
                    });
                }
            }

            // 移動元のレイヤー
            const layer = scene.getLayer(layerId);

            // 移動先のレイヤー
            const targetLayerId = children[index++].dataset.layerId | 0;
            const targetLayer   = scene.getLayer(targetLayerId);

            // 移動先の幅で新規のDisplayObjectを生成、隙間は空のキーフレームを生成
            const characters  = new Map();
            const emptys      = [];
            let currentEmpty  = null;
            let rangeEndFrame = 1;
            for (let idx = 0; idx < frames.length; ++idx) {

                const frame = frames[idx];

                // 移動元が未定義の場合
                if (!layer.getActiveEmptyCharacter(frame)
                    && !layer.getActiveCharacter(frame).length
                ) {

                    if (currentEmpty) {
                        currentEmpty.endFrame = frame + 1;
                        continue;
                    }

                    // 最後のフレームにDisplayObjectがあれば拡張
                    if (characters.size) {

                        // 選択幅の最終フレームだけ後続のフレームを拡張
                        for (const character of characters.values()) {

                            // 最終フレームのDisplayObjectでなければスキップ
                            if (character.endFrame !== rangeEndFrame) {
                                continue;
                            }

                            // tweenであれば情報を更新
                            const keyFrame = character.endFrame - 1;
                            if (character.hasPlace(keyFrame)) {

                                const place = character.getPlace(keyFrame);
                                if (place.tweenFrame) {

                                    character.setPlace(
                                        frame,
                                        character.getClonePlace(keyFrame)
                                    );

                                    character
                                        .getTween(place.tweenFrame)
                                        .endFrame = frame + 1;

                                    Util
                                        .$tweenController
                                        .relocationPlace(character, keyFrame);
                                }
                            }

                            character.endFrame = frame + 1;

                            rangeEndFrame = frame + 1;
                        }

                        continue;
                    }

                    // 未定義のフレームであれば空のキーフレームで生成
                    currentEmpty = new EmptyCharacter();
                    currentEmpty.startFrame = frame;
                    currentEmpty.endFrame   = frame + 1;

                } else {

                    // 配置されてるDisplayObject
                    const activeCharacters = layer.getActiveCharacter(frame);
                    if (activeCharacters.length) {

                        if (currentEmpty) {
                            currentEmpty.endFrame = frame;
                            emptys.push(currentEmpty);

                            // 初期化
                            currentEmpty = null;
                        }

                        for (let idx = 0; idx < activeCharacters.length; ++idx) {

                            const character = activeCharacters[idx];

                            if (!characters.has(character.id)) {

                                // 新規のDisplayObjectを生成
                                const newCharacter      = new Character();
                                newCharacter.libraryId  = character.libraryId;
                                newCharacter.startFrame = frame;
                                newCharacter.endFrame   = frame + 1;
                                newCharacter.screenX    = character.screenX;
                                newCharacter.screenY    = character.screenY;

                                // キーフレームをセット
                                const place = character.getClonePlace(frame);
                                newCharacter.setPlace(frame, place);

                                // tweenの設定があれば移動処理を追加
                                if (place.tweenFrame) {

                                    const tweenObject = character
                                        .getCloneTween(place.tweenFrame);

                                    tweenObject.startFrame = frame;
                                    tweenObject.endFrame   = frame + 1;

                                    place.tweenFrame = frame;
                                    newCharacter.setTween(frame, tweenObject);

                                }

                                characters.set(character.id, newCharacter);

                                rangeEndFrame = Math.max(
                                    newCharacter.endFrame, rangeEndFrame
                                );
                                continue;
                            }

                            const newCharacter = characters.get(character.id);
                            if (character.hasPlace(frame)) {

                                const place = character.getClonePlace(frame);
                                newCharacter.setPlace(frame, place);

                                // tweenの設定も移動
                                if (place.tweenFrame) {

                                    place.tweenFrame = newCharacter.startFrame;

                                    newCharacter
                                        .getTween(place.tweenFrame)
                                        .endFrame = frame + 1;

                                }
                            }

                            newCharacter.endFrame = frame + 1;
                            rangeEndFrame = Math.max(
                                newCharacter.endFrame, rangeEndFrame
                            );
                        }

                        continue;
                    }

                    if (!currentEmpty) {
                        currentEmpty = new EmptyCharacter();
                        currentEmpty.startFrame = frame;
                        currentEmpty.endFrame   = frame + 1;

                        rangeEndFrame = Math.max(
                            currentEmpty.endFrame, rangeEndFrame
                        );

                        continue;
                    }

                    currentEmpty.endFrame = frame + 1;

                    rangeEndFrame = Math.max(
                        currentEmpty.endFrame, rangeEndFrame
                    );
                }
            }

            if (currentEmpty) {
                emptys.push(currentEmpty);
            }

            // 移動先のDisplayObjectにキーフレームがあれば削除
            let distLastFrame = endFrame;
            const targetCharacters = targetLayer._$characters.slice();
            for (let idx = 0; idx < targetCharacters.length; ++idx) {

                const character = targetCharacters[idx];

                if (distFrame > character.endFrame - 1) {
                    continue;
                }

                if (character.startFrame >= endFrame) {
                    continue;
                }

                if (character.startFrame >= distFrame
                    && endFrame >= character.endFrame
                ) {

                    targetLayer.deleteCharacter(character.id);

                } else {

                    // 移動先の幅の最大値をセット
                    const range = character.getRange(endFrame);
                    distLastFrame = Math.max(range.endFrame, distLastFrame);

                    // 選択幅のキーフレームを削除
                    for (let frame = distFrame; endFrame > frame; ++frame) {

                        if (!character.hasPlace(frame)) {
                            continue;
                        }

                        // tween補正
                        const place = character.getPlace(frame);
                        if (place.tweenFrame) {

                            const range = character.getRange(frame);
                            if (character.hasTween(frame)) {

                                // tweenの開始位置なら全て削除
                                for (let frame = range.startFrame; range.endFrame > frame; ++frame) {
                                    character.deletePlace(frame);
                                }
                                character.deleteTween(frame);

                            } else {

                                for (let frame = distFrame; range.endFrame > frame; ++frame) {
                                    character.deletePlace(frame);
                                }

                                character
                                    .getTween(place.tweenFrame)
                                    .endFrame = distFrame;

                                // 再計算
                                Util
                                    .$tweenController
                                    .relocationPlace(character, place.tweenFrame);

                            }
                        }

                        character.deletePlace(frame);
                    }

                    if (!character._$places.size) {

                        // 全てのキーフレームが削除された場合はレイヤーからも削除
                        targetLayer.deleteCharacter(character.id);

                    } else {

                        // 後続にキーフレームがあれば分割
                        if (character.hasPlace(range.endFrame)) {

                            // 移動元と移動先が同じレイヤーならチェック
                            if (selectLayerId === targetLayerId
                                && characters.has(character.id)
                            ) {
                                const newCharacter = characters.get(character.id);
                                for (const keyFrame of newCharacter._$places.keys()) {

                                    // 移動元の範囲内にキーフレームがあれば、削除してレンジの最大フレームを更新
                                    if (!character.hasPlace(keyFrame)) {
                                        continue;
                                    }

                                    distLastFrame = Math.max(
                                        character.getRange(keyFrame).endFrame,
                                        distLastFrame
                                    );

                                    character.deletePlace(keyFrame);
                                }
                            }

                            // 複製して分割
                            const cloneCharacter = character.clone();
                            cloneCharacter.startFrame = range.endFrame;

                            // placeオブジェクトを分割
                            const places = new Map();
                            for (const [keyFrame, place] of cloneCharacter._$places) {

                                if (range.endFrame > keyFrame) {
                                    continue;
                                }

                                character.deletePlace(keyFrame);
                                places.set(keyFrame, place);
                            }

                            // キーフレームがあれば分割したDisplayObjectを登録
                            if (places.size) {

                                // tweenを分割
                                const tweenObjects = new Map();
                                for (const [keyFrame, tweenObject] of cloneCharacter._$tween) {

                                    if (range.endFrame > keyFrame) {
                                        continue;
                                    }

                                    character.deleteTween(keyFrame);
                                    tweenObjects.set(keyFrame, tweenObject);
                                }

                                cloneCharacter._$places = places;
                                cloneCharacter._$tween  = tweenObjects;

                                targetLayer.addCharacter(cloneCharacter);
                            }
                        }

                        // 終了位置を補正
                        character.endFrame = distFrame;
                        if (character.hasTween(range.startFrame)) {

                            character
                                .getTween(range.startFrame)
                                .endFrame = distFrame;

                        }

                    }
                }
            }

            // 移動先に空のキーフレームがあれば削除
            const targetEmptys = targetLayer._$emptys.slice();
            for (let idx = 0; idx < targetEmptys.length; ++idx) {

                const emptyCharacter = targetEmptys[idx];

                if (distFrame > emptyCharacter.endFrame - 1) {
                    continue;
                }

                if (emptyCharacter.startFrame >= endFrame) {
                    continue;
                }

                // 終了位置を補正
                if (targetLayer.getActiveCharacter(emptyCharacter.endFrame).length) {
                    distLastFrame = emptyCharacter.endFrame;
                }

                if (distFrame > emptyCharacter.startFrame) {

                    emptyCharacter.endFrame = distFrame;

                } else {

                    targetLayer.deleteEmptyCharacter(emptyCharacter);

                }
            }

            // Altキーが押下されていない時は、選択元を削除
            if (!Util.$altKey) {

                const endFrame = frame + values.length;

                // DisplayObjectを削除
                for (const characterId of characters.keys()) {

                    const character = layer.getCharacter(characterId);
                    if (!character) {
                        continue;
                    }

                    // 同一のレイヤー移動であれば最終フレームを確認
                    if (selectLayerId === targetLayerId
                        && character.hasPlace(frame)
                    ) {
                        const range = character.getRange(frame);
                        if (range.startFrame === character.startFrame
                            && range.startFrame === distLastFrame
                        ) {
                            distLastFrame = Math.max(range.endFrame, distLastFrame);
                        }
                    }

                    // 選択範囲のキーフレームを削除
                    for (let keyFrame = frame; endFrame > keyFrame; ++keyFrame) {

                        if (!character.hasPlace(keyFrame)) {
                            continue;
                        }

                        // キーフレームの反映情報をセット
                        const range = character.getRange(keyFrame);

                        // tweenがあれば範囲内のplaceオブジェクトを削除
                        if (character.hasTween(keyFrame)) {

                            const tweenObject = character.getTween(keyFrame);
                            for (let frame = tweenObject.startFrame; tweenObject.endFrame > frame; ++frame) {
                                character.deletePlace(frame);
                            }

                            character.deleteTween(keyFrame);

                            // 前方にtweenがあれば統合
                            const prevFrame = keyFrame - 1;
                            if (prevFrame > 1 && prevFrame >= character.startFrame) {
                                const place = character.getPlace(prevFrame);
                                if (place.tweenFrame) {

                                    for (let frame = prevFrame + 1; tweenObject.endFrame > frame; ++frame) {
                                        character.setPlace(frame,
                                            character.getClonePlace(prevFrame)
                                        );
                                    }

                                    character
                                        .getTween(place.tweenFrame)
                                        .endFrame = tweenObject.endFrame;

                                    // 再計算
                                    Util
                                        .$tweenController
                                        .relocationPlace(character, prevFrame);
                                }
                            }

                        } else {

                            // tweenの間のフレームなら削除しない
                            const place = character.getPlace(keyFrame);
                            if (place.tweenFrame) {
                                continue;
                            }

                        }

                        // キーフレームを削除
                        character.deletePlace(keyFrame);

                        // キーフレームがなくなったらレイヤーから削除
                        if (!character._$places.size) {

                            layer.deleteCharacter(characterId);

                            if (!layer.getActiveEmptyCharacter(keyFrame)) {

                                const prevEmptyCharacter = layer
                                    .getActiveEmptyCharacter(keyFrame - 1);

                                if (prevEmptyCharacter) {

                                    prevEmptyCharacter.endFrame = range.endFrame;

                                } else {

                                    layer.addEmptyCharacter(new EmptyCharacter({
                                        "startFrame": range.startFrame,
                                        "endFrame": range.endFrame
                                    }));

                                }
                            }

                            // 終了
                            break;
                        }

                        // 削除するキーフレームが開始フレームの場合は、後方に開始位置を補正
                        if (character.startFrame === keyFrame) {

                            // 開始位置を後方に補正
                            character.startFrame = range.endFrame;

                            // フレームが1じゃない場合
                            const prevFrame = keyFrame - 1;
                            if (prevFrame) {

                                const activeCharacters = layer
                                    .getActiveCharacter(prevFrame);

                                if (activeCharacters.length) {

                                    // 前方に配置されてるDisplayObjectがあれば、後方に補正
                                    for (let idx = 0; activeCharacters.length > idx; ++idx) {

                                        const character = activeCharacters[idx];

                                        const keyFrame = character.endFrame - 1;
                                        if (character.hasPlace(keyFrame)) {

                                            // tweenがあれば再計算
                                            const place = character.getPlace(keyFrame);
                                            if (place.tweenFrame) {

                                                const tweenObject = character
                                                    .getTween(place.tweenFrame);

                                                for (let frame = keyFrame + 1; range.endFrame > frame; ++frame) {
                                                    character.setPlace(frame,
                                                        character.getClonePlace(keyFrame)
                                                    );
                                                }

                                                tweenObject.endFrame = range.endFrame;

                                                Util
                                                    .$tweenController
                                                    .relocationPlace(character, keyFrame);
                                            }
                                        }

                                        // 終了位置を補正
                                        character.endFrame = range.endFrame;
                                    }

                                } else {

                                    const emptyCharacter = layer
                                        .getActiveEmptyCharacter(prevFrame);

                                    if (emptyCharacter) {

                                        emptyCharacter.endFrame = range.endFrame;

                                    } else {

                                        layer.addEmptyCharacter(new EmptyCharacter({
                                            "startFrame": range.startFrame,
                                            "endFrame": range.endFrame
                                        }));

                                    }

                                }

                            } else {

                                const emptyCharacter = layer
                                    .getActiveEmptyCharacter(prevFrame);

                                if (!emptyCharacter) {

                                    layer.addEmptyCharacter(new EmptyCharacter({
                                        "startFrame": range.startFrame,
                                        "endFrame": range.endFrame
                                    }));

                                }
                            }
                        }
                    }
                }

                // 空のフレームを削除
                for (let idx = 0; idx < layer._$emptys.length; ++idx) {

                    const emptyCharacter = layer._$emptys[idx];
                    if (emptyCharacter.startFrame > endFrame) {
                        continue;
                    }

                    if (frame >= emptyCharacter.endFrame) {
                        continue;
                    }

                    for (let keyFrame = frame; endFrame > keyFrame; ++keyFrame) {

                        if (emptyCharacter.startFrame !== keyFrame) {
                            continue;
                        }

                        // 前方のフレームと統合か補正
                        const prevFrame = emptyCharacter.startFrame - 1;
                        if (prevFrame) {

                            distLastFrame = Math.max(emptyCharacter.endFrame, distLastFrame);
                            layer.deleteEmptyCharacter(emptyCharacter);

                            const activeCharacters = layer
                                .getActiveCharacter(prevFrame);

                            if (activeCharacters.length) {

                                for (let idx = 0; idx < activeCharacters.length; ++idx) {
                                    const character = activeCharacters[idx];

                                    const keyFrame = character.endFrame - 1;
                                    if (character.hasPlace(keyFrame)) {
                                        const place = character.getPlace(keyFrame);
                                        if (place.tweenFrame) {

                                            for (let frame = keyFrame + 1; emptyCharacter.endFrame > frame; ++frame) {
                                                character.setPlace(frame,
                                                    character.getClonePlace(keyFrame)
                                                );
                                            }

                                            character
                                                .getTween(place.tweenFrame)
                                                .endFrame = emptyCharacter.endFrame;

                                            // 再計算
                                            Util
                                                .$tweenController
                                                .relocationPlace(character, keyFrame);
                                        }
                                    }

                                    character.endFrame = emptyCharacter.endFrame;
                                }

                                break;
                            }

                            const prevEmptyCharacter = layer
                                .getActiveEmptyCharacter(prevFrame);

                            if (prevEmptyCharacter) {

                                prevEmptyCharacter.endFrame = emptyCharacter.endFrame;

                            } else {

                                // 移動元と移動先が異なるレイヤーの時は空のキーフレームを追加
                                if (selectLayerId !== targetLayerId) {
                                    layer.addEmptyCharacter(new EmptyCharacter({
                                        "startFrame": 1,
                                        "endFrame": emptyCharacter.endFrame
                                    }));
                                }

                            }
                        }

                        break;
                    }
                }
            }

            // 移動先に選択したDisplayObjectをセット
            for (const character of characters.values()) {

                // 横移動の補正
                if (distFrame !== frame) {
                    character.move(distFrame - frame);
                }

                // 最終位置の補正
                if (character.endFrame === endFrame
                    && distLastFrame > endFrame
                ) {

                    // tweenがあれば、tweenの最終フレームを補正
                    const keyFrame = character.endFrame - 1;
                    if (character.hasPlace(keyFrame)) {
                        const place = character.getPlace(keyFrame);
                        if (place.tweenFrame) {

                            for (let frame = keyFrame + 1; distLastFrame > frame; ++frame) {
                                character.setPlace(frame,
                                    character.getClonePlace(keyFrame)
                                );
                            }

                            character
                                .getTween(place.tweenFrame)
                                .endFrame = distLastFrame;

                            // 再計算
                            Util
                                .$tweenController
                                .relocationPlace(character, keyFrame);
                        }
                    }

                    character.endFrame = distLastFrame;
                }

                targetLayer.addCharacter(character);

                // 移動先に空のキーフレームがあれば削除
                const emptyCharacter = targetLayer
                    .getActiveEmptyCharacter(character.startFrame);

                if (emptyCharacter) {
                    targetLayer.deleteEmptyCharacter(emptyCharacter);
                }
            }

            // 移動先に選択した空のキーフレームをセット
            for (let idx = 0; idx < emptys.length; ++idx) {

                const emptyCharacter = emptys[idx];

                if (distFrame !== frame) {
                    emptyCharacter.move(distFrame - frame);
                }

                // 最終位置の補正
                if (emptyCharacter.endFrame === endFrame
                    && distLastFrame > endFrame
                ) {
                    emptyCharacter.endFrame = distLastFrame;
                }

                targetLayer.addEmptyCharacter(emptyCharacter);
            }

            // 前方のキーフレームが未設定の場合は空のキーフレームを設定
            if (distFrame > 1) {

                const targetActiveCharacters = targetLayer
                    .getActiveCharacter(distFrame - 1);

                const emptyCharacter = targetLayer
                    .getActiveEmptyCharacter(distFrame - 1);

                if (!targetActiveCharacters.length && !emptyCharacter) {

                    // 結合用の変数
                    let activeCharacters = null;
                    let emptyCharacter   = null;

                    let idx = 1;
                    for ( ; ; ++idx) {

                        activeCharacters = targetLayer
                            .getActiveCharacter(distFrame - idx);

                        if (activeCharacters.length) {
                            break;
                        }

                        emptyCharacter = targetLayer
                            .getActiveEmptyCharacter(distFrame - idx);

                        if (emptyCharacter) {
                            break;
                        }

                        if (0 >= distFrame - idx) {
                            break;
                        }
                    }

                    if (!activeCharacters.length) {
                        activeCharacters = null;
                    }

                    switch (true) {

                        case activeCharacters !== null:
                            for (let idx = 0; idx < activeCharacters.length; ++idx) {

                                const character = activeCharacters[idx];

                                // tweenがあれば補正
                                let endFrame = distFrame;

                                const keyFrame = character.endFrame - 1;
                                if (character.hasPlace(keyFrame)) {

                                    const place = character.getPlace(keyFrame);
                                    if (place.tweenFrame) {

                                        for (let frame = keyFrame + 1; distFrame > frame; ++frame) {
                                            character.setPlace(frame,
                                                character.getClonePlace(keyFrame)
                                            );
                                        }

                                        if (characters.has(character.id)) {

                                            const newCharacter = characters.get(character.id);

                                            for (let frame = newCharacter.startFrame; newCharacter.endFrame > frame; ++frame) {
                                                const clonePlace = newCharacter.getClonePlace(frame);
                                                clonePlace.tweenFrame = place.tweenFrame;
                                                character.setPlace(frame, clonePlace);
                                            }

                                            character
                                                .getTween(place.tweenFrame)
                                                .endFrame = newCharacter.endFrame;

                                            endFrame = newCharacter.endFrame;

                                            characters.delete(character.id);
                                            targetLayer.deleteCharacter(newCharacter.id);

                                        } else {

                                            character
                                                .getTween(place.tweenFrame)
                                                .endFrame = endFrame;

                                        }

                                        // 再計算
                                        Util
                                            .$tweenController
                                            .relocationPlace(character, place.tweenFrame);
                                    }
                                }

                                character.endFrame = endFrame;
                            }
                            break;

                        // 空のキーフレームがあれば統合
                        case emptyCharacter !== null:
                            emptyCharacter.endFrame = distFrame;
                            break;

                        // 前方に何も定義がない時は空のキーフレームを追加
                        default:
                            targetLayer.addEmptyCharacter(new EmptyCharacter({
                                "startFrame": distFrame - idx + 1,
                                "endFrame": distFrame
                            }));
                            break;

                    }
                }
            }

            // 前後の補正、同一のアイテムなら統合
            for (const character of characters.values()) {

                // 結合用の変数に格納
                let unionCharacter = character;

                // 前のフレームを確認
                const prevFrame = character.startFrame - 1;

                if (prevFrame) {

                    const prevActiveCharacters = targetLayer
                        .getActiveCharacter(prevFrame);

                    for (let idx = 0; idx < prevActiveCharacters.length; ++idx) {

                        const prevCharacter = prevActiveCharacters[idx];

                        if (prevCharacter.libraryId !== character.libraryId) {
                            continue;
                        }

                        if (prevCharacter.endFrame !== character.startFrame) {
                            continue;
                        }

                        unionCharacter = prevCharacter;

                        for (const [keyFrame, place] of character._$places) {
                            unionCharacter.setPlace(keyFrame, place);
                        }

                        for (const [keyFrame, tweenObject] of character._$tween) {
                            unionCharacter.setTween(keyFrame, tweenObject);
                        }

                        unionCharacter.endFrame = character.endFrame;

                        // 統合元のDisplayObjectは削除
                        targetLayer.deleteCharacter(character.id);
                        break;
                    }
                }

                // 後続のフレームを確認
                const nextFrame = character.endFrame;

                const nextActiveCharacters = targetLayer
                    .getActiveCharacter(nextFrame);

                for (let idx = 0; idx < nextActiveCharacters.length; ++idx) {

                    const nextCharacter = nextActiveCharacters[idx];

                    if (nextCharacter.libraryId !== unionCharacter.libraryId) {
                        continue;
                    }

                    if (nextCharacter.startFrame !== unionCharacter.endFrame) {
                        continue;
                    }

                    for (const [keyFrame, place] of nextCharacter._$places) {
                        unionCharacter.setPlace(keyFrame, place);
                    }

                    for (const [keyFrame, tweenObject] of nextCharacter._$tween) {
                        unionCharacter.setTween(keyFrame, tweenObject);
                    }

                    unionCharacter.endFrame = nextCharacter.endFrame;

                    // 統合元のDisplayObjectは削除
                    targetLayer.deleteCharacter(nextCharacter.id);
                    break;
                }
            }

            if (targetLayerId === layerId) {

                layer.reloadStyle();

            } else {

                layer.reloadStyle();
                targetLayer.reloadStyle();

            }
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();

        // 再描画
        this.reloadScreen();

        this._$saved = false;
    }

    /**
     * @description 選択中のレイヤーを全て非選択
     *
     * @return {void}
     * @method
     * @public
     */
    clearActiveLayers ()
    {
        for (const element of this.targetLayers.values()) {
            element
                .classList
                .remove("active");
        }
        this.targetLayers.clear();
    }

    /**
     * @description 選択中のフレームをアクティブ表示に
     *
     * @return {void}
     * @method
     * @public
     */
    moveActiveFrame ()
    {
        // 表示領域の変数
        const timelineWidth = Util.$timelineTool.timelineWidth;
        const elementCount  = Util.$timelineHeader.width / (timelineWidth + 1) | 0;
        const leftFrame     = Util.$timelineHeader.leftFrame;
        const rightFrame    = leftFrame + elementCount;

        const frame = Util.$timelineTool.getFirstFrame();
        const scene = Util.$currentWorkSpace().scene;
        for (const [layerId, values] of this._$targetFrames) {

            const layer = scene.getLayer(layerId);

            // レイヤーの情報が取得できれなければスキップ
            if (!layer) {
                continue;
            }

            for (let idx = 0; idx < values.length; ++idx) {

                const targetFrame = frame + idx;

                // 表示領域より前のフレームならスキップ
                if (leftFrame > targetFrame) {
                    continue;
                }

                // 表示領域より後ろのフレームならスキップ
                if (targetFrame > rightFrame) {
                    continue;
                }

                const element = layer.getChildren(targetFrame);
                if (!element) {
                    continue;
                }

                // アクティブ表示
                element
                    .classList
                    .add("frame-active");
            }
        }
    }

    /**
     * @description 選択中のフレームを全て非選択
     *
     * @return {void}
     * @method
     * @public
     */
    clearActiveFrames ()
    {
        const workSpace = Util.$currentWorkSpace();
        if (!workSpace) {
            this.targetFrames.clear();
            this.hideTargetGroup();
            return ;
        }

        const scene = workSpace.scene;
        if (!scene) {
            this.targetFrames.clear();
            this.hideTargetGroup();
            return ;
        }

        for (const [layerId, values] of this.targetFrames) {

            const layer = scene.getLayer(layerId);
            if (!layer) {
                continue;
            }

            for (let idx = 0; idx < values.length; ++idx) {

                const element = layer.getChildren(values[idx]);
                if (!element) {
                    continue;
                }

                element.classList.remove("frame-active");
            }
        }

        // 変数を初期化
        this.targetFrames.clear();

        // グルーピングElementを非表示にする
        this.hideTargetGroup();
    }

    /**
     * @description 選択したフレームグループElementを非表示
     *
     * @return {void}
     * @method
     * @public
     */
    hideTargetGroup ()
    {
        const element = document.getElementById("target-group");
        if (element) {
            element.style.display = "none";
        }
    }

    /**
     * @description フレームの複数選択
     *
     * @param  {MouseEvent} event
     * @param  {HTMLDivElement} [select_element=null]
     * @return {void}
     * @method
     * @public
     */
    multiSelect (event, select_element = null)
    {
        const target = event
            ? event.target
            : select_element;

        const targetFrame = target.dataset.frame | 0;
        if (!targetFrame) {
            return ;
        }

        // ヘッダー領域の場合は処理をスキップ
        if (!("layerId" in target.dataset)) {
            return ;
        }

        const targetLayer = this.targetLayer;
        if (!targetLayer) {
            return ;
        }

        // 全てのイベント終了
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }

        const selectLayerId = this.targetFrames.keys().next().value | 0;
        const selectFrame   = this.targetFrames.values().next().value[0];

        const minFrame = Math.min(targetFrame, selectFrame);
        const maxFrame = Math.max(targetFrame, selectFrame) + 1;

        // 最初に選択したレイヤーと現在選択中のレイヤーの間を補完
        const selectIds = [selectLayerId];

        // 選択範囲が複数行の時は補完
        const targetLayerId = target.dataset.layerId | 0;
        if (selectLayerId !== targetLayerId) {

            const children = Array.from(
                document.getElementById("timeline-content").children
            );

            const startIndex  = children.indexOf(targetLayer);
            const targetIndex = children.indexOf(
                document.getElementById(`layer-id-${targetLayerId}`)
            );

            if (targetIndex > startIndex) {
                const length = targetIndex - startIndex + 1;
                for (let idx = 1; idx < length; ++idx) {
                    selectIds.push(
                        children[startIndex + idx].dataset.layerId | 0
                    );
                }
            } else {
                const length = startIndex - targetIndex + 1;
                for (let idx = 1; idx < length; ++idx) {
                    selectIds.push(
                        children[startIndex - idx].dataset.layerId | 0
                    );
                }
            }
        }

        // フレームのアクティブ表示を初期化
        this.clearActiveFrames();

        // 再度、選択した範囲でアクティブ計算を行う
        const scene = Util.$currentWorkSpace().scene;
        for (let idx = 0; idx < selectIds.length; ++idx) {

            const layerId = selectIds[idx] | 0;
            const layer = scene.getLayer(layerId);
            for (let frame = minFrame; frame < maxFrame; ++frame) {
                this.addTargetFrame(layer, frame);
            }
        }

        // 最初に選択したフレームの順番を補正
        const frames = this.targetFrames.get(selectLayerId);
        frames.splice(frames.indexOf(selectFrame), 1);
        frames.unshift(selectFrame);

        // 再描画後にアクティブ判定を行う
        this.activeCharacter();
    }

    /**
     * @description フレームの複数洗濯を終了
     *
     * @return {void}
     * @method
     * @public
     */
    endMultiSelect ()
    {
        Util.$setCursor("auto");
        window.removeEventListener("mousemove", this._$multiSelect);
        window.removeEventListener("mouseup", this._$endMultiSelect);
    }
}

Util.$timelineLayer = new TimelineLayer();

/**
 * @class
 * @extends {BaseTimeline}
 * @memberOf view.timeline
 */
class TimelineLayerMenu extends BaseTimeline
{

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "timeline-layer-normal",
            "timeline-layer-mask",
            "timeline-layer-guide",
            "timeline-layer-copy",
            "timeline-layer-paste"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document
                .getElementById(elementIds[idx]);

            if (!element) {
                continue;
            }

            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event);
            });
        }

        // レイヤーカラー変更のイベント登録
        const element = document.getElementById("timeline-layer-color");
        if (element) {
            element.addEventListener("change", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                this.changeLayerHighlightColor(event);
            });
        }

        const select = document.getElementById("timeline-layer-scale");
        if (select) {
            select.addEventListener("change", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // メニューを非表示
                Util.$endMenu();

                // レイヤーの高さを変更
                this.changeLayerScale(event);
            });
        }
    }

    /**
     * @description レイヤーの高さを変更
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    changeLayerScale (event)
    {
        const scale = +event.target.value;

        const defaultHeight = TimelineTool.DEFAULT_TIMELINE_HEIGHT - 1;

        Util.$timelineTool.timelineHeight = defaultHeight * scale;
    }

    /**
     * @description ノーマルレイヤーに変更
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerNormal ()
    {
        // 表示モーダルを全て終了
        Util.$endMenu();

        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const scene   = Util.$currentWorkSpace().scene;
        const layerId = targetLayer.dataset.layerId | 0;

        const layer = scene.getLayer(layerId);
        if (layer.mode === LayerMode.NORMAL) {
            return ;
        }

        // 状態を保存
        this.save();

        const reload = this.resetLayer(targetLayer);

        layer.mode = LayerMode.NORMAL;
        layer.showIcon();

        if (reload) {
            this.reloadScreen();
        }

        // 初期化
        super.focusOut();
    }

    /**
     * @description マスクレイヤーに変更
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerMask ()
    {
        // 表示モーダルを全て終了
        Util.$endMenu();

        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                targetLayer.dataset.layerId | 0
            );

        if (layer.mode === LayerMode.MASK) {
            return ;
        }

        // 状態を保存
        this.save();

        const reload = this.resetLayer(targetLayer);

        layer.mode = LayerMode.MASK;
        layer.showIcon();

        if (reload || layer.lock) {
            this.reloadScreen();
        }

        // 初期化
        super.focusOut();
    }

    /**
     * @description 指定したレイヤーをコピー
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerCopy ()
    {
        // 表示モーダルを全て終了
        Util.$endMenu();

        Util.$timelineMenu.executeContextMenuLayerCopy();
    }

    /**
     * @description 指定したレイヤーの上部にコピーした情報を貼り付け
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerPaste ()
    {
        // 表示モーダルを全て終了
        Util.$endMenu();

        Util.$timelineMenu.executeContextMenuLayerPaste();
    }

    /**
     * @description ガイドレイヤーに変更
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerGuide ()
    {
        // 表示モーダルを全て終了
        Util.$endMenu();

        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                targetLayer.dataset.layerId | 0
            );

        if (layer.mode === LayerMode.GUIDE) {
            return ;
        }

        // 状態を保存
        this.save();

        const reload = this.resetLayer(targetLayer);

        layer.mode = LayerMode.GUIDE;
        layer.showIcon();

        if (reload) {
            this.reloadScreen();
        }

        // 初期化
        super.focusOut();
    }

    /**
     * @description レイヤーのハイライトカラーの変更処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    changeLayerHighlightColor (event)
    {
        this.save();

        const layerId = event.target.dataset.layerId | 0;
        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layerId);

        // レイヤーオブジェクトを更新
        layer.color = event.target.value;

        const lightIcon = document
            .getElementById(`layer-light-icon-${layerId}`);

        lightIcon
            .style
            .backgroundImage = `url('${layer.getHighlightURL()}')`;

        if (layer.light) {
            document
                .getElementById(`layer-id-${layerId}`)
                .style
                .borderBottom = `1px solid ${layer.color}`;
        }

        // 初期化
        super.focusOut();

        // モーダルも終了
        Util.$endMenu();
    }

    /**
     * @description レイヤー切り替え時にマスクとガイドの入れ子を初期化する
     *
     * @param  {HTMLDivElement} element
     * @return {boolean}
     * @method
     * @public
     */
    resetLayer (element)
    {
        const scene = Util.$currentWorkSpace().scene;

        const layer = scene.getLayer(element.dataset.layerId | 0);

        const children = Array.from(
            document.getElementById("timeline-content").children
        );

        let reload = false;
        let index  = children.indexOf(element);
        switch (layer.mode) {

            case LayerMode.MASK:
                for (;;) {
                    const node = children[++index];
                    if (!node) {
                        break;
                    }

                    const layer = scene.getLayer(node.dataset.layerId | 0);
                    if (layer.mode !== LayerMode.MASK_IN) {
                        break;
                    }

                    layer.maskId = null;
                    layer.mode   = LayerMode.NORMAL;
                    layer.showIcon();

                    reload = true;
                }
                break;

            case LayerMode.GUIDE:
                for (;;) {
                    const node = children[++index];
                    if (!node) {
                        break;
                    }

                    const layer = scene.getLayer(node.dataset.layerId | 0);
                    if (layer.mode !== LayerMode.GUIDE_IN) {
                        break;
                    }

                    layer.guideId = null;
                    layer.mode    = LayerMode.NORMAL;
                    layer.showIcon();
                }
                break;

            default:
                break;

        }

        return reload;
    }

    /**
     * @description レイヤー切り替えのモーダルを表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    show (event)
    {
        // 全てのイベントを中止
        event.stopPropagation();

        Util.$endMenu("timeline-layer-menu");

        const layerId = event.target.dataset.layerId | 0;
        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(layerId);

        const input = document
            .getElementById("timeline-layer-color");

        input.dataset.layerId = `${layerId}`;
        input.value = layer.color;

        const element = document
            .getElementById("timeline-layer-menu");

        element.style.left = `${event.pageX + 5}px`;
        element.style.top  = `${event.pageY - element.clientHeight}px`;
        if (15 > element.offsetTop) {
            element.style.top = "10px";
        }

        if (event.pageY + 15 > window.innerHeight) {
            element.style.top = `${event.pageY - element.clientHeight - 15}px`;
        }

        element.setAttribute("class", "fadeIn");
    }
}

Util.$timelineLayerMenu = new TimelineLayerMenu();

/**
 * @class
 * @extends {BaseTimeline}
 * @memberOf view.timeline
 */
class TimelineMarker extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$left = 0;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$pointerEvents = "";

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$moveMarker = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endMarker = null;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document.getElementById("timeline-marker");
        if (element) {
            element.addEventListener("mousedown", (event) =>
            {
                if (event.button) {
                    return ;
                }
                this.startMarker();
            });
        }
    }

    /**
     * @description マーカーElementの移動準備関数
     *
     * @return {void}
     * @method
     * @public
     */
    startMarker ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        // 全てのアクティブを解除
        tool.clear();

        // マーカーElementをイベント管理外に設定
        this._$pointerEvents = "none";
        document
            .getElementById("timeline-marker")
            .setAttribute(
                "style",
                `left: ${this._$left}px; pointer-events: none;`
            );

        if (!this._$moveMarker) {
            this._$moveMarker = this.moveMarker.bind(this);
        }
        if (!this._$endMarker) {
            this._$endMarker = this.endMarker.bind(this);
        }

        window.addEventListener("mousemove", this._$moveMarker);
        window.addEventListener("mouseup", this._$endMarker);

        // ラベル処理を強制的に発火
        document
            .getElementById("label-name")
            .blur();
    }

    /**
     * @description マーカーElementの移動処理関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveMarker (event)
    {
        Util.$setCursor("ew-resize");

        window.requestAnimationFrame(() =>
        {
            const base = document
                .getElementById("timeline-controller-base");

            const timelineWidth = Util.$timelineTool.timelineWidth;

            // タイムラインエリア外(右側)にマウスが出た時の処理
            if (event.pageX + timelineWidth > base.offsetLeft + base.offsetWidth) {

                const frame = (event.pageX + timelineWidth * 2
                    - (base.offsetLeft + base.offsetWidth)) / timelineWidth | 0;

                if (!frame) {
                    return ;
                }

                // フレーム更新してマーカーを移動
                Util.$timelineFrame.currentFrame += frame;
                Util.$timelineHeader.scrollX += frame * timelineWidth;
                Util.$timelineHeader.rebuild();
                Util.$timelineLayer.moveTimeLine();
                this.move();

                // 現在のフレームで再描画
                this.reloadScreen();

                return ;
            }

            // タイムラインエリア外(左側)にマウスが出た時の処理
            if (base.offsetLeft > event.pageX - timelineWidth) {

                let frame = (base.offsetLeft - event.pageX - timelineWidth) / timelineWidth | 0;
                if (!frame || Util.$timelineFrame.currentFrame === 1) {
                    return ;
                }

                if (frame > 0) {
                    frame *= -1;
                }

                // フレーム更新してマーカーを移動
                Util.$timelineFrame.currentFrame += frame;
                Util.$timelineHeader.scrollX += frame * timelineWidth;
                Util.$timelineHeader.rebuild();
                Util.$timelineLayer.moveTimeLine();
                this.move();

                // 現在のフレームで再描画
                this.reloadScreen();

                return ;
            }

            let frame = event.target.dataset.frame | 0;
            if (!frame) {
                return ;
            }

            const currentFrame = Util.$timelineFrame.currentFrame;
            if (currentFrame === frame) {
                return ;
            }

            // フレームを移動
            Util.$timelineFrame.currentFrame = frame;
            this.move();

            // 現在のフレームで再描画
            this.reloadScreen();
        });
    }

    /**
     * @description マーカーElementの移動終了関数
     *
     * @return {void}
     * @method
     * @public
     */
    endMarker ()
    {
        Util.$setCursor("auto");

        // グローバルイベントを削除
        window.removeEventListener("mousemove", this._$moveMarker);
        window.removeEventListener("mouseup", this._$endMarker);

        // マウスダウン用にイベント対象に変更
        this._$pointerEvents = "";
        document
            .getElementById("timeline-marker")
            .setAttribute(
                "style",
                `left: ${this._$left}px;`
            );

        // ラベルがあればInputElementに挿入
        const label = Util
            .$currentWorkSpace()
            .scene
            .getLabel(
                Util.$timelineFrame.currentFrame
            );

        document
            .getElementById("label-name")
            .value = label ? label : "";
    }

    /**
     * @description タイムラインのマーカーを指定フレームへ設置
     *
     * @return {void}
     * @method
     * @public
     */
    move ()
    {
        const element = document.getElementById("timeline-marker");
        if (!element) {
            return ;
        }

        const timelineWidth = Util.$timelineTool.timelineWidth;
        const scrollX = Util.$timelineHeader.scrollX;

        // +1はborder solidの1pxを加算
        const width = timelineWidth + 1;
        const frame = 1 + scrollX / timelineWidth | 0;

        const index = Util.$timelineFrame.currentFrame - frame;
        this._$left = index * width;

        let style = `left: ${this._$left}px;`;
        if (this._$pointerEvents) {
            style += "pointer-events: none;";
        }
        element.setAttribute("style", style);

        // マーカーのボーダーの座標をセット
        this.setMarkerPosition();
    }

    /**
     * @description マーカーのボーダーの座標をセット
     *
     * @return {void}
     * @method
     * @public
     */
    setMarkerPosition ()
    {
        const element = document.getElementById("timeline-marker");
        if (!element) {
            return ;
        }

        const content = document
            .getElementById("timeline-content");
        if (!content) {
            return ;
        }

        const border = document
            .getElementById("timeline-marker-border");
        if (!border) {
            return ;
        }

        const markerLeft = element.offsetLeft;
        const offsetX    = 318;
        const toolWidth  = 45;

        // 表示外なら非表示
        if (0 > markerLeft
            || content.clientWidth
            && markerLeft + offsetX - toolWidth >= content.clientWidth
        ) {
            border.setAttribute("style", "display: none;");
            return ;
        }

        const left   = offsetX + element.clientWidth / 2 + markerLeft;
        const top    = content.offsetTop - 1;
        const height = window.screen.height;

        border.setAttribute(
            "style", `height: ${height}px; top: ${top | 0}px; left: ${left | 0}px;`
        );
    }
}

Util.$timelineMarker = new TimelineMarker();

/**
 * @class
 * @extends {BaseTimeline}
 * @memberOf view.timeline
 */
class TimelineMenu extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$copyWorkSpaceId = -1;

        /**
         * @type {array}
         * @private
         */
        this._$copyLayers = [];

        /**
         * @type {Map}
         * @private
         */
        this._$copyFrames = new Map();
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "context-menu-script-add",
            "context-menu-frame-add",
            "context-menu-key-frame-add",
            "context-menu-empty-key-frame-add",
            "context-menu-frame-delete",
            "context-menu-key-frame-delete",
            "context-menu-tween-add",
            "context-menu-tween-delete",
            "context-menu-frame-copy",
            "context-menu-frame-paste",
            "context-menu-layer-copy",
            "context-menu-layer-paste",
            "context-menu-layer-clone",
            "context-menu-first-frame",
            "context-menu-last-frame",
            "context-menu-key-frame-change"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document
                .getElementById(elementIds[idx]);

            if (!element) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // メニューを非表示
                Util.$endMenu();

                // id名で関数を実行
                this.executeFunction(event);
            });
        }
    }

    /**
     * @description 指定した範囲にキーフレームに変換
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuKeyFrameChange ()
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        this.save();

        const scene = Util.$currentWorkSpace().scene;

        let sortFrame = null;
        const targetFrames = Util.$timelineLayer.targetFrames;
        for (let [layerId, frames] of targetFrames) {

            const layer = scene.getLayer(layerId);

            // 何も配置されてないレイヤーならスキップ
            if (!layer._$characters.length && !layer._$emptys.length) {
                continue;
            }

            // 昇順
            if (!sortFrame) {
                sortFrame = frames.slice().sort((a, b) =>
                {
                    switch (true) {

                        case a > b:
                            return 1;

                        case a < b:
                            return -1;

                        default:
                            return 0;

                    }
                });
            }

            for (let idx = 0; idx < sortFrame.length; ++idx) {

                const frame = sortFrame[idx];

                const characters = layer.getActiveCharacter(frame);

                // 配置されたDisplayObjectがあればクローン
                if (characters.length) {

                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];

                        // tween対応
                        const place = character.getPlace(frame);
                        if (place.tweenFrame) {

                            const tweenFrame = place.tweenFrame;

                            const tween = character.getTween(tweenFrame);

                            // place objectのtweenフレームを書き換え
                            for (let ketFrame = frame; tween.endFrame > ketFrame; ++ketFrame) {
                                const place = character.getPlace(ketFrame);
                                place.tweenFrame = frame;
                            }

                            // クローンを生成して配置
                            const cloneTween = character
                                .getCloneTween(tweenFrame);

                            cloneTween.startFrame = frame;
                            cloneTween.endFrame   = tween.endFrame;
                            character.setTween(frame, cloneTween);

                            // 前方のtweenの終了位置を修正
                            tween.endFrame = frame;

                            continue;
                        }

                        // キーフレームがあればスキップ
                        if (character.hasPlace(frame)) {
                            continue;
                        }

                        // クローンを配置
                        character.setPlace(frame,
                            character.getClonePlace(frame)
                        );
                    }

                    continue;
                }

                // 空のキーフレームがあれば分割
                const emptyCharacter = layer.getActiveEmptyCharacter(frame);
                if (!emptyCharacter || emptyCharacter.startFrame === frame) {
                    continue;
                }

                layer.addEmptyCharacter(new EmptyCharacter({
                    "startFrame": frame,
                    "endFrame": emptyCharacter.endFrame
                }));

                // fixed logic
                emptyCharacter.endFrame = frame;
            }

            layer.reloadStyle();
        }

        // 選択したフレームをアクティブ表示
        Util.$timelineTool.setActiveFrame();

        this._$saved = false;
    }

    /**
     * @description 指定したフレームをコピー
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuFirstFrame ()
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();

        // フレーム1に設定
        Util.$timelineFrame.currentFrame = 1;

        // スクロール位置を調整
        Util.$timelineHeader.scrollX = 0;

        // タイムラインヘッダーを再構成
        Util.$timelineHeader.rebuild();

        // マーカーを移動
        Util.$timelineMarker.move();

        // タイムラインを移動
        Util.$timelineLayer.moveTimeLine();

        // レイヤーを選択
        Util.$timelineLayer.targetLayer = targetLayer;

        // 選択したフレームElementをMapに登録
        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                targetLayer.dataset.layerId | 0
            );

        Util.$timelineLayer.addTargetFrame(layer, 1);

        // 再描画
        this.reloadScreen();
    }

    /**
     * @description 指定したフレームをコピー
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuLastFrame ()
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const totalFrame = Util.$currentWorkSpace().scene.totalFrame;
        if (2 > totalFrame) {
            return ;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();

        const timelineWidth = Util.$timelineTool.timelineWidth;

        // 最終フレームにセット
        Util.$timelineFrame.currentFrame = totalFrame;

        // スクロール位置を調整
        Util.$timelineHeader.scrollX = (totalFrame - 1) * timelineWidth;

        // タイムラインヘッダーを再構成
        Util.$timelineHeader.rebuild();

        // マーカーを移動
        Util.$timelineMarker.move();

        // タイムラインを移動
        Util.$timelineLayer.moveTimeLine();

        // レイヤーを選択
        Util.$timelineLayer.targetLayer = targetLayer;

        // 選択したフレームElementをMapに登録
        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                targetLayer.dataset.layerId | 0
            );

        Util.$timelineLayer.addTargetFrame(layer, totalFrame);

        // 再描画
        this.reloadScreen();
    }

    /**
     * @description 指定したフレームをコピー
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuFrameCopy ()
    {
        // コピー元のワークスペースのIDをセット
        this._$copyWorkSpaceId = Util.$activeWorkSpaceId;

        // コピーレイヤーの配列を初期化
        this._$copyFrames.clear();

        const targetFrames = Util.$timelineLayer.targetFrames;
        for (let [layerId, frames] of targetFrames) {
            this._$copyFrames.set(layerId, frames.slice());
        }
    }

    /**
     * @description 指定したフレームにコピーした情報を貼り付け
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuFramePaste ()
    {
        console.log("TODO executeContextMenuFramePaste");
    }

    /**
     * @description コピー情報を初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clearCopy ()
    {
        this._$copyWorkSpaceId   = -1;
        this._$copyLayers.length = 0;
    }

    /**
     * @description 指定したレイヤーをコピー
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuLayerCopy ()
    {
        // 初期化
        this.clearCopy();

        // コピー元のワークスペースのIDをセット
        this._$copyWorkSpaceId = Util.$activeWorkSpaceId;

        const targetLayers = Util.$timelineLayer.targetLayers;

        const scene = Util.$currentWorkSpace().scene;
        for (const layerElement of targetLayers.values()) {
            const layer = scene.getLayer(
                layerElement.dataset.layerId | 0
            );

            this._$copyLayers.push(layer.clone());
        }
    }

    /**
     * @description 指定したレイヤーの上部にコピーした情報を貼り付け
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuLayerPaste ()
    {
        const element = document.getElementById("timeline-content");
        if (!element) {
            return ;
        }

        const fromWorkSpace = Util.$workSpaces[this._$copyWorkSpaceId];
        const toWorkSpace   = Util.$currentWorkSpace();

        // 状態保存
        this.save();

        let targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            Util.$timelineLayer.attachLayer();
            targetLayer = Util.$timelineLayer.targetLayer;
        }

        const scene = toWorkSpace.scene;

        // ワークスペースが異なる場合は依存するライブラリを移動する
        if (this._$copyWorkSpaceId !== Util.$activeWorkSpaceId) {

            const targetWorkSpace = Util.$workSpaces[this._$copyWorkSpaceId];
            if (!targetWorkSpace) {
                return ;
            }

            // マッピングを初期化
            Util.$confirmModal.clear();

            const mapping = Util.$confirmModal._$mapping;
            for (let idx = 0; idx < this._$copyLayers.length; ++idx) {

                const layer = this._$copyLayers[idx];

                const newLayer = new Layer();
                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                    const character = layer._$characters[idx];

                    // コピー元のidのインクリメント防止でobjectから複製を生成
                    const activeWorkSpaceId = Util.$activeWorkSpaceId;
                    Util.$activeWorkSpaceId = this._$copyWorkSpaceId;

                    const cloneCharacter = new Character(
                        JSON.parse(JSON.stringify(character.toObject()))
                    );

                    // 初期化
                    cloneCharacter._$id = toWorkSpace._$characterId++;
                    Util.$activeWorkSpaceId = activeWorkSpaceId;

                    const libraryId = cloneCharacter.libraryId;

                    // 既に複製したアイテムなら処理を短縮
                    if (mapping.has(libraryId)) {

                        // コピー元のidのインクリメント防止でobjectから複製を生成
                        const activeWorkSpaceId = Util.$activeWorkSpaceId;
                        Util.$activeWorkSpaceId = this._$copyWorkSpaceId;

                        const cloneCharacter = new Character(JSON.parse(JSON.stringify(
                            character.toObject()
                        )));
                        Util.$activeWorkSpaceId = activeWorkSpaceId;

                        // コピー先の情報をセット
                        cloneCharacter.libraryId = mapping.get(libraryId);

                        // レイヤーに追加
                        newLayer.addCharacter(cloneCharacter);
                        continue;
                    }

                    // コピー元のアイテムがなければスキップ
                    const instance = fromWorkSpace.getLibrary(libraryId);
                    if (!instance) {
                        continue;
                    }

                    const path = instance
                        .getPathWithWorkSpace(fromWorkSpace);

                    if (toWorkSpace._$nameMap.has(path)) {
                        Util.$confirmModal.files.push({
                            "file": instance,
                            "character": cloneCharacter,
                            "layer": newLayer,
                            "path": path,
                            "workSpaceId": this._$copyWorkSpaceId,
                            "type": "copy"
                        });
                        continue;
                    }

                    // レイヤーに追加
                    newLayer.addCharacter(cloneCharacter);

                    // ライブラリへアイテムを複製
                    let clone = null;
                    if (instance.type === InstanceType.MOVIE_CLIP) {

                        clone = Util
                            .$confirmModal
                            .cloneMovieClip(this._$copyWorkSpaceId, instance);

                    } else {

                        const activeWorkSpaceId = Util.$activeWorkSpaceId;
                        Util.$activeWorkSpaceId = this._$copyWorkSpaceId;

                        clone = instance.clone();
                        Util.$activeWorkSpaceId = activeWorkSpaceId;

                    }

                    // 新しいIDを付与
                    const id = toWorkSpace.nextLibraryId;
                    cloneCharacter.libraryId = clone._$id = id;

                    // 重複管理
                    mapping.set(instance.id, clone.id);

                    // Elementを追加
                    Util
                        .$libraryController
                        .createInstance(
                            clone.type,
                            clone.name,
                            clone.id,
                            clone.symbol
                        );

                    // 内部データに追加
                    toWorkSpace._$libraries.set(clone.id, clone);

                    // フォルダ内にあればフォルダを生成
                    if (clone.folderId) {
                        Util
                            .$confirmModal
                            .createFolder(
                                this._$copyWorkSpaceId, clone
                            );
                    }
                }

                // 空のキーフレームをコピー
                for (let idx = 0; idx < layer._$emptys.length; ++idx) {
                    newLayer.addEmptyCharacter(
                        layer._$emptys[idx].clone()
                    );
                }

                scene.addLayer(newLayer);

                const addElement = element.lastElementChild;
                element.insertBefore(addElement, targetLayer);
            }

            // 追加したライブラリを再構成
            Util.$libraryController.reload();

        } else {

            // コピーしたLayerを複製して、DisplayObjectのIDを再発行
            for (let idx = 0; idx < this._$copyLayers.length; ++idx) {

                const layer = this._$copyLayers[idx];

                const cloneLayer = layer.clone();
                scene.addLayer(cloneLayer);

                // レイヤーのDisplayObjectのmappingを初期化
                cloneLayer._$instances.clear();

                // 配置されたレイヤーのIDをセット
                for (let idx = 0; idx < cloneLayer._$characters.length; ++idx) {

                    const character = cloneLayer._$characters[idx];

                    // 新しいIDを付与
                    character._$id = toWorkSpace._$characterId++;
                    cloneLayer._$instances.set(character.id, character);
                }

                const addElement = element.lastElementChild;
                element
                    .insertBefore(addElement, targetLayer);

            }
        }

        // 保存用のObjectの順番も入れ替える
        const layers = [];
        for (let idx = 0; idx < element.children.length; ++idx) {
            layers.push(
                scene.getLayer(element.children[idx].dataset.layerId | 0)
            );
        }

        scene.clearLayer();
        for (let idx = 0; idx < layers.length; ++idx) {
            const layer = layers[idx];
            scene.setLayer(layer.id, layer);
        }

        // 確認モーダルを表示
        if (Util.$confirmModal.files.length) {
            Util.$confirmModal.show();
        } else {
            Util.$confirmModal.clear();
        }

        // 再描画
        this.reloadScreen();

        // リセット
        super.focusOut();
    }

    /**
     * @description 指定したレイヤーの上部にコピーした情報を複製
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuLayerClone ()
    {
        this.executeContextMenuLayerCopy();
        this.executeContextMenuLayerPaste();
    }

    /**
     * @description JavaScript編集モーダルを起動
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuScriptAdd ()
    {
        Util.$javaScriptEditor.show();
    }

    /**
     * @description タイムラインにフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuFrameAdd ()
    {
        Util.$timelineTool.executeTimelineFrameAdd();
    }

    /**
     * @description タイムラインにキーフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuKeyFrameAdd ()
    {
        Util.$timelineTool.executeTimelineKeyAdd();
    }

    /**
     * @description タイムラインにキーフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuKeyFrameDelete ()
    {
        Util.$timelineTool.executeTimelineKeyDelete();
    }

    /**
     * @description タイムラインに空のキーフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuEmptyKeyFrameAdd ()
    {
        Util.$timelineTool.executeTimelineEmptyAdd();
    }

    /**
     * @description タイムラインのフレームを削除する
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuFrameDelete ()
    {
        Util.$timelineTool.executeTimelineFrameDelete();
    }

    /**
     * @description 指定のレイヤーにtweenを追加
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuTweenAdd ()
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                targetLayer.dataset.layerId | 0
            );

        const characters = layer.getActiveCharacter(frame);
        if (!characters.length) {
            return ;
        }

        if (characters.length > 1) {
            alert(
                "If you want to add motion tweening to multiple objects, please do so in a single MovieClip."
            );
            return ;
        }

        /**
         * @param {Character}
         */
        const character = characters[0];
        const range = character.getRange(frame);

        // すでに、tweenの設定があればスキップ
        if (character.hasTween(range.startFrame)) {
            return ;
        }

        this.save();

        character.setTween(range.startFrame, {
            "method": "linear",
            "curve": [],
            "custom": Util.$tweenController.createEasingObject(),
            "startFrame": range.startFrame,
            "endFrame": range.endFrame
        });

        character.updateTweenPlace(range.startFrame, range.endFrame);

        //  tweenの座標を再計算してポインターを再配置
        character.relocationTween(range.startFrame);

        // タイムラインを再描画
        layer.reloadStyle();

        // 再描画
        character.dispose();
        this.reloadScreen();

        this._$saved = false;
    }

    /**
     * @description 指定のレイヤーのtweenを削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeContextMenuTweenDelete ()
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const scene = Util.$currentWorkSpace().scene;
        for (let [layerId, frames] of Util.$timelineLayer.targetFrames) {

            const layer = scene.getLayer(layerId);

            for (let idx = 0; idx < frames.length; ++idx) {

                const frame = frames[idx];
                const characters = layer.getActiveCharacter(frame);
                if (!characters.length || characters.length > 1) {
                    continue ;
                }

                /**
                 * @param {Character}
                 */
                const character = characters[0];
                const range = character.getRange(frame);

                // tweenの設定がなければスキップ
                if (!character.hasTween(range.startFrame)) {
                    continue ;
                }

                this.save();

                // tweenで作成したplace objectを削除
                for (let frame = range.startFrame + 1; range.endFrame > frame; ++frame) {
                    if (!character.hasPlace(frame)) {
                        continue;
                    }
                    character.deletePlace(frame);
                }

                // tweenのマスタを削除
                character.deleteTween(range.startFrame);

                const place = character.getPlace(range.startFrame);
                delete place.tweenFrame;

                // キャッシュを削除
                character.dispose();
            }

            // タイムラインを再描画
            layer.reloadStyle();
        }

        // tweenのポインターを削除
        Util
            .$tweenController
            .clearPointer();

        // 再描画
        this.reloadScreen();

        this._$saved = false;
    }

    /**
     * @description タイムラインのメニューを表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    show (event)
    {
        Util.$endMenu("timeline-menu");

        const element = document.getElementById("timeline-menu");

        element.style.left = `${event.pageX + 5}px`;
        element.style.top  = `${event.pageY - element.clientHeight}px`;
        if (15 > element.offsetTop) {
            element.style.top = "10px";
        }

        if (event.pageY + 15 > window.innerHeight) {
            element.style.top = `${event.pageY - element.clientHeight - 15}px`;
        }

        element.setAttribute("class", "fadeIn");
    }
}

Util.$timelineMenu = new TimelineMenu();

/**
 * @class
 * @extends {BaseTimeline}
 * @memberOf view.timeline
 */
class TimelinePlayer extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$stopFlag = true;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$repeat = false;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$totalFrame = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$startTime = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$fps = 0;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$timerId = -1;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$baseOffsetHalfWidth = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$clientWidth = 0;

        /**
         * @type {function}
         * @description null
         * @private
         */
        this._$run = null;
    }

    /**
     * @description リピート設定を返す
     *
     * @return {boolean}
     * @readonly
     * @public
     */
    get repeat ()
    {
        return this._$repeat;
    }

    /**
     * @description 再生フラグを返す
     *
     * @return {boolean}
     * @readonly
     * @public
     */
    get stopFlag ()
    {
        return this._$stopFlag;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "timeline-play",
            "timeline-stop",
            "timeline-repeat",
            "timeline-no-repeat"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const id = elementIds[idx];

            const element = document.getElementById(id);
            if (!element) {
                continue;
            }

            // ストップとリピートアイコンは初期は非表示
            switch (id) {

                case "timeline-stop":
                case "timeline-repeat":
                    element.style.display = "none";
                    break;

                default:
                    break;

            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event);

                // 全てのメニューを終了する
                Util.$endMenu();
            });
        }

        // 毎フレームの再生関数を変数にセット
        this._$run = this.run.bind(this);
    }

    /**
     * @description タイムラインのプレイヤーを再生する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelinePlay ()
    {
        if (this._$stopFlag) {

            // アクティブな再生範囲を取得(空のフレームは含めない)
            this._$totalFrame = Util
                .$currentWorkSpace()
                .scene
                .totalFrame;

            // 1フレーム以上あるタイムラインが再生対象
            if (this._$totalFrame > 1) {

                this._$stopFlag = false;

                // 先に起動しているタイマーがあれば停止する
                if (this._$timerId > -1) {
                    window.cancelAnimationFrame(this._$timerId);
                }

                // 再生位置の補正
                let frame = Util.$timelineFrame.currentFrame;
                if (frame >= this._$totalFrame) {

                    Util.$timelineFrame.currentFrame = 1;

                    // スクロールしていれば左端にセット
                    Util.$timelineHeader.scrollX = 0;

                    // タイムラインを再構成
                    Util.$timelineHeader.rebuild();
                    Util.$timelineLayer.moveTimeLine();

                    // マーカーを移動
                    Util.$timelineMarker.move();

                    // 再描画
                    this.reloadScreen();
                }

                /**
                 * @type {ArrowTool}
                 */
                const tool = Util.$tools.getDefaultTool("arrow");
                tool.clear();

                // 再生ボタンを非表示
                document
                    .getElementById("timeline-play")
                    .style.display = "none";

                // 停止ボタンを表示
                document
                    .getElementById("timeline-stop")
                    .style.display = "";

                // 現在のタイムラインの幅をキャッシュ
                const element = document
                    .getElementById("timeline-controller-base");

                this._$baseOffsetHalfWidth = element.offsetWidth / 2;
                this._$clientWidth = element.clientWidth;

                this._$startTime = window.performance.now();
                this._$fps       = 1000 / (document.getElementById("stage-fps").value | 0);
                this._$timerId   = window.requestAnimationFrame(this._$run);
            }

        } else {

            this.executeTimelineStop();

        }
    }

    /**
     * @description タイムラインのプレイヤーを停止する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineStop ()
    {
        // タイマーを終了
        window.cancelAnimationFrame(this._$timerId);

        // 変数を初期化
        this._$stopFlag = true;
        this._$timerId  = -1;

        // 再生ボタンを表示
        document
            .getElementById("timeline-play")
            .style.display = "";

        // 停止ボタンを非表示
        document
            .getElementById("timeline-stop")
            .style.display = "none";

        // 再生位置で再描画
        this.reloadScreen();
    }

    /**
     * @description タイムラインのプレイヤーの再生が最終フレームにいくと自動的に終了する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineRepeat ()
    {
        document
            .getElementById("timeline-repeat")
            .style.display = "none";

        document
            .getElementById("timeline-no-repeat")
            .style.display = "";

        this._$repeat = false;
    }

    /**
     * @description タイムラインのプレイヤーの再生をリピートする
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineNoRepeat ()
    {
        document
            .getElementById("timeline-repeat")
            .style.display = "";

        document
            .getElementById("timeline-no-repeat")
            .style.display = "none";

        this._$repeat = true;
    }

    /**
     * @description 毎フレームの再生処理
     * @param  {number} timestamp
     * @return {void}
     * @method
     * @public
     */
    run (timestamp = 0)
    {
        if (this._$stopFlag) {
            return ;
        }

        let delta = timestamp - this._$startTime;
        if (delta > this._$fps) {

            let frame = Util.$timelineFrame.currentFrame + 1;
            if (frame > this._$totalFrame) {

                if (!this._$repeat) {
                    return this.executeTimelineStop();
                }

                frame = 1;

                // スクロールしていれば左端にセット
                Util.$timelineHeader.scrollX = 0;
                Util.$timelineLayer.moveTimeLine();
            }

            // フレームを移動
            Util.$timelineFrame.currentFrame = frame;

            const timelineWidth = Util.$timelineTool.timelineWidth;
            const moveFrame     = Util.$timelineHeader.scrollX / timelineWidth | 0;

            // タイムラインの座標修正
            const deltaX = (frame - moveFrame) * (timelineWidth + 1);
            if (0 >= deltaX || deltaX > this._$clientWidth) {
                Util.$timelineHeader.scrollX = (frame - 1) * timelineWidth;
            }

            // ヘッダーを再構成
            Util.$timelineHeader.rebuild();

            // マーカーを移動
            Util.$timelineMarker.move();

            const moveX = (frame - 1) * (Util.$timelineTool.timelineWidth + 1);
            if (moveX > this._$baseOffsetHalfWidth) {
                Util.$timelineLayer.moveTimeLine();
            }

            // 描画した時間を更新
            this._$startTime = timestamp - delta % this._$fps;

            // 再描画
            this.reloadScreen();

        }

        // 描画のタイマーをセット
        this._$timerId = window.requestAnimationFrame(this._$run);
    }
}

Util.$timelinePlayer = new TimelinePlayer();

/**
 * @class
 * @extends {BaseTimeline}
 * @memberOf view.timeline
 */
class TimelineScroll extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$x = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$y = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pageX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pageY = 0;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;
    }

    /**
     * @description シーンのフレーム数に加算するフレーム数
     *
     * @return {number}
     * @const
     * @static
     * @public
     */
    static get FRAME_COUNT ()
    {
        return 600;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "timeline-scroll-bar-x",
            "timeline-scroll-bar-y"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document
                .getElementById(elementIds[idx]);

            if (!element) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();
                event.preventDefault();

                // メニューを非表示
                Util.$endMenu();

                // id名で関数を実行
                this.executeFunction(event);
            });

            // eslint-disable-next-line no-loop-func
            element.addEventListener("wheel", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();
                event.preventDefault();

                // メニューを非表示
                Util.$endMenu();

                // id名で関数を実行
                if (event.target.id === "timeline-scroll-bar-y") {
                    this.executeTimelineYBarBox(event);
                } else {
                    this.executeTimelineXBarBox(event);
                }

            }, { "passive" : false });
        }

        const wheelIds = [
            "timeline-x-bar-box",
            "timeline-y-bar-box"
        ];

        for (let idx = 0; idx < wheelIds.length; ++idx) {

            const element = document
                .getElementById(wheelIds[idx]);

            if (!element) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("wheel", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();
                event.preventDefault();

                // メニューを非表示
                Util.$endMenu();

                // id名で関数を実行
                this.executeFunction(event);

            }, { "passive" : false });
        }
    }

    /**
     * @description レイヤーの擬似スクロールのx座標
     *
     * @member {number}
     * @readonly
     * @public
     */
    get x ()
    {
        return this._$x;
    }
    set x (x)
    {
        this._$x = Math.max(0, Math.min(x, this.maxX));
        this.viewX();
    }

    /**
     * @description レイヤーの擬似スクロールのy座標
     *
     * @member {number}
     * @readonly
     * @public
     */
    get y ()
    {
        return this._$y;
    }
    set y (y)
    {
        this._$y = y;
        this.viewY();
    }

    /**
     * @description x軸のスクロール移動
     *
     * @param  {WheelEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeTimelineXBarBox (event)
    {
        const deltaX = event.deltaX | 0;
        if (!deltaX) {
            return false;
        }

        window.requestAnimationFrame(() =>
        {
            Util.$timelineScroll.execute(deltaX, 0);
        });
    }

    /**
     * @description y軸のスクロール移動
     *
     * @param  {WheelEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeTimelineYBarBox (event)
    {
        const deltaY = event.deltaY | 0;
        if (!deltaY) {
            return false;
        }

        window.requestAnimationFrame(() =>
        {
            Util.$timelineScroll.execute(0, deltaY);
        });
    }

    /**
     * @description スクロールバーのx移動処理をセット
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeTimelineScrollBarX (event)
    {
        // 初期値をセット
        this._$pageX = event.pageX;
        this._$pageY = 0;

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description スクロールバーのy移動処理をセット
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeTimelineScrollBarY (event)
    {
        // 初期値をセット
        this._$pageX = 0;
        this._$pageY = event.pageY;

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description マウス移動処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        event.stopPropagation();
        event.preventDefault();

        window.requestAnimationFrame(() =>
        {
            const scene = Util.$currentWorkSpace().scene;

            if (this._$pageY) {

                const deltaY = event.pageY - this._$pageY;
                if (deltaY) {
                    const maxHeight = scene._$layers.size * Util.$timelineTool.timelineHeight;
                    const scale = maxHeight / Util.$timelineLayer.clientHeight;
                    this.execute(0, deltaY * scale);
                }

                // 現在のポジションをセット
                this._$pageY = event.pageY;
            }

            if (this._$pageX) {

                const deltaX = event.pageX - this._$pageX;
                if (deltaX) {
                    const clientWidth   = Util.$timelineLayer.clientWidth;
                    const totalFrame    = scene.totalFrame + TimelineScroll.FRAME_COUNT;
                    const timelineWidth = Util.$timelineTool.timelineWidth;

                    // スクロールバーの幅を算出
                    const scale = totalFrame * timelineWidth / clientWidth;
                    this.execute(deltaX * scale, 0);
                }

                // 現在のポジションをセット
                this._$pageX = event.pageX;

            }
        });
    }

    /**
     * @description マウス移動で登録されたイベントを解除する
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        // 値を初期化
        this._$pageX = 0;
        this._$pageY = 0;
    }

    /**
     * @description 移動できる最大のx座標の値を返す
     *
     * @member {number}
     * @readonly
     * @public
     */
    get maxX ()
    {
        const scene = Util.$currentWorkSpace().scene;

        const clientWidth   = Util.$timelineLayer.clientWidth - 10;
        const totalFrame    = scene.totalFrame + TimelineScroll.FRAME_COUNT;
        const timelineWidth = Util.$timelineTool.timelineWidth;

        return totalFrame * timelineWidth - clientWidth;
    }

    /**
     * @description 移動できる最大のy座標の値を返す
     *
     * @member {number}
     * @readonly
     * @public
     */
    get maxY ()
    {
        const scene = Util.$currentWorkSpace().scene;
        const stopCount = Util.$timelineLayer.clientHeight / Util.$timelineTool.timelineHeight | 0;
        return (scene._$layers.size - stopCount) * Util.$timelineTool.timelineHeight;
    }

    /**
     * @description レイヤーのy軸のポジションの値を更新
     *
     * @param {number} [delta_x = 0]
     * @param {number} [delta_y = 0]
     * @method
     * @public
     */
    execute (delta_x = 0, delta_y = 0)
    {
        const workSpace = Util.$currentWorkSpace();
        if (!workSpace) {
            return ;
        }

        const scene = workSpace.scene;
        if (!scene) {
            return ;
        }

        const beforeX = this.x;
        if (delta_x) {
            this.x = Math.max(0, Math.min(this.x + delta_x, this.maxX));
            Util.$timelineHeader.scrollX = this.x;
        }

        const beforeY = this.y;
        if (delta_y) {
            const maxHeight = scene._$layers.size * Util.$timelineTool.timelineHeight;
            if (Util.$timelineLayer.clientHeight > maxHeight) {

                this.y = 0;

            } else {

                // 移動範囲があれば実行
                const stopCount = Util.$timelineLayer.clientHeight / Util.$timelineTool.timelineHeight | 0;

                // 表示の高さがスクロールの高さを超えたら非表示に
                if (stopCount >= scene._$layers.size) {
                    this.viewY();
                    return ;
                }

                this.y = Math.max(0, Math.min(this.y + delta_y, this.maxY));
            }
        }

        // 更新があれば
        if (beforeY !== this.y || beforeX !== this.x) {
            // xの時はヘッダーも再構築
            if (beforeX !== this.x) {
                Util.$timelineMarker.move();
                Util.$timelineHeader.rebuild();
            }
            // タイムラインを再構成
            Util.$timelineLayer.moveTimeLine();
        }
    }

    /**
     * @description 擬似スクロールバーの幅をセット
     *
     * @return {void}
     * @method
     * @public
     */
    updateWidth ()
    {
        const workSpace = Util.$currentWorkSpace();
        if (!workSpace) {
            return ;
        }

        const scene = workSpace.scene;
        if (!scene) {
            return ;
        }

        const clientWidth   = Util.$timelineLayer.clientWidth;
        const totalFrame    = scene.totalFrame + TimelineScroll.FRAME_COUNT;
        const timelineWidth = Util.$timelineTool.timelineWidth;

        // スクロールバーの幅を算出
        const scale = clientWidth / (totalFrame * timelineWidth);
        const width = clientWidth * scale | 0;

        // 2pxはborderの1pxの上下の分
        document
            .documentElement
            .style
            .setProperty(
                "--timeline-scroll-bar-width",
                `${width - 2}px`
            );

        // 表示判定
        this.viewX();
    }

    /**
     * @description 擬似スクロールバーの高さをセット
     *
     * @return {void}
     * @method
     * @public
     */
    updateHeight ()
    {
        const workSpace = Util.$currentWorkSpace();
        if (!workSpace) {
            return ;
        }

        const scene = workSpace.scene;
        if (!scene) {
            return ;
        }

        const clientHeight = Util.$timelineLayer.clientHeight;
        const stopCount    = clientHeight / Util.$timelineTool.timelineHeight | 0;

        // 表示する場合だけ更新
        if (scene._$layers.size > stopCount) {

            // 最小表示の高さ
            const minHeight = stopCount * Util.$timelineTool.timelineHeight | 0;

            // 最小表示の時の余白の高さ
            const spaceHeight = clientHeight - minHeight;

            // スクロールバーの高さを算出
            const scale  = clientHeight / (scene._$layers.size * Util.$timelineTool.timelineHeight);
            const height = (clientHeight - spaceHeight) * scale | 0;

            // 2pxはborderの1pxの上下の分
            document
                .documentElement
                .style
                .setProperty(
                    "--timeline-scroll-bar-height",
                    `${height - 2}px`
                );

        }

        // 表示判定
        this.viewY();
    }

    /**
     * @description xスクロールバーを表示。タイマーで一定時間に非表示に
     *
     * @return {void}
     * @method
     * @public
     */
    viewX ()
    {
        const element = document
            .getElementById("timeline-scroll-bar-x");

        if (element) {

            const workSpace = Util.$currentWorkSpace();
            if (!workSpace) {
                return ;
            }

            const scene = workSpace.scene;
            if (!scene) {
                return ;
            }

            const clientWidth   = Util.$timelineLayer.clientWidth;
            const totalFrame    = scene.totalFrame + TimelineScroll.FRAME_COUNT;
            const timelineWidth = Util.$timelineTool.timelineWidth;

            const scale = clientWidth / (totalFrame * timelineWidth);

            const x = this.x * scale | 0;

            element.style.left = `${x + 1}px`;
        }
    }

    /**
     * @description yスクロールバーを表示。タイマーで一定時間に非表示に
     *
     * @return {void}
     * @method
     * @public
     */
    viewY ()
    {
        const element = document
            .getElementById("timeline-scroll-bar-y");

        if (element) {

            const workSpace = Util.$currentWorkSpace();
            if (!workSpace) {
                return ;
            }

            const scene = workSpace.scene;
            if (!scene) {
                return ;
            }

            const stopCount = Util.$timelineLayer.clientHeight / Util.$timelineTool.timelineHeight | 0;
            if (stopCount >= scene._$layers.size) {
                element.style.display = "none";
                return ;
            }

            // 表示をon
            element.style.display = "";

            const scale = Util.$timelineLayer.clientHeight
                / (scene._$layers.size * Util.$timelineTool.timelineHeight);

            const y = this.y * scale | 0;

            element.style.top = `${y + 1}px`;
        }
    }
}

Util.$timelineScroll = new TimelineScroll();

/**
 * @class
 * @extends {BaseTimeline}
 * @memberOf view.timeline
 */
class TimelineTool extends BaseTimeline
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$labelFrame = 0;

        /**
         * @type {number}
         * @default
         * @private
         */
        this._$timelineWidth = TimelineTool.DEFAULT_TIMELINE_WIDTH;

        /**
         * @type {number}
         * @default
         * @private
         */
        this._$timelineHeight = TimelineTool.DEFAULT_TIMELINE_HEIGHT;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$lightAll = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$lockAll = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$disableAll = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$preview = false;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "timeline-layer-add",
            "timeline-layer-trash",
            "timeline-layer-light-all",
            "timeline-layer-disable-all",
            "timeline-layer-lock-all",
            "timeline-script-add",
            "timeline-frame-add",
            "timeline-key-add",
            "timeline-empty-add",
            "timeline-frame-delete",
            "timeline-onion-skin",
            "timeline-preview",
            "scene-list"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event);
            });
        }

        const inputIds = [
            "label-name"
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {

            const element = document.getElementById(inputIds[idx]);
            if (!element) {
                continue;
            }

            element.addEventListener("focusin", (event) =>
            {
                this.focusIn(event);
            });
            element.addEventListener("keypress", (event) =>
            {
                if (event.key !== "Enter") {
                    return ;
                }
                event.target.blur();
            });
            element.addEventListener("focusout", (event) =>
            {
                this.executeFunction(event);
            });
        }

        const element = document.getElementById("timeline-scale");
        if (element) {
            this.setInputEvent(element);
        }
    }

    /**
     * @description プレビュー機能のOn/Offフラグ
     *
     * @member {boolean}
     * @readonly
     * @public
     */
    get preview ()
    {
        return this._$preview;
    }

    /**
     * @description タイムライン幅の初期値
     *
     * @return {number}
     * @const
     * @static
     */
    static get DEFAULT_TIMELINE_WIDTH ()
    {
        return 13;
    }

    /**
     * @description タイムライン高さの初期値
     *
     * @return {number}
     * @const
     * @static
     */
    static get DEFAULT_TIMELINE_HEIGHT ()
    {
        return 31;
    }

    /**
     * @description タイムラインの高さを返す
     *
     * @return {number}
     * @public
     */
    get timelineHeight ()
    {
        return this._$timelineHeight;
    }
    set timelineHeight (timeline_height)
    {
        this._$timelineHeight = timeline_height;

        // タイムラインの幅を変更
        document
            .documentElement
            .style
            .setProperty("--timeline-frame-height", `${timeline_height}px`);

        // レイヤーの横スクロール幅を再計算
        Util.$timelineScroll.updateHeight();

        // タイムラインを再構成
        Util.$timelineLayer.moveTimeLine();
    }

    /**
     * @description タイムラインの幅を返す
     *
     * @member {number}
     * @public
     */
    get timelineWidth ()
    {
        return this._$timelineWidth;
    }
    set timelineWidth (timeline_width)
    {
        this._$timelineWidth = timeline_width;

        // タイムラインの幅を変更
        document
            .documentElement
            .style
            .setProperty("--timeline-frame-width", `${timeline_width}px`);

        // マーカーの幅を変更
        document
            .documentElement
            .style
            .setProperty(
                "--marker-width",
                `${Util.$clamp(timeline_width, 4, TimelineTool.DEFAULT_TIMELINE_WIDTH)}px`
            );

        // スケールInputに値を反映
        document
            .getElementById("timeline-scale")
            .value = `${timeline_width / TimelineTool.DEFAULT_TIMELINE_WIDTH * 100 | 0}`;

        // レイヤーの横スクロール幅を再計算
        Util.$timelineScroll.updateWidth();

        // フレーム幅に合わせてマーカーを移動
        Util.$timelineHeader.rebuild();
        Util.$timelineMarker.move();
    }

    /**
     * @description タイムラインツールのInput共通関数
     *
     * @return {void}
     * @method
     * @public
     */
    focusIn ()
    {
        super.focusIn();
        this._$labelFrame = Util.$timelineFrame.currentFrame;
    }

    /**
     * @description ラベル名のInput処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeLabelName (event)
    {
        if (!this._$labelFrame) {
            return ;
        }

        const leftFrame = Util.$timelineHeader.leftFrame;
        if (leftFrame > this._$labelFrame) {
            return ;
        }

        const index = this._$labelFrame - leftFrame;
        const parent = document
            .getElementById("timeline-header")
            .children[index];

        const element = parent.children[TimelineHeader.MARKER_INDEX];

        const value = event.target.value;
        const scene = Util.$currentWorkSpace().scene;
        if (value) {

            // ラベル名があれば登録
            this.save(); // 事前保存
            scene.setLabel(this._$labelFrame, value);
            element.setAttribute("class", "frame-border-box-marker");

        } else {

            // ラベル名があって、Inputが空ならラベルの削除処理を行う
            const label = scene.getLabel(this._$labelFrame);
            if (label) {
                this.save(); // 事前保存
                scene.deleteLabel(this._$labelFrame);
                element.setAttribute("class", "frame-border-box");
            }

        }

        // 初期化
        super.focusOut();
        this._$labelFrame = 0;
    }

    /**
     * @description タイムラインのスケールのInput処理
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeTimelineScale (value)
    {
        value = Util.$clamp(value | 0, 41, 2000);

        this.timelineWidth = TimelineTool.DEFAULT_TIMELINE_WIDTH * value / 100;

        // ヘッダーを再構成
        Util.$timelineHeader._$currentFrame = -1;
        Util.$timelineHeader.rebuild();

        // マーカーを移動
        Util.$timelineMarker.move();

        // 各レイヤーを再描画
        Util.$timelineLayer.moveTimeLine();

        return value;
    }

    /**
     * @description 全てのレイヤーロックをOn/Offに変更
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerLockAll ()
    {
        this._$lockAll = !this._$lockAll;

        const content = document
            .getElementById("timeline-content");

        const scene = Util.$currentWorkSpace().scene;

        let useMask = false;
        const length = content.children.length;
        for (let idx = 0; idx < length; ++idx) {

            const child   = content.children[idx];
            const layerId = child.dataset.layerId | 0;

            const element = document
                .getElementById(`layer-lock-icon-${layerId}`);

            const layer = scene.getLayer(layerId);
            if (layer.mode === LayerMode.MASK) {
                useMask = true;
            }

            if (this._$lockAll) {

                element
                    .classList
                    .remove("icon-disable");

                element
                    .classList
                    .add("icon-active");

                layer.lock = true;

            } else {

                element
                    .classList
                    .remove("icon-active");

                element
                    .classList
                    .add("icon-disable");

                layer.lock = false;

            }

            if (useMask) {
                this.reloadScreen();
            }
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clear();
    }

    /**
     * @description 全てのレイヤーを表示/非表示に変更
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerDisableAll ()
    {
        this._$disableAll = !this._$disableAll;

        const content = document
            .getElementById("timeline-content");

        const scene = Util.$currentWorkSpace().scene;

        const length = content.children.length;
        for (let idx = 0; idx < length; ++idx) {

            const child   = content.children[idx];
            const layerId = child.dataset.layerId | 0;

            const element = document
                .getElementById(`layer-disable-icon-${layerId}`);

            const layer = scene.getLayer(layerId);
            if (this._$disableAll) {

                element
                    .classList
                    .remove("icon-disable");

                element
                    .classList
                    .add("icon-active");

                layer.disable = true;

            } else {

                element
                    .classList
                    .remove("icon-active");

                element
                    .classList
                    .add("icon-disable");

                layer.disable = false;

            }

            /**
             * @type {ArrowTool}
             */
            const tool = Util.$tools.getDefaultTool("arrow");
            tool.clear();

            this.reloadScreen();
        }
    }

    /**
     * @description 全てのハイライトをOn/Offに変更
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerLightAll ()
    {
        this._$lightAll = !this._$lightAll;

        const content = document
            .getElementById("timeline-content");

        const scene = Util.$currentWorkSpace().scene;

        const length = content.children.length;
        for (let idx = 0; idx < length; ++idx) {

            const child   = content.children[idx];
            const layerId = child.dataset.layerId | 0;

            const element = document
                .getElementById(`layer-light-icon-${layerId}`);

            const parent = document
                .getElementById(`layer-id-${layerId}`);

            const layer = scene.getLayer(layerId);
            if (this._$lightAll) {

                element
                    .classList
                    .remove("icon-disable");

                element
                    .classList
                    .add("light-icon-active");

                parent
                    .style
                    .borderBottom = `1px solid ${layer.color}`;

                layer.light = true;

            } else {

                element
                    .classList
                    .remove("light-icon-active");

                element
                    .classList
                    .add("icon-disable");

                parent
                    .style
                    .borderBottom = "";

                layer.light = false;

            }

        }
    }

    /**
     * @description 選択中のレイヤーをタイムラインから削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerTrash ()
    {
        const targetLayers = Util.$timelineLayer.targetLayers;
        if (targetLayers.size) {

            // 変更前の情報を保存
            this.save();

            const scene = Util.$currentWorkSpace().scene;

            // setup
            const parentElement = document
                .getElementById("timeline-content");

            let currentIndex = Array
                .from(parentElement.children)
                .indexOf(Util.$timelineLayer.targetLayer);

            let reload = false;
            const frame = Util.$timelineFrame.currentFrame;
            for (const element of targetLayers.values()) {

                const index = Array
                    .from(parentElement.children)
                    .indexOf(element);

                // マスクの対象となっているレイヤーを元に戻す
                const layerId = element.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const children = parentElement.children;
                switch (layer.mode) {

                    case LayerMode.MASK:
                        for (let idx = index + 1; idx < children.length; ++idx) {

                            const child = children[idx];

                            const layer = scene.getLayer(
                                child.dataset.layerId | 0
                            );

                            if (layer.mode !== LayerMode.MASK_IN) {
                                break;
                            }

                            layer.mode = LayerMode.NORMAL;
                            layer.showIcon();

                        }
                        break;

                    case LayerMode.GUIDE:
                        for (let idx = index + 1; idx < children.length; ++idx) {

                            const child = children[idx];

                            const layer = scene.getLayer(
                                child.dataset.layerId | 0
                            );

                            if (layer.mode !== LayerMode.GUIDE_IN) {
                                break;
                            }

                            layer.mode = LayerMode.NORMAL;
                            layer.showIcon();

                        }
                        break;

                    default:
                        break;

                }

                const characters = layer.getActiveCharacter(frame);
                if (characters.length) {
                    reload = true;
                }

                // 一覧からElementを削除
                element.remove();
                scene.deleteLayer(layerId);
            }

            /**
             * @type {ArrowTool}
             */
            const tool = Util.$tools.getDefaultTool("arrow");
            tool.clear();

            // タイムラインにレイヤーがあれば選択したいた近くのレイヤーをアクティブに
            if (parentElement.children.length) {
                let layerElement = null;
                for (;;) {
                    layerElement = parentElement.children[currentIndex--];
                    if (layerElement) {
                        Util.$timelineLayer.activeLayer(layerElement);
                        break;
                    }
                }
            }

            // レイヤーの横スクロール幅を再計算
            Util.$timelineScroll.updateWidth();

            // 追加後のレイヤーを再構成
            Util.$timelineLayer.moveTimeLine();

            // 追加後の擬似スクロールの高さを更新
            Util.$timelineScroll.updateHeight();

            if (reload) {
                this.reloadScreen();
            }
        }
    }

    /**
     * @description タイムラインに新規レイヤーを追加
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineLayerAdd ()
    {
        this.save();

        const layerElement = Util.$timelineLayer.targetLayer
            || document
                .getElementById("timeline-content")
                .children[0];

        const scene = Util.$currentWorkSpace().scene;

        // 最終行にレイヤーを追加
        scene.addLayer();

        // アクティブ中のレイヤーの上部に新規追加したレイヤーを移動
        if (layerElement) {

            const element = document
                .getElementById("timeline-content");

            const targetLayer = scene.getLayer(
                layerElement.dataset.layerId | 0
            );

            const lastElement = element.lastElementChild;
            switch (targetLayer.mode) {

                case LayerMode.MASK_IN:
                    {
                        const newLayer = scene.getLayer(
                            lastElement.dataset.layerId | 0
                        );
                        newLayer.maskId = targetLayer.maskId === null
                            ? targetLayer.id
                            : targetLayer.maskId;
                        newLayer.mode = LayerMode.MASK_IN;
                        newLayer.showIcon();
                    }
                    break;

                case LayerMode.GUIDE_IN:
                    {
                        const newLayer = scene.getLayer(
                            lastElement.dataset.layerId | 0
                        );
                        newLayer.guideId = targetLayer.guideId === null
                            ? targetLayer.id
                            : targetLayer.guideId;
                        newLayer.mode = LayerMode.GUIDE_IN;
                        newLayer.showIcon();
                    }
                    break;

                default:
                    break;

            }

            // 選択中のレイヤーの上部に新規レイヤーを追加
            element
                .insertBefore(lastElement, layerElement);

            // 保存用のObjectの順番も入れ替える
            const layers = [];
            for (let idx = 0; idx < element.children.length; ++idx) {
                layers.push(
                    scene.getLayer(element.children[idx].dataset.layerId | 0)
                );
            }

            scene.clearLayer();
            for (let idx = 0; idx < layers.length; ++idx) {
                const layer = layers[idx];
                scene.setLayer(layer.id, layer);
            }

            // 追加後のレイヤーを再構成
            Util.$timelineLayer.moveTimeLine();

            // 追加後の擬似スクロールの高さを更新
            Util.$timelineScroll.updateHeight();
        }

        // 初期化
        super.focusOut();
    }

    /**
     * @description JavaScript編集モーダルを起動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeTimelineScriptAdd (event)
    {
        Util.$javaScriptEditor.show(event);
    }

    /**
     * @description タイムラインにフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineFrameAdd ()
    {
        const targetFrames = Util.$timelineLayer.targetFrames;
        if (!targetFrames.size) {
            return ;
        }

        this.save();

        const startFrame = this.getFirstFrame();
        const scene = Util.$currentWorkSpace().scene;
        for (const [layerId, values] of targetFrames) {

            const endFrame = startFrame + values.length;

            const layer = scene.getLayer(layerId);

            const element = layer.getChildren(startFrame);
            if (!element) {
                continue;
            }

            // 未設定フレームに追加
            if (element.dataset.frameState === "empty") {

                let done = false;

                // 前方の最終フレームを取得
                let frame = 1;
                for (let idx = 0; idx < layer._$characters.length; ++idx) {
                    frame = Math.max(layer._$characters[idx].endFrame - 1, frame);
                }
                for (let idx = 0; idx < layer._$emptys.length; ++idx) {
                    frame = Math.max(layer._$emptys[idx].endFrame - 1, frame);
                }

                // DisplayObjectが配置されたレイヤーでれば終了位置を補正
                const characters = layer.getActiveCharacter(frame);
                if (characters.length) {

                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];

                        const range = character.getRange(frame);
                        if (character.hasTween(range.startFrame)) {

                            // tweenの幅情報を更新して各place objectを更新
                            const tweenObject = character
                                .getTween(range.startFrame);

                            tweenObject.endFrame = endFrame;

                            character
                                .updateTweenPlace(
                                    range.startFrame, endFrame
                                );

                            //  tweenの座標を再計算してポインターを再配置
                            character.relocationTween(range.startFrame);
                        }

                        // fixed logic 終了するフレーム番号を更新
                        character.endFrame = endFrame;
                    }

                    done = true;
                }

                // 空フレームでれば終了位置を補正
                const emptyCharacter = layer.getActiveEmptyCharacter(frame);
                if (!done && emptyCharacter) {

                    emptyCharacter.endFrame = endFrame;

                    done = true;
                }

                // レイヤーが空であれば、空フレームを追加
                if (!done) {
                    layer.addEmptyCharacter(
                        new EmptyCharacter({
                            "startFrame": frame,
                            "endFrame": endFrame
                        })
                    );
                }

            } else {

                // 後方補正(DisplayObject)
                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                    const character = layer._$characters[idx];
                    if (startFrame >= character.startFrame) {
                        continue;
                    }

                    character.move(values.length);
                }

                // 後方補正(空のフレーム)
                for (let idx = 0; idx < layer._$emptys.length; ++idx) {

                    const character = layer._$emptys[idx];
                    if (startFrame >= character.startFrame) {
                        continue;
                    }

                    character.move(values.length);

                }

                // 定義済みのフレームの場合
                const characters = layer
                    .getActiveCharacter(startFrame);

                // DisplayObjectが配置されたフレーム
                if (characters.length) {

                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];

                        const range = character.getRange(startFrame);

                        const places = new Map();
                        for (const [keyFrame, place] of character._$places) {

                            // レンジ内か、前方のキーフレームは現状維持
                            if (range.startFrame > keyFrame) {
                                places.set(keyFrame, place);
                                continue;
                            }

                            if (keyFrame >= range.startFrame && range.endFrame > keyFrame) {
                                places.set(keyFrame, place);
                                continue;
                            }

                            place.frame = keyFrame + values.length;
                            if (place.tweenFrame) {
                                place.tweenFrame += values.length;
                            }
                            places.set(place.frame, place);

                        }

                        // キーフレームの情報を上書き
                        character._$places = places;

                        if (character._$tween.size) {

                            // tween情報を更新
                            const tween = new Map();
                            for (const [keyFrame, tweenObject] of character._$tween) {

                                if (range.startFrame >= keyFrame) {
                                    tween.set(keyFrame, tweenObject);
                                    continue;
                                }

                                // 後方のtweenは開始終了位置を追加フレーム分後方に移動
                                // このplace objectを先行処理でキーフレーム情報を更新済み
                                tweenObject.startFrame += values.length;
                                tweenObject.endFrame   += values.length;
                                tween.set(tweenObject.startFrame, tweenObject);
                            }
                            character._$tween = tween;

                            if (character.hasTween(range.startFrame)) {

                                // tweenの幅情報を更新して各place objectを更新
                                const tweenObject = character
                                    .getTween(range.startFrame);

                                tweenObject.endFrame += values.length;

                                character.updateTweenPlace(
                                    range.startFrame,
                                    range.endFrame + values.length
                                );

                                //  tweenの座標を再計算してポインターを再配置
                                character.relocationTween(range.startFrame);
                            }
                        }

                        // fixed logic 終了するフレーム番号を更新
                        character.endFrame += values.length;
                    }

                } else {

                    // 空のフレーム
                    const emptyCharacter = layer
                        .getActiveEmptyCharacter(startFrame);

                    if (emptyCharacter) {
                        emptyCharacter.endFrame += values.length;
                    }

                }

            }

            layer.reloadStyle();
        }

        // アクティブなフレームを再設定
        this.setActiveFrame();

        // 再描画
        this.reloadScreen();

        // 初期化
        super.focusOut();
    }

    /**
     * @description タイムラインにキーフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineKeyAdd ()
    {
        const targetFrames = Util.$timelineLayer.targetFrames;
        if (!targetFrames.size) {
            return ;
        }

        this.save();

        const frame = Util.$timelineFrame.currentFrame;
        const scene = Util.$currentWorkSpace().scene;

        for (const layerId of targetFrames.keys()) {

            const layer = scene.getLayer(layerId);

            const characters = layer.getActiveCharacter(frame);
            if (characters.length) {

                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    // キーフレームがあればスキップ
                    if (character.hasPlace(frame)) {

                        // tweenでキーフレームを追加
                        const place = character.getPlace(frame);
                        if (place.tweenFrame) {

                            const range = character.getRange(frame);

                            const tweenObject    = character.getTween(place.tweenFrame);
                            tweenObject.endFrame = frame;

                            character.setTween(frame, {
                                "method": tweenObject.method,
                                "curve": [],
                                "custom": Util.$tweenController.createEasingObject(),
                                "startFrame": frame,
                                "endFrame": range.endFrame
                            });

                            character
                                .updateTweenPlace(frame, range.endFrame);

                            // 再計算
                            Util
                                .$tweenController
                                .relocationPlace(character, frame);

                            // ポインターを再配置
                            Util
                                .$tweenController
                                .clearPointer()
                                .relocationPointer();
                        }

                        continue;
                    }

                    character.setPlace(frame,
                        character.getClonePlace(frame)
                    );
                }

            } else {

                this.addEmptyCharacter(layer);

            }

            layer.reloadStyle();
        }

        // アクティブなフレームを再設定
        this.setActiveFrame();

        // 再描画(DisplayObjectの再配置で必須)
        this.reloadScreen();

        // 初期化
        super.focusOut();
    }

    /**
     * @description タイムラインのキーフレームを削除する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineKeyDelete ()
    {
        const targetFrames = Util.$timelineLayer.targetFrames;
        if (!targetFrames.size) {
            return ;
        }

        this.save();

        const scene = Util.$currentWorkSpace().scene;

        const startFrame = this.getFirstFrame();
        for (const [layerId, frames] of targetFrames) {

            const layer = scene.getLayer(layerId);

            // 何も設定がないのでスキップ
            if (!layer._$characters.length && !layer._$emptys.length) {
                continue;
            }

            const totalFrame = layer.totalFrame;
            let endFrame = 0;
            for (let idx = 0; frames.length > idx; ++idx) {

                if (!layer._$characters.length && !layer._$emptys.length) {
                    break;
                }

                const frame = frames[idx];

                const characters = layer.getActiveCharacter(frame);
                if (characters.length) {

                    // キーフレームを削除
                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];

                        if (!character.hasPlace(frame)) {
                            continue;
                        }

                        // tween内のplace objectであればスキップ
                        const place = character.getPlace(frame);
                        if (place.tweenFrame && place.tweenFrame !== frame) {
                            continue;
                        }

                        const range = character.getRange(frame);
                        endFrame = Math.max(endFrame, range.endFrame);
                        if (character.hasTween(frame)) {

                            const tweenObject = character.getTween(frame);
                            switch (true) {

                                // tweenのレンジ幅がDisplayObjectのフレーム数であれば全て削除
                                case character.startFrame === tweenObject.startFrame && character.endFrame === tweenObject.endFrame:
                                    character._$places.clear();
                                    break;

                                // 削除するキーフレームが開始位置ならレンジ幅のplace objectを初期
                                case character.startFrame === tweenObject.startFrame:
                                    for (let keyFrame = tweenObject.startFrame; keyFrame < tweenObject.endFrame; ++keyFrame) {
                                        character.deletePlace(keyFrame);
                                    }
                                    break;

                                default:
                                    {
                                        const prevRange = character
                                            .getRange(tweenObject.startFrame - 1);

                                        if (character.hasTween(prevRange.startFrame)) {

                                            // 直前にtweenがあれば結合
                                            for (let keyFrame = tweenObject.startFrame; keyFrame < tweenObject.endFrame; ++keyFrame) {
                                                const place = character.getPlace(keyFrame);
                                                place.tweenFrame = prevRange.startFrame;
                                            }

                                            const prevTweenObject = character.getTween(prevRange.startFrame);
                                            prevTweenObject.endFrame = tweenObject.endFrame;

                                            //  tweenの座標を再計算してポインターを再配置
                                            character.updateTweenFilter(prevRange.startFrame);
                                            character.updateTweenBlend(prevRange.startFrame);
                                            character.relocationTween(prevRange.startFrame);

                                        } else {

                                            // 単独のtweenであればレンジ幅のplace objectを削除
                                            for (let keyFrame = tweenObject.startFrame; keyFrame < tweenObject.endFrame; ++keyFrame) {
                                                character.deletePlace(keyFrame);
                                            }
                                        }
                                    }
                                    break;

                            }

                            character.deleteTween(frame);

                        } else {

                            // キーフレームを削除
                            character.deletePlace(frame);

                        }

                        // キーフレームがなければタイムラインから削除
                        if (!character._$places.size) {
                            layer.deleteCharacter(character.id);
                            continue;
                        }

                        // 削除したキーフレームが開始フレームなら開始位置を変更
                        if (frame === character.startFrame) {
                            let startFrame = character.endFrame;
                            for (const keyFrame of character._$places.keys()) {
                                startFrame = Math.min(startFrame, keyFrame);
                            }
                            character.startFrame = startFrame;
                        }
                    }

                    continue;
                }

                // 空のフレームの場合
                const emptyCharacter = layer
                    .getActiveEmptyCharacter(frame);

                // キーフレームがなければスキップ
                if (!emptyCharacter || emptyCharacter.startFrame !== frame) {
                    continue;
                }

                endFrame = Math.max(endFrame, emptyCharacter.endFrame);

                // 空白のフレームを削除
                layer.deleteEmptyCharacter(emptyCharacter);
            }

            // タイムラインの補正
            this.adjustmentKeyFrame(layer, startFrame, endFrame, totalFrame);

            // 再配置
            layer.reloadStyle();
        }

        // アクティブなフレームを再設定
        this.setActiveFrame();

        // 削除するものがあるので、選択範囲を再計算して再描画
        Util.$timelineLayer.activeCharacter();
        this.reloadScreen();

        // 初期化
        super.focusOut();
    }

    /**
     * @description タイムラインに空のキーフレームを追加する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineEmptyAdd ()
    {
        const targetFrames = Util.$timelineLayer.targetFrames;
        if (!targetFrames.size) {
            return ;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        // スクリーンエリアで選択中のDisplayObjectを未選択に
        tool.clearActiveElement();

        this.save();

        const frame = Util.$timelineFrame.currentFrame;
        const scene = Util.$currentWorkSpace().scene;
        for (const layerId of targetFrames.keys()) {

            const layer = scene.getLayer(layerId);

            const characters = layer.getActiveCharacter(frame);
            if (characters.length) {

                // キーフレームが設定されている場合は何もしない
                const frameElement = layer.getChildren(frame);
                if (frameElement.dataset.frameState === "key-frame") {

                    Util.$fadeIn({
                        "currentTarget": {
                            "dataset": {
                                "detail": "{{キーフレームに空のキーフレームを追加できません}}"
                            }
                        },
                        "pageX": frameElement.offsetLeft,
                        "pageY": frameElement.offsetTop
                    });

                    continue;
                }

                // 分割するフレーム番号を算出
                let splitFrame = Number.MAX_VALUE;
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    splitFrame = Math.min(splitFrame, character.endFrame);
                    for (let keyFrame of character._$places.keys()) {

                        if (frame > keyFrame) {
                            continue;
                        }

                        splitFrame = Math.min(splitFrame, keyFrame);
                    }
                }

                // 分割処理
                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    // fixed logic 先に分割
                    character.split(layer, frame, splitFrame);

                    // 終了するフレームが後方にある場合は分割
                    if (character.endFrame > splitFrame) {
                        layer.addCharacter(character.split(layer,
                            splitFrame,
                            character.endFrame
                        ));
                    }
                }

                // 空のフレームを追加
                const emptyCharacter = new EmptyCharacter();
                emptyCharacter.startFrame = frame;
                emptyCharacter.endFrame   = splitFrame;
                layer.addEmptyCharacter(emptyCharacter);

            } else {

                this.addEmptyCharacter(layer);

            }

            layer.reloadStyle();
        }

        // アクティブなフレームを再設定
        this.setActiveFrame();

        // 再描画
        this.reloadScreen();

        // 初期化
        super.focusOut();
    }

    /**
     * @description 空のキーフレームを登録
     *
     * @param  {Layer} layer
     * @return {void}
     * @method
     * @public
     */
    addEmptyCharacter (layer)
    {
        const frame = Util.$timelineFrame.currentFrame;

        // DisplayObjectが何も設置されてないフレームのケース
        const character = layer.getActiveEmptyCharacter(frame);
        if (character) {

            // キーフレームが設定されている場合は何もしない
            const frameElement = layer.getChildren(frame);
            if (frameElement
                && frameElement.dataset.frameState === "empty-key-frame"
            ) {
                return ;
            }

            // 空のフレームと重なっている
            if (character.startFrame !== frame) {

                // 空のフレームを分割、後半に新しいオブジェクトを設定
                layer.addEmptyCharacter(
                    new EmptyCharacter({
                        "startFrame": frame,
                        "endFrame": character.endFrame
                    })
                );

                // 前半のオブジェクトは再利用
                character.endFrame = frame;

            }

        } else {

            // emptyのフレームの場合

            // 1フレーム目でない時は手前のフレームの確認を行う
            if (frame > 1) {

                // 前方の最終フレームを取得
                let startFrame = 1;
                for (let idx = 0; idx < layer._$characters.length; ++idx) {
                    startFrame = Math.max(layer._$characters[idx].endFrame - 1, startFrame);
                }
                for (let idx = 0; idx < layer._$emptys.length; ++idx) {
                    startFrame = Math.max(layer._$emptys[idx].endFrame - 1, startFrame);
                }

                const characters = layer.getActiveCharacter(startFrame);
                if (characters.length) {

                    // 手前にDisplayObjectを配置したフレームがあった場合は終了位置を補正
                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];
                        character.endFrame = frame;

                    }

                } else {

                    const prevEmptyCharacter = layer
                        .getActiveEmptyCharacter(startFrame);

                    // 手前のフレームに空フレームがあれば最終位置を伸ばす
                    if (prevEmptyCharacter) {

                        prevEmptyCharacter.endFrame = frame;

                    } else {

                        // なければ新規作成
                        layer.addEmptyCharacter(
                            new EmptyCharacter({
                                "startFrame": startFrame,
                                "endFrame": frame
                            })
                        );

                    }

                }
            }

            const emptyCharacter = new EmptyCharacter();
            emptyCharacter.startFrame = frame;
            emptyCharacter.endFrame   = frame + 1;
            layer.addEmptyCharacter(emptyCharacter);
        }
    }

    /**
     * @description タイムラインのフレームを削除する
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineFrameDelete ()
    {
        const targetFrames = Util.$timelineLayer.targetFrames;
        if (!targetFrames.size) {
            return ;
        }

        this.save();

        const frame = this.getFirstFrame();
        const scene = Util.$currentWorkSpace().scene;
        for (const [layerId, frames] of targetFrames) {

            // 未設定のフレームの場合は処理をスキップ
            const layer = scene.getLayer(layerId);

            const element = layer.getChildren(frame);
            if (!element || element.dataset.frameState === "empty") {
                continue;
            }

            // 定義済みのフレームの場合
            const characters = layer
                .getActiveCharacter(frame);

            let moveFrame = 0;

            // DisplayObjectが配置されたフレーム
            if (characters.length) {

                for (let idx = 0; idx < characters.length; ++idx) {

                    const character = characters[idx];

                    // 削除対象範囲を計算
                    const range = character.getRange(frame);

                    // 削除開始位置がキーフレームの場合
                    if (character.hasPlace(frame)) {

                        // 削除範囲がキーフレームの幅を超えてる場合はキーフレームを削除
                        if (frames.length >= range.endFrame - range.startFrame) {

                            // tweenがあれば情報を削除
                            if (character.hasTween(frame)) {
                                for (let keyFrame = range.startFrame; keyFrame < range.endFrame; ++keyFrame) {
                                    character.deletePlace(keyFrame);
                                }
                                character.deleteTween(frame);

                                // tweenのポインターを削除
                                Util
                                    .$tweenController
                                    .clearPointer();
                            }

                            // キーフレームを削除
                            character.deletePlace(frame);
                        }

                    }

                    // 削除範囲のフレーム数
                    moveFrame = Math.min(
                        range.endFrame, frame + frames.length
                    ) - frame;

                    // キーフレームが存在しなけれなDisplayObjectを削除
                    if (!character._$places.size) {

                        layer.deleteCharacter(character.id);

                    } else {

                        const places = new Map();
                        for (const [keyFrame, place] of character._$places) {

                            // レンジ内か、前方のキーフレームは現状維持
                            if (range.startFrame > keyFrame) {
                                places.set(keyFrame, place);
                                continue;
                            }

                            if (keyFrame >= range.startFrame && range.endFrame > keyFrame) {

                                // 削除した範囲外だけ登録
                                if (range.endFrame - moveFrame > keyFrame) {
                                    places.set(keyFrame, place);
                                }

                                // 最後のフレームはキーフレームとしてレンジの最後のフレームに挿入
                                if (range.endFrame - 1 === keyFrame) {
                                    places.set(range.endFrame - moveFrame - 1, place);
                                }

                                continue;
                            }

                            place.frame = keyFrame - moveFrame;
                            if (place.tweenFrame) {
                                place.tweenFrame -= moveFrame;
                            }

                            places.set(place.frame, place);

                        }
                        character._$places = places;

                        // tweenの情報があれば更新して再計算
                        if (character._$tween.size) {

                            const tween = new Map();
                            for (const [keyFrame, tweenObject] of character._$tween) {

                                if (range.startFrame >= keyFrame) {

                                    if (range.startFrame === keyFrame) {
                                        tweenObject.endFrame -= moveFrame;
                                    }

                                    tween.set(keyFrame, tweenObject);

                                } else {

                                    // 削除したフレーム数分、前方へ移動
                                    // レンジ内のplace objectは別処理で移動済み
                                    tweenObject.startFrame -= moveFrame;
                                    tweenObject.endFrame   -= moveFrame;
                                    tween.set(tweenObject.startFrame, tweenObject);

                                }

                            }
                            character._$tween = tween;

                            // tweenの座標を再計算してポインターを再配置
                            character.relocationTween(range.startFrame);
                        }

                        character.endFrame -= moveFrame;
                    }

                }

            } else {

                // 空のフレーム
                const emptyCharacter = layer
                    .getActiveEmptyCharacter(frame);

                if (emptyCharacter) {

                    const totalFrame = emptyCharacter.endFrame
                        - emptyCharacter.startFrame;

                    const endFrame = Math.min(
                        emptyCharacter.endFrame, frame + frames.length
                    );

                    moveFrame = endFrame - frame;
                    if (moveFrame >= totalFrame) {

                        // 削除するフレーム数が超えていれば削除
                        layer.deleteEmptyCharacter(emptyCharacter);

                    } else {

                        // フレームを削除
                        emptyCharacter.endFrame -= moveFrame;

                    }

                }
            }

            // 後方補正(DisplayObject)
            for (let idx = 0; idx < layer._$characters.length; ++idx) {

                const character = layer._$characters[idx];
                if (frame >= character.startFrame) {
                    continue;
                }

                character.move(-moveFrame);
            }

            // 後方補正(空のフレーム)
            for (let idx = 0; idx < layer._$emptys.length; ++idx) {

                const character = layer._$emptys[idx];
                if (frame >= character.startFrame) {
                    continue;
                }

                character.move(-moveFrame);

            }

            layer.reloadStyle();
        }

        // アクティブなフレームを再設定
        this.setActiveFrame();

        // 指定フレームの有効なDisplayObjectを確認
        Util.$timelineLayer.activeCharacter();

        // 再描画
        this.reloadScreen();

        // 初期化
        super.focusOut();
    }

    /**
     * @description オニオンスキン機能のon/off
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelineOnionSkin ()
    {
        const element = document
            .getElementById("timeline-onion-skin");

        if (element.classList.contains("onion-skin-active")) {

            element
                .classList
                .remove("onion-skin-active");

            // 全てのDisplayObjectのキャッシュを削除
            const layers = Util
                .$currentWorkSpace()
                .scene
                ._$layers;

            for (const layer of layers.values()) {
                for (let idx = 0; idx < layer._$characters.length; ++idx) {
                    layer._$characters[idx].dispose();
                }
            }

        } else {

            element
                .classList
                .add("onion-skin-active");

        }

        // 再描画
        this.reloadScreen();
    }

    /**
     * @description タイムラインのマウスオーバーでのプレビュー機能のon/off
     *
     * @return {void}
     * @method
     * @public
     */
    executeTimelinePreview ()
    {
        const element = document
            .getElementById("timeline-preview");

        if (!element) {
            return ;
        }

        if (this._$preview) {

            this._$preview = false;
            element.setAttribute("class", "");

        } else {

            this._$preview = true;
            element.setAttribute("class", "timeline-preview-active");

        }
    }

    /**
     * @description 先祖のMovieClipを一覧で表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeSceneList (event)
    {

        // リストがない時は何もしない
        if (!document
            .getElementById("scene-name-menu-list")
            .children.length
        ) {
            return ;
        }

        const element = document
            .getElementById("scene-name-menu");

        // 表示されていれば非表示
        if (element.classList.contains("fadeIn")) {

            element.setAttribute("class", "fadeOut");

        } else {

            const target = event.currentTarget;
            element.style.left = `${target.offsetLeft + target.offsetWidth}px`;
            element.style.top  = `${target.offsetTop + 10}px`;
            element.setAttribute("class", "fadeIn");

            // 一覧以外のメニューを非表示
            Util.$endMenu("scene-name-menu");
        }
    }

    /**
     * @description フレーム追加した場合、アクティブも初期化されるので再度設定が必要
     *
     * @return {void}
     * @method
     * @public
     */
    setActiveFrame ()
    {
        // 表示領域の変数
        const timelineWidth = this.timelineWidth;
        const elementCount  = Util.$timelineHeader.width / (timelineWidth + 1) | 0;
        const leftFrame     = Util.$timelineHeader.leftFrame;
        const rightFrame    = leftFrame + elementCount;

        const scene = Util.$currentWorkSpace().scene;
        for (const [layerId, frames] of Util.$timelineLayer.targetFrames) {

            const layer = scene.getLayer(layerId);
            for (let idx = 0; idx < frames.length; ++idx) {

                const frame = frames[idx];
                // 表示領域より前のフレームならスキップ
                if (leftFrame > frame) {
                    continue;
                }

                // 表示領域より後ろのフレームならスキップ
                if (frame > rightFrame) {
                    continue;
                }

                const element = layer.getChildren(frame);
                if (!element) {
                    continue;
                }

                element
                    .classList
                    .add("frame-active");
            }
        }

        // レイヤーの横スクロール幅を再計算
        Util.$timelineScroll.updateWidth();
    }

    /**
     * @description キーフレームを削除した時のタイムラインの補正
     *
     * @param  {Layer}  layer
     * @param  {number} key_frame
     * @param  {number} end_frame
     * @param  {number} total_frame
     * @return {void}
     * @method
     * @public
     */
    adjustmentKeyFrame (layer, key_frame, end_frame, total_frame)
    {
        if (key_frame > 1) {

            // フレームが2以上なら前方確認
            for (let idx = 1; key_frame - idx > 0; ++idx) {

                const frame = key_frame - idx;

                const characters = layer
                    .getActiveCharacter(frame);

                if (characters.length) {

                    // 終了位置の補正
                    for (let idx = 0; idx < characters.length; ++idx) {

                        const character = characters[idx];

                        // tweenの補正
                        const keyFrame = character.endFrame - 1;
                        if (character.hasPlace(keyFrame)) {
                            const place = character.getPlace(keyFrame);
                            if (place.tweenFrame) {

                                const tween = character
                                    .getTween(place.tweenFrame);

                                if (end_frame > tween.endFrame) {
                                    tween.endFrame = endFrame;

                                    for (let frame = keyFrame + 1; end_frame > frame; ++frame) {
                                        character.setPlace(frame,
                                            character.getClonePlace(keyFrame)
                                        );
                                    }
                                }

                                // 再計算
                                Util
                                    .$tweenController
                                    .relocationPlace(character, keyFrame);
                            }
                        }

                        if (end_frame > character.endFrame) {
                            character.endFrame = end_frame;
                        }
                    }

                    break;
                }

                const emptyCharacter = layer
                    .getActiveEmptyCharacter(frame);

                if (emptyCharacter) {
                    emptyCharacter.endFrame = end_frame;
                    break;
                }

            }

        } else {

            // 1フレーム以降に何かの配置があれば実行
            if (layer._$characters.length || layer._$emptys.length) {

                // フレームが1なら後方確認
                for (let idx = 1; ; ++idx) {

                    const frame = 1 + idx;

                    const characters = layer
                        .getActiveCharacter(frame);

                    if (characters.length) {

                        for (let idx = 0; idx < characters.length; ++idx) {

                            const character = characters[idx];

                            let moveFrame = character.endFrame;
                            for (let keyFrame of character._$places.keys()) {
                                moveFrame = Math.min(moveFrame, keyFrame);
                            }

                            // キーフレームを補正
                            const place = character.getPlace(moveFrame);
                            character.deletePlace(moveFrame);
                            character.setPlace(1, place);

                            // 開始位置の補正
                            character.startFrame = 1;
                        }

                        break;
                    }

                    const emptyCharacter = layer
                        .getActiveEmptyCharacter(frame);

                    if (emptyCharacter) {
                        emptyCharacter.startFrame = 1;
                        break;
                    }
                }
            } else {

                layer.addEmptyCharacter(new EmptyCharacter({
                    "startFrame": key_frame,
                    "endFrame": total_frame
                }));

            }
        }
    }

    /**
     * @description 複数のフレームを選択した時の一番若いフレーム番号を返す
     *
     * @return {number}
     * @method
     * @public
     */
    getFirstFrame ()
    {
        if (!Util.$timelineLayer.targetFrame) {
            return 1;
        }

        const frames = Util
            .$timelineLayer
            .targetFrames
            .values()
            .next()
            .value;

        let minFrame = Number.MAX_VALUE;
        for (let idx = 0; idx < frames.length; ++idx) {
            minFrame = Math.min(minFrame, frames[idx]);
        }

        return minFrame;
    }
}

Util.$timelineTool = new TimelineTool();

/**
 * 整列機能のコントローラークラス
 * Controller class for blend function
 *
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class AlignController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("align");
    }

    /**
     * @description 初期起動関数
     *              initial invoking function
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "align-position-left",
            "align-position-center",
            "align-position-right",
            "align-position-top",
            "align-position-middle",
            "align-position-bottom",
            "align-stage-position-left",
            "align-stage-position-center",
            "align-stage-position-right",
            "align-stage-position-top",
            "align-stage-position-middle",
            "align-stage-position-bottom"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document
                .getElementById(elementIds[idx]);

            if (!element) {
                continue;
            }

            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event.target.id);
            });
        }
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で左揃え
     *
     * @return {void}
     * @method
     * @public
     */
    changeAlignStagePositionLeft ()
    {
        Util.$screenMenu.alignment("left", "stage");
    }

    /**
     * @description 指定したDisplayObjectを左揃え
     *
     * @return {void}
     * @method
     * @public
     */
    changeAlignPositionLeft ()
    {
        Util.$screenMenu.alignment("left");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で中央揃え(水平方向)
     *
     * @return {void}
     * @method
     * @public
     */
    changeAlignStagePositionCenter ()
    {
        Util.$screenMenu.alignment("center", "stage");
    }

    /**
     * @description 指定したDisplayObjectを中央揃え(水平方向)
     *
     * @return {void}
     * @method
     * @public
     */
    changeAlignPositionCenter ()
    {
        Util.$screenMenu.alignment("center");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で右揃え
     *
     * @return {void}
     * @method
     * @public
     */
    changeAlignStagePositionRight ()
    {
        Util.$screenMenu.alignment("right", "stage");
    }

    /**
     * @description 指定したDisplayObjectを右揃え
     *
     * @return {void}
     * @method
     * @public
     */
    changeAlignPositionRight ()
    {
        Util.$screenMenu.alignment("right");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で上揃え
     *
     * @return {void}
     * @method
     * @public
     */
    changeAlignStagePositionTop ()
    {
        Util.$screenMenu.alignment("top", "stage");
    }

    /**
     * @description 指定したDisplayObjectを上揃え
     *
     * @return {void}
     * @method
     * @public
     */
    changeAlignPositionTop ()
    {
        Util.$screenMenu.alignment("top");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で中央揃え(垂直方向)
     *
     * @return {void}
     * @method
     * @public
     */
    changeAlignStagePositionMiddle ()
    {
        Util.$screenMenu.alignment("middle", "stage");
    }

    /**
     * @description 指定したDisplayObjectを中央揃え(垂直方向)
     *
     * @return {void}
     * @method
     * @public
     */
    changeAlignPositionMiddle ()
    {
        Util.$screenMenu.alignment("middle");
    }

    /**
     * @description 指定したDisplayObjectをステージ基準で下揃え
     *
     * @return {void}
     * @method
     * @public
     */
    changeAlignStagePositionBottom ()
    {
        Util.$screenMenu.alignment("bottom", "stage");
    }

    /**
     * @description 指定したDisplayObjectを下揃え
     *
     * @return {void}
     * @method
     * @public
     */
    changeAlignPositionBottom ()
    {
        Util.$screenMenu.alignment("bottom");
    }
}

Util.$alignController = new AlignController();

/**
 * ブレンド機能のコントローラークラス
 * Controller class for blend function
 *
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class BlendController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("blend");
    }

    /**
     * @description 初期起動関数
     *              initial invoking function
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        this.setChangeEvent(
            document.getElementById("blend-select")
        );
    }

    /**
     * @description ブレンドモードの値を変更
     *              Change blend mode value
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeBlendSelect (value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const scene   = Util.$currentWorkSpace().scene;
        const element = activeElements[0];

        // 対象レイヤーオブジェクト
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        // スクリーンで選択しているDisplayObject
        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        const frame = Util.$timelineFrame.currentFrame;

        // 指定フレームのplace objectを取得
        let place = character.getPlace(frame);
        if (place.tweenFrame) {

            // キーフレームの途中でブレンドモードを切り替えたらtweenを分割する
            if (character.endFrame - 1 > frame && !character.hasTween(frame)) {

                Util
                    .$timelineTool
                    .executeTimelineKeyAdd();

                // 新規のキーフレームのplace objectをセット
                place = character.getPlace(frame);
            }

            // tweenの場合は主となるキーフレームに切り替える
            place = character.getPlace(place.tweenFrame);
        }

        // 指定のブレンドモードを適用
        place.blendMode = `${value}`;

        // tween情報を更新
        if (place.tweenFrame) {
            character.updateTweenBlend(frame);
        }

        // 再描画ように、キャッシュを削除
        character.dispose();
    }
}

Util.$blendController = new BlendController();

/**
 * カラートランスフォーム機能のコントローラークラス
 * Controller class for color transform function
 *
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class ColorTransformController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("color");
    }

    /**
     * @description カラーオフセットの最小数値
     *              Minimum color offset value
     *
     * @return {number}
     * @const
     * @static
     */
    static get MIN_OFFSET ()
    {
        return -255;
    }

    /**
     * @description カラーオフセットの最大数値
     *              Maximum color offset value
     *
     * @return {number}
     * @const
     * @static
     */
    static get MAX_OFFSET ()
    {
        return 255;
    }

    /**
     * @description カラーマルチプライヤの最小数値
     *              Minimum value for color multiplier
     *
     * @return {number}
     * @const
     * @static
     */
    static get MIN_MULTIPLIER ()
    {
        return 0;
    }

    /**
     * @description カラーマルチプライヤの最大数値
     *              Maximum number of color multipliers
     *
     * @return {number}
     * @const
     * @static
     */
    static get MAX_MULTIPLIER ()
    {
        return 100;
    }

    /**
     * @description 初期起動関数
     *              initial invoking function
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "color-alpha-offset",
            "color-red-offset",
            "color-green-offset",
            "color-blue-offset",
            "color-alpha-multiplier",
            "color-red-multiplier",
            "color-green-multiplier",
            "color-blue-multiplier"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            this.setInputEvent(element);
        }
    }

    /**
     * @description 赤の値を更新
     *              Update red value
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeColorRedMultiplier (value)
    {
        // 補正
        value = Util.$clamp(
            +value,
            ColorTransformController.MIN_MULTIPLIER,
            ColorTransformController.MAX_MULTIPLIER
        );

        this.updateColor(0, value / 100);

        return value;
    }

    /**
     * @description 緑の値を更新
     *              Update green value
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeColorGreenMultiplier (value)
    {
        // 補正
        value = Util.$clamp(
            +value,
            ColorTransformController.MIN_MULTIPLIER,
            ColorTransformController.MAX_MULTIPLIER
        );

        this.updateColor(1, value / 100);

        return value;
    }

    /**
     * @description 青の値を更新
     *              Update blue value
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeColorBlueMultiplier (value)
    {
        // 補正
        value = Util.$clamp(
            +value,
            ColorTransformController.MIN_MULTIPLIER,
            ColorTransformController.MAX_MULTIPLIER
        );

        this.updateColor(2, value / 100);

        return value;
    }

    /**
     * @description 透明度の値を更新
     *              Update transparency value
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeColorAlphaMultiplier (value)
    {
        // 補正
        value = Util.$clamp(
            +value,
            ColorTransformController.MIN_MULTIPLIER,
            ColorTransformController.MAX_MULTIPLIER
        );

        this.updateColor(3, value / 100);

        return value;
    }

    /**
     * @description Offsetの赤の値を更新
     *              Update red value of Offset
     *
     * @param {string} value
     * @method
     * @public
     */
    changeColorRedOffset (value)
    {
        // 補正
        value = Util.$clamp(
            value | 0,
            ColorTransformController.MIN_OFFSET,
            ColorTransformController.MAX_OFFSET
        );

        this.updateColor(4, value);

        return value;
    }

    /**
     * @description Offsetの緑の値を更新
     *              Update green value of Offset
     *
     * @param {string} value
     * @method
     * @public
     */
    changeColorGreenOffset (value)
    {
        // 補正
        value = Util.$clamp(
            value | 0,
            ColorTransformController.MIN_OFFSET,
            ColorTransformController.MAX_OFFSET
        );

        this.updateColor(5, value);

        return value;
    }

    /**
     * @description Offsetの青の値を更新
     *              Update the blue value of Offset
     *
     * @param {string} value
     * @method
     * @public
     */
    changeColorBlueOffset (value)
    {
        // 補正
        value = Util.$clamp(
            value | 0,
            ColorTransformController.MIN_OFFSET,
            ColorTransformController.MAX_OFFSET
        );

        this.updateColor(6, value);

        return value;
    }

    /**
     * @description Offsetの透明度の値を更新
     *              Update Offset transparency value
     *
     * @param {string} value
     * @method
     * @public
     */
    changeColorAlphaOffset (value)
    {
        // 補正
        value = Util.$clamp(
            value | 0,
            ColorTransformController.MIN_OFFSET,
            ColorTransformController.MAX_OFFSET
        );

        this.updateColor(7, value);

        return value;
    }

    /**
     * @description カラーの値の更新、indexで分岐処理を行う
     *              Update color values, branch processing with index
     *
     * @param  {number} index
     * @param  {number} value
     * @return {number}
     * @method
     * @public
     */
    updateColor (index, value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        const element   = activeElements[0];

        // 対象レイヤーオブジェクト
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        // スクリーンで選択しているDisplayObject
        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        const frame = Util.$timelineFrame.currentFrame;

        // 対象のカラーを更新
        const place = character.getPlace(frame);
        place.colorTransform[index] = value;

        // tweenの座標を再計算してポインターを再配置
        character.relocationTween(frame);

        // 再描画ように、キャッシュを削除
        character.dispose();
    }
}

Util.$colorTransformController = new ColorTransformController();

/**
 * ライブラリのアイテムの上書きを確認するモーダルクラス
 * Modal class to confirm overwriting of items in the library
 *
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class ConfirmModal extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("");

        /**
         * @type {array}
         * @private
         */
        this._$files = [];

        /**
         * @type {string}
         * @default "hide"
         * @private
         */
        this._$state = "hide";

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$currentObject = null;

        /**
         * @type {Map}
         * @private
         */
        this._$mapping = new Map();

        /**
         * @type {Map}
         * @private
         */
        this._$layers = new Map();
    }

    /**
     * @description 上書き確認のアイテムを格納した配列
     *              Array containing overwrite confirmation items
     *
     * @member {array}
     * @default []
     * @public
     */
    get files ()
    {
        return this._$files;
    }
    set files (files)
    {
        this._$files = files;
    }

    /**
     * @description 初期起動関数
     *              initial invoking function
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elements = [
            "confirm-overwriting",
            "confirm-skip",
            "confirm-all-overwriting",
            "confirm-all-skip"
        ];

        for (let idx = 0; idx < elements.length; ++idx) {

            const element = document
                .getElementById(elements[idx]);

            if (!element) {
                continue;
            }

            element.addEventListener("mousedown", (event) =>
            {
                event.stopPropagation();

                const names = event.target.id.split("-");

                let functionName = names
                    .map((value) =>
                    {
                        return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
                    })
                    .join("");

                return this[`execute${functionName}`](event);
            });
        }
    }

    /**
     * @description 追加したファイルを全て上書き
     *              Overwrite all added files
     *
     * @return {Promise}
     * @method
     * @public
     */
    executeConfirmAllOverwriting ()
    {
        this.save();

        const promises = [];

        const workSpace = Util.$currentWorkSpace();

        this._$files.unshift(this._$currentObject);
        for (let idx = 0; idx < this._$files.length; ++idx) {

            const object = this._$files[idx];
            if (!object) {
                continue;
            }

            // 上書きするIDを指定
            const libraryId = workSpace._$nameMap.get(object.path);
            switch (object.type) {

                // ライブラリ内での移動処理
                case "move":
                    this._$currentObject = object;
                    this.moveOverwriting(libraryId);
                    break;

                // コピー、ペースト処理
                case "copy":
                    this._$currentObject = object;
                    this.copyOverwriting(libraryId);
                    break;

                // ファイル追加処理
                default:
                    // eslint-disable-next-line no-loop-func
                    promises.push(new Promise((resolve) =>
                    {
                        Util
                            .$libraryController
                            .loadFile(
                                object.file,
                                resolve,
                                object.folderId,
                                object.file.name,
                                libraryId
                            );
                    }));
                    break;

            }
        }

        // 値を初期化
        this._$currentObject = null;
        this._$files.length  = 0;

        // 再描画
        return Promise
            .all(promises)
            .then(() =>
            {
                // モーダルを非表示
                this.hide();

                //ライブラリを再構築
                Util.$libraryController.reload();

                // 再描画
                this.reloadScreen();

                this._$saved = false;
            });
    }

    /**
     * @description 全ての上書きをスキップ
     *              Skip all overwrites
     *
     * @return {void}
     * @method
     * @public
     */
    executeConfirmAllSkip ()
    {
        for (let idx = 0; idx < this._$files.length; ++idx) {

            const object = this._$files[idx];
            if (object.type !== "copy") {
                continue;
            }

            const layer     = object.layer;
            const character = object.character;

            if (layer && character) {
                layer.deleteCharacter(character.id);
            }
        }

        // 初期化
        this._$currentObject = null;
        this._$files.length  = 0;

        // 非表示に
        this.hide();
    }

    /**
     * @description フォルダの中にあるアイテムを複製
     *
     * @param  {number} from_work_space_id
     * @param  {number} instance_id
     * @param  {Folder} folder
     * @return {void}
     * @method
     * @public
     */
    cloneFolderItem (from_work_space_id, instance_id, folder)
    {
        const fromWorkSpace = Util.$workSpaces[from_work_space_id];
        const toWorkSpace   = Util.$currentWorkSpace();

        for (const instance of fromWorkSpace._$libraries.values()) {

            if (instance.folderId !== instance_id) {
                continue;
            }

            // 既に複製していればスキップ
            if (this._$mapping.has(instance.id)) {
                continue;
            }

            // 重複したアイテムがあれば確認モーダルを表示
            const path = instance.getPathWithWorkSpace(fromWorkSpace);
            if (toWorkSpace._$nameMap.has(path)) {
                this.files.push({
                    "file": instance,
                    "character": null,
                    "layer": null,
                    "path": path,
                    "workSpaceId": from_work_space_id,
                    "type": "copy"
                });
                continue;
            }

            let clone = null;
            if (instance.type === InstanceType.MOVIE_CLIP) {

                clone = this.cloneMovieClip(from_work_space_id, instance);

            } else {

                const activeWorkSpaceId = Util.$activeWorkSpaceId;
                Util.$activeWorkSpaceId = from_work_space_id;

                clone = instance.clone();
                Util.$activeWorkSpaceId = activeWorkSpaceId;

            }

            clone._$id = toWorkSpace.nextLibraryId;
            clone.folderId = folder.id;

            // 重複判定用にコピー元のIDをセット
            this._$mapping.set(instance.id, clone._$id);

            // Elementを追加
            Util
                .$libraryController
                .createInstance(
                    clone.type,
                    clone.name,
                    clone.id,
                    clone.symbol
                );

            // 内部データに追加
            toWorkSpace._$libraries.set(clone.id, clone);

            // フォルダなら中身を複製
            if (clone.type === InstanceType.FOLDER) {
                this.cloneFolderItem(
                    from_work_space_id, instance.id, clone
                );
            }
        }
    }

    /**
     * @description MovieClipを複製
     *
     * @param  {number} from_work_space_id
     * @param  {MovieClip} movie_clip
     * @return {MovieClip}
     * @method
     * @public
     */
    cloneMovieClip (from_work_space_id, movie_clip)
    {
        const fromWorkSpace = Util.$workSpaces[from_work_space_id];
        const toWorkSpace   = Util.$currentWorkSpace();

        const activeWorkSpaceId = Util.$activeWorkSpaceId;
        Util.$activeWorkSpaceId = from_work_space_id;

        // MovieClipを複製
        const movieClip = movie_clip.clone();
        Util.$activeWorkSpaceId = activeWorkSpaceId;

        for (const layer of movieClip._$layers.values()) {

            for (let idx = 0; idx < layer._$characters.length; ++idx) {
                const character = layer._$characters[idx];

                // 既に複製されていればスキップ
                if (this._$mapping.has(character.libraryId)) {
                    character.libraryId = this._$mapping.get(character.libraryId);
                    continue;
                }

                const instance = fromWorkSpace
                    .getLibrary(character.libraryId);

                const path = instance
                    .getPathWithWorkSpace(fromWorkSpace);

                // 重複している場合は確認モーダルを表示
                if (toWorkSpace._$nameMap.has(path)) {
                    this.files.push({
                        "file": instance,
                        "character": character,
                        "layer": layer,
                        "path": path,
                        "workSpaceId": from_work_space_id,
                        "type": "copy"
                    });
                    continue;
                }

                let clone = null;
                if (instance.type === InstanceType.MOVIE_CLIP) {

                    clone = this.cloneMovieClip(from_work_space_id, instance);

                } else {

                    const activeWorkSpaceId = Util.$activeWorkSpaceId;
                    Util.$activeWorkSpaceId = from_work_space_id;

                    clone = instance.clone();
                    Util.$activeWorkSpaceId = activeWorkSpaceId;

                }

                if (!clone) {
                    continue;
                }

                // 新しいIDをセット
                character.libraryId = clone._$id = toWorkSpace.nextLibraryId;
                this._$mapping.set(instance.id, clone.id);

                if (clone.folderId) {
                    this.createFolder(from_work_space_id, instance);
                }

                // 登録
                Util
                    .$libraryController
                    .createInstance(
                        clone.type,
                        clone.name,
                        clone.id,
                        clone.symbol
                    );

                toWorkSpace._$libraries.set(clone.id, clone);
            }
        }

        return movieClip;
    }

    /**
     * @description コピー、ペースト時の上書き処理
     *              Overwrite processing when copying and pasting
     *
     * @param  {number} [libraryId = 0]
     * @param  {string} [value = ""]
     * @return {void}
     * @method
     * @public
     */
    copyOverwriting (libraryId = 0, value = "")
    {
        const workSpace = Util.$currentWorkSpace();

        // 名前を変えて上書き
        const instance = this._$currentObject.file;

        const id = libraryId || workSpace.nextLibraryId;
        if (!this._$mapping.has(instance.id)) {

            this
                ._$mapping
                .set(instance.id, id);

            // 上書きなら元のElementを削除
            if (libraryId) {

                // Elementを削除
                const element = document
                    .getElementById(`library-child-id-${libraryId}`);

                if (element) {
                    element.remove();
                }

                // 移動元を配置しているDisplayObjectの情報を書き換え
                if (instance.type !== InstanceType.FOLDER) {

                    for (const library of workSpace._$libraries.values()) {

                        if (library.type !== InstanceType.MOVIE_CLIP) {
                            continue;
                        }

                        for (const layer of library._$layers.values()) {
                            for (let idx = 0; idx < layer._$characters.length; ++idx) {
                                const character = layer._$characters[idx];
                                character.dispose();

                                // 対象のDisplayObjectならIDを入れ替える
                                if (character.libraryId === libraryId) {
                                    character.libraryId = id;
                                }
                            }
                        }
                    }
                }

                workSpace.removeLibrary(libraryId);
            }

            // ライブラリに登録がなけれな登録
            let clone = null;
            if (instance.type === InstanceType.MOVIE_CLIP) {

                clone = this.cloneMovieClip(
                    this._$currentObject.workSpaceId,
                    instance
                );

            } else {

                // ワークスペースを切り替え
                const activeWorkSpaceId = Util.$activeWorkSpaceId;
                Util.$activeWorkSpaceId = this._$currentObject.workSpaceId;

                clone = instance.clone();
                Util.$activeWorkSpaceId = activeWorkSpaceId;

            }

            clone._$id = id;
            if (value) {
                clone._$name = value;
            }

            // 登録
            Util
                .$libraryController
                .createInstance(
                    clone.type,
                    clone.name,
                    clone.id,
                    clone.symbol
                );

            workSpace._$libraries.set(clone.id, clone);

            // フォルダ内にあればフォルダを生成
            if (clone.folderId) {
                this.createFolder(
                    this._$currentObject.workSpaceId,
                    clone
                );
            }
        }

        // レイヤーコピーの場合のみ動く関数
        this.addLayer(id);
    }

    /**
     * @description コピー先のレイヤーに同一のDisplayObjectがあれば統合、なければ追加
     *
     * @param {Layer} layer
     * @param {Character} character
     * @param {number} copy_frame
     * @method
     * @public
     */
    pasteDisplayObject (layer, character, copy_frame)
    {
        //  コピー先にキーフレームがなければ登録
        const currentFrame = Util.$timelineFrame.currentFrame;

        let range = null;
        const characters = layer.getActiveCharacter(currentFrame);
        if (characters.length) {
            range = characters[0].getRange(currentFrame);
        }

        if (!range) {

            const emptyCharacter = layer
                .getActiveEmptyCharacter(currentFrame);

            if (emptyCharacter) {
                range = {
                    "startFrame": emptyCharacter.startFrame,
                    "endFrame": emptyCharacter.endFrame
                };

                // 不要になるので空のキーフレームは削除
                layer.deleteEmptyCharacter(emptyCharacter);
            }
        }

        if (!range) {

            // 空のキーフレームを登録
            Util
                .$timelineTool
                .executeTimelineFrameAdd();

            const characters = layer.getActiveCharacter(currentFrame);
            if (characters.length) {
                range = characters[0].getRange(currentFrame);
            }

            if (!range) {
                const emptyCharacter = layer
                    .getActiveEmptyCharacter(currentFrame);
                if (emptyCharacter) {
                    range = {
                        "startFrame": emptyCharacter.startFrame,
                        "endFrame": emptyCharacter.endFrame
                    };

                    // 不要になるので空のキーフレームは削除
                    layer.deleteEmptyCharacter(emptyCharacter);
                }
            }
        }

        const libraryMap = new Map();

        // 前のフレームがあれば結合する可能性があるのでmapに登録
        const prevCharacters = layer.getActiveCharacter(
            Math.min(1, range.startFrame - 1)
        );

        for (let idx = 0; idx < prevCharacters.length; ++idx) {

            const character = prevCharacters[idx];
            if (character.endFrame > currentFrame) {
                continue;
            }

            const libraryId = character.libraryId;
            if (!libraryMap.has(libraryId)) {
                libraryMap.set(libraryId, []);
            }
            libraryMap.get(libraryId).push(character);
        }

        const libraryId = character.libraryId;

        // コピー元のplace objectを取得
        const place = character.getPlace(copy_frame);

        // 最前面に配置
        place.depth = layer.getActiveCharacter(currentFrame).length;

        // 結合先がなければレイヤーに追加
        if (!libraryMap.size || !libraryMap.has(libraryId)) {

            // コピー元のキーフレームの幅で作成
            character.startFrame = range.startFrame;
            character.endFrame   = range.endFrame;

            // キーフレームとtweenを初期化
            character._$places.clear();
            character._$tween.clear();

            // 再登録
            character.setPlace(range.startFrame, place);

            // レイヤーに登録
            layer.addCharacter(character);

        } else {

            // 結合先があれば結合
            const characters = libraryMap.get(libraryId);

            const character = characters.pop();
            if (characters.length) {
                libraryMap.delete(libraryId);
            }

            character.startFrame = Math.min(character.startFrame, range.startFrame);
            character.endFrame   = Math.max(character.endFrame, range.endFrame);
            character.setPlace(range.startFrame, place);

        }
    }

    /**
     * @description コピーするアイテムがフォルダ内にある場合、先祖のフォルダを作成する
     *
     * @param  {number} from_work_space_id
     * @param  {Instance} instance
     * @return {void}
     * @method
     * @public
     */
    createFolder (from_work_space_id, instance)
    {
        const fromWorkSpace = Util.$workSpaces[from_work_space_id];
        const toWorkSpace   = Util.$currentWorkSpace();

        let child  = instance;
        let folder = fromWorkSpace
            .getLibrary(instance.folderId);

        for (;;) {

            const path = folder
                .getPathWithWorkSpace(fromWorkSpace);

            // 既にフォルダがあればIDをセットして終了
            if (toWorkSpace._$nameMap.has(path)) {
                child.folderId = toWorkSpace._$nameMap.get(path);
                break;
            }

            // IDを再発行
            const clone = folder.clone();
            child.folderId = clone._$id = toWorkSpace.nextLibraryId;

            // Elementを追加
            Util
                .$libraryController
                .createInstance(
                    clone.type,
                    clone.name,
                    clone.id,
                    clone.symbol
                );

            // 内部データに追加
            toWorkSpace._$libraries.set(clone.id, clone);

            // 先祖がなければ終了
            if (!folder.folderId) {
                break;
            }

            child  = folder;
            folder = fromWorkSpace
                .getLibrary(folder.folderId);
        }
    }

    /**
     * @description フォルダの移動時に重複しているアイテムがないかチェック
     *
     * @param  {Folder} folder
     * @param  {string} [parent_path=""]
     * @return {void}
     * @method
     * @public
     */
    checkFolder (folder, parent_path = "")
    {
        const workSpace = Util.$currentWorkSpace();
        for (const instance of workSpace._$libraries.values()) {

            if (instance.folderId !== folder.id) {
                continue;
            }

            if (instance.type === InstanceType.FOLDER) {

                const parentPath = parent_path
                    ? instance.name
                    : `${parent_path}/${instance.name}`;

                this.checkFolder(instance, parentPath);
            }

            instance.folderId = 0;
            const path = parent_path
                ? instance.path
                : `${parent_path}/${instance.path}`;
            instance.folderId = folder.id;

            // 重複チェック
            if (!workSpace._$nameMap.has(path)) {
                continue;
            }

            // 確認モーダルを表示
            Util.$confirmModal.files.push({
                "file": instance,
                "folderId": folder.id,
                "path": path,
                "type": "move"
            });
            Util.$confirmModal.show();
        }
    }

    /**
     * @description 指定フォルダ内にあるアイテムを全て削除する
     *
     * @param  {Folder} folder
     * @return {void}
     * @method
     * @public
     */
    deleteFolderItem (folder)
    {
        const workSpace = Util.$currentWorkSpace();
        for (const instance of workSpace._$libraries.values()) {

            if (instance.folderId !== folder.id) {
                continue;
            }

            if (instance.type === InstanceType.FOLDER) {
                // フォルダなら中身を削除する
                this.deleteFolderItem(instance);
            } else {
                // 削除するアイテムがMovieClipに配置されていれば削除する
                this.removeCharacter(instance.id);
            }

            document
                .getElementById(`library-child-id-${instance.id}`)
                .remove();

            workSpace.removeLibrary(instance.id);
        }
    }

    /**
     * @description 指定のアイテムが配置されていれば削除を行う
     *
     * @param  {number} library_id
     * @return {void}
     * @method
     * @public
     */
    removeCharacter (library_id)
    {
        const workSpace = Util.$currentWorkSpace();
        for (const instance of workSpace._$libraries.values()) {

            if (instance.type !== InstanceType.MOVIE_CLIP) {
                continue;
            }

            for (const layer of instance._$layers.values()) {
                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                    const character = layer._$characters[idx];
                    if (character.libraryId !== library_id) {
                        continue;
                    }

                    layer.deleteCharacter(character.id);
                }
            }
        }
    }

    /**
     * @description 登録されてるライブラリ移動時の重複アイテムの上書き処理
     *              Overwrite duplicate items when moving registered libraries
     *
     * @param  {number} library_id
     * @return {void}
     * @method
     * @public
     */
    moveOverwriting (library_id)
    {
        const workSpace = Util.$currentWorkSpace();
        const instance  = this._$currentObject.file;

        // Elementを削除
        const element = document
            .getElementById(`library-child-id-${library_id}`);

        if (element) {
            element.remove();
        }

        // 移動元になっElementを削除
        document
            .getElementById(`library-child-id-${instance.id}`)
            .remove();

        const library = workSpace.getLibrary(library_id);
        instance.folderId = library.folderId;

        // 移動元を配置しているDisplayObjectの情報を書き換え
        if (instance.type !== InstanceType.FOLDER) {

            for (const library of workSpace._$libraries.values()) {

                if (library.type !== InstanceType.MOVIE_CLIP) {
                    continue;
                }

                for (const layer of library._$layers.values()) {
                    for (let idx = 0; idx < layer._$characters.length; ++idx) {

                        const character = layer._$characters[idx];
                        if (character.libraryId !== instance.id) {
                            continue;
                        }

                        // 情報を更新してキャッシュをクリア
                        character.libraryId = library_id;
                        character.dispose();
                    }
                }
            }

        } else {

            // フォルダーの場合は内部データも情報を更新する
            this.deleteFolderItem(library);

            // 移動するフォルダに合わせてアイテムも移動
            for (const library of workSpace._$libraries.values()) {

                if (library.folderId !== instance.id) {
                    continue;
                }

                library.folderId = library_id;
            }

        }

        // 元を削除してIDを差し替え
        workSpace.removeLibrary(instance.id);
        instance._$id = library_id;

        // Elementを追加
        Util
            .$libraryController
            .createInstance(
                instance.type,
                instance.name,
                instance.id,
                instance.symbol
            );

        // 内部データに追加
        workSpace._$libraries.set(instance.id, instance);

        // 再描画前に、現在のシーンのキャッシュをクリア
        const scene = Util.$currentWorkSpace().scene;
        for (const layer of scene._$layers.values()) {
            for (let idx = 0; idx < layer._$characters.length; ++idx) {
                layer._$characters[idx].dispose();
            }
        }
    }

    /**
     * @description 単体の上書きを実行
     *              Perform a single overwrite
     *
     * @return {void}
     * @method
     * @public
     */
    executeConfirmOverwriting ()
    {
        this.save();

        const inputValue = document
            .getElementById("confirm-file-name")
            .value;

        let name = this._$currentObject.file.name;
        if (name.indexOf(".swf") > -1) {
            name = name.replace(".swf", "");
        }

        const workSpace = Util.$currentWorkSpace();

        let libraryId = 0;
        if (inputValue === name) {

            // 上書きならIDを指定
            libraryId = workSpace
                ._$nameMap
                .get(this._$currentObject.path);

        }

        // 移動による上書き
        switch (this._$currentObject.type) {

            case "move":
                if (libraryId) {

                    // 上書き
                    this.moveOverwriting(libraryId);

                } else {

                    // 名前を変えて上書き
                    const instance = this._$currentObject.file;

                    // 名前を変更
                    instance.name     = inputValue;
                    instance.folderId = this._$currentObject.folderId;

                    // 名前を変えたのがフォルダの場合は後続の処理を中止
                    if (instance.type === InstanceType.FOLDER) {
                        this._$files.length = 0;
                    }

                    // 一度削除
                    document
                        .getElementById(`library-child-id-${instance.id}`)
                        .remove();

                    // 再登録
                    Util
                        .$libraryController
                        .createInstance(
                            instance.type,
                            instance.name,
                            instance.id,
                            instance.symbol
                        );

                }

                this.setup();
                break;

            case "copy":
                this.copyOverwriting(libraryId, inputValue);
                this.setup();
                break;

            default:

                new Promise((resolve) =>
                {
                    Util
                        .$libraryController
                        .loadFile(
                            this._$currentObject.file,
                            resolve,
                            this._$currentObject.folderId,
                            inputValue,
                            libraryId
                        );

                })
                    .then(() =>
                    {
                        this.setup();
                    });
                break;

        }

        this._$saved = false;
    }

    /**
     * @description レイヤーコピーを実行した際に、レイヤーにDisplayObjectを追加
     *              Add DisplayObject to layer
     *
     * @return {void}
     * @method
     * @public
     */
    addLayer (id)
    {
        // 複製
        const character = this._$currentObject.character;
        if (!character) {
            return ;
        }

        character.libraryId = id;

        const layer = this._$currentObject.layer;
        if (layer) {
            const copyFrame = this._$currentObject.copyFrame;
            if (copyFrame) {

                this.pasteDisplayObject(layer, character, copyFrame);

            } else {

                layer.addCharacter(character);

                if (!this._$layers.has(layer.id)) {
                    this._$layers.set(layer.id, layer);
                }

            }

            layer.reloadStyle();
        }
    }

    /**
     * @description 単体アイテムのスキップ処理
     *              Skip processing of single items
     *
     * @return {void}
     * @method
     * @public
     */
    executeConfirmSkip ()
    {
        if (this._$currentObject.type === "copy") {
            const layer     = this._$currentObject.layer;
            const character = this._$currentObject.character;

            if (layer && character) {
                layer.deleteCharacter(character.id);
            }
        }

        this.setup();
    }

    /**
     * @description 上書き確認モーダルを非表示にする
     *              Hide overwrite confirmation modal
     *
     * @return {void}
     * @method
     * @public
     */
    hide ()
    {
        if (this._$state === "hide") {
            return ;
        }

        // 初期化
        this._$state = "hide";

        const element = document
            .getElementById("confirm-modal");

        if (element) {
            if (!element.classList.contains("fadeOut")) {
                element.setAttribute("class", "fadeOut");
            }
        }
    }

    /**
     * @description 上書き確認モーダルを表示
     *              Display overwrite confirmation modal
     *
     * @return {void}
     * @method
     * @public
     */
    show ()
    {
        if (this._$state === "show") {
            return ;
        }

        // 状態を更新
        this._$state = "show";

        // 全てのモーダルを非表示に
        Util.$endMenu();

        const element = document
            .getElementById("confirm-modal");

        if (element) {
            if (!element.classList.contains("fadeIn")) {
                element.setAttribute("class", "fadeIn");
            }
        }

        this.setup();
    }

    /**
     * @description 処理確認用のMapを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clear ()
    {
        this._$layers.clear();
        this._$mapping.clear();
    }

    /**
     * @description 配列にアイテムがあれば表示、なければモーダル表示を終了
     *              If there are items in the array, display them; if not, exit modal display
     *
     * @return {void}
     * @method
     * @public
     */
    setup ()
    {
        this._$currentObject = this._$files.shift();

        // 重複したDisplayObjectはここで処理を行う
        if (this._$currentObject && this._$mapping.size) {
            while (this._$mapping.has(this._$currentObject.file.id)) {

                const id = this._$mapping.get(this._$currentObject.file.id);
                this.addLayer(id);

                this._$currentObject = this._$files.shift();
                if (!this._$currentObject) {
                    break;
                }
            }
        }

        // 表示項目がなければモーダル表示を終了
        if (!this._$currentObject) {

            // 非表示
            this.hide();

            //ライブラリを再構築
            Util.$libraryController.reload();

            // レイヤーを再描画
            if (this._$layers.size) {
                for (const layer of this._$layers.values()) {
                    layer.setCharacterStyle();
                }
            }

            // reset
            this.clear();

            // 再描画
            this.reloadScreen();

            return ;
        }

        // 表示を初期化
        const beforeElement = document
            .getElementById("confirm-before-preview");

        while (beforeElement.firstChild) {
            beforeElement.firstChild.remove();
        }

        // 表示を初期化
        const afterElement = document
            .getElementById("confirm-after-preview");

        while (afterElement.firstChild) {
            afterElement.firstChild.remove();
        }

        const input = document
            .getElementById("confirm-file-name");

        let name = this._$currentObject.file.name;
        if (name.indexOf(".swf") > -1) {
            name = name.replace(".swf", "");
        }

        input.value = name;
        input.focus();

        const workSpace = Util.$currentWorkSpace();

        const instance = workSpace.getLibrary(
            workSpace._$nameMap.get(this._$currentObject.path)
        );

        if (instance) {
            beforeElement.appendChild(instance.getPreview());
        }

        const file = this._$currentObject.file;
        switch (file.type) {

            case "image/svg+xml":
            case "image/png":
            case "image/jpeg":
            case "image/gif":
                {
                    const image = new Image();
                    image.onload = () =>
                    {
                        afterElement.appendChild(image);
                    };

                    image.src = URL.createObjectURL(file);
                }
                break;

            case "video/mp4":
                {
                    const video = document.createElement("video");
                    video.crossOrigin = "anonymous";
                    video.type        = "video/mp4";
                    video.muted       = true;
                    video.autoplay    = false;
                    video.controls    = true;

                    video.onloadedmetadata = () =>
                    {
                        afterElement.appendChild(video);
                    };
                    video.src = URL.createObjectURL(file);
                    video.load();
                }
                break;

            case "audio/mpeg":
                {
                    const audio = document.createElement("audio");
                    audio.preload  = "auto";
                    audio.autoplay = false;
                    audio.loop     = false;
                    audio.controls = true;

                    audio.src = URL.createObjectURL(file);
                    audio.load();
                    afterElement.appendChild(audio);
                }
                break;

            default:
                if (this._$currentObject.type === "copy") {

                    // ワークスペースを切り替え
                    const activeWorkSpaceId = Util.$activeWorkSpaceId;
                    Util.$activeWorkSpaceId = this._$currentObject.workSpaceId;

                    // プレビューを生成して、ワークスペースを切り替え
                    afterElement
                        .appendChild(
                            this._$currentObject.file.getPreview()
                        );
                    Util.$activeWorkSpaceId = activeWorkSpaceId;

                } else {

                    afterElement
                        .appendChild(
                            this._$currentObject.file.getPreview()
                        );

                }
                break;

        }
    }
}

Util.$confirmModal = new ConfirmModal();

/**
 * コントローラー表示の管理クラス
 * Management class for controller display
 *
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class Controller extends BaseController
{
    /**
     * @description 初期起動関数
     *              initial invoking function
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document
            .getElementById("controller");

        if (element) {
            element.addEventListener("mouseover", () =>
            {
                Util.$setCursor("auto");
            });
        }
    }

    /**
     * @description 指定したIDを表示する
     *              Display the specified ID
     *
     * @param  {array} names
     * @return {void}
     * @method
     * @public
     */
    showObjectSetting (names)
    {
        for (let idx = 0; idx < names.length; ++idx) {
            const element = document.getElementById(names[idx]);
            if (!element) {
                continue;
            }
            element.setAttribute("style", "");
        }
    }

    /**
     * @description 指定したIDを非表示にする
     *              Hide the specified ID
     *
     * @param  {array} names
     * @return {void}
     * @method
     * @public
     */
    hideObjectSetting (names)
    {
        for (let idx = 0; idx < names.length; ++idx) {
            const element = document.getElementById(names[idx]);
            if (!element) {
                continue;
            }
            element.setAttribute("style", "display: none;");
        }
    }

    /**
     * @description コントローラーの表示項目を初期表示に戻す
     *              Reset controller display items to initial display.
     *
     * @return {void}
     * @method
     * @public
     */
    default ()
    {
        // フィルターを初期化
        Util.$filterController.clear();

        this.hideObjectSetting([
            "object-area",
            "instance-setting",
            "fill-color-setting"
        ]);

        this.showObjectSetting([
            "stage-setting",
            "sound-setting",
            "object-setting",
            "color-setting",
            "blend-setting",
            "filter-setting"
        ]);

        const workSpace = Util.$currentWorkSpace();
        if (!workSpace) {
            return ;
        }

        const scene = workSpace.scene;
        if (!scene) {
            return ;
        }

        const objectName = document
            .getElementById("object-name");

        if (objectName) {
            objectName.value = scene.name;
        }

        const objectSymbol = document
            .getElementById("object-symbol");

        if (objectSymbol) {
            objectSymbol.value = scene.symbol;
        }
    }
}

Util.$controller = new Controller();

/**
 * コントローラー表示幅の操作クラス
 * Controller Display Width Operation Class
 *
 * @class
 * @memberOf view.controller
 */
class ControllerAdjustment
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$pointX = 0;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUp = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description デフォルトのコントローラー表示幅
     *              Default controller display width.
     *
     * @return {number}
     * @const
     * @static
     */
    static get DEFAULT_SIZE ()
    {
        return 360;
    }

    /**
     * @description コントローラーの共通の初期起動関数
     *              Common initial startup functions for controllers.
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        document
            .documentElement
            .style
            .setProperty(
                "--controller-width",
                `${ControllerAdjustment.DEFAULT_SIZE}px`
            );

        const element = document
            .getElementById("controller-adjustment");

        if (element) {
            element.addEventListener("mousedown", (event) =>
            {
                this.mouseDown(event);
            });
        }

        Util.$initializeEnd();
    }

    /**
     * @description コントローラーのサイズ変更イベントを起動
     *              Controller resizing event triggered
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        // 全てのイベントを中止
        event.preventDefault();
        event.stopPropagation();

        this._$pointX = event.screenX;

        if (!this._$mouseMove) {
            this._$mouseMove = this.mouseMove.bind(this);
        }

        if (!this._$mouseUp) {
            this._$mouseUp = this.mouseUp.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMove);
        window.addEventListener("mouseup", this._$mouseUp);
    }

    /**
     * @description コントローラーのサイズ変更実行処理
     *              Controller resizing execution process
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        Util.$setCursor("col-resize");

        window.requestAnimationFrame(() =>
        {
            // 全てのイベントを中止
            event.preventDefault();
            event.stopPropagation();

            const workSpace = Util.$currentWorkSpace();

            const diff = this._$pointX - event.screenX;

            const width = Math.max(
                ControllerAdjustment.DEFAULT_SIZE,
                workSpace._$controllerWidth + diff
            );

            document
                .documentElement
                .style
                .setProperty(
                    "--controller-width",
                    `${width}px`
                );

            workSpace._$controllerWidth = width;

            this._$pointX = event.screenX;

            // タイムラインを再構成
            Util.$rebuildTimeline();
        });
    }

    /**
     * @description コントローラーのサイズ変更イベントを終了
     *              Terminate controller resizing event
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUp ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMove);
        window.removeEventListener("mouseup", this._$mouseUp);

        // カーソルを初期値に戻す
        Util.$setCursor("auto");
    }
}

Util.$controllerAdjustment = new ControllerAdjustment();

/**
 * フィルター機能のコントローラークラス、グラデーションは親クラスで管理
 * Controller class for filter functions, gradients managed by parent class
 *
 * @class
 * @extends {GradientFilterController}
 * @memberOf view.controller
 */
class FilterController extends GradientFilterController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("filter");

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$filterId = 0;

        /**
         * @type {Map}
         * @private
         */
        this._$filters = new Map();
    }

    /**
     * @description ブラーの最小値
     *              Minimum value of blur
     *
     * @return {number}
     * @const
     * @static
     */
    static get MIN_BLUR ()
    {
        return 0;
    }

    /**
     * @description ブラーの最大値
     *              Maximum value of blur
     *
     * @return {number}
     * @const
     * @static
     */
    static get MAX_BLUR ()
    {
        return 255;
    }

    /**
     * @description 透明度の最小値
     *              Minimum value of alpha
     *
     * @return {number}
     * @const
     * @static
     */
    static get MIN_ALPHA ()
    {
        return 0;
    }

    /**
     * @description 透明度の最大値
     *              Maximum value of alpha
     *
     * @return {number}
     * @const
     * @static
     */
    static get MAX_ALPHA ()
    {
        return 100;
    }

    /**
     * @description 塗りの強さの最小値
     *              Minimum value of strength
     *
     * @return {number}
     * @const
     * @static
     */
    static get MIN_STRENGTH ()
    {
        return 0;
    }

    /**
     * @description 塗りの強さの最大値
     *              Maximum value of strength
     *
     * @return {number}
     * @const
     * @static
     */
    static get MAX_STRENGTH ()
    {
        return 255;
    }

    /**
     * @description 回転の最小値
     *              Minimum value of rotate
     *
     * @return {number}
     * @const
     * @static
     */
    static get MIN_ROTATE ()
    {
        return -360;
    }

    /**
     * @description 回転の最大値
     *              Maximum value of rotate
     *
     * @return {number}
     * @const
     * @static
     */
    static get MAX_ROTATE ()
    {
        return 360;
    }

    /**
     * @description 距離の最小値
     *              Minimum value of distance
     *
     * @return {number}
     * @const
     * @static
     */
    static get MIN_DISTANCE ()
    {
        return -255;
    }

    /**
     * @description 距離の最大値
     *              Maximum value of distance
     *
     * @return {number}
     * @const
     * @static
     */
    static get MAX_DISTANCE ()
    {
        return 255;
    }

    /**
     * @description カラーの最小値
     *              Minimum value of color
     *
     * @return {number}
     * @const
     * @static
     */
    static get MIN_COLOR ()
    {
        return 0;
    }

    /**
     * @description カラーの最大値
     *              Maximum value of color
     *
     * @return {number}
     * @const
     * @static
     */
    static get MAX_COLOR ()
    {
        return 0xffffff;
    }

    /**
     * @description クオリティーの最小値
     *              Minimum value of quality
     *
     * @return {number}
     * @const
     * @static
     */
    static get MIN_QUALITY ()
    {
        return 0;
    }

    /**
     * @description クオリティーの最大値
     *              Maximum value of quality
     *
     * @return {number}
     * @const
     * @static
     */
    static get MAX_QUALITY ()
    {
        return 16;
    }

    /**
     * @description 初期起動関数
     *              initial invoking function
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document.getElementById("filter-add");
        if (element) {
            element
                .addEventListener("mousedown", () =>
                {
                    this.addFilter();
                    this.disposeCharacterImage();
                    this.reloadScreen();
                });
        }
    }

    /**
     * @description 幅高さの変更のロックのOn/Off関数
     *              On/Off function for locking width-height changes.
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    lock (event)
    {
        // 全てのイベントを中止
        event.preventDefault();
        event.stopPropagation();

        // ロックのOn/Off
        const filterId = event.currentTarget.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return ;
        }

        const object = this._$filters.get(filterId);
        object.lock  = !object.lock;

        // 初期化
        this._$currentValue = null;

        event
            .currentTarget
            .childNodes[1]
            .setAttribute("class", object.lock
                ? "active"
                : "disable"
            );
    }

    /**
     * @description フィルターのコントローラー枠を表示・非表示にする
     *              Show/hide the controller frame of the filter
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    clickNodeTitle (event)
    {
        const filterId = event.target.dataset.filterId | 0;

        const element = document
            .getElementById(`filter-view-area-${filterId}`);

        if (!element) {
            return ;
        }

        if (element.style.display === "none") {

            element.setAttribute("style", "");
            document
                .getElementById(`filter-title-arrow-${filterId}`)
                .setAttribute("class", "arrow active");

        } else {

            element.setAttribute("style", "display: none;");
            document
                .getElementById(`filter-title-arrow-${filterId}`)
                .setAttribute("class", "arrow disable");

        }
    }

    /**
     * @description フィルターの有効・無効の処理
     *              Enabling and disabling filters
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    changeState (event)
    {
        const filterId = event.target.dataset.filterId | 0;

        if (!this._$filters.has(filterId)) {
            return ;
        }

        const object = this._$filters.get(filterId);

        // 値を更新
        object.filter.state = !object.filter.state;

        const element = document
            .getElementById(`filter-state-${filterId}`);

        if (element) {
            element.setAttribute("class", object.filter.state
                ? "filter-active"
                : "filter-disable"
            );
        }

        this.disposeCharacterImage();
    }

    /**
     * @description フィルターのコントローラーブロックの削除
     *              Delete the controller block of the filter
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    removeFilter (event)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const filterId = event.target.dataset.filterId | 0;

        const target = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                target.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            target.dataset.characterId | 0
        );

        const frame = Util.$timelineFrame.currentFrame;

        let place = character.getPlace(frame);
        if (place.tweenFrame) {

            if (character.endFrame - 1 > frame && !character.hasTween(frame)) {

                Util
                    .$timelineTool
                    .executeTimelineKeyAdd();

                place = character.getPlace(frame);
            }

            place = character.getPlace(place.tweenFrame);
        }

        const object = this._$filters.get(filterId);
        const index  = place.filter.indexOf(object.filter);
        place.filter.splice(index, 1);

        // tween情報があれば更新
        character.updateTweenFilter(frame);

        // remove
        this._$filters.delete(filterId);
        if (!this._$filters.size) {
            document
                .querySelectorAll(".filter-none")[0]
                .style.display = "";
        }

        const element = document
            .getElementById(`filter-id-${filterId}`);

        if (element) {
            element.remove();
        }

        super.focusOut();

        // 再描画用にキャッシュを削除
        character.dispose();
    }

    /**
     * @description InputElementにフォーカスした際の処理関数
     *              Processing function when InputElement is focused
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    focusIn (event)
    {
        super.focusIn(event);
        this.setLockElement(event);
    }

    /**
     * @description InputElement上でマウスを押下した際の処理関数
     *              Processing function when the mouse is pressed on an InputElement
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        super.mouseDown(event);
        this.setLockElement(event);
    }

    /**
     * @description ロックが有効の際に対象となるElementを変数にセット
     *              Set a variable to the target Element when locking is enabled
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    setLockElement (event)
    {
        // 初期化
        this._$lockTarget = null;

        if (this._$focus) {
            return ;
        }

        const filterId = event.target.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return ;
        }

        const object = this._$filters.get(filterId);
        if (!object.lock) {
            return ;
        }

        switch (this._$currentTarget.dataset.name) {

            case "blurX":
                this._$lockTarget = document.getElementById(`blurY-${filterId}`);
                break;

            case "blurY":
                this._$lockTarget = document.getElementById(`blurX-${filterId}`);
                break;

            default:
                // 他のInput変更時もこの処理が行われるので、対象以外はスキップ
                break;

        }
    }

    /**
     * @description blurXの値を更新
     *              Update blurX values
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeBlurX (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_BLUR,
            FilterController.MAX_BLUR
        );

        this.updateProperty("blurX", value);

        return value;
    }

    /**
     * @description blurYの値を更新
     *              Update blurY values
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeBlurY (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_BLUR,
            FilterController.MAX_BLUR
        );

        this.updateProperty("blurY", value);

        return value;
    }

    /**
     * @description strengthの値を更新
     *              Update strength values
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeStrength (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_STRENGTH,
            FilterController.MAX_STRENGTH
        );

        this.updateProperty("strength", value);

        return value;
    }

    /**
     * @description 透明度の値を更新
     *              Update alpha values
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeAlpha (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_ALPHA,
            FilterController.MAX_ALPHA
        );

        this.updateProperty("alpha", value);

        return value;
    }

    /**
     * @description 影の透明度を更新
     *              Update shadow transparency
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeShadowAlpha (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_ALPHA,
            FilterController.MAX_ALPHA
        );

        this.updateProperty("shadowAlpha", value);

        return value;
    }

    /**
     * @description ハイライトの透明度を更新
     *              Update highlight transparency
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeHighlightAlpha (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_ALPHA,
            FilterController.MAX_ALPHA
        );

        this.updateProperty("highlightAlpha", value);

        return value;
    }

    /**
     * @description 回転の値を更新
     *              Update rotation values
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeAngle (value)
    {
        value = Util.$clamp(
            (value | 0) % 360,
            FilterController.MIN_ROTATE,
            FilterController.MAX_ROTATE
        );
        if (0 > value) {
            value += 360;
        }

        this.updateProperty("angle", value);

        return value;
    }

    /**
     * @description 距離の値を更新
     *              Update distance values
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeDistance (value)
    {
        value = Util.$clamp(
            +value,
            FilterController.MIN_DISTANCE,
            FilterController.MAX_DISTANCE
        );

        this.updateProperty("distance", value);

        return value;
    }

    /**
     * @description カラーの値を更新
     *              Update color values
     *
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    changeColor (value)
    {
        this.updateProperty("color", Util.$clamp(
            `0x${value.slice(1)}` | 0,
            FilterController.MIN_COLOR,
            FilterController.MAX_COLOR
        ));

        return value;
    }

    /**
     * @description 影の色の値を更新
     *              Update shadow color values
     *
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    changeShadowColor (value)
    {
        this.updateProperty("shadowColor", Util.$clamp(
            `0x${value.slice(1)}` | 0,
            FilterController.MIN_COLOR,
            FilterController.MAX_COLOR
        ));
        return value;
    }

    /**
     * @description ハイライトカラーの値を更新
     *              Update highlight color values
     *
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    changeHighlightColor (value)
    {
        this.updateProperty("highlightColor", Util.$clamp(
            `0x${value.slice(1)}` | 0,
            FilterController.MIN_COLOR,
            FilterController.MAX_COLOR
        ));
        return value;
    }

    /**
     * @description 品質の値を更新
     *              Update quality values
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeQuality (value)
    {
        value = Util.$clamp(
            value | 0,
            FilterController.MIN_QUALITY,
            FilterController.MAX_QUALITY
        );
        this.updateProperty("quality", value);
    }

    /**
     * @description タイプの値を更新
     *              Update type values
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeType (value)
    {
        switch (value) {

            case "inner":
            case "outer":
            case "full":
                this.updateProperty("type", value);
                break;

            default:
                break;

        }
    }

    /**
     * @description Knockoutの値を更新
     *              Update knockout values
     *
     * @return {void}
     * @method
     * @public
     */
    changeKnockout ()
    {
        this.updateProperty("knockout", !!this._$currentTarget.checked);
    }

    /**
     * @description innerの値を更新
     *              Update INNER value
     *
     * @return {void}
     * @method
     * @public
     */
    changeInner ()
    {
        this.updateProperty("inner", !!this._$currentTarget.checked);
    }

    /**
     * @description hideObjectの変更値を更新
     *              Update HideObject value
     *
     * @return {void}
     * @method
     * @public
     */
    changeHideObject ()
    {
        this.updateProperty("hideObject", !!this._$currentTarget.checked);
    }

    /**
     * @description 指定プロパティーの値を更新
     *              Update the value of the specified property
     *
     * @param  {string} name
     * @param  {*} value
     * @return {void}
     * @method
     * @public
     */
    updateProperty (name, value)
    {
        if (!this._$currentTarget) {
            return ;
        }

        const filterId = this._$currentTarget.dataset.filterId | 0;
        if (!this._$filters.has(filterId)) {
            return ;
        }

        const object = this._$filters.get(filterId);
        if (object.filter[name] === value) {
            return ;
        }

        object.filter[name] = value;
        this.disposeCharacterImage();
    }

    /**
     * @description 更新したDisplayObjectを再描画する為、内部キャッシュを削除する
     *              Delete internal cache to redraw updated DisplayObjects
     *
     * @return {void}
     * @method
     * @public
     */
    disposeCharacterImage ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const element = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                element.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        // tween情報があれば更新
        character.relocationTween(
            Util.$timelineFrame.currentFrame
        );

        // 再描画用にキャッシュを削除
        character.dispose();
    }

    /**
     * @description フィルターの共有イベント処理(ロック・表示/非表示・有効/無効・削除)
     *              Filter share event handling (lock, show/hide, enable/disable, delete)
     *
     * @param  {number} id
     * @return {void}
     * @method
     * @public
     */
    setCommonEvent (id)
    {
        this.setLockEvent(
            document.getElementById(`filter-${id}-lock`)
        );
        this.setTitleEvent(
            document.getElementById(`filter-name-${id}`)
        );
        this.setStateEvent(
            document.getElementById(`filter-state-${id}`)
        );
        this.setTrashEvent(
            document.getElementById(`trash-${id}`)
        );
    }

    /**
     * @description blurのロックイベントを登録
     *              Register blur lock event
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setLockEvent (element)
    {
        if (!element) {
            return ;
        }

        element.addEventListener("mousedown", (event) =>
        {
            this.lock(event);
        });
    }

    /**
     * @description フィルターのコントローラーブロックの表示・非表示イベント
     *              Show/Hide events for the controller block of the filter
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setTitleEvent (element)
    {
        if (!element) {
            return ;
        }

        element.addEventListener("mousedown", (event) =>
        {
            this.clickNodeTitle(event);
        });
    }

    /**
     * @description フィルターの有効・無効イベント
     *              Filter enable/disable events
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setStateEvent (element)
    {
        if (!element) {
            return ;
        }

        const filterId = element.dataset.filterId | 0;
        if (this._$filters.has(filterId)) {
            const object = this._$filters.get(filterId);
            element
                .setAttribute("class", object.filter.state
                    ? "filter-active"
                    : "filter-disable"
                );
        }

        element.addEventListener("mousedown", (event) =>
        {
            this.save();

            this.changeState(event);

            this.reloadScreen();

            this._$saved = false;
        });
    }

    /**
     * @description フィルターの削除イベント
     *              Delete Filter Event
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    setTrashEvent (element)
    {
        if (!element) {
            return ;
        }

        element.addEventListener("click", (event) =>
        {
            this.removeFilter(event);
            this.reloadScreen();
        });
    }

    /**
     * @description フィルターの追加処理関数
     *              Additional processing functions for filters
     *
     * @return {void}
     * @method
     * @public
     */
    addFilter ()
    {
        const element = document
            .querySelectorAll(".filter-none")[0];

        if (element) {
            element.setAttribute("style", "display: none;");
        }

        const select = document.getElementById("filter-select");
        if (select) {
            this[`add${select.value}`]();
        }
    }

    /**
     * @description フィルター表示を初期化
     *              Initialize filter display
     *
     * @return {void}
     * @method
     * @public
     */
    clear ()
    {
        this._$filterId = 0;
        this._$filters.clear();

        const element = document
            .getElementById("filter-setting-list");

        if (!element) {
            return ;
        }

        // fixed logic
        // テキストのElementは消えてもいいようにここで変数に格納しておく
        const textElement = document
            .querySelectorAll(".filter-none")[0];

        while (element.firstChild) {
            element.firstChild.remove();
        }

        // 表示してDOMに追加
        textElement.setAttribute("style", "");
        element.appendChild(textElement);
    }

    /**
     * @description フィルターのオブジェクトを生成してマッピングに登録
     *              Generate filter objects and register them in the mapping
     *
     * @param  {function} filterClass
     * @param  {DropShadowFilter|BlurFilter|GlowFilter|BevelFilter|GradientGlowFilter|GradientBevelFilter} [filter=null]
     * @return {number}
     * @method
     * @public
     */
    createFilter (filterClass, filter = null)
    {
        if (!filter) {

            /**
             * @type {ArrowTool}
             */
            const tool = Util.$tools.getDefaultTool("arrow");
            const activeElements = tool.activeElements;
            if (!activeElements.length) {
                return -1;
            }

            filter = new filterClass();

            const target = activeElements[0];
            const scene  = Util.$currentWorkSpace().scene;
            const layer  = scene.getLayer(
                target.dataset.layerId | 0
            );

            const character = layer.getCharacter(
                target.dataset.characterId | 0
            );

            const frame = Util.$timelineFrame.currentFrame;

            let place = character.getPlace(frame);
            if (place.tweenFrame) {

                if (character.endFrame - 1 > frame && !character.hasTween(frame)) {

                    Util
                        .$timelineTool
                        .executeTimelineKeyAdd();

                    place = character.getPlace(frame);
                }

                place = character.getPlace(place.tweenFrame);

                // tweenの情報を更新
                character.updateTweenFilter(frame);
            }

            place.filter.push(filter);
        }

        const id = this._$filterId++;

        // 複数のフィルターを管理するので、Mapで状態管理を行う
        this._$filters.set(id, {
            "id": id,
            "lock": false,
            "filter": filter,
            "context": null
        });

        return id;
    }

    /**
     * @description DropShadowFilterの設定項目をコントローラーに追加
     *              Added DropShadowFilter configuration item to controller
     *
     * @param  {DropShadowFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    addDropShadowFilter (filter = null, reload = true)
    {
        const element = document.getElementById("filter-setting-list");
        if (!element) {
            return ;
        }

        const id = this.createFilter(DropShadowFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = `
${FilterHTML.createHeaderHTML(id, "DropShadow")}

        <div class="filter-view-area-right">
        
            <div class="filter-container">
                ${FilterHTML.createBlurX(id, filter.blurX)}
                ${FilterHTML.createStrength(id, filter.strength)}
            </div>
    
            <div class="filter-container">
                ${FilterHTML.createBlurY(id, filter.blurY)}
                ${FilterHTML.createAngle(id, filter.angle)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createDistance(id, filter.distance)}
            </div>
    
            <div class="filter-container">
                ${FilterHTML.createShadowColor(id, filter.color)}
                ${FilterHTML.createShadowAlpha(id, filter.alpha)}
            </div>
            
            <div class="filter-container">
                ${FilterHTML.createKnockout(id)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createInnerShadow(id)}
            </div>
    
            <div class="filter-container">
                ${FilterHTML.createHideObject(id)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createQuality(id)}
            </div> 
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // 共有イベント処理
        this.setCommonEvent(id);

        // 保存データの場合はcheckboxの値を更新
        if (filter.knockout) {
            document
                .getElementById(`knockout-${id}`)
                .checked = true;
        }
        if (filter.inner) {
            document
                .getElementById(`inner-${id}`)
                .checked = true;
        }
        if (filter.hideObject) {
            document
                .getElementById(`hideObject-${id}`)
                .checked = true;
        }

        const inputIds = [
            `blurX-${id}`,
            `blurY-${id}`,
            `strength-${id}`,
            `angle-${id}`,
            `alpha-${id}`,
            `distance-${id}`
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const clickIds = [
            `knockout-${id}`,
            `inner-${id}`,
            `hideObject-${id}`
        ];

        for (let idx = 0; idx < clickIds.length; ++idx) {
            this.setClickEvent(
                document.getElementById(clickIds[idx])
            );
        }

        const changeIds = [
            `color-${id}`,
            `quality-${id}`
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(changeIds[idx])
            );
        }

        // 内部キャッシュを削除
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(
            document.getElementById(`filter-id-${id}`)
        );
    }

    /**
     * @description BlurFilterの設定項目をコントローラーに追加
     *              Added BlurFilter configuration item to controller
     *
     * @param  {BlurFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    addBlurFilter (filter = null, reload = true)
    {
        const element = document.getElementById("filter-setting-list");
        if (!element) {
            return ;
        }

        const id = this.createFilter(BlurFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = `
${FilterHTML.createHeaderHTML(id, "Blur")}
        
        <div class="filter-view-area-right">
        
            <div class="filter-container">
                ${FilterHTML.createBlurX(id, filter.blurX)}
            </div>
        
            <div class="filter-container">
                ${FilterHTML.createBlurY(id, filter.blurY)}
            </div>
        
            <div class="filter-container">
                ${FilterHTML.createQuality(id)}
            </div> 
        
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // 共有イベント処理
        this.setCommonEvent(id);

        const inputIds = [
            `blurX-${id}`,
            `blurY-${id}`
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const changeIds = [
            `quality-${id}`
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(changeIds[idx])
            );
        }

        // 内部キャッシュを削除
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(
            document.getElementById(`filter-id-${id}`)
        );
    }

    /**
     * @description GlowFilterの設定項目をコントローラーに追加
     *              Added GlowFilter configuration item to controller
     *
     * @param  {GlowFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    addGlowFilter (filter = null, reload = true)
    {
        const element = document.getElementById("filter-setting-list");
        if (!element) {
            return ;
        }

        const id = this.createFilter(GlowFilter, filter);
        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = `
${FilterHTML.createHeaderHTML(id, "Glow")}

        <div class="filter-view-area-right">

            <div class="filter-container">
                ${FilterHTML.createBlurX(id, filter.blurX)}
                ${FilterHTML.createStrength(id, filter.strength)}
            </div>
            
            <div class="filter-container">
                ${FilterHTML.createBlurY(id, filter.blurY)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createColor(id, filter.color)}
                ${FilterHTML.createAlpha(id, filter.alpha)}
            </div>
            
            <div class="filter-container">
                ${FilterHTML.createInnerShadow(id)}
            </div>
            
            <div class="filter-container">
                ${FilterHTML.createKnockout(id)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createQuality(id)}
            </div> 
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // 共有イベント処理
        this.setCommonEvent(id);

        // 保存データの場合はcheckboxの値を更新
        if (filter.knockout) {
            document
                .getElementById(`knockout-${id}`)
                .checked = true;
        }
        if (filter.inner) {
            document
                .getElementById(`inner-${id}`)
                .checked = true;
        }

        const inputIds = [
            `blurX-${id}`,
            `blurY-${id}`,
            `strength-${id}`,
            `alpha-${id}`,
            `distance-${id}`
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const clickIds = [
            `knockout-${id}`,
            `inner-${id}`
        ];

        for (let idx = 0; idx < clickIds.length; ++idx) {
            this.setClickEvent(
                document.getElementById(clickIds[idx])
            );
        }

        const changeIds = [
            `color-${id}`,
            `quality-${id}`
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(changeIds[idx])
            );
        }

        // 内部キャッシュを削除
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(
            document.getElementById(`filter-id-${id}`)
        );
    }

    /**
     * @description BevelFilterの設定項目をコントローラーに追加
     *              Added BevelFilter configuration item to controller
     *
     * @param  {BevelFilter} [filter=null]
     * @param  {boolean} [reload=true]
     * @return {void}
     * @method
     * @public
     */
    addBevelFilter (filter = null, reload = true)
    {
        const element = document.getElementById("filter-setting-list");
        if (!element) {
            return ;
        }

        const id = this.createFilter(BevelFilter, filter);
        if (0 > id) {
            return ;
        }

        if (!filter) {
            filter = this._$filters.get(id).filter;
        }

        const htmlTag = `
${FilterHTML.createHeaderHTML(id, "Bevel")}
        
        <div class="filter-view-area-right">

            <div class="filter-container">
                ${FilterHTML.createBlurX(id, filter.blurX)}
                ${FilterHTML.createStrength(id, filter.strength)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createBlurY(id, filter.blurY)}
                ${FilterHTML.createAngle(id, filter.angle)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createDistance(id, filter.distance)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createShadowColor(id, filter.shadowColor)}
                ${FilterHTML.createShadowAlpha(id, filter.shadowAlpha)}
            </div>
            
            <div class="filter-container">
                ${FilterHTML.createHighlightColor(id, filter.highlightColor)}
                ${FilterHTML.createHighlightAlpha(id, filter.highlightAlpha)}
            </div>
            
            <div class="filter-container">
                ${FilterHTML.createKnockout(id)}
            </div>

            <div class="filter-container">
                ${FilterHTML.createBevelType(id)}
                ${FilterHTML.createQuality(id)}
            </div>
            
        </div>
    </div>
</div>
`;

        // added element
        element.insertAdjacentHTML("beforeend", htmlTag);

        // 共有イベント処理
        this.setCommonEvent(id);

        // 保存データの場合はcheckboxの値を更新
        if (filter.knockout) {
            document
                .getElementById(`knockout-${id}`)
                .checked = true;
        }

        const inputIds = [
            `blurX-${id}`,
            `blurY-${id}`,
            `strength-${id}`,
            `angle-${id}`,
            `shadowAlpha-${id}`,
            `highlightAlpha-${id}`,
            `distance-${id}`
        ];

        // 各inputのelementにイベントを登録
        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const clickIds = [
            `knockout-${id}`
        ];

        for (let idx = 0; idx < clickIds.length; ++idx) {
            this.setClickEvent(
                document.getElementById(clickIds[idx])
            );
        }

        const changeIds = [
            `shadowColor-${id}`,
            `highlightColor-${id}`,
            `type-${id}`,
            `quality-${id}`
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(changeIds[idx])
            );
        }

        // 内部キャッシュを削除
        if (reload) {
            this.disposeCharacterImage();
        }

        Util.$addModalEvent(
            document.getElementById(`filter-id-${id}`)
        );
    }
}

Util.$filterController = new FilterController();

/**
 * フィルターのコントローラーに追加するHTMLを管理するクラス
 * Class that manages HTML to be added to the filter's controller
 *
 * @class
 * @memberOf view.controller
 */
class FilterHTML
{
    /**
     * @description フィルター表示で共通しているHTMLを返す
     *              Returns HTML that is common in the filter display
     *
     * @param  {number} id
     * @param  {string} name
     * @return {string}
     * @method
     * @public
     */
    static createHeaderHTML (id, name)
    {
        return `
<div id="filter-id-${id}" class="filter-border">

    <div class="filter-title">
        <i id="filter-title-arrow-${id}" class="arrow active"></i>
        <span id="filter-name-${id}" data-filter-id="${id}">${name}</span>
        <i class="filter-active" id="filter-state-${id}" data-filter-id="${id}" data-detail="{{フィルターを表示・非表示する}}"></i>
        <i class="trash" id="trash-${id}" data-filter-id="${id}" data-detail="{{フィルターを削除}}"></i>
    </div>
    
    <div id="filter-view-area-${id}" class="filter-view-area">
    
        <div class="filter-view-area-left">
        
            <div id="filter-${id}-lock" data-filter-id="${id}" class="filter-lock">
                ┌
                <div class="disable" data-detail="{{比率を固定}}"></div>
                └
            </div>
        
        </div>
`;
    }

    /**
     * @description BlurXのHTMLタグを返す
     *              Return BlurX HTML
     *
     * @param  {number} id
     * @param  {number} value
     * @return {string}
     * @method
     * @static
     */
    static createBlurX (id, value)
    {
        return `
<div class="filter-text">BlurX</div>
<div><input type="text" id="blurX-${id}" value="${value}" data-name="blurX" data-filter-id="${id}" data-detail="{{水平方向にぼかす}}"></div>
`;
    }

    /**
     * @description BlurYのHTMLタグを返す
     *              Return BlurY HTML
     *
     * @param  {number} id
     * @param  {number} value
     * @return {string}
     * @method
     * @static
     */
    static createBlurY (id, value)
    {
        return `
<div class="filter-text">BlurY</div>
<div><input type="text" id="blurY-${id}" value="${value}" data-name="blurY" data-filter-id="${id}" data-detail="{{垂直方向にぼかす}}"></div>
`;
    }

    /**
     * @description StrengthのHTMLタグを返す
     *              Return Strength HTML
     *
     * @param  {number} id
     * @param  {number} value
     * @return {string}
     * @method
     * @static
     */
    static createStrength (id, value)
    {
        return `
<div class="filter-text">Strength</div>
<div><input type="text" id="strength-${id}" value="${value}" data-filter-id="${id}" data-name="strength" data-detail="{{フィルター強度}}"></div>
`;
    }

    /**
     * @description AngleのHTMLタグを返す
     *              Return Angle HTML
     *
     * @param  {number} id
     * @param  {number} value
     * @return {string}
     * @method
     * @static
     */
    static createAngle (id, value)
    {
        return `
<div class="filter-text">Angle</div>
<div><input type="text" id="angle-${id}" value="${value}" data-filter-id="${id}" data-name="angle" data-detail="{{フィルター角度}}"></div>
`;
    }

    /**
     * @description AngleのHTMLタグを返す
     *              Return Angle HTML
     *
     * @param  {number} id
     * @param  {number} value
     * @return {string}
     * @method
     * @static
     */
    static createDistance (id, value)
    {
        return `
<div class="filter-text">Distance</div>
<div><input type="text" id="distance-${id}" value="${value}" data-filter-id="${id}" data-name="distance" data-detail="{{フィルター距離}}"></div>
`;
    }

    /**
     * @description ShadowColorのHTMLタグを返す
     *              Return ShadowColor HTML
     *
     * @param  {number} id
     * @param  {number} value
     * @return {string}
     * @method
     * @static
     */
    static createShadowColor (id, value)
    {
        return `
<div class="filter-text">Shadow<br>Color</div>
<div><input type="color" id="shadowColor-${id}" value="#${value.toString(16).padStart(6, "0")}" data-filter-id="${id}" data-name="shadowColor" data-detail="{{シャドウのカラー}}"></div>
`;
    }

    /**
     * @description ShadowAlphaのHTMLタグを返す
     *              Return ShadowAlpha HTML
     *
     * @param  {number} id
     * @param  {number} value
     * @return {string}
     * @method
     * @static
     */
    static createShadowAlpha (id, value)
    {
        return `
<div class="filter-text">Shadow<br>Alpha</div>
<div><input type="text" id="shadowAlpha-${id}" value="${value}" data-filter-id="${id}" data-name="shadowAlpha" data-detail="{{シャドウのアルファ}}"></div>
`;
    }

    /**
     * @description HighlightColorのHTMLタグを返す
     *              Return HighlightColor HTML
     *
     * @param  {number} id
     * @param  {number} value
     * @return {string}
     * @method
     * @static
     */
    static createHighlightColor (id, value)
    {
        return `
<div class="filter-text">Highlight<br>Color</div>
<div><input type="color" id="highlightColor-${id}" value="#${value.toString(16).padStart(6, "0")}" data-filter-id="${id}" data-name="highlightColor" data-detail="{{ハイライトのカラー}}"></div>
`;
    }

    /**
     * @description HighlightAlphaのHTMLタグを返す
     *              Return HighlightAlpha HTML
     *
     * @param  {number} id
     * @param  {number} value
     * @return {string}
     * @method
     * @static
     */
    static createHighlightAlpha (id, value)
    {
        return `
<div class="filter-text">Highlight<br>Alpha</div>
<div><input type="text" id="highlightAlpha-${id}" value="${value}" data-filter-id="${id}" data-name="highlightAlpha" data-detail="{{ハイライトのアルファ}}"></div>
`;
    }

    /**
     * @description KnockoutのHTMLタグを返す
     *              Return Knockout HTML
     *
     * @param  {number} id
     * @return {string}
     * @method
     * @static
     */
    static createKnockout (id)
    {
        return `
<div><input type="checkbox" id="knockout-${id}" data-name="knockout" data-filter-id="${id}"></div>
<div class="filter-text-long">
    <label for="knockout-${id}">Knockout</label>
</div>
`;
    }

    /**
     * @description BevelTypeのHTMLタグを返す
     *              Return BevelType HTML
     *
     * @param  {number} id
     * @return {string}
     * @method
     * @static
     */
    static createBevelType (id)
    {
        return `
<div class="filter-text-long">Type</div>
<div>
    <select id="type-${id}" data-name="type" data-filter-id="${id}">
        <option value="inner">Inner</option>
        <option value="outer">Outer</option>
        <option value="full">Full</option>
    </select>
</div>
`;
    }

    /**
     * @description QualityのHTMLタグを返す
     *              Return Quality HTML
     *
     * @param  {number} id
     * @return {string}
     * @method
     * @static
     */
    static createQuality (id)
    {
        return `
<div class="filter-text-long">Quality</div>
<div>
    <select id="quality-${id}" data-name="quality" data-filter-id="${id}">
        <option value="1">Low</option>
        <option value="2">Middle</option>
        <option value="3">High</option>
    </select>
</div>
`;
    }

    /**
     * @description InnerShadowのHTMLタグを返す
     *              Return InnerShadow HTML
     *
     * @param  {number} id
     * @return {string}
     * @method
     * @static
     */
    static createInnerShadow (id)
    {
        return `
<div><input type="checkbox" id="inner-${id}" data-name="inner" data-filter-id="${id}"></div>
<div class="filter-text-long">
    <label for="inner-${id}">Inner Shadow</label>
</div>
`;
    }

    /**
     * @description HideObjectのHTMLタグを返す
     *              Return HideObject HTML
     *
     * @param  {number} id
     * @return {string}
     * @method
     * @static
     */
    static createHideObject (id)
    {
        return `
<div><input type="checkbox" id="hideObject-${id}" data-name="hideObject" data-filter-id="${id}"></div>
<div class="filter-text-long">
    <label for="hideObject-${id}">Hide Object</label>
</div>
`;
    }

    /**
     * @description ColorのHTMLタグを返す
     *              Return Color HTML
     *
     * @param  {number} id
     * @param  {number} value
     * @return {string}
     * @method
     * @static
     */
    static createColor (id, value)
    {
        return `
<div class="filter-text">Color</div>
<div><input type="color" id="color-${id}" value="#${value.toString(16).padStart(6, "0")}" data-filter-id="${id}" data-name="color" data-detail="{{シャドウのカラー}}"></div>
`;
    }

    /**
     * @description AlphaのHTMLタグを返す
     *              Return Alpha HTML
     *
     * @param  {number} id
     * @param  {number} value
     * @return {string}
     * @method
     * @static
     */
    static createAlpha (id, value)
    {
        return `
<div class="filter-text">Alpha</div>
<div><input type="text" id="alpha-${id}" value="${value}" data-filter-id="${id}" data-name="alpha" data-detail="{{シャドウのアルファ}}"></div>
`;
    }

    /**
     * @description GradientColorのHTMLタグを返す
     *              Return GradientColor HTML
     *
     * @param  {number} id
     * @return {string}
     * @method
     * @static
     */
    static createGradientColor (id)
    {
        return `
<div class="filter-text">Color</div>
<div><input type="color" id="gradientColor-${id}" value="#000000" data-filter-id="${id}" data-name="gradientColor" data-detail="{{グラデーションカラー}}"></div>
`;
    }

    /**
     * @description GradientAlphaのHTMLタグを返す
     *              Return GradientAlpha HTML
     *
     * @param  {number} id
     * @return {string}
     * @method
     * @static
     */
    static createGradientAlpha (id)
    {
        return `
<div class="filter-text">Alpha</div>
<div><input type="text" id="gradientAlpha-${id}" value="100" data-filter-id="${id}" data-name="gradientAlpha" data-detail="{{グラデーションのアルファ}}"></div>
        `;
    }

    /**
     * @description GradientColorPaletteのHTMLタグを返す
     *              Return GradientColorPalette HTML
     *
     * @param  {number} id
     * @return {string}
     * @method
     * @static
     */
    static createGradientColorPalette (id)
    {
        return `
<div id="gradient-color-palette-${id}" class="gradient-color-palette">
    <div id="color-palette-${id}" class="color-palette">
        <canvas id="gradient-canvas-${id}"></canvas>
    </div>
    <div id="color-pointer-list-${id}" data-filter-id="${id}" class="color-pointer-list" data-detail="{{カラーポインターを追加}}"></div>
</div>
`;
    }
}

/**
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class GridController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("nine-slice");

        /**
         * @description 表示非表示の状態変数、初期値は非表示
         * @type {string}
         * @default "hide"
         * @private
         */
        this._$state = "hide";

        /**
         * @type {array}
         * @private
         */
        this._$elementIds = [
            "grid-top-left",
            "grid-top-right",
            "grid-bottom-left",
            "grid-bottom-right"
        ];

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$gridMouseMove = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$gridMouseUp = null;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const inputIds = [
            "nine-slice-setting-x",
            "nine-slice-setting-y",
            "nine-slice-setting-w",
            "nine-slice-setting-h"
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        // スクリーンのグリッドElementのイベントを登録
        for (let idx = 0; idx < this._$elementIds.length; ++idx) {

            const element = document.getElementById(this._$elementIds[idx]);
            if (!element) {
                continue;
            }

            // 初期は非表示
            element.style.display = "none";
            element.addEventListener("mousedown", (event) =>
            {
                this.standbyPointer(event);
            });
        }
    }

    /**
     * @description スクリーンの変形Elementの選択時の関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    standbyPointer (event)
    {
        // 親のイベントを中止する
        event.stopPropagation();

        const activeTool = Util.$tools.activeTool;
        if (activeTool) {
            event.grid = true;
            activeTool.dispatchEvent(
                EventType.MOUSE_DOWN,
                event
            );
        }
    }

    /**
     * @description グリッドのx座標の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeNineSliceSettingX (value)
    {
        this.updateShapeGrid (
            +value,
            +document.getElementById("nine-slice-setting-y").value,
            +document.getElementById("nine-slice-setting-w").value,
            +document.getElementById("nine-slice-setting-h").value
        );
        return +value;
    }

    /**
     * @description グリッドのy座標の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeNineSliceSettingY (value)
    {
        this.updateShapeGrid (
            +document.getElementById("nine-slice-setting-x").value,
            +value,
            +document.getElementById("nine-slice-setting-w").value,
            +document.getElementById("nine-slice-setting-h").value
        );
        return +value;
    }

    /**
     * @description グリッドの幅の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeNineSliceSettingW (value)
    {
        this.updateShapeGrid (
            +document.getElementById("nine-slice-setting-x").value,
            +document.getElementById("nine-slice-setting-y").value,
            +value,
            +document.getElementById("nine-slice-setting-h").value
        );
        return +value;
    }

    /**
     * @description グリッドの高さの値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeNineSliceSettingH (value)
    {
        this.updateShapeGrid (
            +document.getElementById("nine-slice-setting-x").value,
            +document.getElementById("nine-slice-setting-y").value,
            +document.getElementById("nine-slice-setting-w").value,
            +value
        );
        return +value;
    }

    /**
     * @description グリッドのElementの値を更新
     *
     * @param  {number} [x=0]
     * @param  {number} [y=0]
     * @param  {number} [w=0]
     * @param  {number} [h=0]
     * @return {void}
     * @method
     * @public
     */
    updateShapeGrid (x, y, w, h)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                activeElements[0].dataset.libraryId | 0
            );

        switch (0) {

            case x:
            case y:
                instance._$grid = null;
                this.hide();
                break;

            default:
                instance._$grid = {
                    "x": x,
                    "y": y,
                    "w": w,
                    "h": h
                };

                this
                    .show()
                    .relocation();
                break;

        }

        instance.cacheClear();
    }

    /**
     * @description スクリーンのグリッドElementを表示
     *
     * @return {GridController}
     * @method
     * @public
     */
    show ()
    {
        if (this._$state !== "show") {
            this._$state = "show";

            for (let idx = 0; idx < this._$elementIds.length; ++idx) {

                const element = document
                    .getElementById(this._$elementIds[idx]);

                if (!element) {
                    continue;
                }

                element.style.display = "";
            }
        }

        return this;
    }

    /**
     * @description スクリーンのグリッドElementを非表示
     *
     * @return {void}
     * @method
     * @public
     */
    hide ()
    {
        if (this._$state === "hide") {
            return ;
        }

        for (let idx = 0; idx < this._$elementIds.length; ++idx) {

            const element = document
                .getElementById(this._$elementIds[idx]);

            if (!element) {
                continue;
            }

            element.style.display = "none";
        }
        this._$state = "hide";
    }

    /**
     * @description スクリーンのグリッドElementを再配置
     *
     * @return {void}
     * @method
     * @public
     */
    relocation ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return this.hide();
        }

        const target      = activeElements[0];
        const characterId = target.dataset.characterId | 0;

        const element = document
            .getElementById(`character-${characterId}`);

        if (!element) {
            return this.hide();
        }

        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace.getLibrary(
            target.dataset.libraryId | 0
        );

        if (!instance || instance.type !== InstanceType.SHAPE) {
            return this.hide();
        }

        const grid = instance._$grid;
        if (!grid) {
            return this.hide();
        }

        const layerId   = target.dataset.layerId | 0;
        const layer     = workSpace.scene.getLayer(layerId);
        const character = layer.getCharacter(
            target.dataset.characterId | 0
        );

        if (character.rotation) {
            this.hide();
            return;
        }

        const bounds = character.getBounds();

        const x = element.offsetLeft;
        const y = element.offsetTop;
        const w = character.width  - Math.abs(bounds.xMax - bounds.xMin);
        const h = character.height - Math.abs(bounds.yMax - bounds.yMin);

        const topLeft = document.getElementById("grid-top-left");
        topLeft.style.left = `${x + grid.x - 4}px`;
        topLeft.style.top  = `${y + grid.y - 4}px`;

        const topRight = document.getElementById("grid-top-right");
        topRight.style.left = `${x + grid.x + grid.w + w - 4}px`;
        topRight.style.top  = `${y + grid.y - 4}px`;

        const bottomLeft = document.getElementById("grid-bottom-left");
        bottomLeft.style.left = `${x + grid.x - 4}px`;
        bottomLeft.style.top  = `${y + grid.y + grid.h + h - 4}px`;

        const bottomRight = document.getElementById("grid-bottom-right");
        bottomRight.style.left = `${x + grid.x + grid.w + w - 4}px`;
        bottomRight.style.top  = `${y + grid.y + grid.h + h - 4}px`;
    }
}

Util.$gridController = new GridController();

/**
 * @class
 * @memberOf view.controller
 */
class InstanceSelectController extends BaseController
{
    /**
     * @description ライブラリの選択インスタンスのプルダウン制御
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        // インスタンス設定は初期は非表示
        const element = document.getElementById("instance-setting");
        if (element) {
            element.style.display = "none";
        }
    }

    /**
     * @description ライブラリの選択可能なインスタンスをプルダウンにセット
     *
     * @param  {object} instance
     * @return {void}
     * @method
     * @public
     */
    createInstanceSelect (instance)
    {
        const workSpace = Util.$currentWorkSpace();

        const element = document
            .getElementById("instance-type-name");

        while (element.children.length) {
            element.children[0].remove();
        }

        // アイコンを登録
        const i = document.createElement("i");
        i.setAttribute("class", `library-type-${instance.type}`);
        element.appendChild(i);

        const select = document.createElement("select");
        select.classList.add("instance-select");

        select.addEventListener("change", (event) =>
        {
            const activeTool = Util.$tools.activeTool;
            if (activeTool) {
                event.displayObject = true;
                activeTool.dispatchEvent(
                    EventType.CHANGE,
                    event
                );
            }
        });

        for (const value of workSpace._$libraries.values()) {

            if (!value.id) {
                continue;
            }

            switch (value.type) {

                case InstanceType.FOLDER:
                case InstanceType.SOUND:
                    continue;

                default:
                    break;

            }

            const option = document.createElement("option");
            option.value = value.id;

            // フォルダの場合はパス名を追加する
            let path = value.name;
            if (value._$folderId) {
                let parent = value;
                while (parent._$folderId) {
                    parent = workSpace.getLibrary(parent._$folderId);
                    path = `${parent.name}/${path}`;
                }
            }
            option.innerHTML = path;

            if (value.id === instance.id) {
                option.defaultSelected = true;
            }

            select.appendChild(option);
        }

        // DOMに登録
        element.appendChild(select);
    }
}

Util.$instanceSelectController = new InstanceSelectController();


/**
 * @class
 * @memberOf view.controller
 */
class JavascriptController
{
    /**
     * @return {void}
     * @method
     * @public
     */
    reload ()
    {
        const element = document
            .getElementById("javascript-internal-list-box");

        if (!element) {
            return;
        }

        // 表示リストを初期化
        const children = element.children;
        while (children.length) {
            children[0].remove();
        }

        const workSpaces = Util.$currentWorkSpace();
        if (!workSpaces) {
            return;
        }

        for (const instance of workSpaces._$libraries.values()) {

            if (instance._$type !== InstanceType.MOVIE_CLIP) {
                continue;
            }

            if (!instance._$actions.size) {
                continue;
            }

            const id = instance.id;
            const parentTag = `<div id="script-${id}" data-library-id="${id}" class="internal-parent"><i></i>${instance._$name}</div>`;

            element.insertAdjacentHTML("beforeend", parentTag);

            const parentElement = document
                .getElementById(`script-${id}`);

            // eslint-disable-next-line no-loop-func
            parentElement.addEventListener("dblclick", (event) =>
            {
                Util.$sceneChange.reload(
                    event.currentTarget.dataset.libraryId | 0
                );
            });

            for (const frame of instance._$actions.keys()) {

                const childTag = `<div id="script-${id}-${frame}" data-library-id="${id}" data-frame="${frame}" class="internal-child"><i></i>frame ${frame}</div>`;

                element.insertAdjacentHTML("beforeend", childTag);

                const childElement = document
                    .getElementById(`script-${id}-${frame}`);

                // eslint-disable-next-line no-loop-func
                childElement.addEventListener("mousedown", (event) =>
                {
                    Util.$javaScriptEditor.hide();

                    const target = event.currentTarget;

                    const scene = Util
                        .$currentWorkSpace()
                        .getLibrary(target.dataset.libraryId | 0);

                    const frame = target.dataset.frame | 0;
                    Util.$javaScriptEditor.show(null, frame, scene);
                });
            }

        }
    }
}

Util.$javascriptController = new JavascriptController();

/**
 * @class
 * @memberOf view.controller
 */
class LibraryController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;

        /**
         * @type {Map}
         * @private
         */
        this._$activeInstances = new Map();

        /**
         * @type {Map}
         * @private
         */
        this._$copyMapping = new Map();

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @return {Map}
     * @public
     */
    get activeInstances ()
    {
        return this._$activeInstances;
    }

    /**
     * @param  {HTMLDivElement} element
     * @return {void}
     * @public
     */
    set activeInstance (element)
    {
        switch (true) {

            case Util.$ctrlKey && this.activeInstances.size > 0:
                {
                    const libraryId = element.dataset.libraryId | 0;

                    // 選択中であれば非アクティブに
                    if (this.activeInstances.has(libraryId)) {

                        this.activeInstances.delete(libraryId);

                        element
                            .classList
                            .remove("active");

                    } else {

                        // アクティブ化
                        this.activeInstances.set(libraryId, element);

                        element
                            .classList
                            .add("active");

                    }
                }
                break;

            case Util.$shiftKey && this.activeInstances.size > 0:
                {
                    const children = Array.from(document
                        .getElementById("library-list-box")
                        .children);

                    const startIndex = children.indexOf(
                        this.activeInstances.values().next().value
                    );

                    const selectIndex = children.indexOf(element);
                    if (selectIndex === -1) {
                        return ;
                    }

                    // 初期化
                    this.clearActive();

                    // 同一のアイテムなら初期化して、選択したアイテムだけをアクティブにする
                    if (selectIndex === startIndex) {

                        this.activeInstances.set(
                            element.dataset.libraryId | 0, element
                        );

                        element
                            .classList
                            .add("active");

                        break;
                    }

                    if (selectIndex > startIndex) {

                        const length = selectIndex - startIndex + 1;
                        for (let idx = 0; length > idx; ++idx) {

                            const element = children[startIndex + idx];

                            this.activeInstances.set(
                                element.dataset.libraryId | 0, element
                            );

                            element
                                .classList
                                .add("active");
                        }

                    } else {

                        const length = startIndex - selectIndex + 1;
                        for (let idx = 0; length > idx; ++idx) {

                            const element = children[startIndex - idx];

                            this.activeInstances.set(
                                element.dataset.libraryId | 0, element
                            );

                            element
                                .classList
                                .add("active");
                        }

                    }

                }
                break;

            default:

                // 初期化
                this.clearActive();

                if (element) {
                    this.activeInstances.set(
                        element.dataset.libraryId | 0, element
                    );

                    element
                        .classList
                        .add("active");
                }
                break;

        }

    }

    /**
     * @description 別ワークスペースにMovieClipを複製する
     *
     * @param  {number} from_work_space_id
     * @param  {MovieClip} movie_clip
     * @return {MovieClip}
     * @method
     * @public
     */
    cloneMovieClip (from_work_space_id, movie_clip)
    {
        const fromWorkSpace = Util.$workSpaces[from_work_space_id];
        const toWorkSpace   = Util.$currentWorkSpace();

        const activeWorkSpaceId = Util.$activeWorkSpaceId;
        Util.$activeWorkSpaceId = from_work_space_id;
        const movieClip = movie_clip.clone();
        Util.$activeWorkSpaceId = activeWorkSpaceId;

        for (const layer of movieClip._$layers.values()) {

            const newLayer = new Layer();
            for (let idx = 0; idx < layer._$characters.length; ++idx) {

                // コピー先のcharacterIdがインクリメントされないようtoObjectで複製
                Util.$activeWorkSpaceId = from_work_space_id;
                const character = new Character(
                    JSON.parse(JSON.stringify(layer._$characters[idx].toObject()))
                );

                // 初期化
                character._$id = toWorkSpace._$characterId++;

                Util.$activeWorkSpaceId = activeWorkSpaceId;

                const instance = fromWorkSpace
                    .getLibrary(character.libraryId);

                if (this._$copyMapping.has(instance.id)) {
                    character.libraryId = this._$copyMapping.get(instance.id);
                    newLayer.addCharacter(character);
                    continue;
                }

                // フォルダ内にあればコピー元のフォルダを複製
                if (instance.folderId) {
                    this.cloneFolder(from_work_space_id, instance.id);
                }

                // コピー元のワークスペースからpathを算出
                const path = instance
                    .getPathWithWorkSpace(fromWorkSpace);

                // 重複したアイテムなら確認モーダルを表示
                if (toWorkSpace._$nameMap.has(path)) {

                    Util.$confirmModal.files.push({
                        "file": instance,
                        "character": character,
                        "layer": newLayer,
                        "path": path,
                        "workSpaceId": from_work_space_id,
                        "type": "copy"
                    });

                    continue;
                }

                // fixed logic 複製を生成
                const clone = instance.type === InstanceType.MOVIE_CLIP
                    ? this.cloneMovieClip(instance)
                    : instance.clone();

                // 新しいフォルダIDをセット
                if (clone.folderId) {
                    const folder = fromWorkSpace.getLibrary(
                        clone.folderId
                    );

                    clone.folderId = 0;
                    if (folder) {
                        clone.folderId = toWorkSpace._$libraries.get(
                            folder.getPathWithWorkSpace(fromWorkSpace)
                        );
                    }
                }

                // ライブラリにアイテムを追加
                const id = toWorkSpace.nextLibraryId;
                this._$copyMapping.set(instance.id, id);

                clone._$id = character.libraryId = id;
                toWorkSpace._$libraries.set(clone.id, clone);

                // ライブラリに登録
                Util
                    .$libraryController
                    .createInstance(
                        clone.type,
                        clone.name,
                        clone.id,
                        clone.symbol
                    );

                toWorkSpace
                    ._$nameMap
                    .set(path, clone.id);

                newLayer.addCharacter(character);
            }

            // 空のキーフレームをコピー
            for (let idx = 0; idx < layer._$emptys.length; ++idx) {
                newLayer.addEmptyCharacter(
                    layer._$emptys[idx].clone()
                );
            }

            newLayer.id = layer.id;
            movieClip.setLayer(newLayer.id, newLayer);
        }

        return movieClip;
    }

    /**
     * @description 複製するアイテムがフォルダー内にある場合はコピー先に同じ階層でフォルダを生成
     *
     * @param  {number} from_work_space_id
     * @param  {number} from_library_id
     * @return {void}
     * @method
     * @public
     */
    cloneFolder (from_work_space_id, from_library_id)
    {
        const fromWorkSpace = Util.$workSpaces[from_work_space_id];
        const toWorkSpace   = Util.$currentWorkSpace();

        const instance = fromWorkSpace
            .getLibrary(from_library_id);

        if (!instance) {
            return ;
        }

        const folders = [];

        let parent = instance;
        while (parent.folderId) {
            parent = fromWorkSpace.getLibrary(
                parent.folderId
            );
            folders.unshift(parent);
        }

        const folderMap = new Map();
        for (let idx = 0; folders.length > idx; ++idx) {

            const folder = folders[idx];

            const path = folder
                .getPathWithWorkSpace(fromWorkSpace);

            if (toWorkSpace._$nameMap.has(path)) {
                folderMap.set(
                    folder.id, toWorkSpace._$nameMap.get(path)
                );
                continue;
            }

            // フォルダがなければ複製してコピー先のプロジェクトに登録
            const cloneFolder = folder.clone();
            cloneFolder._$id  = toWorkSpace.nextLibraryId;
            toWorkSpace._$libraries.set(cloneFolder.id, cloneFolder);

            folderMap.set(folder.id, cloneFolder.id);
            if (cloneFolder.folderId) {
                cloneFolder.folderId = folderMap.get(cloneFolder.folderId);
            }

            // elementを追加
            Util
                .$libraryController
                .createInstance(
                    cloneFolder.type,
                    cloneFolder.name,
                    cloneFolder.id,
                    cloneFolder.symbol
                );

            toWorkSpace
                ._$nameMap
                .set(path, cloneFolder.id);
        }
    }

    /**
     * @description 別プロジェクトへ指定のアイテムを複製
     *
     * @param  {number} from_work_space_id
     * @param  {number} from_library_id
     * @param  {Layer} layer
     * @param  {Character} character
     * @return {void}
     * @method
     * @public
     */
    clone (from_work_space_id, from_library_id, layer = null, character = null)
    {
        const fromWorkSpace = Util.$workSpaces[from_work_space_id];
        const toWorkSpace   = Util.$currentWorkSpace();

        const instance = fromWorkSpace
            .getLibrary(from_library_id);

        if (!instance) {
            return ;
        }

        // フォルダ内にあればコピー元のフォルダを複製
        if (instance.folderId) {
            this.cloneFolder(from_work_space_id, instance.id);
        }

        // コピー元のワークスペースからpathを算出
        const path = instance
            .getPathWithWorkSpace(fromWorkSpace);

        // 重複したアイテムなら確認モーダルを表示
        if (toWorkSpace._$nameMap.has(path)) {

            Util.$confirmModal.files.push({
                "file": instance,
                "character": character,
                "layer": layer,
                "path": path,
                "workSpaceId": from_work_space_id,
                "type": "copy"
            });

            return ;
        }

        const activeWorkSpaceId = Util.$activeWorkSpaceId;
        Util.$activeWorkSpaceId = from_work_space_id;

        const clone = instance.type === InstanceType.MOVIE_CLIP
            ? this.cloneMovieClip(instance)
            : instance.clone();

        Util.$activeWorkSpaceId = activeWorkSpaceId;

        // 新しいフォルダIDをセット
        if (clone.folderId) {
            const folder = fromWorkSpace.getLibrary(
                clone.folderId
            );

            clone.folderId = 0;
            if (folder) {
                clone.folderId = toWorkSpace._$libraries.get(
                    folder.getPathWithWorkSpace(fromWorkSpace)
                );
            }
        }

        // 複製先のプロジェクトからIDを付与してもらう
        clone._$id = toWorkSpace.nextLibraryId;

        // プロジェクトに登録
        toWorkSpace._$libraries.set(clone.id, clone);

        // ライブラリに登録
        Util
            .$libraryController
            .createInstance(
                clone.type,
                clone.name,
                clone.id,
                clone.symbol
            );

        // 登録
        toWorkSpace
            ._$nameMap
            .set(path, clone.id);

        // 再構成
        this.reload();
    }

    /**
     * @description 選択中のアイテムを非アクティブ化
     *
     * @return {void}
     * @method
     * @public
     */
    clearActive ()
    {
        for (const element of this.activeInstances.values()) {
            element
                .classList
                .remove("active");
        }
        this.activeInstances.clear();

        // プレビューを初期化
        Util.$libraryPreview.dispose();
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const element = document
            .getElementById("library-list-box");

        if (element) {

            element.addEventListener("dragover", function (event)
            {
                event.preventDefault();
            });

            element.addEventListener("drop", (event) =>
            {
                this.drop(event);
            });

            element.addEventListener("dragstart", () =>
            {
                this.dragstart();
            });

            element.addEventListener("dragend", () =>
            {
                this.dragend();
            });

            element.addEventListener("mousedown", (event) =>
            {
                // 全てのイベントを中止
                event.stopPropagation();

                if (event.button) {
                    return ;
                }

                this.clearActive();
            });
        }

        // 終了コール
        Util.$initializeEnd();
    }

    /**
     * @description サウンドのselectを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clearSoundSelect ()
    {
        const element = document
            .getElementById("sound-select");

        if (!element) {
            return ;
        }

        while (element.children.length) {
            element.children[0].remove();
        }
    }

    /**
     * @description ライブラリのリストを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clearLibrary ()
    {
        const element = document
            .getElementById("library-list-box");

        if (element) {
            while (element.children.length) {
                element.children[0].remove();
            }
        }

        // 上書き管理のマップも初期化
        Util
            .$currentWorkSpace()
            ._$nameMap
            .clear();

        Util.$confirmModal.hide();
    }

    /**
     * @description ライブラリの情報の再読み込み
     *
     * @param  {array} libraries
     * @return {void}
     * @method
     * @public
     */
    reload (libraries = null)
    {
        const workSpace = Util.$currentWorkSpace();

        // 指定がなければ現在のタブのライブラリを使用する
        if (!libraries) {
            libraries = Array.from(
                workSpace._$libraries.values()
            );
        }

        // ライブラリ一覧を初期化
        this.clearLibrary();

        // サウンド情報を初期化
        this.clearSoundSelect();

        // 名前順に並び替え
        libraries.sort((a, b) =>
        {
            const aString = a.name.toLowerCase();
            const bString = b.name.toLowerCase();
            switch (true) {

                case aString > bString:
                    return 1;

                case aString < bString:
                    return -1;

                default:
                    return 0;

            }
        });

        const folderMap   = new Map();
        const childrenMap = new Map();

        // ライブラリにセット
        for (let idx = 0; idx < libraries.length; ++idx) {

            const value = libraries[idx];

            if (!value.id) {
                continue;
            }

            Util
                .$libraryController
                .createInstance(
                    value.type, value.name, value.id, value.symbol
                );

            // 階層のパスでマッピング
            workSpace
                ._$nameMap
                .set(value.path, value.id);

            // fixed logic
            if (value.type === "folder" && value.mode === FolderType.OPEN) {

                this.openFolder(value);

            }

            if (value.folderId) {

                const element = document
                    .getElementById(`library-child-id-${value.id}`);

                element.remove();

                if (!childrenMap.has(value.folderId)) {
                    childrenMap.set(value.folderId, []);
                }

                childrenMap
                    .get(value.folderId)
                    .push(element);
            }

            if (value.type === "folder") {
                folderMap.set(value.id, value);
            }
        }

        if (folderMap.size) {

            const parent = document
                .getElementById("library-list-box");

            const dup = new Map();
            while (folderMap.size !== dup.size) {

                for (const [folderId, folder] of folderMap) {

                    // 空のフォルダはスキップ
                    if (!childrenMap.has(folderId)) {
                        dup.set(folderId, true);
                        continue;
                    }

                    // 処理済みであればスキップ
                    if (dup.has(folderId)) {
                        continue;
                    }

                    const element = document
                        .getElementById(`library-child-id-${folder.id}`);

                    // 順番的にまだelementがない時は後続のタスクにする
                    if (!element) {
                        continue;
                    }

                    const children = childrenMap.get(folderId);
                    for (let idx = children.length - 1; idx > -1; --idx) {

                        const child = children[idx];

                        parent.insertBefore(
                            child, element.nextElementSibling
                        );

                        if (folder.mode === FolderType.CLOSE) {
                            child.style.display = "none";
                        }

                    }

                    // 終了管理
                    dup.set(folderId, true);
                }

                // 一番上位のフォルダから処理を実行
                for (const [folderId, folder] of folderMap) {

                    // 空のフォルダか、子孫のフォルダならスキップ
                    if (!childrenMap.has(folderId) || folder.folderId) {
                        continue;
                    }

                    this.updateFolderStyle(folder, folder.mode);
                }

            }

            dup.clear();
            folderMap.clear();
            childrenMap.clear();
        }

        // 重複登録防止のnameMapを生成
    }

    /**
     * @description ライブラリにコンテンツを生成
     *
     * @param  {string} type
     * @param  {string} name
     * @param  {uint}   id
     * @param  {string} [symbol=""]
     * @return {object}
     * @method
     * @public
     */
    createInstance (type, name, id, symbol = "")
    {
        const htmlTag = `
<div draggable="true" class="library-list-box-child" id="library-child-id-${id}" data-library-id="${id}">
    <div class="library-list-box-name">
        <i class="library-type-${type === InstanceType.FOLDER ? "arrow close" : "space"}" id="arrow-${id}" data-library-id="${id}"></i>
        <i class="library-type-${type} " id="${type}-${id}" data-library-id="${id}"></i>
        <p>
            <span id="library-name-${id}" class="view-text" data-type="name" data-library-id="${id}">${name}</span>
            <input type="text" id="library-name-input-${id}" data-library-id="${id}" data-type="name" value="${name}" style="display: none;">
        </p>
    </div>
    <div class="library-list-box-symbol">
        <p>
            <span id="library-symbol-name-${id}" class="view-symbol-text" data-type="symbol" data-library-id="${id}">${symbol}</span>
            <input type="text" id="library-symbol-name-input-${id}" data-library-id="${id}" data-type="symbol" value="${symbol}" style="display: none;">
        </p>
    </div>
</div>`;

        const element = document
            .getElementById("library-list-box");

        element.insertAdjacentHTML("beforeend", htmlTag);

        if (type === InstanceType.MOVIE_CLIP) {
            document
                .getElementById(`${type}-${id}`)
                .addEventListener("dblclick", (event) =>
                {
                    // 定規は削除
                    Util.$screenRuler.clear();

                    // 再描画
                    Util.$sceneChange.reload(
                        event.currentTarget.dataset.libraryId | 0
                    );
                });
        }

        const child = document
            .getElementById(`library-child-id-${id}`);

        // 選択中のアイテムであれば上書きしてアクティブ化
        if (this.activeInstances.has(id)) {

            this.activeInstances.set(id, child);

            child
                .classList
                .add("active");
        }

        // elementの選択処理
        child.addEventListener("mousedown", (event) =>
        {
            this.selectInstance(event);
        });

        if (type === "folder") {

            child.addEventListener("dragover", (event) =>
            {
                event.preventDefault();
            });

            child.addEventListener("drop", (event) =>
            {
                this.folderIn(event);
            });

            const arrowElement = document.getElementById(`arrow-${id}`);
            arrowElement.addEventListener("mousedown", (event) =>
            {
                this.clickFolder(event);
            });

            const iconElement = document.getElementById(`${type}-${id}`);
            iconElement.addEventListener("dblclick", (event) =>
            {
                this.clickFolder(event);
            });

            iconElement
                .classList
                .remove("library-type-folder");

            iconElement
                .classList
                .add("library-type-folder-close");

        }

        if (type === InstanceType.SOUND) {

            const option = document.createElement("option");
            option.value     = `${id}`;
            option.innerHTML = name;

            document
                .getElementById("sound-select")
                .appendChild(option);

        }

        const viewElements = [
            `library-name-${id}`
        ];

        if (type !== "folder") {
            viewElements.push(`library-symbol-name-${id}`);
        }

        for (let idx = 0; idx < viewElements.length; ++idx) {

            document
                .getElementById(viewElements[idx])
                .addEventListener("dblclick", (event) =>
                {
                    this.inputStart(event);
                });

        }

        const inputElements = [
            `library-name-input-${id}`
        ];

        if (type !== "folder") {
            inputElements.push(`library-symbol-name-input-${id}`);
        }

        for (let idx = 0; idx < inputElements.length; ++idx) {

            const input = document
                .getElementById(inputElements[idx]);

            input.addEventListener("focusout", (event) =>
            {
                this.inputEnd(event);
            });

            input.addEventListener("keypress", (event) =>
            {
                this.inputEnd(event);
            });

        }

        return {
            "id": id,
            "type": type,
            "name": name,
            "symbol": symbol
        };
    }

    /**
     * @description ライブラリアイテムの選択処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    selectInstance (event)
    {
        if (event.button || Util.$keyLock) {
            return ;
        }

        // モーダルを非表示に
        Util.$endMenu();

        // 全てのイベントw中止
        event.stopPropagation();

        const target = event.currentTarget;

        if (!Util.$ctrlKey && !Util.$shiftKey
            && target.classList.contains("active")
        ) {
            return ;
        }

        this.activeInstance = target;

        // プレビューに表示
        Util
            .$libraryPreview
            .loadImage(
                target.dataset.libraryId | 0
            );
    }

    /**
     * @description inputタグを有効にする、移動を無効化
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    inputStart (event)
    {
        // キーロック
        Util.$keyLock = true;

        // 全てのイベントを中止
        event.stopPropagation();

        const target = event.target;
        const libraryId = target.dataset.libraryId | 0;

        const parent = document
            .getElementById(`library-child-id-${libraryId}`);

        parent
            .classList
            .remove("active");

        parent.draggable = false;

        const inputId = target.dataset.type === "name"
            ? `library-name-input-${libraryId}`
            : `library-symbol-name-input-${libraryId}`;

        const input = document.getElementById(inputId);
        input.value = target.textContent;
        input.style.display = "";
        input.focus();

        target.style.display = "none";
    }

    /**
     * @description inputタグを無効にする
     *
     * @param  {Event|KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    inputEnd (event)
    {
        if (event.key === "Enter") {
            event.target.blur();
            return ;
        }

        if (event.type === "focusout") {

            this.save();

            const target    = event.target;
            const libraryId = target.dataset.libraryId | 0;

            const workSpace = Util.$currentWorkSpace();
            const library = workSpace.getLibrary(libraryId);

            const viewId = target.dataset.type === "name"
                ? `library-name-${libraryId}`
                : `library-symbol-name-${libraryId}`;

            const element = document
                .getElementById(viewId);

            let value = target.value;
            if (element.textContent !== value) {

                if (target.dataset.type === "name") {

                    const cache = library.name;
                    library.name = value;

                    // 重複してないかチェック
                    if (workSpace._$nameMap.has(library.path)) {
                        library.name = cache;
                        value = cache;

                        const modal = document
                            .getElementById("detail-modal");

                        modal.textContent = Util.$currentLanguage.replace(
                            "{{同名のアイテムが存在します}}"
                        );

                        modal.style.left = `${target.offsetLeft}px`;
                        modal.style.top  = `${target.offsetTop}px`;
                        modal.setAttribute("class", "fadeIn");

                        modal.dataset.timerId = setTimeout(() =>
                        {
                            if (!modal.classList.contains("fadeOut")) {
                                modal.setAttribute("class", "fadeOut");
                            }
                        }, 1500);
                    }

                } else {

                    library.symbol = value;

                }

                // データを更新
                element.textContent = value;
            }

            element.style.display = "";

            const parent = document
                .getElementById(`library-child-id-${libraryId}`);

            if (this.activeInstances.has(libraryId)) {
                parent
                    .classList
                    .add("active");
            }

            target.style.display = "none";
            parent.draggable     = true;
            Util.$keyLock        = false;
            this._$saved         = false;

            if (target.dataset.type === "name") {
                this.reload();
            }
        }
    }

    /**
     * @description フォルダーアイコンをダブルクリックした処理
     *
     * @return {void}
     * @method
     * @public
     */
    clickFolder (event)
    {
        // 全てのイベント中止
        event.stopPropagation();

        const folder = Util
            .$currentWorkSpace()
            .getLibrary(
                event.target.dataset.libraryId | 0
            );

        if (folder.mode === FolderType.OPEN) {

            // 閉じる処理
            this.closeFolder(folder);

        } else {

            // 開く処理
            this.openFolder(folder);

        }

        this.updateFolderStyle(folder, folder.mode);
    }

    /**
     * @description フォルダーの内部にelementのスタイルを変更する
     *
     * @param  {Folder} folder
     * @param  {string} mode
     * @return {void}
     * @public
     */
    updateFolderStyle (folder, mode)
    {
        const workSpace = Util.$currentWorkSpace();

        const children = document
            .getElementById("library-list-box")
            .children;

        let depth = 20;
        let instanceId = folder.folderId;
        if (instanceId) {
            for (;;) {

                const instance = workSpace.getLibrary(instanceId);
                if (!instance) {
                    break;
                }

                depth += 20;

                instanceId = instance.folderId;
                if (!instanceId) {
                    break;
                }

            }
        }

        for (let idx = 0; idx < children.length; ++idx) {

            const node = children[idx];

            const instance = workSpace
                .getLibrary(node.dataset.libraryId | 0);

            if (!instance.folderId) {
                continue;
            }

            if (instance.folderId !== folder.id) {
                continue;
            }

            let style = `padding-left: ${depth}px;`;
            if (mode !== FolderType.OPEN ) {
                style += "display: none;";
            }
            node.setAttribute("style", style);

            if (instance.type === InstanceType.FOLDER) {
                this.updateFolderStyle(
                    instance,
                    mode === FolderType.OPEN ? instance.mode : mode
                );
            }
        }
    }

    /**
     * @description フォルダーを開く
     *
     * @param  {Folder} folder
     * @return {void}
     * @method
     * @public
     */
    openFolder (folder)
    {
        folder.mode = FolderType.OPEN;

        const iconElement = document
            .getElementById(`folder-${folder.id}`);

        iconElement
            .classList
            .remove("library-type-folder-close");

        iconElement
            .classList
            .add("library-type-folder-open");

        const arrowElement = document
            .getElementById(`arrow-${folder.id}`);

        arrowElement
            .classList
            .add("open");

        arrowElement
            .classList
            .remove("close");
    }

    /**
     * @description フォルダーを閉じる
     *
     * @param  {Folder} folder
     * @return {void}
     * @method
     * @public
     */
    closeFolder (folder)
    {
        folder.mode = FolderType.CLOSE;

        const iconElement = document
            .getElementById(`folder-${folder.id}`);

        iconElement
            .classList
            .remove("library-type-folder-open");

        iconElement
            .classList
            .add("library-type-folder-close");

        const arrowElement = document
            .getElementById(`arrow-${folder.id}`);

        arrowElement
            .classList
            .remove("open");

        arrowElement
            .classList
            .add("close");
    }

    /**
     * @description ドラッグ時はスクリーンのイベントを無効にする
     *
     * @return {void}
     * @method
     * @public
     */
    dragstart ()
    {
        const children = document
            .getElementById("stage-area")
            .children;

        for (let idx = 1; idx < children.length; ++idx) {
            children[idx].style.pointerEvents = "none";
        }
    }

    /**
     * @description ドラッグ終了時はスクリーンのイベントを有効にする
     *
     * @return {void}
     * @method
     * @public
     */
    dragend ()
    {
        const children = document
            .getElementById("stage-area")
            .children;

        for (let idx = 1; idx < children.length; ++idx) {

            const node = children[idx];
            if (node.dataset.preview) {
                continue;
            }

            node.style.pointerEvents = "";
        }
    }

    /**
     * @description ライブラリエリアにコンテンツのドロップ処理
     *
     * @param  {DragEvent} event
     * @return {void}
     * @method
     * @public
     */
    drop (event)
    {
        event.preventDefault();
        event.stopPropagation();

        this.save();

        const items = event.dataTransfer.items;
        if (items.length) {

            if (Util.$saveProgress.active) {
                return ;
            }

            // 選択中のコンテンツを非アクティブに
            this.clearActive();

            Util.$saveProgress.start();

            Util.$saveProgress.loadFiles();

            const promises = [];
            const items = event.dataTransfer.items;
            for (let idx = 0; idx < items.length; ++idx) {
                promises.push(this.scanFiles(
                    items[idx].webkitGetAsEntry()
                ));
            }

            Promise
                .all(promises)
                .then(() =>
                {
                    Util.$saveProgress.end();
                });

        } else {
            // フォルダーの外に移動
            this.folderOut();
        }

        this._$saved = false;
    }

    /**
     * @description 読み込んだファイルのチェック
     *
     * @param  {FileSystemDirectoryEntry} entry
     * @param  {number} [folder_id=0]
     * @return {Promise}
     * @method
     * @public
     */
    scanFiles (entry, folder_id = 0)
    {
        if (entry.isDirectory) {

            const instance = Util
                .$currentWorkSpace()
                .addLibrary({
                    "id": Util.$currentWorkSpace().nextLibraryId,
                    "type": "folder",
                    "name": entry.name,
                    "symbol": ""
                });

            if (folder_id) {
                instance.folderId = folder_id;
            }

            return new Promise((resolve) =>
            {
                entry
                    .createReader()
                    .readEntries((entries) =>
                    {
                        const promises = [];
                        for (let idx = 0; idx < entries.length; ++idx) {
                            promises.push(this.scanFiles(
                                entries[idx], instance.id
                            ));
                        }

                        Promise
                            .all(promises)
                            .then(() =>
                            {
                                this.updateFolderStyle(instance, instance.mode);
                                resolve();
                            });
                    });
            });
        }

        return new Promise((resolve) =>
        {
            entry
                .file((file) =>
                {
                    this.loadFile(file, resolve, folder_id);
                });
        });

    }

    /**
     * @description 関連するコンテンツを表示と内部データから削除
     *
     * @param  {number} library_id
     * @return {void}
     * @method
     * @public
     */
    removeLibrary (library_id)
    {
        const element = document
            .getElementById(`library-child-id-${library_id}`);

        if (element) {
            element.remove();
        }

        const workSpace = Util.$currentWorkSpace();

        const instance = workSpace.getLibrary(library_id);
        if (!instance) {
            return ;
        }

        // SWFとSVGの場合はコンテナを基準に削除処理を行う
        if (instance.type === InstanceType.MOVIE_CLIP) {

            const libraryIds = new Map();
            for (const layer of instance._$layers.values()) {

                for (let idx = 0; idx < layer._$characters.length; ++idx) {

                    const character = layer._$characters[idx];

                    if (!libraryIds.has(character.libraryId)) {
                        libraryIds.set(character.libraryId, true);
                    }

                    const instance = workSpace
                        .getLibrary(character.libraryId);

                    if (instance && instance.type === InstanceType.MOVIE_CLIP) {
                        this.removeLibrary(character.libraryId);
                    }
                }
            }

            if (libraryIds.size) {

                // 削除対象でないMovieClipで利用されていれば削除
                for (const libraryId of libraryIds.keys()) {

                    const instance = workSpace.getLibrary(libraryId);
                    if (!instance) {
                        continue;
                    }

                    const element = document
                        .getElementById(`library-child-id-${libraryId}`);

                    if (element) {
                        element.remove();
                    }

                    instance.remove();

                    workSpace.removeLibrary(libraryId);
                }
            }
        }

        workSpace.removeLibrary(library_id);
    }

    /**
     * @description 読み込み処理
     *
     * @param  {File} file
     * @param  {function} resolve
     * @param  {number} [folder_id=0]
     * @param  {string} [name=""]
     * @param  {number} [library_id=0]
     * @return {Promise}
     * @method
     * @public
     */
    loadFile (file, resolve, folder_id = 0, name = "", library_id = 0)
    {
        const workSpace = Util.$currentWorkSpace();

        let path = name || file.name;

        // swfの場合は拡張子を削除
        if (path.indexOf(".swf") > -1) {
            path = path.replace(".swf", "");
        }

        if (folder_id) {
            let parent = workSpace.getLibrary(folder_id);
            path = `${parent.name}/${path}`;
            while (parent._$folderId) {
                parent = workSpace.getLibrary(parent._$folderId);
                path = `${parent.name}/${path}`;
            }
        }

        // 上書き確認
        if (!library_id && workSpace._$nameMap.has(path)) {

            Util.$confirmModal.files.push({
                "file": file,
                "folderId": folder_id,
                "path": path
            });

            Util.$confirmModal.show();

            return Promise.resolve();
        }

        // 上書きの場合はElementと内部データを削除
        if (library_id) {
            this.removeLibrary(library_id);
        }

        switch (file.type) {

            case "image/svg+xml":
                file
                    .text()
                    .then((value) =>
                    {
                        const object = this.createInstance(
                            InstanceType.MOVIE_CLIP,
                            name || file.name,
                            library_id || workSpace.nextLibraryId
                        );

                        const movieClip = workSpace.addLibrary(object);

                        workSpace
                            ._$nameMap
                            .set(path, object.id);

                        // ドロップしたアイテムをアクティブ化
                        const element = document
                            .getElementById(`library-child-id-${object.id}`);

                        if (element) {
                            this.activeInstances.set(object.id, element);

                            element
                                .classList
                                .add("active");
                        }

                        if (folder_id) {
                            movieClip.folderId = folder_id;

                            const folder = workSpace.getLibrary(folder_id);

                            this.updateFolderStyle(folder, folder.mode);
                        }

                        SVGToShape.parse(value, movieClip);

                        // ライブラリ選択のselectを更新
                        Util
                            .$instanceSelectController
                            .createInstanceSelect(movieClip);

                        // ライブラリ一覧を再構成
                        Util.$libraryController.reload();

                        // プレビューを表示
                        Util.$libraryPreview.loadImage(movieClip.id);

                        // 上書きならスクリーンを再描画
                        if (library_id) {
                            this.reloadScreen(library_id);
                        }

                        resolve();
                    });
                break;

            case "image/png":
            case "image/jpeg":
            case "image/gif":
                file
                    .arrayBuffer()
                    .then((buffer) =>
                    {
                        const blob = new Blob([buffer], {
                            "type": file.type
                        });

                        const image = new Image();
                        image.src = URL.createObjectURL(blob);
                        return image
                            .decode()
                            .then(() =>
                            {
                                const width   = image.width;
                                const height  = image.height;

                                const canvas  = Util.$getCanvas();
                                canvas.width  = width;
                                canvas.height = height;
                                const context = canvas.getContext("2d");

                                context.drawImage(image, 0, 0, width, height);
                                const buffer = new Uint8Array(
                                    context.getImageData(0, 0, width, height).data
                                );
                                Util.$poolCanvas(context);

                                const object = this.createInstance(
                                    InstanceType.BITMAP,
                                    name || file.name,
                                    library_id || workSpace.nextLibraryId
                                );

                                workSpace
                                    ._$nameMap
                                    .set(path, object.id);

                                // ドロップしたアイテムをアクティブ化
                                const element = document
                                    .getElementById(`library-child-id-${object.id}`);

                                if (element) {
                                    this.activeInstances.set(object.id, element);

                                    element
                                        .classList
                                        .add("active");
                                }

                                object.width     = image.width;
                                object.height    = image.height;
                                object.imageType = file.type;
                                object.buffer    = new Uint8Array(buffer);

                                const instance = workSpace.addLibrary(object);

                                if (folder_id) {

                                    instance.folderId = folder_id;

                                    const folder = workSpace.getLibrary(folder_id);

                                    this.updateFolderStyle(folder, folder.mode);
                                }

                                // ライブラリ選択のselectを更新
                                Util
                                    .$instanceSelectController
                                    .createInstanceSelect(instance);

                                // ライブラリ一覧を再構成
                                Util.$libraryController.reload();

                                // プレビューを表示
                                Util.$libraryPreview.loadImage(instance.id);

                                // 上書きならスクリーンを再描画
                                if (library_id) {
                                    this.reloadScreen(library_id);
                                }

                                resolve();
                            });
                    });
                break;

            case "video/mp4":
                file
                    .arrayBuffer()
                    .then((buffer) =>
                    {
                        const blob = new Blob([buffer], {
                            "type": file.type
                        });

                        const video = document.createElement("video");
                        video.onloadedmetadata = () =>
                        {
                            const object = this.createInstance(
                                InstanceType.VIDEO,
                                name || file.name,
                                library_id || workSpace.nextLibraryId
                            );

                            workSpace
                                ._$nameMap
                                .set(path, object.id);

                            // ドロップしたアイテムをアクティブ化
                            const element = document
                                .getElementById(`library-child-id-${object.id}`);

                            if (element) {
                                this.activeInstances.set(object.id, element);

                                element
                                    .classList
                                    .add("active");
                            }

                            object.width  = video.videoWidth;
                            object.height = video.videoHeight;
                            object.buffer = new Uint8Array(buffer);

                            const instance = workSpace.addLibrary(object);
                            if (folder_id) {

                                instance.folderId = folder_id;

                                const folder = workSpace.getLibrary(folder_id);

                                this.updateFolderStyle(folder, folder.mode);
                            }

                            // ライブラリ選択のselectを更新
                            Util
                                .$instanceSelectController
                                .createInstanceSelect(instance);

                            // ライブラリ一覧を再構成
                            Util.$libraryController.reload();

                            // プレビューを表示
                            Util.$libraryPreview.loadImage(instance.id);

                            // 上書きならスクリーンを再描画
                            if (library_id) {
                                this.reloadScreen(library_id);
                            }

                            resolve();
                        };

                        video.src = URL.createObjectURL(blob);
                        video.load();
                    });
                break;

            case "audio/mpeg":
                file
                    .arrayBuffer()
                    .then((buffer) =>
                    {
                        const object = this.createInstance(
                            InstanceType.SOUND,
                            name || file.name,
                            library_id || workSpace.nextLibraryId
                        );

                        workSpace
                            ._$nameMap
                            .set(path, object.id);

                        // ドロップしたアイテムをアクティブ化
                        const element = document
                            .getElementById(`library-child-id-${object.id}`);

                        if (element) {
                            this.activeInstances.set(object.id, element);

                            element
                                .classList
                                .add("active");
                        }

                        object.buffer = new Uint8Array(buffer);

                        const instance = workSpace.addLibrary(object);

                        if (folder_id) {

                            instance.folderId = folder_id;

                            const folder = workSpace.getLibrary(folder_id);

                            this.updateFolderStyle(folder, folder.mode);

                        }

                        // ライブラリ一覧を再構成
                        Util.$libraryController.reload();

                        // プレビューを表示
                        Util.$libraryPreview.loadImage(instance.id);

                        // 上書きならスクリーンを再描画
                        if (library_id) {
                            this.reloadScreen(library_id);
                        }

                        resolve();
                    });
                break;

            case "application/x-shockwave-flash":
                file
                    .arrayBuffer()
                    .then((buffer) =>
                    {
                        new ReComposition()
                            .setData(new Uint8Array(buffer))
                            .run(
                                name || file.name,
                                resolve,
                                folder_id,
                                library_id
                            );
                    });
                break;

            default:
                resolve();
                break;

        }
    }

    /**
     * @description フォルダ外に移動
     *
     * @return {void}
     * @method
     * @public
     */
    folderOut ()
    {
        if (!this.activeInstances.size) {
            this.reload();
            return ;
        }

        this.save();

        const workSpace = Util.$currentWorkSpace();

        let useConfirmModal = false;
        for (const element of this.activeInstances.values()) {

            const instance = workSpace
                .getLibrary(element.dataset.libraryId | 0);

            if (!instance || !instance.folderId) {
                continue;
            }

            // フォルダから一時的に出す
            const folderId = instance.folderId;

            instance.folderId = 0;
            const path = instance.path;
            instance.folderId = folderId;

            // 同一のファイルがないかチェック
            if (workSpace._$nameMap.has(path)) {

                useConfirmModal = true;

                Util.$confirmModal.files.push({
                    "file": instance,
                    "folderId": 0,
                    "path": path,
                    "type": "move"
                });

                Util.$confirmModal.show();

                continue;
            }

            // スタイルを初期化
            if (instance.folderId) {

                instance.folderId = 0;

                element.setAttribute("style", "");
            }

        }

        // ライブラリを再構成
        if (!useConfirmModal) {
            this.reload();
        }

        // 初期化
        this._$saved = false;
    }

    /**
     * @description フォルダーにコンテンツを移動する
     *
     * @param  {DragEvent} event
     * @return {void}
     * @method
     * @public
     */
    folderIn (event)
    {
        if (!this.activeInstances.size) {
            return ;
        }

        event.stopPropagation();
        event.preventDefault();

        const workSpace = Util.$currentWorkSpace();

        const folderElement = event.currentTarget;
        const folder = workSpace
            .getLibrary(folderElement.dataset.libraryId | 0);

        this.save();

        let useConfirmModal = false;
        for (const element of this.activeInstances.values()) {

            const instance = workSpace
                .getLibrary(element.dataset.libraryId | 0);

            if (!instance) {
                continue;
            }

            // 自分自身への移動をブロック
            if (instance.id === folder.id) {
                continue;
            }

            let parent = workSpace.getLibrary(folder.id);
            const path = `${parent.name}/${instance.path}`;

            // 同一のファイルがないかチェック
            if (workSpace._$nameMap.has(path)) {

                useConfirmModal = true;

                Util.$confirmModal.files.push({
                    "file": instance,
                    "folderId": 0,
                    "path": path,
                    "type": "move"
                });

                Util.$confirmModal.show();

                continue;
            }

            // 格納するフォルダのIDをセット
            instance.folderId = folder.id;
        }

        // ライブラリを再構成
        if (!useConfirmModal) {
            this.reload();
        }

        // 初期化
        this._$saved = false;
    }

    /**
     * @description undo用にデータを内部保管する
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }

    /**
     * @description スクリーンエリアで変更があったElementを再描画
     *
     * @param  {number} library_id
     * @return {void}
     * @method
     * @public
     */
    reloadScreen (library_id)
    {
        Util.$changeLibraryId = library_id;
        const frame = Util.$timelineFrame.currentFrame;

        Util
            .$currentWorkSpace()
            .scene
            .changeFrame(frame);

        Util.$changeLibraryId = 0;
    }
}

Util.$libraryController = new LibraryController();

/**
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class LibraryExport extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super();

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$lock = false;

        /**
         * @type {Instance}
         * @default null
         * @private
         */
        this._$instance = null;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$xScale = 1;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$yScale = 1;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$currentFrame = 1;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$startFrame = 1;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$endFrame = 1;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$width = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$height = 0;
    }

    /**
     * @return {number}
     * @static
     */
    static get MAX_SIZE ()
    {
        return 0xfff;
    }

    /**
     * @return {number}
     * @static
     */
    static get MIN_SIZE ()
    {

        return 1;
    }

    /**
     * @return {number}
     * @static
     */
    static get DEFAULT_SIZE ()
    {
        return 450;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "library-menu-export",
            "library-export-hide-icon",
            "library-export-size-lock",
            "library-export-execution"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                if (event.button) {
                    return ;
                }

                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                const names = event.currentTarget.id.split("-");

                let functionName = names
                    .map((value) =>
                    {
                        return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
                    })
                    .join("");

                this[`execute${functionName}`](event);
            });

        }

        const inputIds = [
            "export-width",
            "export-height",
            "export-start-frame",
            "export-end-frame",
            "export-current-frame"
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {

            const element = document.getElementById(inputIds[idx]);
            if (!element) {
                continue;
            }

            this.setInputEvent(element);
        }
    }

    /**
     * @description Input終了後に再描画しない
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    finishInput (event)
    {
        super.finishInput(event, false);
    }

    /**
     * @description マウス移動時の処理で再描画させない
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseMove (event)
    {
        super.mouseMove(event, false);
    }

    /**
     * @description 書き出しの実行
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryExportExecution ()
    {
        // モーダルを終了
        Util.$endMenu();

        const ext = document
            .getElementById("library-export-file-type")
            .value;

        const name = document
            .getElementById("export-name")
            .value;

        switch (this._$instance.type) {

            case InstanceType.MOVIE_CLIP:
                {
                    const zip = new JSZip();
                    for (let frame = this._$startFrame; this._$endFrame >= frame; ++frame) {

                        const context = this.getContext(frame);

                        zip.file(
                            `${name}_frame_${frame}.${ext}`,
                            context.canvas.toDataURL(`image/${ext}`, 1).replace(/^.*,/, ""),
                            { "base64" : true }
                        );

                        Util.$poolCanvas(context.canvas);
                    }

                    zip
                        .generateAsync({ "type" : "blob" })
                        .then((content) =>
                        {
                            const url = URL.createObjectURL(content);

                            const anchor    = document.createElement("a");
                            anchor.download = `${name}.zip`;
                            anchor.href     = url;
                            anchor.click();

                            URL.revokeObjectURL(url);
                        });
                }
                break;

            case InstanceType.VIDEO:
                {
                    const names = name.split(".");
                    if (names[names.length - 1] === "mp4") {
                        names.pop();
                    }

                    const anchor = document.createElement("a");

                    anchor.download = `${names.join(".")}.mp4`;
                    anchor.href = URL.createObjectURL(new Blob(
                        [new Uint8Array(this._$instance._$buffer)],
                        { "type": "video/mp4" }
                    ));

                    anchor.click();
                }
                break;

            case InstanceType.SOUND:
                {
                    const names = name.split(".");
                    if (names[names.length - 1] === "mp3") {
                        names.pop();
                    }

                    const anchor = document.createElement("a");

                    anchor.download = `${names.join(".")}.mp3`;
                    anchor.href = URL.createObjectURL(new Blob(
                        [new Uint8Array(this._$instance._$buffer)],
                        { "type": "audio/mp3" }
                    ));

                    anchor.click();
                }
                break;

            default:
                {
                    const context   = this.getContext();
                    const anchor    = document.createElement("a");
                    anchor.download = `${name}.${ext}`;
                    anchor.href     = context.canvas.toDataURL(`image/${ext}`, 1);
                    anchor.click();
                }
                break;
        }
    }

    /**
     * @description ロックのOn/Off関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    executeLibraryExportSizeLock (event)
    {
        // ロックのOn/Off
        this._$lock = !this._$lock;

        // 初期化
        this._$currentValue = null;

        event
            .currentTarget
            .childNodes[1]
            .setAttribute("class", this._$lock
                ? "active"
                : "disable"
            );
    }

    /**
     * @description 書き出しの幅の設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeExportWidth (value)
    {
        value = Util.$clamp(+value,
            LibraryExport.MIN_SIZE,
            LibraryExport.MAX_SIZE,
            1
        );

        // xスケールの更新
        const xScale = value / this._$width;

        // ロック中であれば高さも更新
        if (this._$lock) {

            this._$yScale += xScale - this._$xScale;

            document
                .getElementById("export-height")
                .value = `${Math.ceil(this._$height * this._$yScale)}`;
        }

        this._$xScale = xScale;
        this.appendImage();

        return value;
    }

    /**
     * @description 書き出しの高さの設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeExportHeight (value)
    {
        value = Util.$clamp(+value,
            LibraryExport.MIN_SIZE,
            LibraryExport.MAX_SIZE,
            1
        );

        // yスケールの更新
        const yScale = value / this._$height;

        if (this._$lock) {
            this._$xScale += yScale - this._$yScale;

            document
                .getElementById("export-width")
                .value = `${Math.ceil(this._$width * this._$xScale)}`;
        }

        this._$yScale = yScale;
        this.appendImage();

        return value;
    }

    /**
     * @description MovieClipの書き出しの開始フレームの設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeExportStartFrame (value)
    {
        value = Util.$clamp(value | 0,
            1,
            this._$instance.totalFrame
        );

        this._$startFrame = value;

        // 開始フレームが最終フレーム設定を上回った補正
        const element = document
            .getElementById("export-end-frame");

        const endFrame = element.value | 0;
        if (value > endFrame) {
            element.value   = `${value}`;
            this._$endFrame = value;
        }

        if (value > this._$currentFrame) {
            document
                .getElementById("export-current-frame")
                .value = `${value}`;
            this._$currentFrame = value;
        }

        // 再計算
        this.reloadMovieClip();

        this.appendImage();

        return value;
    }

    /**
     * @description MovieClipの書き出しの終了フレームの設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeExportEndFrame (value)
    {
        value = Util.$clamp(value | 0,
            1,
            this._$instance.totalFrame
        );

        // 最終フレームが開始フレーム設定を下回った補正
        const element = document
            .getElementById("export-start-frame");

        const startFrame = element.value | 0;
        if (startFrame > value) {
            element.value     = `${value}`;
            this._$startFrame = value;
        }

        if (this._$currentFrame > value) {
            document
                .getElementById("export-current-frame")
                .value = `${value}`;
            this._$currentFrame = value;
        }

        // 再計算
        this.reloadMovieClip();

        this.appendImage();

        return value;
    }

    /**
     * @description MovieClipの表示したいフレームの設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeExportCurrentFrame (value)
    {
        value = Util.$clamp(value | 0,
            this._$startFrame,
            this._$endFrame
        );

        this._$currentFrame = value;

        this.appendImage();

        return value;
    }

    /**
     * @description 書き出しモーダルを非表示に
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryExportHideIcon ()
    {
        Util.$endMenu();
    }

    /**
     * @description 指定範囲のMovieClipの表示幅を再計算
     *
     * @return {void}
     * @method
     * @public
     */
    reloadMovieClip ()
    {
        const bounds  = this.getBounds();
        this._$width  = Math.abs(bounds.xMax - bounds.xMin);
        this._$height = Math.abs(bounds.yMax - bounds.yMin);

        document
            .getElementById("export-start-frame")
            .value = `${this._$startFrame}`;

        document
            .getElementById("export-end-frame")
            .value = `${this._$endFrame}`;

        document
            .getElementById("export-width")
            .value = `${Math.ceil(this._$width)}`;

        document
            .getElementById("export-height")
            .value = `${Math.ceil(this._$height)}`;
    }

    /**
     * @description 指定したアイテムを画像として書き出す
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuExport ()
    {
        const activeInstances = Util
            .$libraryController
            .activeInstances;

        if (!activeInstances.size) {
            return ;
        }

        // 書き出すアイテムの情報をセット
        const LibraryElement = activeInstances.values().next().value;

        this._$instance = Util
            .$currentWorkSpace()
            .getLibrary(
                LibraryElement.dataset.libraryId | 0
            );

        // 初期化
        this._$lock   = false;
        this._$xScale = 1;
        this._$yScale = 1;

        document
            .getElementById("library-export-size-lock")
            .childNodes[1]
            .setAttribute("class", "disable");

        const containerArea = document
            .getElementById("library-export-container-area");

        const sizeArea = document
            .getElementById("library-export-size-area");

        const fileArea = document
            .getElementById("library-export-file-area");

        switch (this._$instance.type) {

            case InstanceType.MOVIE_CLIP:
                this._$currentFrame = 1;
                this._$startFrame   = 1;
                this._$endFrame     = this._$instance.totalFrame;

                // 書き出し項目のを表示設定
                containerArea.style.display = "";
                sizeArea.style.display      = "";
                fileArea.style.display      = "";

                this.reloadMovieClip();
                break;

            case InstanceType.VIDEO:
            case InstanceType.SOUND:
                // 書き出し項目のを表示設定
                containerArea.style.display = "none";
                sizeArea.style.display      = "none";
                fileArea.style.display      = "none";
                break;

            default:
                {
                    // 書き出し項目のを表示設定
                    containerArea.style.display = "none";
                    sizeArea.style.display      = "";
                    fileArea.style.display      = "";

                    const bounds = this._$instance.getBounds();
                    this._$width  = Math.abs(bounds.xMax - bounds.xMin);
                    this._$height = Math.abs(bounds.yMax - bounds.yMin);

                    // サイズをセット
                    document
                        .getElementById("export-width")
                        .value  = `${Math.ceil(this._$width)}`;

                    document
                        .getElementById("export-height")
                        .value = `${Math.ceil(this._$height)}`;
                }
                break;

        }

        document
            .getElementById("export-name")
            .value = `${this._$instance.name}`;

        // プレビュー画面を初期化して画像をセット
        this.appendImage();

        // 書き出しモーダル以外を終了
        Util.$endMenu("library-export-modal");

        // 書き出しのモーダルを表示
        const element = document
            .getElementById("library-export-modal");

        element.style.display = "";
        element.setAttribute("class", "fadeIn");
    }

    /**
     * @description 表示領域を返す
     *
     * @return {object}
     * @method
     * @public
     */
    getBounds ()
    {
        const matrix = [1, 0, 0, 1, 0, 0];

        const place = {
            "frame": 1,
            "matrix": matrix,
            "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
            "blendMode": "normal",
            "filter": [],
            "loop": Util.$getDefaultLoopConfig()
        };

        const range = {
            "startFrame": 1,
            "endFrame": this._$instance.totalFrame + 1
        };

        const currentFrame = Util.$currentFrame;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;
        for (let frame = this._$startFrame; this._$endFrame >= frame; ++frame) {

            place.frame = Util.$currentFrame = frame;

            const bounds = this._$instance.getBounds(matrix, place, range);

            xMin = Math.min(bounds.xMin, xMin);
            xMax = Math.max(bounds.xMax, xMax);
            yMin = Math.min(bounds.yMin, yMin);
            yMax = Math.max(bounds.yMax, yMax);
        }

        // reset
        Util.$currentFrame = currentFrame;

        return {
            "xMin": xMin,
            "xMax": xMax,
            "yMin": yMin,
            "yMax": yMax
        };
    }

    /**
     * @description プレビューのイメージを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    removeImage ()
    {
        const element = document.getElementById("library-export-image");
        if (element) {
            while (element.firstChild) {
                const node = element.firstChild;
                Util.$poolCanvas(node);
                node.remove();
            }
        }
    }

    /**
     * @description プレビュー画像をセット
     *
     * @return {void}
     * @method
     * @public
     */
    appendImage ()
    {
        this.removeImage();

        switch (this._$instance.type) {

            case InstanceType.VIDEO:
            case InstanceType.SOUND:
                document
                    .getElementById("library-export-image")
                    .appendChild(this._$instance.getPreview());
                break;

            default:
                {
                    const context = this.getContext(this._$currentFrame, true);
                    const canvas  = context.canvas;

                    const ratio = window.devicePixelRatio;
                    canvas.style.width  = `${canvas.width  / ratio}px`;
                    canvas.style.height = `${canvas.height / ratio}px`;

                    document
                        .getElementById("library-export-image")
                        .appendChild(canvas);
                }
                break;

        }
    }

    /**
     * @description Elementを生成
     *
     * @param  {number} frame
     * @param  {boolean} [preview=false]
     * @return {CanvasRenderingContext2D}
     * @method
     * @public
     */
    getContext (frame = 1, preview = false)
    {
        const currentFrame = Util.$currentFrame;
        const zoomScale    = Util.$zoomScale;
        Util.$currentFrame = frame;
        Util.$zoomScale    = 1;

        const bounds = this.getBounds();

        // size
        let width  = Math.abs(bounds.xMax - bounds.xMin);
        let height = Math.abs(bounds.yMax - bounds.yMin);
        if (!width || !height) {
            return new Image();
        }

        let xScale = this._$xScale;
        let adjScaleX = 0;
        if (preview && this._$width * this._$xScale > LibraryExport.DEFAULT_SIZE) {
            adjScaleX = LibraryExport.DEFAULT_SIZE / (this._$width * this._$xScale);
        }

        let yScale = this._$yScale;
        let adjScaleY = 0;
        if (preview && this._$height * this._$yScale > LibraryExport.DEFAULT_SIZE) {
            adjScaleY = LibraryExport.DEFAULT_SIZE / (this._$height * this._$yScale);
        }

        if (adjScaleX) {
            xScale *= adjScaleX;
            yScale *= adjScaleX;
        }

        if (adjScaleY) {
            xScale *= adjScaleY;
            yScale *= adjScaleY;
        }

        const context = this._$instance.draw(
            Util.$getCanvas(),
            Math.ceil(width * xScale),
            Math.ceil(height * yScale),
            {
                "frame": 1,
                "matrix": [xScale, 0, 0, yScale, 0, 0],
                "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                "blendMode": "normal",
                "filter": []
            },
            null, frame, true
        );

        // reset
        Util.$zoomScale    = zoomScale;
        Util.$currentFrame = currentFrame;

        return context;
    }
}

Util.$libraryExport = new LibraryExport();

/**
 * @class
 * @extends {KeyboardCommand}
 * @memberOf view.controller
 */
class LibraryKeyboardCommand extends KeyboardCommand
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("library");
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document
            .getElementById("library-list-box");

        if (element) {

            element.addEventListener("mouseleave", () =>
            {
                this.active = false;
            });

            element.addEventListener("mouseover", () =>
            {
                if (!this.active) {
                    this.active = true;
                }
            });

            element.addEventListener("mouseup", () =>
            {
                if (!this.active) {
                    this.active = true;
                }
            });
        }

        // 選択したアイテムを削除
        this.add("Backspace", () =>
        {
            Util
                .$libraryMenu
                .executeLibraryMenuDelete();
        });

        // スクリーンで使用してないアイテムを全て削除
        this.add(Util.$generateShortcutKey("Backspace", { "ctrl": true, "shift": true }), () =>
        {
            Util.$libraryMenu.executeLibraryMenuNoUseDelete();
        });

        // MovieClipを追加
        this.add(Util.$generateShortcutKey("m", { "ctrl": true }), () =>
        {
            Util
                .$libraryMenu
                .executeLibraryMenuContainerAdd();
        });

        // フォルダーを追加
        this.add(Util.$generateShortcutKey("f", { "ctrl": true }), () =>
        {
            Util
                .$libraryMenu
                .executeLibraryMenuFolderAdd();
        });

        // 外部ファイル読み込み
        this.add(
            Util.$generateShortcutKey("r", { "ctrl": true }),
            this.loadFile
        );

        // コピー
        this.add(Util.$generateShortcutKey("c", { "ctrl": true }), () =>
        {
            Util.$libraryMenu.executeLibraryMenuCopy();
        });

        // 貼り付け
        this.add(Util.$generateShortcutKey("v", { "ctrl": true }), () =>
        {
            Util.$libraryMenu.executeLibraryMenuPaste();
        });

        // 書き出し
        this.add(Util.$generateShortcutKey("s", { "ctrl": true, "shift": true }), () =>
        {
            Util
                .$libraryExport
                .executeLibraryMenuExport();
        });

        // 指定したアイテムの書き出し
        this.add(Util.$generateShortcutKey("s", { "ctrl": true, "shift": true }), () =>
        {
            Util.$libraryExport.executeLibraryMenuExport();
        });

        // カーソルでのアイテム移動
        this.add("ArrowDown", this.moveItem);
        this.add("ArrowUp", this.moveItem);
        this.add(
            Util.$generateShortcutKey("ArrowDown", { "shift": true }),
            this.moveItem
        );
        this.add(
            Util.$generateShortcutKey("ArrowUp", { "shift": true }),
            this.moveItem
        );

        // 全てを選択
        this.add(Util.$generateShortcutKey("a", { "ctrl": true }), () =>
        {
            this.allItemSelect();
        });
    }

    /**
     * @description 全てのライブラリのアイテムをアクティブにする
     *
     * @return {void}
     * @method
     * @public
     */
    allItemSelect ()
    {
        const children = document
            .getElementById("library-list-box")
            .children;

        const activeInstances = Util
            .$libraryController
            .activeInstances;

        // 初期化
        activeInstances.clear();

        // 全てを選択
        for (let idx = 0; children.length > idx; ++idx) {

            const element = children[idx];
            element
                .classList
                .add("active");

            const libraryId = element.dataset.libraryId | 0;

            activeInstances.set(libraryId, element);
        }
    }

    /**
     * @description カーソルでのアイテム移動
     *
     * @param  {string} code
     * @return {void}
     * @method
     * @public
     */
    moveItem (code)
    {
        const element = document
            .getElementById("library-list-box");

        if (!element) {
            return ;
        }

        const children = Array.from(element.children);

        let index = 0;
        const activeInstances = Util.$libraryController.activeInstances;
        if (activeInstances.size) {

            let activeInstance = null;
            const iterator = activeInstances.values();
            for (let idx = 0; activeInstances.size > idx; ++idx) {
                activeInstance = iterator.next().value;
            }

            index = children.indexOf(activeInstance);
        }

        switch (code) {

            case "ArrowDown":
            case "ArrowDownShift":
                index++;
                break;

            case "ArrowUp":
            case "ArrowUpShift":
                index--;
                break;

        }

        const node = children[index];
        if (node) {
            Util.$libraryController.activeInstance = node;

            // プレビューに表示
            Util
                .$libraryPreview
                .loadImage(
                    node.dataset.libraryId | 0
                );
        }
    }

    /**
     * @description 外部ファイルの読み込み
     *
     * @return {void}
     * @method
     * @public
     */
    loadFile ()
    {
        Util.$shiftKey = false;
        Util.$ctrlKey  = false;
        Util.$altKey   = false;

        document
            .getElementById("library-menu-file-input")
            .click();
    }
}

Util.$libraryKeyboardCommand = new LibraryKeyboardCommand();

/**
 * @class
 * @memberOf view.controller
 */
class LibraryMenu
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$copyWorkSpaceId = -1;

        /**
         * @type {*[]}
         * @private
         */
        this._$copyLibraries = [];

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$adjusted = false;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const element = document.getElementById("library-list-box");
        if (element) {

            element.addEventListener("contextmenu", (event) =>
            {
                this.show(event);
            });

            element.addEventListener("mousedown", (event) =>
            {
                if (event.button) {
                    return ;
                }

                this.hide();
            });

        }

        const elementIds = [
            "library-menu-container-add",
            "library-menu-folder-add",
            "library-menu-file",
            "library-menu-delete",
            "library-menu-no-use-delete",
            "library-menu-empty-folder-delete",
            "library-menu-copy",
            "library-menu-paste",
            "library-open-photopea"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                if (event.button) {
                    return ;
                }

                // 表示モーダルを全て終了
                Util.$endMenu();

                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                const names = event.target.id.split("-");

                let functionName = names
                    .map((value) =>
                    {
                        return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
                    })
                    .join("");

                this[`execute${functionName}`](event);
            });

        }

        const fileInput = document
            .getElementById("library-menu-file-input");

        if (fileInput) {

            fileInput.addEventListener("change", (event) =>
            {
                if (Util.$saveProgress.active) {
                    return ;
                }

                Util.$saveProgress.start();

                this.save();

                Util.$saveProgress.loadFiles();

                const promises = [];
                const files = event.target.files;
                for (let idx = 0; idx < files.length; ++idx) {
                    // eslint-disable-next-line no-loop-func
                    promises.push(new Promise((resolve) =>
                    {
                        Util
                            .$libraryController
                            .loadFile(files[idx], resolve);
                    }));
                }

                Promise
                    .all(promises)
                    .then(() =>
                    {
                        Util.$saveProgress.end();
                    });

                event.target.value = "";
                this._$saved = false;
            });
        }

        // 終了コール
        Util.$initializeEnd();
    }

    /**
     * @description 画像編集でPhotopeaを起動
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryOpenPhotopea ()
    {
        const activeInstances = Util
            .$libraryController
            .activeInstances;

        if (!activeInstances.size) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        for (let libraryId of activeInstances.keys()) {

            const instance = workSpace.getLibrary(libraryId);
            if (instance.type !== InstanceType.BITMAP) {
                continue;
            }

            const canvas  = Util.$getCanvas();
            const context = instance.draw(
                canvas,
                Math.ceil(instance.width),
                Math.ceil(instance.height),
                {
                    "frame": 1,
                    "matrix": [1, 0, 0, 1, 0, 0],
                    "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                    "blendMode": "normal",
                    "filter": []
                },
                null, 0, true
            );

            const object = {
                "files" : [
                    canvas.toDataURL(instance.imageType)
                ]
            };

            Util.$poolCanvas(context);

            const a = document.createElement("a");
            a.href = `https://www.photopea.com#${encodeURI(JSON.stringify(object))}`;
            a.target = "_blank";
            a.click();
        }

    }

    /**
     * @description 新規のコンテナを生成
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuContainerAdd ()
    {
        this.save();

        const workSpace = Util.$currentWorkSpace();

        const id = workSpace.nextLibraryId;
        workSpace.addLibrary({
            "id": id,
            "type": InstanceType.MOVIE_CLIP,
            "name": `MovieClip_${id}`,
            "symbol": ""
        });

        this._$saved = false;

        // 再読み込み
        Util.$libraryController.reload();
    }

    /**
     * @description 新規のフォルダを生成
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuFolderAdd ()
    {
        this.save();

        const workSpace = Util.$currentWorkSpace();

        const id = workSpace.nextLibraryId;
        const folder = workSpace.addLibrary({
            "id": id,
            "type": "folder",
            "name": `Folder_${id}`,
            "symbol": ""
        });

        // 選択中のアイテムがあればフォルダーの中に格納
        const activeInstances = Util
            .$libraryController
            .activeInstances;

        if (activeInstances.size) {
            for (let libraryId of activeInstances.keys()) {

                const instance = workSpace.getLibrary(libraryId);

                instance.folderId = id;
            }

            folder.mode = FolderType.OPEN;
        }

        // 再読み込み
        Util.$libraryController.reload();

        this._$saved = false;
    }

    /**
     * @description 外部ファイルの読み込み処理
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuFile (event)
    {
        event.preventDefault();

        document
            .getElementById("library-menu-file-input")
            .click();
    }

    /**
     * @description 選択中のアイテムを削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuDelete ()
    {
        const activeInstances = Util
            .$libraryController
            .activeInstances;

        if (!activeInstances.size) {
            return ;
        }

        this.save();

        const workSpace = Util.$currentWorkSpace();
        for (const element of activeInstances.values()) {

            const libraryId = element.dataset.libraryId | 0;
            const instance = workSpace.getLibrary(libraryId);
            if (!instance) {
                continue;
            }

            // 削除関数を実行
            instance.remove();

            // elementを削除
            element.remove();

            // 内部データからも削除
            workSpace.removeLibrary(libraryId);
        }

        // 選択中のアイテムを解放
        activeInstances.clear();

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        tool.clearActiveElement();

        // スクリーンエリアの変形Elementを非表示に
        Util.$transformController.hide();
        Util.$gridController.hide();
        Util.$tweenController.clearPointer();

        // コントローラーエリアを初期化
        Util.$controller.default();

        // JavaScriptのリストを再読み込み
        Util.$javascriptController.reload();

        // ライブラリを再読み込み
        Util.$libraryController.reload();

        // プレビューを初期化
        Util.$libraryPreview.dispose();

        // 現在の配置での再計算
        Util.$timelineLayer.activeCharacter();

        // シーンを再読み込み
        workSpace.scene.changeFrame(
            Util.$timelineFrame.currentFrame
        );

        this._$saved = false;
    }

    /**
     * @description 空のフォルダを全て削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuEmptyFolderDelete ()
    {
        const workSpace = Util.$currentWorkSpace();

        // 全てのフォルダを配列に格納
        const folders = [];
        for (let instance of workSpace._$libraries.values()) {
            if (instance.type !== InstanceType.FOLDER) {
                continue;
            }
            folders.push(instance);
        }

        if (folders.length) {

            let reload = false;
            for (;;) {

                const deleted = [];
                for (let idx = 0; idx < folders.length; ++idx) {

                    let use = false;
                    const folder = folders[idx];
                    for (let instance of workSpace._$libraries.values()) {

                        if (instance.folderId !== folder.id) {
                            continue;
                        }

                        use = true;
                        break;
                    }

                    if (use) {
                        continue;
                    }

                    reload = true;

                    // 利用していないフォルダを削除
                    document
                        .getElementById(`library-child-id-${folder.id}`)
                        .remove();

                    workSpace.removeLibrary(folder.id);

                    deleted.push(folder);
                }

                // 削除するものがなければ終了
                if (!deleted.length) {
                    break;
                }

                for (let idx = 0; idx < deleted.length; ++idx) {
                    const index = folders.indexOf(deleted[idx]);
                    folders.splice(index, 1);
                }

            }

            // ライブラリを再構成
            if (reload) {
                Util.$libraryController.reload();
            }
        }
    }

    /**
     * @description スクリーンに配置されていないアイテムを全て削除
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuNoUseDelete ()
    {
        let reload = false;
        const workSpace = Util.$currentWorkSpace();

        // 使用中のidを検索
        const useIds = new Map();
        for (let instance of workSpace._$libraries.values()) {

            if (instance.type !== InstanceType.MOVIE_CLIP) {
                continue;
            }

            for (let layer of instance._$layers.values()) {

                const characters = layer._$characters;
                for (let idx = 0; idx < characters.length; ++idx) {

                    const libraryId = characters[idx].libraryId;
                    if (!useIds.has(libraryId)) {
                        useIds.set(libraryId, 0);
                    }

                    const addCount = useIds.get(libraryId) + 1;
                    useIds.set(libraryId, addCount);
                }
            }

            if (instance._$sounds.size) {
                for (const sounds of instance._$sounds.values()) {
                    for (let idx = 0; idx < sounds.length; ++idx) {

                        const sound = sounds[idx];
                        useIds.set(sound.characterId, true);

                    }
                }
            }
        }

        // 削除処理
        this.save();
        for (let instance of workSpace._$libraries.values()) {

            if (!instance.id) {
                continue;
            }

            if (useIds.has(instance.id)
                || instance.type === InstanceType.FOLDER
                || instance.symbol
            ) {
                continue;
            }

            reload = true;
            if (instance.type === InstanceType.MOVIE_CLIP) {

                for (let layer of instance._$layers.values()) {

                    const characters = layer._$characters;
                    for (let idx = 0; idx < characters.length; ++idx) {

                        const libraryId = characters[idx].libraryId;
                        if (!useIds.has(libraryId)) {
                            continue;
                        }

                        const instance = workSpace.getLibrary(libraryId);
                        if (!instance || instance.symbol) {
                            continue;
                        }

                        const count = useIds.get(libraryId) - 1;
                        useIds.set(libraryId, count);
                    }
                }
            }

            workSpace.removeLibrary(instance.id);
        }

        for (;;) {

            let idEnd = true;
            for (const [libraryId, currentCount] of useIds) {

                if (currentCount > 0) {
                    continue;
                }

                // 指定のアイテムを取得
                const instance = workSpace.getLibrary(libraryId);
                if (instance.symbol) {
                    continue;
                }

                idEnd = false;
                if (!instance) {
                    continue;
                }

                if (instance.type === InstanceType.MOVIE_CLIP) {

                    for (let layer of instance._$layers.values()) {

                        const characters = layer._$characters;
                        for (let idx = 0; idx < characters.length; ++idx) {

                            const libraryId = characters[idx].libraryId;
                            if (!useIds.has(libraryId)) {
                                continue;
                            }

                            const instance = workSpace.getLibrary(libraryId);
                            if (!instance || instance.symbol) {
                                continue;
                            }

                            const count = useIds.get(libraryId) - 1;
                            useIds.set(libraryId, count);
                        }
                    }
                }

                workSpace.removeLibrary(libraryId);
                useIds.delete(libraryId);
            }

            if (idEnd || !useIds.size) {
                break;
            }
        }

        if (reload) {

            Util
                .$libraryController
                .clearActive();

            // JavaScriptのリストを再読み込み
            Util.$javascriptController.reload();

            // ライブラリを再読み込み
            Util.$libraryController.reload();
        }

        this._$saved = false;
    }

    /**
     * @description コピー情報を初期化
     *
     * @return {void}
     * @method
     * @public
     */
    clearCopy ()
    {
        this._$adjusted = false;
        this._$copyWorkSpaceId = -1;
        this._$copyLibraries.length = 0;
    }

    /**
     * @description 選択したアイテムをコピー
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuCopy ()
    {
        // 初期化
        this.clearCopy();

        // コピー元のワークスペースのIDをセット
        this._$copyWorkSpaceId = Util.$activeWorkSpaceId;

        const workSpace = Util.$currentWorkSpace();
        const activeInstances = Util.$libraryController.activeInstances;
        for (const element of activeInstances.values()) {

            const instance = workSpace.getLibrary(
                element.dataset.libraryId | 0
            );

            if (!instance) {
                continue;
            }

            this._$copyLibraries.push(instance.clone());
        }
    }

    /**
     * @description コピーしたアイテムを現在のプロジェクトに複製
     *
     * @return {void}
     * @method
     * @public
     */
    executeLibraryMenuPaste ()
    {
        if (!this._$copyLibraries.length) {
            return ;
        }

        const fromWorkSpace = Util.$workSpaces[this._$copyWorkSpaceId];
        const toWorkSpace   = Util.$currentWorkSpace();

        // コピーしたアイテムがフォルダーの中にある場合
        // そのフォルダーがコピーに含まれているかチェック
        // コピーにフォルダーが含まれない場合は一階層上にコピーする
        if (!this._$adjusted) {

            this._$adjusted = true;

            // コピーしたアイテムがフォルダ内部にあるかチェック
            const idMap   = new Map();
            const inItems = [];
            for (let idx = 0; this._$copyLibraries.length > idx; ++idx) {

                const instance = this._$copyLibraries[idx];
                idMap.set(instance.id, true);

                if (!instance.folderId) {
                    continue;
                }

                inItems.push(instance);
            }

            // フォルダ内部にある場合、コピーデータにフォルダが含まれてるかチェック
            for (let idx = 0; idx < inItems.length; ++idx) {

                let instance = inItems[idx];
                while (instance.folderId) {

                    const folder = fromWorkSpace.getLibrary(instance.folderId);
                    if (idMap.has(folder.id)) {
                        // コピーの配列にフォルダが含まれていれば
                        // 全てコピーとなるので、単体のアイテムを配列から削除する
                        const index = this._$copyLibraries.indexOf(inItems[idx]);
                        if (index > -1) {
                            this._$copyLibraries.splice(index, 1);
                        }
                        break;
                    }

                    instance = folder;
                }

            }
        }

        // 状態保存
        this.save();
        for (let idx = 0; this._$copyLibraries.length > idx; ++idx) {

            const instance = this._$copyLibraries[idx];

            let clone = null;
            if (this._$copyWorkSpaceId === Util.$activeWorkSpaceId) {

                clone = instance.clone();

                // 名前が重複しなくなるまでprefixを追加する
                for (;;) {

                    const path = clone.path;

                    if (!toWorkSpace._$nameMap.has(path)) {
                        break;
                    }

                    clone.name += "_copy";
                }

            } else {

                // 別プロジェクトへのコピーなら確認モーダルを表示する
                const path = instance.getPathWithWorkSpace(fromWorkSpace);

                if (toWorkSpace._$nameMap.has(path)) {
                    Util.$confirmModal.files.push({
                        "file": instance,
                        "character": null,
                        "layer": null,
                        "path": path,
                        "workSpaceId": this._$copyWorkSpaceId,
                        "type": "copy"
                    });
                    continue;
                }

                if (instance.type === InstanceType.MOVIE_CLIP) {

                    clone = Util
                        .$confirmModal
                        .cloneMovieClip(this._$copyWorkSpaceId, instance);

                } else {

                    // プロジェクトを切り替えて複製
                    const activeWorkSpaceId = Util.$activeWorkSpaceId;
                    Util.$activeWorkSpaceId = this._$copyWorkSpaceId;

                    clone = instance.clone();
                    Util.$activeWorkSpaceId = activeWorkSpaceId;

                }

                if (!clone) {
                    continue;
                }

                // コピーするアイテムがフォルダ内にあれば階層を維持する
                if (clone.folderId) {

                    Util
                        .$confirmModal
                        .createFolder(this._$copyWorkSpaceId, clone);

                }

            }

            // IDを再発行
            clone._$id = toWorkSpace.nextLibraryId;

            // Elementを追加
            Util
                .$libraryController
                .createInstance(
                    clone.type,
                    clone.name,
                    clone.id,
                    clone.symbol
                );

            // 内部データに追加
            toWorkSpace._$libraries.set(clone.id, clone);

            // フォルダの中にあるアイテムを複製
            if (clone.type === InstanceType.FOLDER) {
                Util.$confirmModal.cloneFolderItem(
                    this._$copyWorkSpaceId, instance.id, clone
                );
            }
        }

        // ライブラリを再構成
        Util.$libraryController.reload();

        // 確認モーダルを表示
        if (Util.$confirmModal.files.length) {
            Util.$confirmModal.show();
        } else {
            Util.$confirmModal.clear();
        }

        // 初期化
        this._$saved = false;
    }

    /**
     * @description ライブラリのメニューを表示
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    show (event)
    {
        const element = document
            .getElementById("library-menu");

        element.style.left = element.clientWidth + event.pageX + 5 > window.innerWidth
            ? `${event.pageX - (element.clientWidth + event.pageX + 10 - window.innerWidth)}px`
            : `${event.pageX + 5}px`;

        element.style.top = `${event.pageY - element.clientHeight / 2}px`;
        element.setAttribute("class", "fadeIn");

        Util.$endMenu("library-menu");
    }

    /**
     * @description モーダルを非表示
     *
     * @return {void}
     * @method
     * @public
     */
    hide ()
    {
        Util.$endMenu();
    }

    /**
     * @description undo用にデータを内部保管する
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }
}

Util.$libraryMenu = new LibraryMenu();

/**
 * @class
 * @memberOf view.controller
 */
class LibraryPreview
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$currentId = -1;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const element = document
            .getElementById("library-preview-area");

        if (element) {

            element.addEventListener("mousedown", (event) =>
            {
                this.mousedown(event);
            });

            element.addEventListener("dragstart", () =>
            {
                Util.$libraryController.dragstart();
            });

            element.addEventListener("dragend", () =>
            {
                Util.$libraryController.dragend();
            });
        }

        // 終了コール
        Util.$initializeEnd();
    }

    /**
     * @description プレビューエリアのドラッグを無効化
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseout (event)
    {
        if (this._$currentId === -1) {
            return ;
        }

        // 全てのイベントを中止
        event.stopPropagation();

        document
            .getElementById("library-preview-area")
            .draggable = false;
    }

    /**
     * @description プレビューエリアをタップした時の処理関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mousedown (event)
    {
        if (this._$currentId === -1) {
            return ;
        }

        // 全てのイベントを中止
        event.stopPropagation();

        const target = document
            .getElementById(`library-child-id-${this._$currentId}`);

        if (target) {

            // 現在のプレビューをキャッシュ
            const preview = document
                .getElementById("library-preview-area");

            const children = Array.from(document
                .getElementById("library-preview-area")
                .children);

            Util
                .$libraryController
                .activeInstance = target;

            // プレビューを再描画
            for (let idx = 0; idx < children.length; ++idx) {
                preview.appendChild(children[idx]);
            }

            preview.draggable = true;
        }
    }

    /**
     * @description プレビューエリアを初期化
     *
     * @return {void}
     * @method
     * @public
     */
    dispose ()
    {
        this._$currentId = -1;

        // 初期化
        const element = document
            .getElementById("library-preview-area");

        if (!element) {
            return ;
        }

        while (element.firstChild) {
            Util.$poolCanvas(element.firstChild);
            element.firstChild.remove();
        }

        element.draggable = false;
    }

    /**
     * @description 選択したインスタンスの情報をプレビューエリアに表示
     *
     * @param  {number} library_id
     * @return {void}
     * @method
     * @public
     */
    loadImage (library_id)
    {
        // 初期化
        this.dispose();

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(library_id);

        if (instance.type !== InstanceType.FOLDER) {

            this._$currentId = library_id;

            document
                .getElementById("library-preview-area")
                .appendChild(instance.getPreview());

            if (instance.type === InstanceType.SOUND) {

                Util.$soundWaveform.draw(instance._$buffer.slice());

            } else {

                Util.$soundWaveform.stop();

            }

        }
    }
}

Util.$libraryPreview = new LibraryPreview();

/**
 * @class
 * @memberOf view.controller
 */
class LibrarySearch
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const element = document
            .getElementById("library-search");

        if (element) {

            element.addEventListener("focusin", () =>
            {
                Util.$keyLock = true;
            });
            element.addEventListener("focusout", () =>
            {
                Util.$keyLock = false;
            });
            element.addEventListener("input", (event) =>
            {
                this.execute(event);
            });

        }

        // 終了コール
        Util.$initializeEnd();
    }

    /**
     * @description inputの値をライブラリ内で検索
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    execute (event)
    {
        const value = event.target.value;

        const children = document
            .getElementById("library-list-box")
            .children;

        const length = children.length;
        for (let idx = 0; idx < length; ++idx) {

            const node = children[idx];

            if (!value
                || node.children[0].innerText.indexOf(value) > -1
                || node.children[1].innerText.indexOf(value) > -1
            ) {
                node.style.display = "";
                continue;
            }

            node.style.display = "none";
        }
    }
}

Util.$librarySearch = new LibrarySearch();

/**
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class LoopController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("loop");

        /**
         * @type {string}
         * @default "start"
         * @private
         */
        this._$frameTarget = "start";
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "no-use-loop",
            "loop-repeat",
            "loop-no-repeat",
            "fixed-one",
            "loop-no-repeat-reversal",
            "loop-repeat-reversal",
            "frame-picker-button",
            "target-start-button",
            "target-end-button"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            element.addEventListener("mousedown", (event) =>
            {
                // 他のイベントを中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event.target.id, event);
            });
        }

        const inputIds = [
            "loop-start-frame",
            "loop-end-frame"
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {

            const element = document.getElementById(inputIds[idx]);
            if (!element) {
                continue;
            }

            this.setInputEvent(element);
        }
    }

    /**
     * @description デフォルトのループ設定値
     *
     * @return {number}
     * @const
     * @static
     */
    static get DEFAULT ()
    {
        return 5;
    }

    /**
     * @description カスタム設定したフレーム範囲でループを行う
     *
     * @return {number}
     * @const
     * @static
     */
    static get REPEAT ()
    {
        return 0;
    }

    /**
     * @description カスタム設定したフレーム範囲で再生して終了。ループしない
     *
     * @return {number}
     * @const
     * @static
     */
    static get NO_REPEAT ()
    {
        return 1;
    }

    /**
     * @description 指定フレームに固定してフレーム移動させない
     *
     * @return {number}
     * @const
     * @static
     */
    static get FIXED_ONE ()
    {
        return 2;
    }

    /**
     * @description カスタム設定したフレーム範囲で逆再生して終了。ループはしない
     *
     * @return {number}
     * @const
     * @static
     */
    static get NO_REPEAT_REVERSAL ()
    {
        return 3;
    }

    /**
     * @description カスタム設定したフレーム範囲を逆再生し、ループを行う
     *
     * @return {number}
     * @const
     * @static
     */
    static get REPEAT_REVERSAL ()
    {
        return 4;
    }

    /**
     * @description ループの開始フレームを設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeLoopStartFrame (value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return value;
        }

        const element = activeElements[0];

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        if (!character) {
            return value;
        }

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                character.libraryId
            );

        if (!instance) {
            return value;
        }

        value = Util.$clamp(value | 0, 1, instance.totalFrame);

        const frame = Util.$timelineFrame.currentFrame;
        const range = character.getRange(frame);

        let place = character.getPlace(range.startFrame);
        if (!place.loop) {
            return value;
        }

        // ループタイプを更新してキャッシュを削除
        place.loop.start  = value;
        character.dispose();

        // 再描画
        this.reloadScreen();

        return value;
    }

    /**
     * @description ループの終了フレームを設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeLoopEndFrame (value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return value;
        }

        const element = activeElements[0];

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        if (!character) {
            return value;
        }

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                character.libraryId
            );

        if (!instance) {
            return value;
        }

        value = Util.$clamp(value | 0, 0, instance.totalFrame);

        const frame = Util.$timelineFrame.currentFrame;
        const range = character.getRange(frame);

        let place = character.getPlace(range.startFrame);
        if (!place.loop) {
            return value;
        }

        // ループタイプを更新してキャッシュを削除
        place.loop.end    = value;
        character.dispose();

        // 再描画
        this.reloadScreen();

        return value ? value : "-";
    }

    /**
     * @description フレーム毎のイメージを生成
     *
     * @return {void}
     * @method
     * @public
     */
    changeFramePickerButton ()
    {
        document
            .getElementById("loop-image-list")
            .style.display = "none";

        this.loadLoopFrameList();
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    changeTargetStartButton ()
    {
        const element = document
            .getElementById("target-start-button");

        if (!element.classList.contains("active")) {
            element.classList.add("active");
        }

        document
            .getElementById("target-end-button")
            .classList.remove("active");

        this._$frameTarget = "start";
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    changeTargetEndButton ()
    {
        const element = document
            .getElementById("target-end-button");

        if (!element.classList.contains("active")) {
            element.classList.add("active");
        }

        document
            .getElementById("target-start-button")
            .classList.remove("active");

        this._$frameTarget = "end";
    }

    /**
     * @description カスタムループ機能をOnに
     *
     * @return {void}
     * @method
     * @public
     */
    changeLoopRepeat ()
    {
        const element = document
            .getElementById("loop-repeat");

        // 全てのボタンを非アクティブに
        this.clearLoopButton(element);

        element.classList.add("active");

        this.updateLoopType(0);
    }

    /**
     * @description カスタムループの1回終了機能をOnに
     *
     * @return {void}
     * @method
     * @public
     */
    changeLoopNoRepeat ()
    {
        const element = document
            .getElementById("loop-no-repeat");

        // 全てのボタンを非アクティブに
        this.clearLoopButton(element);

        element.classList.add("active");

        this.updateLoopType(1);
    }

    /**
     * @description 指定フレームに固定
     *
     * @return {void}
     * @method
     * @public
     */
    changeFixedOne ()
    {
        const element = document
            .getElementById("fixed-one");

        // 全てのボタンを非アクティブに
        this.clearLoopButton(element);

        element.classList.add("active");

        this.updateLoopType(2);
    }

    /**
     * @description カスタムループの逆再生の1回終了機能をOnに
     *
     * @return {void}
     * @method
     * @public
     */
    changeLoopNoRepeatReversal ()
    {
        const element = document
            .getElementById("loop-no-repeat-reversal");

        // 全てのボタンを非アクティブに
        this.clearLoopButton(element);

        element.classList.add("active");

        this.updateLoopType(3);
    }

    /**
     * @description カスタムループ機能の逆再生をOnに
     *
     * @return {void}
     * @method
     * @public
     */
    changeLoopRepeatReversal ()
    {
        const element = document
            .getElementById("loop-repeat-reversal");

        // 全てのボタンを非アクティブに
        this.clearLoopButton(element);

        element.classList.add("active");

        this.updateLoopType(4);
    }

    /**
     * @description Playerのループ機能をOn
     *
     * @return {void}
     * @method
     * @public
     */
    changeNoUseLoop ()
    {
        const element = document
            .getElementById("no-use-loop");

        // 全てのボタンを非アクティブに
        this.clearLoopButton(element);

        element.classList.add("active");

        this.updateLoopType(5);
    }

    /**
     * @description 全てのボタンを非アクティブに
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    clearLoopButton (element)
    {
        // 全てのボタンを非アクティブに
        const children = element.parentNode.children;
        for (let idx = 0; idx < children.length; ++idx) {
            children[idx]
                .classList
                .remove("active");
        }
    }

    /**
     * @description 初期化
     *
     * @param  {object} loop_setting
     * @return {void}
     * @method
     * @public
     */
    reload (loop_setting)
    {
        const children = document
            .getElementById("loop-setting-view-area")
            .firstElementChild.children;

        for (let idx = 0; idx < children.length; ++idx) {
            children[idx].classList.remove("active");
        }

        const element = document
            .getElementById("loop-image-list");

        const elements = element.getElementsByTagName("canvas");
        for (let idx = 0; idx < elements.length; ++idx) {
            Util.$poolCanvas(elements[idx]);
        }

        while (element.children.length) {
            element.children[0].remove();
        }

        const types = [
            "loop-repeat",
            "loop-no-repeat",
            "fixed-one",
            "loop-no-repeat-reversal",
            "loop-repeat-reversal",
            "no-use-loop"
        ];

        document
            .getElementById(types[loop_setting.type])
            .classList.add("active");

        document
            .getElementById("loop-start-frame")
            .value = `${loop_setting.start}`;

        document
            .getElementById("loop-end-frame")
            .value = `${loop_setting.end ? loop_setting.end : "-"}`;
    }

    /**
     * @return {void}
     * @public
     */
    loadLoopFrameList ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        // イメージ表示を初期化
        const element = document
            .getElementById("loop-image-list");

        const elements = element.getElementsByTagName("canvas");
        for (let idx = 0; idx < elements.length; ++idx) {
            Util.$poolCanvas(elements[idx]);
        }

        while (element.children.length) {
            element.children[0].remove();
        }

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        const target = activeElements[0];

        const layerId = target.dataset.layerId | 0;
        const layer   = scene.getLayer(layerId);

        const characterId = target.dataset.characterId | 0;
        const character   = layer.getCharacter(characterId);

        const range = {
            "startFrame": character.startFrame,
            "endFrame": character.endFrame
        };

        const instance = workSpace.getLibrary(character.libraryId);

        const currentFrame = Util.$timelineFrame.currentFrame;

        const promises = [];
        const endFrame = instance.totalFrame;
        for (let frame = 1; endFrame >= frame; ++frame) {

            // eslint-disable-next-line no-loop-func
            promises.push(new Promise((resolve) =>
            {
                window.requestAnimationFrame(() =>
                {
                    const { Sprite, BitmapData } = window.next2d.display;
                    const { Matrix, ColorTransform } = window.next2d.geom;

                    Util.$currentFrame = frame;

                    const sprite = new Sprite();

                    const placeObject = {
                        "frame": frame,
                        "matrix": [1, 0, 0, 1, 0, 0],
                        "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                        "blendMode": "normal",
                        "filter": [],
                        "loop": Util.$getDefaultLoopConfig()
                    };

                    const displayObject = sprite
                        .addChild(
                            instance.createInstance(placeObject, range)
                        );

                    displayObject
                        .transform
                        .matrix = new Matrix();

                    displayObject
                        .transform
                        .colorTransform = new ColorTransform();

                    const bounds = instance.getBounds(
                        [1, 0, 0, 1, 0, 0], placeObject, range
                    );

                    const width  = Math.ceil(Math.abs(bounds.xMax - bounds.xMin));
                    const height = Math.ceil(Math.abs(bounds.yMax - bounds.yMin));
                    const scale  = Math.min(95 / width, 95 / height);
                    const ratio  = window.devicePixelRatio;

                    const bitmapData = new BitmapData(
                        width  * scale * ratio,
                        height * scale * ratio,
                        true, 0
                    );

                    const matrix = new Matrix(
                        ratio, 0, 0, ratio,
                        -bounds.xMin * ratio,
                        -bounds.yMin * ratio
                    );

                    matrix.scale(scale, scale);
                    bitmapData.draw(sprite, matrix);
                    const context = bitmapData.drawFromCanvas(Util.$getCanvas());
                    bitmapData.dispose();

                    const canvas = context.canvas;
                    canvas.style.width  = `${bitmapData.width  / ratio}px`;
                    canvas.style.height = `${bitmapData.height / ratio}px`;

                    return resolve({
                        "index": frame - 1,
                        "image": canvas
                    });
                });
            }));
        }

        Promise.all(promises)
            .then((results) =>
            {
                // reset
                Util.$currentFrame = currentFrame;

                const images = [];
                for (let idx = 0; idx < results.length; ++idx) {
                    const object = results[idx];
                    images[object.index] = object.image;
                }

                for (let idx = 0; idx < images.length; ++idx) {

                    const frame = idx + 1;

                    const span = document.createElement("span");
                    span.textContent = `[ ${frame} ]`;

                    const p = document.createElement("p");
                    p.appendChild(images[idx]);

                    const div = document.createElement("div");
                    div.dataset.frame = `${frame}`;

                    div.appendChild(p);
                    div.appendChild(span);

                    // eslint-disable-next-line no-loop-func
                    div.addEventListener("click", (event) =>
                    {
                        this.clickImage(event);
                    });

                    element.appendChild(div);
                }

                element.style.display = "";
            });
    }

    /**
     * @description フレームのイメージを押下してフレーム番号を適用
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    clickImage (event)
    {
        // 他のイベントを中止
        event.stopPropagation();

        const element = document
            .getElementById(
                `loop-${this._$frameTarget}-frame`
            );

        this.save();

        element.focus();
        element.value = event.currentTarget.dataset.frame;
        element.blur();

        this._$saved = false;
    }

    /**
     * @description ループタイプの更新
     *
     * @param  {number} [type=0]
     * @return {void}
     * @method
     * @public
     */
    updateLoopType (type = 0)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const element = activeElements[0];

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        if (!character) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;
        const range = character.getRange(frame);

        let place = character.getPlace(range.startFrame);
        if (place.loop.type === type) {
            return ;
        }

        // ループタイプを更新してキャッシュを削除
        place.loop.type   = type;
        character.dispose();

        // 再描画
        this.reloadScreen();
    }
}

Util.$loopController = new LoopController();

/**
 * @class
 * @memberOf view.controller
 */
class ObjectController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("object");
    }

    /**
     * @description オブジェクトコントローラーの初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const objectName = document.getElementById("object-name");
        if (objectName) {
            objectName.addEventListener("focusout", (event) =>
            {
                this.finishInput(event, false);
            });
            objectName.addEventListener("keypress", (event) =>
            {
                this.finishInput(event, false);
            });
            objectName.addEventListener("focusin", (event) =>
            {
                this.focusIn(event);
            });
        }

        const objectSymbol = document.getElementById("object-symbol");
        if (objectSymbol) {
            objectSymbol.addEventListener("focusout", (event) =>
            {
                this.finishInput(event, false);
            });
            objectSymbol.addEventListener("keypress", (event) =>
            {
                this.finishInput(event, false);
            });
            objectSymbol.addEventListener("focusin", (event) =>
            {
                this.focusIn(event);
            });
        }
    }

    /**
     * @description シンボル名を反映
     *
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    changeObjectSymbol (value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        switch (tool.activeElements.length) {

            case 0:
                Util
                    .$currentWorkSpace()
                    .scene
                    .symbol = value;
                break;

            case 1:
                {
                    const element = tool.activeElements[0];
                    Util
                        .$currentWorkSpace()
                        .getLibrary(
                            element.dataset.libraryId | 0
                        )
                        .symbol = value;
                }
                break;

            default:
                break;

        }

        return value;
    }

    /**
     * @description インスタン名を反映
     *
     * @param  {string} value
     * @return {string}
     * @method
     * @public
     */
    changeObjectName (value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        switch (tool.activeElements.length) {

            case 0:
                Util
                    .$currentWorkSpace()
                    .scene
                    .name = value;
                break;

            case 1:
                {
                    const element = tool.activeElements[0];

                    const layer = Util
                        .$currentWorkSpace()
                        .scene
                        .getLayer(
                            element.dataset.layerId | 0
                        );

                    const character = layer.getCharacter(
                        element.dataset.characterId | 0
                    );

                    character.name = value;
                }
                break;

            default:
                break;

        }

        return value;
    }
}

Util.$objectController = new ObjectController();

/**
 * @class
 * @memberOf view.controller
 */
class PluginController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$saved = false;

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$selectElement = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$deleteCommand = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        this._$deleteCommand = this.deleteCommand.bind(this);

        const element = document.getElementById("plugin-list-box");
        if (element) {

            element.addEventListener("mouseleave", () =>
            {
                this.mouseleave();
            });

            element.addEventListener("dragover", (event) =>
            {
                event.preventDefault();
            });

            element.addEventListener("drop", (event) =>
            {
                this.dropElement(event);
            });
        }

        // 終了コール
        Util.$initializeEnd();
    }

    /**
     * @description 選択したElementを解放
     *
     * @param  {DragEvent} event
     * @return {void}
     * @method
     * @public
     */
    dropElement (event)
    {
        this.save();

        event.preventDefault();

        const workSpace = Util.$currentWorkSpace();

        const promises = [];

        const files = event.dataTransfer.files;
        for (let idx = 0; idx < files.length; ++idx) {

            const file = files[idx];

            promises.push(file
                .text()
                .then((src) =>
                {
                    // 上書き
                    workSpace._$plugins.set(file.name, {
                        "name": file.name,
                        "src": src
                    });
                }));

        }

        Promise
            .all(promises)
            .then(() =>
            {
                this.reload(
                    Array.from(Util.$currentWorkSpace()._$plugins.values())
                );

                this._$saved = false;
            });
    }

    /**
     * @description 選択したElementを解放
     *
     * @return {void}
     * @method
     * @public
     */
    mouseleave ()
    {
        if (this._$selectElement) {
            this
                ._$selectElement
                .classList
                .remove("active");
        }

        window
            .removeEventListener("keydown", this._$deleteCommand);

        this._$selectElement = null;
    }

    /**
     * @description プラグインデータを追加
     *
     * @param  {array} plugins
     * @return {void}
     * @method
     * @public
     */
    reload (plugins)
    {
        // elementを初期化
        const elementIds = [
            "plugin-list-box",
            "plugin-tools",
            "plugin-menu"
        ];

        // プラグインで追加されたelementを初期化
        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document
                .getElementById(elementIds[idx]);

            if (!element) {
                continue;
            }

            while (element.children.length) {
                element.children[0].remove();
            }

        }

        const scripts = document.getElementsByTagName("script");
        for (let idx = 0; idx < scripts.length; ++idx) {

            const element = scripts[idx];
            if (!element.dataset.plugin) {
                continue;
            }

            element.remove();
        }

        for (let idx = 0; idx < plugins.length; ++idx) {

            const plugin = plugins[idx];

            const element = document.getElementById(plugin.name);
            if (element) {
                continue;
            }

            this.appendScript(plugin.name, plugin.src);
            this.appendNode(plugin.name);
        }
    }

    /**
     * @description 取り込んだscriptをhtmlに挿入する
     *
     * @param  {string} name
     * @param  {string} src
     * @return {void}
     * @method
     * @public
     */
    appendScript (name, src)
    {
        const script = document.createElement("script");
        script.dataset.plugin = "true";

        script.async = true;
        script.id    = name;
        script.type  = "text/javascript";
        script.src   = URL.createObjectURL(
            new Blob([src], {
                "type": "text/javascript"
            })
        );

        document
            .getElementsByTagName("head")[0]
            .appendChild(script);
    }

    /**
     * @description プラグインの一覧にelementを追加
     *
     * @param  {string} name
     * @return {void}
     * @method
     * @public
     */
    appendNode (name)
    {
        const div = document.createElement("div");
        div.dataset.id   = `${name}_node`;
        div.dataset.name = `${name}`;
        div.classList.add("plugin-list");
        div.innerHTML = `<i></i>${name}`;

        div.addEventListener("mousedown", (event) =>
        {
            if (!this._$selectElement) {
                window
                    .addEventListener("keydown", this._$deleteCommand);
            }

            if (this._$selectElement) {
                this
                    ._$selectElement
                    .classList
                    .remove("active");
            }

            // 選択したelementをセット
            this._$selectElement = event.currentTarget;

            this
                ._$selectElement
                .classList
                .add("active");
        });

        document
            .getElementById("plugin-list-box")
            .appendChild(div);
    }

    /**
     * @description 選択しているプラグインを削除
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    deleteCommand (event)
    {
        if (Util.$keyLock) {
            return ;
        }

        // 削除キー以外はスキップ
        if (event.key !== "Backspace") {
            return ;
        }

        this.save();

        window
            .removeEventListener("keydown", this._$deleteCommand);

        // 削除処理
        this.dispose(this._$selectElement);

        // 初期化
        this._$selectElement = null;
        this._$saved = false;
    }

    /**
     * @description 削除処理
     *
     * @param  {HTMLDivElement} element
     * @return {void}
     * @method
     * @public
     */
    dispose (element)
    {
        const name = element.dataset.name;

        // スクリプトを削除
        const plugin = document.getElementById(name);
        if (plugin) {
            plugin.remove();
        }

        Util
            .$currentWorkSpace()
            ._$plugins.delete(name);

        // elementを削除
        element.remove();
    }

    /**
     * @description undo用にデータを内部保管する
     *
     * @return {void}
     * @method
     * @public
     */
    save ()
    {
        if (!this._$saved) {
            this._$saved = true;

            Util
                .$currentWorkSpace()
                .temporarilySaved();
        }
    }
}

Util.$pluginController = new PluginController();

/**
 * @class
 * @memberOf view.controller
 */
class PluginPanel
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$screenX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$screenY = 0;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$moveModal = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endModal = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const elementIds = [
            "plugin-bar",
            "plugin-hide-icon"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            // eslint-disable-next-line no-loop-func
            element.addEventListener("mousedown", (event) =>
            {
                // 親のイベント中止
                event.stopPropagation();

                // id名で関数を実行
                const names = event.target.id.split("-");

                let functionName = names
                    .map((value) =>
                    {
                        return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;
                    })
                    .join("");

                this[`execute${functionName}`](event);
            });

        }

        document
            .documentElement
            .style
            .setProperty(
                "--plugin-panel-width",
                `${PluginPanel.PLUGIN_DEFAULT_WIDTH}px`
            );

        document
            .documentElement
            .style
            .setProperty(
                "--plugin-panel-height",
                `${PluginPanel.PLUGIN_DEFAULT_HEIGHT}px`
            );

        // 終了コール
        Util.$initializeEnd();
    }

    /**
     * @return {number}
     * @static
     * @const
     */
    static get PLUGIN_DEFAULT_WIDTH ()
    {
        return 200;
    }

    /**
     * @return {number}
     * @static
     * @const
     */
    static get PLUGIN_DEFAULT_HEIGHT ()
    {
        return 200;
    }

    /**
     * @description プラグインのモーダルの移動イベントを起動
     *
     * @return {void}
     * @method
     * @public
     */
    executePluginBar (event)
    {
        this._$screenX = event.screenX;
        this._$screenY = event.screenY;

        if (!this._$moveModal) {
            this._$moveModal = this.moveModal.bind(this);
        }

        if (!this._$endModal) {
            this._$endModal = this.endModal.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$moveModal);
        window.addEventListener("mouseup", this._$endModal);
    }

    /**
     * @description プラグインのモーダルの移動処理
     *
     * @return {void}
     * @method
     * @public
     */
    moveModal (event)
    {
        const element = document
            .getElementById("plugin-modal");

        element.style.left = `${element.offsetLeft + (event.screenX - this._$screenX)}px`;
        element.style.top  = `${element.offsetTop  + (event.screenY - this._$screenY)}px`;

        this._$screenX = event.screenX;
        this._$screenY = event.screenY;
    }

    /**
     * @description プラグインのモーダルの移動を終了
     *
     * @return {void}
     * @method
     * @public
     */
    endModal ()
    {
        Util.$setCursor("auto");
        window.removeEventListener("mousemove", this._$moveModal);
        window.removeEventListener("mouseup", this._$endModal);
    }

    /**
     * @description プラグインのモーダルを非表示にする
     *
     * @return {void}
     * @method
     * @public
     */
    executePluginHideIcon ()
    {
        window.nt.hidePanel();
    }
}

Util.$pluginPanel = new PluginPanel();

/**
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class ReferenceController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("reference");

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$pointer = null;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        this._$pointer = { "x": 0, "y": 0 };

        const elementIds = [
            "transform-reference-x",
            "transform-reference-y"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(elementIds[idx])
            );
        }

        const element = document.getElementById("reference-point");
        if (element) {
            element.addEventListener("dblclick", (event) =>
            {
                // イベントを全て中止
                event.stopPropagation();

                this.resetPointer();
            });
        }

        const parent = document
            .getElementById("reference-setting-box");

        if (parent) {
            const elements = parent
                .getElementsByClassName("reference-setting-box-child");

            for (let idx = 0; idx < elements.length; ++idx) {

                const node = elements[idx];

                node.addEventListener("mousedown", (event) =>
                {
                    // イベントを全て中止
                    event.stopPropagation();

                    this.moveNineReferencePoint(event);
                });
            }
        }
    }

    /**
     * @return {object}
     * @public
     */
    get pointer ()
    {
        return this._$pointer;
    }

    /**
     * @param  {object} pointer
     * @return {void}
     * @public
     */
    set pointer (pointer)
    {
        this._$pointer = pointer;
    }

    /**
     * @description 9点の固定位置に中心点を移動
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveNineReferencePoint (event)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        const matrix = Util.$sceneChange.concatenatedMatrix;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;
        for (let idx = 0; activeElements.length > idx; ++idx) {
            const target = activeElements[idx];

            const layer = scene.getLayer(target.dataset.layerId | 0);
            if (!layer || layer.lock || layer.disable) {
                continue;
            }

            const characterId = target.dataset.characterId | 0;

            const element = document
                .getElementById(`character-${characterId}`);

            if (!element) {
                continue;
            }

            const character = layer.getCharacter(characterId);

            const bounds = character.getBounds(matrix);
            const tx = Util.$sceneChange.offsetX + bounds.xMin;
            const ty = Util.$sceneChange.offsetY + bounds.yMin;

            xMin = Math.min(xMin, tx);
            xMax = Math.max(xMax, tx + Math.ceil(Math.abs(bounds.xMax - bounds.xMin)));
            yMin = Math.min(yMin, ty);
            yMax = Math.max(yMax, ty + Math.ceil(Math.abs(bounds.yMax - bounds.yMin)));
        }

        const x = xMin;
        const y = yMin;
        const width  = xMax - xMin;
        const height = yMax - yMin;

        // 中央にセット
        let dx = x + width  / 2;
        let dy = y + height / 2;
        switch (event.target.dataset.position) {

            case "top-left":
                dx = x;
                dy = y;
                break;

            case "top-center":
                dx = x + width / 2;
                dy = y;
                break;

            case "top-right":
                dx = x + width;
                dy = y;
                break;

            case "center-left":
                dx = x;
                dy = y + height / 2;
                break;

            case "center-right":
                dx = x + width;
                dy = y + height / 2;
                break;

            case "bottom-left":
                dx = x;
                dy = y + height;
                break;

            case "bottom-center":
                dx = x + width / 2;
                dy = y + height;
                break;

            case "bottom-right":
                dx = x + width;
                dy = y + height;
                break;

        }

        this.save();
        if (activeElements.length > 1) {

            this._$pointer.x = dx;
            this._$pointer.y = dy;

        } else {

            const target = activeElements[0];
            const layer  = Util
                .$currentWorkSpace()
                .scene
                .getLayer(
                    target.dataset.layerId | 0
                );

            const character = layer.getCharacter(
                target.dataset.characterId | 0
            );

            if (!character) {
                return ;
            }

            const frame = Util.$timelineFrame.currentFrame;
            const place = character.getPlace(frame);
            if (!place.point) {
                place.point = {
                    "x": 0,
                    "y": 0
                };
            }

            place.point.x = dx;
            place.point.y = dy;
        }

        // コントローラーの値を更新
        this.setInputValue(dx, dy);

        // 再計算
        Util
            .$transformController
            .relocation();

        this._$saved = false;
    }

    /**
     * @description 中心点のx座標を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeTransformReferenceX (value)
    {
        value = Util.$clamp(+value, -Number.MAX_VALUE, Number.MAX_VALUE);

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return value;
        }

        // 中心点を0,0にリセット
        if (activeElements.length === 1) {

            const target = activeElements[0];
            const layer  = Util
                .$currentWorkSpace()
                .scene
                .getLayer(
                    target.dataset.layerId | 0
                );

            const character = layer.getCharacter(
                target.dataset.characterId | 0
            );

            if (!character) {
                return value;
            }

            const frame = Util.$timelineFrame.currentFrame;
            const place = character.getPlace(frame);
            place.point.x = value;

        } else {

            this._$pointer.x = value;

        }

        return value;
    }

    /**
     * @description 中心点のx座標を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeTransformReferenceY (value)
    {
        value = Util.$clamp(+value, -Number.MAX_VALUE, Number.MAX_VALUE);

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return value;
        }

        // 中心点を0,0にリセット
        if (activeElements.length === 1) {

            const target = activeElements[0];
            const layer  = Util
                .$currentWorkSpace()
                .scene
                .getLayer(
                    target.dataset.layerId | 0
                );

            const character = layer.getCharacter(
                target.dataset.characterId | 0
            );

            if (!character) {
                return value;
            }

            const frame = Util.$timelineFrame.currentFrame;
            const place = character.getPlace(frame);
            place.point.y = value;

        } else {

            this._$pointer.y = value;

        }

        return value;
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    resetPointer ()
    {
        // 初期化
        this._$pointer = null;

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        const matrix = Util.$sceneChange.concatenatedMatrix;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;
        for (let idx = 0; activeElements.length > idx; ++idx) {

            const target = activeElements[idx];

            const layer = scene.getLayer(target.dataset.layerId | 0);
            if (!layer || layer.lock || layer.disable) {
                continue;
            }

            const characterId = target.dataset.characterId | 0;

            const element = document
                .getElementById(`character-${characterId}`);

            if (!element) {
                continue;
            }

            const character = layer.getCharacter(characterId);

            const bounds = character.getBounds(matrix);
            const tx = Util.$sceneChange.offsetX + bounds.xMin;
            const ty = Util.$sceneChange.offsetY + bounds.yMin;

            xMin = Math.min(xMin, tx);
            xMax = Math.max(xMax, tx + Math.ceil(Math.abs(bounds.xMax - bounds.xMin)));
            yMin = Math.min(yMin, ty);
            yMax = Math.max(yMax, ty + Math.ceil(Math.abs(bounds.yMax - bounds.yMin)));
        }

        const point = {
            "x": xMin + Math.abs(xMax - xMin) / 2,
            "y": yMin + Math.abs(yMax - yMin) / 2
        };

        if (activeElements.length === 1) {

            const target = activeElements[0];
            const layer  = Util
                .$currentWorkSpace()
                .scene
                .getLayer(
                    target.dataset.layerId | 0
                );

            const character = layer.getCharacter(
                target.dataset.characterId | 0
            );

            const frame = Util.$timelineFrame.currentFrame;
            const place = character.getPlace(frame);

            place.point = point;

        } else {

            this._$pointer = point;

        }

        // 再計算
        Util
            .$transformController
            .relocation();
    }

    /**
     * @description コントローラーの値を更新
     *
     * @param {number} x
     * @param {number} y
     */
    setInputValue (x = 0, y = 0)
    {
        document.getElementById("transform-reference-x").value = `${x}`;
        document.getElementById("transform-reference-y").value = `${y}`;
    }
}

Util.$referenceController = new ReferenceController();

/**
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class ShapeController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("fill-color");

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$currentPointer = null;

        /**
         * @type {CanvasRenderingContext2D}
         * @default null
         * @private
         */
        this._$viewGradientContext = null;

        /**
         * @type {CanvasRenderingContext2D}
         * @default null
         * @private
         */
        this._$drawGradientContext = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseMoveGradientColorPointer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$mouseUpGradientColorPointer = null;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get GRADIENT_CANVAS_WIDTH ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get GRADIENT_CANVAS_HEIGHT ()
    {
        return 30;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_COLOR ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_COLOR ()
    {
        return 100;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_ALPHA ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_ALPHA ()
    {
        return 100;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_STROKE ()
    {
        return 1;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_STROKE ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_GRADIENT_POINTER ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_GRADIENT_POINTER ()
    {
        return 255;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const canvas = document.getElementById("gradient-canvas");
        if (canvas) {

            canvas.style.transform          = `scale(${1 / window.devicePixelRatio}, ${1 / window.devicePixelRatio})`;
            canvas.style.backfaceVisibility = "hidden";
            canvas.style.transformOrigin    = "0 0";

            const width  = ShapeController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio;
            const height = ShapeController.GRADIENT_CANVAS_HEIGHT  * window.devicePixelRatio;

            canvas.width  = width;
            canvas.height = height;
            this._$viewGradientContext = canvas.getContext("2d");

            const drawCanvas  = document.createElement("canvas");
            drawCanvas.width  = width;
            drawCanvas.height = height;
            this._$drawGradientContext = drawCanvas.getContext("2d");
        }

        const inputIds = [
            "fill-alpha-value",
            "fill-stroke-width-value"
        ];
        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }

        const selectIds = [
            "fill-color-type-select",
            "fill-color-value",
            "fill-bitmap-select"
        ];

        for (let idx = 0; idx < selectIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(selectIds[idx])
            );
        }

        const element = document
            .getElementById("color-pointer-list");

        if (element) {
            element.addEventListener("mousedown", (event) =>
            {
                this.setGradientColorPointerEvent(event);
            });
        }
    }

    /**
     * @description グラデーションのポインターを削除
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    removeGradientColorPointer (event)
    {
        const element = document
            .getElementById("color-pointer-list");

        if (element.children.length > 2 && Util.$hitColor) {

            const index = event.target.dataset.index | 0;

            Util.$hitColor.ratios.splice(index, 1);

            // remove
            event.target.remove();

            // adj
            for (let idx = index; idx < element.children.length; ++idx) {

                const child = element.children[idx];
                const index = (child.dataset.index | 0) - 1;

                child.dataset.index = `${index}`;
            }

            // グラデーションレビューを再描画
            this.updateGradientCanvas();

            // 再描画ようにキャッシュを削除
            Util.$hitColor.shape.cacheClear();

            // 再描画
            this.reloadScreen();
        }
    }

    /**
     * @description グラデーションのポインター追加イベント
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    setGradientColorPointerEvent (event)
    {
        if (!this._$currentPointer || !Util.$hitColor) {
            return ;
        }

        const color  = document.getElementById("fill-color-value").value;
        const alpha  = document.getElementById("fill-alpha-value").value | 0;
        const object = Util.$intToRGB(`0x${color.slice(1)}` | 0);

        const stopObject = {
            "R": object.R,
            "G": object.G,
            "B": object.B,
            "A": alpha / 100 * 255,
            "ratio": event.offsetX / 255
        };

        Util.$hitColor.ratios.push(stopObject);

        Util.$hitColor.ratios.sort((a, b) =>
        {
            switch (true) {

                case a.ratio > b.ratio:
                    return 1;

                case a.ratio < b.ratio:
                    return -1;

                default:
                    return 0;

            }
        });

        // グラデーションレビューを再描画
        this.initializeGradient();

        // 再描画ようにキャッシュを削除
        Util.$hitColor.shape.cacheClear();

        // 再描画
        this.reloadScreen();

        // 新しいポインターElementをセット
        this._$currentPointer = event.target.children[
            Util.$hitColor.ratios.indexOf(stopObject)
        ];
    }

    /**
     * @description 塗りの透明度
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFillAlphaValue (value)
    {
        value = Util.$clamp(
            value | 0,
            ShapeController.MIN_ALPHA,
            ShapeController.MAX_ALPHA
        );

        if (Util.$hitColor) {

            const { GradientType } = window.next2d.display;
            switch (Util.$hitColor.type) {

                case GradientType.LINEAR:
                case GradientType.RADIAL:
                    if (this._$currentPointer) {
                        this._$currentPointer.dataset.alpha = value;
                        Util.$hitColor.shape.changeColor(
                            this._$currentPointer.dataset.index | 0
                        );
                        this.updateGradientCanvas();
                    }
                    break;

                default:
                    Util.$hitColor.shape.changeColor();
                    break;

            }

        }

        return value;
    }

    /**
     * @description 線の幅
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFillStrokeWidthValue (value)
    {
        value = Util.$clamp(
            value | 0,
            ShapeController.MIN_STROKE,
            ShapeController.MAX_STROKE
        );

        if (this._$currentValue !== value && Util.$hitColor) {

            Util.$hitColor.shape.changeColor();

            const { GradientType } = window.next2d.display;
            switch (Util.$hitColor.type) {

                case GradientType.LINEAR:
                case GradientType.RADIAL:
                    this.updateGradientCanvas();
                    break;

                default:
                    break;

            }

        }

        return value;
    }

    /**
     * @description 塗りのカラータイプの設定
     *
     * @param  {string} [value=""]
     * @return {void}
     * @method
     * @public
     */
    changeFillColorTypeSelect (value = "")
    {
        const gradientElement = document
            .getElementById("fill-color-gradient-container");

        const bitmapElement = document
            .getElementById("fill-color-bitmap-container");

        const colorElement = document
            .getElementById("fill-color-rgba-container");

        const widthElement = document
            .getElementById("fill-stroke-color-rgba-container");

        // reset
        if (value) {
            Util.$hitColor.shape.bitmapId = 0;
        }

        // 表示切り替え
        switch (document.getElementById("fill-color-type-select").value) {

            case "rgba":
                gradientElement.style.display = "none";
                bitmapElement.style.display   = "none";
                colorElement.style.display    = "";
                widthElement.style.display    = Util.$hitColor.width ? "" : "none";
                break;

            case "bitmap":
                gradientElement.style.display = "none";
                bitmapElement.style.display   = "";
                colorElement.style.display    = "none";
                widthElement.style.display    = Util.$hitColor.width ? "" : "none";
                this.createBitmapList();
                break;

            default:
                gradientElement.style.display = "";
                bitmapElement.style.display   = "none";
                colorElement.style.display    = "";
                widthElement.style.display    = Util.$hitColor.width ? "" : "none";
                if (!value) {
                    this.initializeGradient();
                }
                break;

        }

        if (value) {
            Util.$hitColor.shape.changeStyle(value);
        }
    }

    /**
     * @description 塗りのカラー設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFillColorValue (value)
    {
        if (Util.$hitColor) {

            if (this._$currentPointer) {

                const pointerColor = this
                    ._$currentPointer
                    .getElementsByTagName("i")[0];

                this._$currentPointer.dataset.color = value;
                pointerColor.style.backgroundColor  = value;

                Util.$hitColor.shape.changeColor(
                    this._$currentPointer.dataset.index | 0
                );

                this.updateGradientCanvas();

            } else {

                Util.$hitColor.shape.changeColor();

            }
        }
    }

    /**
     * @description 塗りの画像設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFillBitmapSelect (value)
    {
        if (!Util.$hitColor) {
            return ;
        }

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                value | 0
            );

        Util.$hitColor.shape.bitmapId = instance.id;
        Util.$hitColor.shape.cacheClear();
    }

    /**
     * @description 画像のSelectを生成
     *
     * @return {void}
     * @method
     * @public
     */
    createBitmapList ()
    {
        const element = document
            .getElementById("fill-bitmap-select");

        const children = element.children;
        while (children.length) {
            children[0].remove();
        }

        const option = document.createElement("option");
        option.innerHTML       = "Image Selection";
        option.defaultSelected = true;
        option.disabled        = true;
        element.appendChild(option);

        const bitmapId = Util.$hitColor.shape.bitmapId;

        const workSpace = Util.$currentWorkSpace();
        for (const instance of workSpace._$libraries.values()) {

            if (instance.type !== InstanceType.BITMAP) {
                continue;
            }

            const option = document.createElement("option");

            option.value     = instance.id;
            option.innerHTML = instance.name;

            if (bitmapId && bitmapId === instance.id) {
                option.selected = true;
            }

            element.appendChild(option);
        }
    }

    /**
     * @description グラデーション初期化
     *
     * @return {void}
     * @method
     * @public
     */
    initializeGradient ()
    {
        if (!Util.$hitColor) {
            return ;
        }

        const children = document
            .getElementById("color-pointer-list")
            .children;

        while (children.length) {
            children[0].remove();
        }

        const length = Util.$hitColor.ratios.length;
        for (let idx = 0; idx < length; ++idx) {

            const color = Util.$hitColor.ratios[idx];
            const R = color.R.toString(16).padStart(2, "0");
            const G = color.G.toString(16).padStart(2, "0");
            const B = color.B.toString(16).padStart(2, "0");

            this.addGradientColorPointer(
                idx, color.ratio * 255, `#${R}${G}${B}`, color.A / 255 * 100
            );

            if (idx + 1 === length) {
                document
                    .getElementById("fill-color-value")
                    .value = `#${R}${G}${B}`;

                document
                    .getElementById("fill-alpha-value")
                    .value = color.A / 255 * 100;
            }
        }

        this.updateGradientCanvas();
    }

    /**
     * @description グラデーションのポインターを追加
     *
     * @param  {number} index
     * @param  {number} ratio
     * @param  {string} color
     * @param  {number} alpha
     * @return {void}
     * @method
     * @public
     */
    addGradientColorPointer (index, ratio, color, alpha)
    {
        const element = document
            .getElementById("color-pointer-list");

        const htmlTag = `
<div class="color-pointer" style="left: ${ratio - 4}px;" data-index="${index}" data-color="${color}" data-alpha="${alpha}">
    <div class="color-pointer-triangle"></div>
    <div class="color-pointer-rect">
        <i class="pointer-color" style="background-color: ${color}"></i>
    </div>
</div>
`;

        element.insertAdjacentHTML("beforeend", htmlTag);

        const pointer = element.lastElementChild;

        pointer.addEventListener("mousedown", (event) =>
        {
            this.mouseDownGradientColorPointer(event);
        });

        pointer.addEventListener("dblclick", (event) =>
        {
            this.removeGradientColorPointer(event);
        });

        // 初期値は最後に生成されたポインターのElement
        this._$currentPointer = pointer;
    }

    /**
     * @description グラデーションプレビューの再描画
     *
     * @return {void}
     * @method
     * @public
     */
    updateGradientCanvas ()
    {
        const drawContext = this._$drawGradientContext;

        // clear
        drawContext.clearRect(0, 0,
            ShapeController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            ShapeController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );

        drawContext.beginPath();

        const ratios = Util.$hitColor.ratios;

        const length = ratios.length;
        const x1 = Math.ceil(ratios[length - 1].ratio * 255 * window.devicePixelRatio);

        const gradient = drawContext.createLinearGradient(0, 0, x1, 0);
        for (let idx = 0; idx < length; ++idx) {

            const object = ratios[idx];

            gradient.addColorStop(
                object.ratio,
                `rgba(${object.R}, ${object.G}, ${object.B}, ${object.A / 255})`
            );

        }

        drawContext.fillStyle = gradient;
        drawContext.rect(0, 0,
            ShapeController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            ShapeController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );

        drawContext.fill();

        const viewContext = this._$viewGradientContext;
        viewContext.clearRect(0, 0,
            ShapeController.GRADIENT_CANVAS_WIDTH  * window.devicePixelRatio,
            ShapeController.GRADIENT_CANVAS_HEIGHT * window.devicePixelRatio
        );
        viewContext.drawImage(drawContext.canvas, 0, 0);
    }

    /**
     * @description ポインターのマウスダウンで移動イベントを起動する
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDownGradientColorPointer (event)
    {
        // 親のイベントを中止
        event.stopPropagation();

        // 初期化
        this._$saved          = false;
        this._$pointX         = event.screenX;
        this._$currentPointer = event.target;

        document
            .getElementById("fill-color-value")
            .value = event.target.dataset.color;

        document
            .getElementById("fill-alpha-value")
            .value = event.target.dataset.alpha;

        if (!this._$mouseMoveGradientColorPointer) {
            this._$mouseMoveGradientColorPointer =
                this.mouseMoveGradientColorPointer.bind(this);
        }

        if (!this._$mouseUpGradientColorPointer) {
            this._$mouseUpGradientColorPointer =
                this.mouseUpGradientColorPointer.bind(this);
        }

        // イベントを登録
        window.addEventListener("mousemove", this._$mouseMoveGradientColorPointer);
        window.addEventListener("mouseup", this._$mouseUpGradientColorPointer);
    }

    /**
     * @description グラデーションのカラーポインターの移動処理
     *
     * @return {void}
     * @method
     * @public
     */
    mouseMoveGradientColorPointer (event)
    {
        const element = this._$currentPointer;
        if (!element) {
            return ;
        }

        window.requestAnimationFrame(() =>
        {
            if (!Util.$hitColor) {
                return ;
            }

            this.save();

            event.preventDefault();

            const currentPoint = parseFloat(
                element.style.left
            );

            const value = Util.$clamp(
                currentPoint + (event.screenX - this._$pointX) + 4,
                ShapeController.MIN_GRADIENT_POINTER,
                ShapeController.MAX_GRADIENT_POINTER
            );

            element.style.left = `${value - 4}px`;

            Util.$hitColor.ratios[element.dataset.index].ratio = value / 255;

            if (this._$pointX) {
                this._$pointX = event.screenX;
            }

            // グラデーションプレビューを更新
            this.updateGradientCanvas();

            // 再描画ようにキャッシュを削除
            Util.$hitColor.shape.cacheClear();

            // 再描画
            this.reloadScreen();
        });
    }

    /**
     * @description グラデーションのカラーポインターの移動を終了、イベントも削除
     *
     * @return {void}
     * @method
     * @public
     */
    mouseUpGradientColorPointer ()
    {
        // イベントを削除
        window.removeEventListener("mousemove", this._$mouseMoveGradientColorPointer);
        window.removeEventListener("mouseup", this._$mouseUpGradientColorPointer);
        Util.$setCursor("auto");

        // 設定を初期化
        super.focusOut();
    }
}

Util.$shapeController = new ShapeController();

/**
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class SoundController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("sound");
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_VOLUME ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_VOLUME ()
    {
        return 100;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_LOOP_COUNT ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_LOOP_COUNT ()
    {
        return 0xffff;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const element = document
            .getElementById("sound-add");

        if (element) {
            element
                .addEventListener("mousedown", () =>
                {
                    const element = document.getElementById("sound-select");
                    if (element && element.options.length) {
                        // undo用にセーブ
                        this.save();

                        // DOM追加
                        this.addSound();

                        // saveフラグを初期化
                        this._$saved = false;
                    }
                });
        }
    }

    /**
     * @description タイムラインにサウンドを追加
     *              タイムラインでフレームを指定した際に引数がセットされる
     *
     * @param  {object} [object=null]
     * @param  {number} [id=0]
     * @return {void}
     * @method
     * @public
     */
    addSound (object = null, id = 0)
    {
        if (!object) {

            const element = document.getElementById("sound-select");
            const option  = element.options[element.selectedIndex];

            const frame = Util.$timelineFrame.currentFrame;

            const scene = Util.$currentWorkSpace().scene;
            if (!scene._$sounds.has(frame)) {
                scene._$sounds.set(frame, []);
            }

            const sounds = scene._$sounds.get(frame);
            id = sounds.length;

            object = {
                "characterId": element.value | 0,
                "name":        option.textContent,
                "volume":      100,
                "loopCount":   0,
                "autoPlay":    false
            };

            sounds.push(object);

            // アイコンをセット
            this.setIcon(frame);
        }

        const htmlTag = `
<div id="sound-id-${id}" class="sound-border">
    <div class="sound-title">
      <span id="sound-name-${id}" data-sound-id="${id}">${object.name}</span>
      <i class="trash" id="sound-trash-${id}" data-sound-id="${id}" data-detail="{{サウンドを削除}}"></i>
    </div>

    <div class="sound-container">
        <div class="sound-setting-container">
            <div class="sound-text">Volume</div>
            <div><input type="text" id="sound-volume-${id}" data-sound-id="${id}" data-name="volume" value="100" data-detail="{{音量設定}}"></div>
        
            <div class="sound-text">Loop<br>Count</div>
            <div><input type="text" id="sound-loop-count-${id}" data-sound-id="${id}" data-name="loop-count" value="0" data-detail="{{ループ回数}}"></div>
        </div>
    </div>
</div>
`;
        document
            .getElementById("sound-list-area")
            .insertAdjacentHTML("beforeend", htmlTag);

        const soundVolume = document
            .getElementById(`sound-volume-${id}`);
        soundVolume.value = `${object.volume}`;
        this.setInputEvent(soundVolume);

        const soundLoopCount = document
            .getElementById(`sound-loop-count-${id}`);
        soundLoopCount.value = `${object.loopCount}`;
        this.setInputEvent(soundLoopCount);

        document
            .getElementById(`sound-trash-${id}`)
            .addEventListener("click", (event) =>
            {
                // undo用にセーブ
                this.save();

                this.trash(
                    event.target.dataset.soundId | 0
                );

                // 再描画
                this.createSoundElements();

                // saveフラグを初期化
                this._$saved = false;
            });

        Util.$addModalEvent(
            document.getElementById(`sound-id-${id}`)
        );
    }

    /**
     * @description ボリュームをコントロール
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeSoundVolume (value)
    {
        value = Util.$clamp(
            value | 0,
            SoundController.MIN_VOLUME,
            SoundController.MAX_VOLUME
        );

        this.updateSoundProperty("volume", value);

        return value;
    }

    /**
     * @description ボリュームをコントロール
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeSoundLoopCount (value)
    {
        value = Util.$clamp(
            value | 0,
            SoundController.MIN_LOOP_COUNT,
            SoundController.MAX_LOOP_COUNT
        );

        this.updateSoundProperty("loopCount", value);

        return value;
    }

    /**
     * @description 指定したサウンドの値を更新
     *
     * @param {string} name
     * @param {*} value
     * @method
     * @public
     */
    updateSoundProperty (name, value)
    {
        if (!this._$currentTarget) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;

        const scene  = Util.$currentWorkSpace().scene;
        const index  = this._$currentTarget.dataset.soundId | 0;
        const object = scene._$sounds.get(frame)[index];
        object[name] = value;
    }

    /**
     * @description タイムラインのヘッダーに音符アイコンを追加
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    setIcon (frame)
    {
        const leftFrame = Util.$timelineHeader.leftFrame;
        if (leftFrame > frame) {
            return ;
        }

        const index  = frame - leftFrame;
        const parent = document
            .getElementById("timeline-header")
            .children[index];

        const element = parent.children[TimelineHeader.SOUND_INDEX];
        // const element = document
        //     .getElementById(`frame-label-sound-${frame}`);

        if (!element.classList.contains("frame-border-box-sound")) {
            element
                .setAttribute("class", "frame-border-box-sound");
        }
    }

    /**
     * @description タイムラインヘッダーの音符アイコンを削除
     *
     * @param  {number} frame
     * @return {void}
     * @method
     * @public
     */
    deleteIcon (frame)
    {
        const element = document
            .getElementById("timeline-header");

        if (!element) {
            return ;
        }

        const nodes = element
            .getElementsByClassName("frame-border-box-sound");

        for (let idx = 0; idx < nodes.length; ++idx) {

            const node = nodes[idx];

            const targetFrame = node.dataset.frame | 0;
            if (targetFrame !== frame) {
                continue;
            }

            node.setAttribute("class", "frame-border-box");
            break;
        }

    }

    /**
     * @description 指定のサウンドを削除
     *
     * @param {number} index
     * @method
     * @public
     */
    trash (index)
    {
        const frame = Util.$timelineFrame.currentFrame;

        const scene  = Util.$currentWorkSpace().scene;
        const sounds = scene._$sounds.get(frame);
        sounds.splice(index, 1);

        if (!sounds.length) {

            scene._$sounds.delete(frame);

            // 音符アイコンを削除
            this.deleteIcon(frame);
        }
    }

    /**
     * @description 指定のシーンとフレームからサウンド設定を反映
     *
     * @return {void}
     * @method
     * @public
     */
    createSoundElements ()
    {
        const element = document
            .getElementById("sound-list-area");

        if (element) {
            while (element.children.length) {
                element.children[0].remove();
            }
        }

        const frame = Util.$timelineFrame.currentFrame;

        const scene = Util.$currentWorkSpace().scene;
        if (scene.hasSound(frame)) {

            const sounds = scene.getSound(frame);
            for (let idx = 0; idx < sounds.length; ++idx) {
                this.addSound(sounds[idx], idx);
            }

        }
    }
}

Util.$soundController = new SoundController();


/**
 * @class
 * @memberOf view.controller
 */
class SoundWaveform
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {number}
         * @default 280
         * @private
         */
        this._$width = 280;

        /**
         * @type {number}
         * @default 60
         * @private
         */
        this._$height = 60;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$stopFlag = false;
    }

    /**
     * @description 波形の生成を停止
     *
     * @return {void}
     * @method
     * @public
     */
    stop ()
    {
        this._$stopFlag = true;
    }

    /**
     * @description canvasに波形情報を描画
     *
     * @param  {Uint8Array} buffer
     * @return {void}
     * @method
     * @public
     */
    draw (buffer)
    {
        this._$stopFlag = false;

        this
            .load(buffer, this._$width)
            .then((channels) =>
            {
                if (this._$stopFlag) {
                    return ;
                }

                const ch1 = channels[0];
                const ch2 = channels[1];

                const canvas  = Util.$getCanvas();
                canvas.width  = this._$width  * window.devicePixelRatio;
                canvas.height = this._$height * window.devicePixelRatio;
                const context = canvas.getContext("2d");

                const barWidth    = canvas.width / ch1.length;
                const halfCanvasH = canvas.height / 2;

                context.fillStyle = "#1355a5";
                for (let idx = 0; idx < ch1.length; ++idx) {

                    //ch1
                    const ch1Height = ch1[idx] * halfCanvasH;
                    context.fillRect(idx * barWidth, halfCanvasH - ch1Height, barWidth, ch1Height);

                    //ch2
                    const ch2Height = ch2[idx] * halfCanvasH;
                    context.fillRect(idx * barWidth, halfCanvasH, barWidth, ch2Height);

                }

                canvas.setAttribute(
                    "style",
                    `margin-bottom: 10px; width: ${this._$width}px; height: ${this._$height}px`
                );

                document
                    .getElementById("library-preview-area")
                    .prepend(canvas);
            });
    }

    /**
     * @description 音声データを変換して波形配列を取得
     *
     * @param  {Uint8Array} buffer
     * @param  {number} width
     * @return {Promise}
     * @method
     * @public
     */
    load (buffer, width)
    {
        return Util
            .$audioContext
            .decodeAudioData(buffer.buffer)
            .then((buffer) =>
            {
                const ch1 = buffer.getChannelData(0);
                const peaks1 = this.getPeaks(ch1, width * window.devicePixelRatio);

                const ch2 = buffer.getChannelData(1);
                const peaks2 = this.getPeaks(ch2, width * window.devicePixelRatio);

                return [peaks1, peaks2];
            });
    }

    /**
     * @description 波形の幅を配列にして返す
     *
     * @param  {Float32Array} buffer
     * @param  {number} width
     * @return {array}
     * @method
     * @public
     */
    getPeaks (buffer, width)
    {
        let step;

        step = Math.floor(buffer.length / width * window.devicePixelRatio);

        if (step < 1) {
            step = 1;
        }

        let peaks = [];
        for (let idx = 0; idx < buffer.length; idx += step) {
            const peak = this.getPeak(buffer, idx, idx + step);
            peaks.push(peak);
        }

        return peaks;
    }

    /**
     * @description 個別の波形の幅を返す
     *
     * @param  {Float32Array} buffer
     * @param  {number} start_index
     * @param  {number} end_index
     * @return {number}
     * @method
     * @public
     */
    getPeak (buffer, start_index, end_index)
    {
        const sliced = buffer.slice(start_index, end_index);

        let peak = -100;
        for (let idx = 0; idx < sliced.length; idx++) {
            const sample = sliced[idx];
            if (sample > peak) {
                peak = sample;
            }
        }

        return peak;
    }
}

Util.$soundWaveform = new SoundWaveform();

/**
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class StageController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("stage");

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$stageLock = false;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_FPS ()
    {
        return 1;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_FPS ()
    {
        return 60;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_STAGE_SIZE ()
    {
        return 1;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_STAGE_SIZE ()
    {
        return 3000;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_STROKE_SIZE ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_STROKE_SIZE ()
    {
        return 200;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const stageLock = document.getElementById("stage-lock");
        if (stageLock) {
            stageLock
                .addEventListener("mousedown", (event) =>
                {
                    this.stageLock(event);
                });
        }

        const elementIds = [
            "stage-width",
            "stage-height",
            "stage-fps"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(elementIds[idx])
            );
        }

        this.setChangeEvent(
            document.getElementById("stage-bgColor")
        );

    }

    /**
     * @description 幅高さの変更のロックのOn/Off関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    stageLock (event)
    {
        event.stopPropagation();

        // ロックのOn/Off
        this._$stageLock = !this._$stageLock;

        // 初期化
        this._$currentValue = null;

        event
            .currentTarget
            .childNodes[1]
            .setAttribute("class", this._$stageLock
                ? "active"
                : "disable"
            );
    }

    /**
     * @description Stageの背景色を変更
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeStageBgColor (value)
    {
        document
            .getElementById("stage")
            .style.backgroundColor = value;

        document
            .getElementById("library-preview-area")
            .style.backgroundColor = value;

        const workSpace = Util.$currentWorkSpace();
        workSpace.stage.bgColor = value;
    }

    /**
     * @description Stageの幅を設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeStageWidth (value)
    {
        value = Util.$clamp(
            value | 0,
            StageController.MIN_STAGE_SIZE,
            StageController.MAX_STAGE_SIZE
        );

        const stageArea = document.getElementById("stage-area");
        const stage     = document.getElementById("stage");
        const workSpace = Util.$currentWorkSpace();

        stageArea.style.width = `${value + window.screen.width}px`;
        stage.style.width     = `${value}px`;
        workSpace.stage.width = value;

        Util.$offsetLeft = stage.offsetLeft;
        Util.$offsetTop  = stage.offsetTop;

        return value;
    }

    /**
     * @description Stageの高さを設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeStageHeight (value)
    {
        value = Util.$clamp(
            value | 0,
            StageController.MIN_STAGE_SIZE,
            StageController.MAX_STAGE_SIZE
        );

        const stageArea = document.getElementById("stage-area");
        const stage     = document.getElementById("stage");
        const workSpace = Util.$currentWorkSpace();

        stageArea.style.height = `${value + window.screen.height}px`;
        stage.style.height     = `${value}px`;
        workSpace.stage.height = value;

        Util.$offsetLeft = stage.offsetLeft;
        Util.$offsetTop  = stage.offsetTop;

        return value;
    }

    /**
     * @description StageのFPS設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeStageFps (value)
    {
        value = Util.$clamp(
            value | 0,
            StageController.MIN_FPS,
            StageController.MAX_FPS
        );

        Util.$timelineHeader.rebuild();

        const workSpace = Util.$currentWorkSpace();
        workSpace.stage.fps = value;

        return value;
    }
}

Util.$stageController = new StageController();

/**
 * @class
 * @memberOf view.controller
 */
class TabController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {HTMLDivElement}
         * @private
         */
        this._$active = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$handler = null;

        // DOMの読込がまだであれば、イベントに登録
        Util.$readEnd++;
        if (document.readyState !== "complete") {
            this._$handler = this.initialize.bind(this);
            window.addEventListener("DOMContentLoaded", this._$handler);
        } else {
            this.initialize();
        }
    }

    /**
     * @description コントローラーのタブのイベント登録
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        // イベントの登録を解除して、変数を解放
        if (this._$handler) {
            window.removeEventListener("DOMContentLoaded", this._$handler);
            this._$handler = null;
        }

        const tabArea = document
            .getElementById("controller-tab-area");

        if (tabArea) {

            const tabs = tabArea.children;
            for (let idx = 0; idx < tabs.length; ++idx) {

                const tab = tabs[idx];

                // 一番左のタブを初期アクティブに設定
                if (!this._$active) {
                    tab.classList.add("active");
                    this._$active = tab;
                }

                tab.addEventListener("click", (event) =>
                {
                    this.mouseDown(event);
                });

            }
        }

        const controllerArea = document
            .getElementById("controller-area");

        if (controllerArea) {

            const nodes = controllerArea.children;
            for (let idx = 0; idx < nodes.length; ++idx) {

                const node = nodes[idx];
                if (idx) {
                    node.style.display = "none";
                }

            }
        }

        Util.$initializeEnd();
    }

    /**
     * @description 選択したタブをアクティブ表示する
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        event.stopPropagation();
        Util.$endMenu();

        // アクティブになっているタブのcssを初期化
        this
            ._$active
            .classList
            .remove("active");

        this
            ._$active
            .classList
            .add("disable");

        // 選択したタブをアクティブに
        event
            .target
            .classList
            .remove("disable");

        event
            .target
            .classList
            .add("active");

        this._$active = event.target;

        // タブの対象となるDOMを表示してそれ以外を非表示
        const nodes = document
            .getElementById("controller-area")
            .children;

        for (let idx = 0; idx < nodes.length; ++idx) {

            const node = nodes[idx];

            if (node.id !== event.target.dataset.tabType) {
                node.style.display = "none";
                continue;
            }

            node.style.display = "";
        }

        if (event.target.dataset.tabType === "controller-area-property") {
            this.showController();
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    showController ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (activeElements.length !== 1) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        const target    = activeElements[0];

        const layer = scene.getLayer(
            target.dataset.layerId | 0
        );

        const character = layer.getCharacter(
            target.dataset.characterId | 0
        );

        character.showController();
    }
}

Util.$tabController = new TabController();

/**
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class TextController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("text");
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_SIZE ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_SIZE ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_FONT_SIZE ()
    {
        return 10;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_FONT_SIZE ()
    {
        return 255;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_STROKE_SIZE ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_STROKE_SIZE ()
    {
        return 200;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const selectIds = [
            "font-select",
            "font-style-select",
            "font-align-select",
            "font-wrap-select",
            "font-input-select",
            "font-scroll-select",
            "font-border-select",
            "font-auto-size-select",
            "font-color",
            "font-stroke-color"
        ];

        for (let idx = 0; idx < selectIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(selectIds[idx])
            );
        }

        const inputIds = [
            "font-size",
            "font-stroke-size",
            "font-leading",
            "font-letterSpacing",
            "font-leftMargin",
            "font-rightMargin"
        ];

        for (let idx = 0; idx < inputIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(inputIds[idx])
            );
        }
    }

    /**
     * @description 行間の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFontLeading (value)
    {
        value = Util.$clamp(
            value | 0,
            TextController.MIN_SIZE,
            TextController.MAX_SIZE
        );

        this.updateText({
            "name": "leading",
            "value": value
        });

        return value;
    }

    /**
     * @description 文字幅の値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFontLetterSpacing (value)
    {
        value = Util.$clamp(
            value | 0,
            -TextController.MAX_SIZE,
            TextController.MAX_SIZE
        );

        this.updateText({
            "name": "letterSpacing",
            "value": value
        });

        return value;
    }

    /**
     * @description 左マージンの値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFontLeftMargin (value)
    {
        value = Util.$clamp(
            value | 0,
            TextController.MIN_SIZE,
            TextController.MAX_SIZE
        );

        this.updateText({
            "name": "leftMargin",
            "value": value
        });

        return value;
    }

    /**
     * @description 右マージンの値を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFontRightMargin (value)
    {
        value = Util.$clamp(
            value | 0,
            TextController.MIN_SIZE,
            TextController.MAX_SIZE
        );

        this.updateText({
            "name": "rightMargin",
            "value": value
        });

        return value;
    }

    /**
     * @description テキスト枠のサイズを変更
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFontStrokeSize (value)
    {
        value = Util.$clamp(
            value | 0,
            TextController.MIN_STROKE_SIZE,
            TextController.MAX_STROKE_SIZE
        );

        this.updateText({
            "name": "thickness",
            "value": value
        });

        return value;
    }

    /**
     * @description テキストサイズを変更
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeFontSize (value)
    {
        value = Util.$clamp(
            value | 0,
            TextController.MIN_FONT_SIZE,
            TextController.MAX_FONT_SIZE
        );

        this.updateText({
            "name": "size",
            "value": value
        });

        return value;
    }

    /**
     * @description テキスト枠のカラーを設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontStrokeColor (value)
    {
        this.updateText({
            "name": "thicknessColor",
            "value": `0x${value.slice(1)}` | 0
        });
    }

    /**
     * @description テキストのカラーを設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontColor (value)
    {
        this.updateText({
            "name": "color",
            "value": `0x${value.slice(1)}` | 0
        });
    }

    /**
     * @description テキストのフォントを指定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontSelect (value)
    {
        this.updateText({
            "name": "font",
            "value": value
        });
    }

    /**
     * @description テキストエリアの改行設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontStyleSelect (value)
    {
        value |= 0;
        this.updateText({
            "name": "fontType",
            "value": Util.$clamp(value, 0, 3)
        });
    }

    /**
     * @description テキストエリアの改行設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontAlignSelect (value)
    {
        switch (value) {

            case "left":
            case "center":
            case "right":
                this.updateText({
                    "name": "align",
                    "value": value
                });
                break;

            default:
                break;

        }
    }

    /**
     * @description テキストエリアの改行設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontWrapSelect (value)
    {
        switch (value | 0) {

            case 0:
                this.updateText({
                    "name": "wordWrap",
                    "value": false
                });
                this.updateText({
                    "name": "multiline",
                    "value": false
                });
                break;

            case 1:
                this.updateText({
                    "name": "wordWrap",
                    "value": false
                });
                this.updateText({
                    "name": "multiline",
                    "value": true
                });
                break;

            case 2:
                this.updateText({
                    "name": "wordWrap",
                    "value": true
                });
                this.updateText({
                    "name": "multiline",
                    "value": true
                });
                break;

        }
    }

    /**
     * @description テキストエリアのスクロール機能のOn/Off設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontInputSelect (value)
    {
        value |= 0;
        this.updateText({
            "name": "inputType",
            "value": value ? "input" : "static"
        });
    }

    /**
     * @description テキストエリアのスクロール機能のOn/Off設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontScrollSelect (value)
    {
        this.updateText({
            "name": "scroll",
            "value": !!(value | 0)
        });
    }

    /**
     * @description テキストエリアのボータ表示設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeFontBorderSelect (value)
    {
        this.updateText({
            "name": "border",
            "value": !!(value | 0)
        });
    }

    /**
     * @description オートリサイズのSelect変更時の関数
     * @param  {number} value
     * @return {void}
     * @method
     * @public
     */
    changeFontAutoSizeSelect (value)
    {
        value |= 0;
        this.updateText({
            "name": "autoSize",
            "value": Util.$clamp(value, 0, 2)
        });
    }

    /**
     * @description テキストのプロパティーを更新
     *
     * @param  {object} object
     * @return {void}
     * @method
     * @public
     */
    updateText (object)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        const element   = activeElements[0];

        // 対象レイヤーオブジェクト
        const layer = scene.getLayer(
            element.dataset.layerId | 0
        );

        // スクリーンで選択しているDisplayObject
        const character = layer.getCharacter(
            element.dataset.characterId | 0
        );

        // ライブラリ内のインスタンスオブジェクト
        const instance = workSpace.getLibrary(character.libraryId);

        // 対象のプロパティーを更新
        instance[object.name] = object.value;

        // 再描画ように、キャッシュを削除
        character.dispose();
    }
}

Util.$textController = new TextController();

/**
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class TransformController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("transform");

        /**
         * @description 表示非表示の状態変数、初期値は非表示
         * @type {string}
         * @default "hide"
         * @private
         */
        this._$state = "hide";

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$sizeLock = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$scaleLock = false;

        /**
         * @description スクリーンに表示するElementのID名の配列
         * @type {array}
         * @private
         */
        this._$screenTargets = [
            "target-rect",         // 枠
            "scale-top-left",      // 左上
            "scale-top-right",     // 右上
            "scale-bottom-left",   // 左下
            "scale-bottom-right",  // 右下
            "scale-center-left",   // 左中央
            "scale-center-top",    // 中央上
            "scale-center-right",  // 右中央
            "scale-center-bottom", // 中央下
            "target-rotation",     // 回転表示
            "reference-point"      // 中心点
        ];
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_SIZE ()
    {
        return 1;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_SIZE ()
    {
        return 3000;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_SCALE ()
    {
        return -32768;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_SCALE ()
    {
        return 32767;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_ROTATE ()
    {
        return -360;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_ROTATE ()
    {
        return 360;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        // スクリーンに配置されてるElementにイベントを登録して非表示に
        for (let idx = 0; idx < this._$screenTargets.length; ++idx) {

            const element = document
                .getElementById(this._$screenTargets[idx]);

            if (!element) {
                continue;
            }

            // 初期値は非表示
            element.style.display = "none";
            element.addEventListener("mousedown", (event) =>
            {
                this.standbyPointer(event);
            });
        }

        // 幅高さのロック機能
        const transformSizeLock = document
            .getElementById("transform-size-lock");

        if (transformSizeLock) {
            transformSizeLock
                .addEventListener("mousedown", (event) =>
                {
                    this.sizeLock(event);
                });
        }

        // スケールのロック機能
        const transformScaleLock = document
            .getElementById("transform-scale-lock");

        if (transformScaleLock) {
            transformScaleLock
                .addEventListener("mousedown", (event) =>
                {
                    this.scaleLock(event);
                });
        }

        const elementIds = [
            "object-width",
            "object-height",
            "object-x",
            "object-y",
            "transform-scale-x",
            "transform-scale-y",
            "transform-rotate"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {
            this.setInputEvent(
                document.getElementById(elementIds[idx])
            );
        }
    }

    /**
     * @description DisplayObjectの幅を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeObjectWidth (value)
    {
        value = Util.$clamp(
            +value,
            TransformController.MIN_SIZE,
            TransformController.MAX_SIZE
        );

        this.updateWidth(value);

        return value;
    }

    /**
     * @description DisplayObjectの高さを更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeObjectHeight (value)
    {
        value = Util.$clamp(
            +value,
            TransformController.MIN_SIZE,
            TransformController.MAX_SIZE
        );

        this.updateHeight(value);

        return value;
    }

    /**
     * @description DisplayObjectのx座標を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeObjectX (value)
    {
        value = Util.$clamp(
            +value,
            TransformController.MIN_SCALE,
            TransformController.MAX_SCALE
        );

        this.updateX(value - this._$currentValue);

        return value;
    }

    /**
     * @description DisplayObjectのy座標を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeObjectY (value)
    {
        value = Util.$clamp(
            +value,
            TransformController.MIN_SCALE,
            TransformController.MAX_SCALE
        );

        this.updateY(value - this._$currentValue);

        return value;
    }

    /**
     * @description DisplayObjectのxスケールを更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeTransformScaleX (value)
    {
        value = Util.$clamp(
            +value,
            TransformController.MIN_SCALE,
            TransformController.MAX_SCALE
        );

        this.updateScaleX(value / 100);

        return value;
    }

    /**
     * @description DisplayObjectのyスケールを更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeTransformScaleY (value)
    {
        value = Util.$clamp(
            +value,
            TransformController.MIN_SCALE,
            TransformController.MAX_SCALE
        );

        this.updateScaleY(value / 100);

        return value;
    }

    /**
     * @description DisplayObjectの回転を更新
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeTransformRotate (value)
    {
        value = Util.$clamp(
            (value | 0) % 360,
            TransformController.MIN_ROTATE,
            TransformController.MAX_ROTATE
        );
        if (0 > value) {
            value += 360;
        }

        this.updateRotate(value);

        return value;
    }

    /**
     * @description InputElementにフォーカスした際の処理関数
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    focusIn (event)
    {
        super.focusIn(event);
        this.setLockElement(event);
    }

    /**
     * @description InputElement上でマウスを押下した際の処理関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    mouseDown (event)
    {
        super.mouseDown(event);
        this.setLockElement(event);
    }

    /**
     * @description ロックが有効の際に対象となるElementを変数にセット
     *
     * @param  {Event} event
     * @return {void}
     * @method
     * @public
     */
    setLockElement (event)
    {
        if (this._$focus) {
            return ;
        }

        switch (event.target.id) {

            case "object-width":
                if (this._$sizeLock) {
                    this._$lockTarget = document.getElementById("object-height");
                }
                break;

            case "object-height":
                if (this._$sizeLock) {
                    this._$lockTarget = document.getElementById("object-width");
                }
                break;

            case "transform-scale-x":
                if (this._$scaleLock) {
                    this._$lockTarget = document.getElementById("transform-scale-y");
                }
                break;

            case "transform-scale-y":
                if (this._$scaleLock) {
                    this._$lockTarget = document.getElementById("transform-scale-x");
                }
                break;

        }
    }

    /**
     * @description 拡大縮小の変更のロックのOn/Off関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    scaleLock (event)
    {
        event.stopPropagation();

        // ロックのOn/Off
        this._$scaleLock = !this._$scaleLock;

        // 初期化
        this._$currentValue = null;

        if (!this._$scaleLock) {
            this._$lockTarget = null;
        }

        event
            .currentTarget
            .childNodes[1]
            .setAttribute("class", this._$scaleLock
                ? "active"
                : "disable"
            );
    }

    /**
     * @description 幅高さの変更のロックのOn/Off関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    sizeLock (event)
    {
        event.stopPropagation();

        // ロックのOn/Off
        this._$sizeLock = !this._$sizeLock;

        // 初期化
        this._$currentValue = null;

        if (!this._$sizeLock) {
            this._$lockTarget = null;
        }

        event
            .currentTarget
            .childNodes[1]
            .setAttribute("class", this._$sizeLock
                ? "active"
                : "disable"
            );
    }

    /**
     * @description スクリーンの変形Elementの選択時の関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    standbyPointer (event)
    {
        // 親のイベントを中止する
        event.stopPropagation();

        const activeTool = Util.$tools.activeTool;
        if (activeTool) {
            event.transform = true;
            activeTool.dispatchEvent(
                EventType.MOUSE_DOWN,
                event
            );
        }
    }

    /**
     * @description スクリーンエリアの変形Elementを表示
     *
     * @return {TransformController}
     * @method
     * @public
     */
    show ()
    {
        const tool = Util.$tools.getDefaultTool("arrow-transform");
        if (this._$state !== "show") {
            this._$state = "show";
            for (let idx = 0; idx < this._$screenTargets.length; ++idx) {

                const id = this._$screenTargets[idx];
                if (!tool.active && id !== "target-rect") {
                    continue;
                }

                const element = document.getElementById(id);
                if (!element) {
                    continue;
                }

                element.style.display = "";
            }
        }
        return this;
    }

    /**
     * @description スクリーンエリアの変形Elementを非表示
     *
     * @return {void}
     * @method
     * @public
     */
    hide ()
    {
        if (this._$state === "hide") {
            return ;
        }

        for (let idx = 0; idx < this._$screenTargets.length; ++idx) {

            const element = document
                .getElementById(this._$screenTargets[idx]);

            if (!element) {
                continue;
            }

            element.setAttribute("style", "display:none;");
        }

        const standardPoint = document
            .getElementById("standard-point");

        if (standardPoint) {
            standardPoint.setAttribute("style", "display:none;");
        }

        this._$state = "hide";
    }

    /**
     * @description 選択中のDisplayObjectの矩形範囲を計算してElementを配置
     *
     * @return {void}
     * @method
     * @public
     */
    relocation ()
    {
        // 非表示中なら何もしない
        if (this._$state === "hide") {
            return;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");

        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return this.hide();
        }

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        const frame = Util.$timelineFrame.currentFrame;

        const matrix = Util.$sceneChange.concatenatedMatrix;

        let skipCount = 0;
        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const target = activeElements[idx];

            const layer = scene.getLayer(target.dataset.layerId | 0);
            if (!layer || layer.lock || layer.disable) {
                skipCount++;
                continue;
            }

            const characterId = target.dataset.characterId | 0;

            const element = document
                .getElementById(`character-${characterId}`);

            if (!element) {
                continue;
            }

            const character = layer.getCharacter(characterId);

            const bounds = character.getBounds(matrix);
            const tx = Util.$offsetLeft + (Util.$sceneChange.offsetX + bounds.xMin) * Util.$zoomScale;
            const ty = Util.$offsetTop  + (Util.$sceneChange.offsetY + bounds.yMin) * Util.$zoomScale;

            xMin = Math.min(xMin, tx);
            xMax = Math.max(xMax, tx + Math.ceil(Math.abs(bounds.xMax - bounds.xMin) * Util.$zoomScale));
            yMin = Math.min(yMin, ty);
            yMax = Math.max(yMax, ty + Math.ceil(Math.abs(bounds.yMax - bounds.yMin) * Util.$zoomScale));
        }

        if (activeElements.length - skipCount === 0) {
            return this.hide();
        }

        const standardPoint = document
            .getElementById("standard-point");

        const width  = xMax - xMin;
        const height = yMax - yMin;

        // 中心点をセット
        let point = null;
        if (activeElements.length === 1) {

            const target = activeElements[0];
            const layer  = scene.getLayer(target.dataset.layerId | 0);

            const character = layer.getCharacter(
                target.dataset.characterId | 0
            );

            // 画面の拡大縮小対応
            const place = character.getPlace(frame);
            if (!place.point) {

                const bounds = character.getBounds(matrix);
                const tx = Util.$sceneChange.offsetX + bounds.xMin;
                const ty = Util.$sceneChange.offsetY + bounds.yMin;
                const w  = Math.ceil(Math.abs(bounds.xMax - bounds.xMin)) / 2;
                const h  = Math.ceil(Math.abs(bounds.yMax - bounds.yMin)) / 2;

                place.point = {
                    "x": tx + w,
                    "y": ty + h
                };
            }

            point = place.point;

            Util
                .$referenceController
                .setInputValue(point.x, point.y);

            const characterElement = document
                .getElementById(`character-${character.id}`);

            // 非表示などでElementがない時は非表示にして終了
            if (!characterElement) {
                return this.hide();
            }

            const instance = workSpace.getLibrary(character.libraryId);
            if (instance.type === InstanceType.MOVIE_CLIP) {

                // 初期化
                standardPoint
                    .setAttribute("style", "");

                const w = standardPoint.clientWidth  / 2;
                const h = standardPoint.clientHeight / 2;

                const matrix = Util.$sceneChange.concatenatedMatrix;

                const x  = character.x;
                const y  = character.y;
                const dx = x * matrix[0] + y * matrix[2] + matrix[4];
                const dy = x * matrix[1] + y * matrix[3] + matrix[5];

                const left = Util.$offsetLeft + dx * Util.$zoomScale - w;
                const top  = Util.$offsetTop  + dy * Util.$zoomScale - h;

                standardPoint
                    .setAttribute("style", `left: ${left}px; top: ${top}px;`);

            } else {

                standardPoint
                    .setAttribute("style", "display: none;");

            }

        } else {

            if (!Util.$referenceController.pointer) {
                Util.$referenceController.pointer = {
                    "x": xMin + width  / 2,
                    "y": yMin + height / 2
                };
            }

            point = Util.$referenceController.pointer;

            standardPoint
                .setAttribute("style", "display: none;");

        }

        document
            .getElementById("target-rect")
            .setAttribute(
                "style",
                `width: ${width}px; height: ${height}px; left: ${xMin - 1}px; top: ${yMin - 1}px;`
            );

        const arrowTransform = Util.$tools.getDefaultTool("arrow-transform");
        if (arrowTransform.active) {

            // 中心点をセット
            if (point) {
                const pointX = Util.$offsetLeft + point.x * Util.$zoomScale;
                const pointY = Util.$offsetTop  + point.y * Util.$zoomScale;

                const referenceElement = document
                    .getElementById("reference-point");

                referenceElement.setAttribute("style", "");

                const left = pointX - referenceElement.offsetWidth  / 2;
                const top  = pointY - referenceElement.offsetHeight / 2;
                referenceElement.setAttribute(
                    "style",
                    `left: ${left}px; top: ${top}px;`
                );
            }

            document
                .getElementById("scale-top-left")
                .setAttribute(
                    "style",
                    `left: ${xMin - 6}px; top: ${yMin - 6}px;`
                );

            document
                .getElementById("scale-top-right")
                .setAttribute(
                    "style",
                    `left: ${xMax - 5}px; top: ${yMin - 6}px;`
                );

            document
                .getElementById("scale-bottom-left")
                .setAttribute(
                    "style",
                    `left: ${xMin - 6}px; top: ${yMax - 5}px;`
                );

            document
                .getElementById("scale-bottom-right")
                .setAttribute(
                    "style",
                    `left: ${xMax - 5}px; top: ${yMax - 5}px;`
                );

            document
                .getElementById("target-rotation")
                .setAttribute(
                    "style",
                    `left: ${xMax + 5}px; top: ${yMax + 5}px;`
                );

            document
                .getElementById("scale-center-left")
                .setAttribute(
                    "style",
                    `left: ${xMin - 6}px; top: ${yMin + height / 2 - 5}px;`
                );

            document
                .getElementById("scale-center-top")
                .setAttribute(
                    "style",
                    `left: ${xMin + width / 2 - 5}px; top: ${yMin - 6}px;`
                );

            document
                .getElementById("scale-center-right")
                .setAttribute(
                    "style",
                    `left: ${xMax - 5}px; top: ${yMin + height / 2 - 5}px;`
                );

            document
                .getElementById("scale-center-bottom")
                .setAttribute(
                    "style",
                    `left: ${xMin + width / 2 - 5}px; top: ${yMax - 5}px;`
                );

        }
    }

    /**
     * @param  {number} x
     * @return {void}
     * @method
     * @public
     */
    updateX (x)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = Util.$timelineFrame.currentFrame;

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const target  = activeElements[idx];
            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            character.x += x;

            const place = character.getPlace(frame);
            if (!place.point) {
                const bounds = character.getBounds();

                place.point = {
                    "x": place.matrix[4] + (bounds.xMax - bounds.xMin) / 2,
                    "y": place.matrix[5] + (bounds.yMax - bounds.yMin) / 2
                };
            }
            place.point.x += x;

            //  tweenの座標を再計算してポインターを再配置
            character.relocationTween(frame);
        }

        if (activeElements.length > 1) {
            const pointer = Util.$referenceController.pointer;
            pointer.x += x;
        }

        this.relocation();
    }

    /**
     * @param  {number} y
     * @return {void}
     * @method
     * @public
     */
    updateY (y)
    {
        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = Util.$timelineFrame.currentFrame;

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const target  = activeElements[idx];
            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            character.y += y;

            const place = character.getPlace(frame);
            if (!place.point) {
                const bounds = character.getBounds();

                place.point = {
                    "x": place.matrix[4] + (bounds.xMax - bounds.xMin) / 2,
                    "y": place.matrix[5] + (bounds.yMax - bounds.yMin) / 2
                };
            }
            place.point.y += y;

            //  tweenの座標を再計算してポインターを再配置
            character.relocationTween(frame);
        }

        if (activeElements.length > 1) {
            const pointer = Util.$referenceController.pointer;
            pointer.y += y;
        }

        this.relocation();
    }

    /**
     * @param  {number} width
     * @return {void}
     * @method
     * @public
     */
    updateWidth (width)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        width = Util.$clamp(
            width,
            TransformController.MIN_SIZE,
            TransformController.MAX_SIZE
        );

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        if (activeElements.length > 1) {

            let xMin =  Number.MAX_VALUE;
            let xMax = -Number.MAX_VALUE;
            let yMin =  Number.MAX_VALUE;
            let yMax = -Number.MAX_VALUE;

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const bounds = character.getBounds();

                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);
            }

            this.updateScaleX(width / Math.abs(xMax - xMin));

        } else {

            const target  = activeElements[0];
            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            const instance = workSpace
                .getLibrary(character.libraryId);

            const bounds = instance.getBounds([1, 0, 0, 1, 0, 0]);

            this.updateScaleX(
                width / Math.abs(bounds.xMax - bounds.xMin)
            );

            document
                .getElementById("transform-scale-x")
                .value = `${character.scaleX * 100}`;

        }

    }

    /**
     * @param  {number} scale_x
     * @return {void}
     * @method
     * @public
     */
    updateScaleX (scale_x)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const { Matrix } = window.next2d.geom;

        scale_x = Util.$toFixed4(Util.$clamp(
            scale_x,
            TransformController.MIN_SCALE,
            TransformController.MAX_SCALE
        ));

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = Util.$timelineFrame.currentFrame;

        let tx = Number.MAX_VALUE;
        let ty = Number.MAX_VALUE;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        const concatenatedMatrix = Util.$sceneChange.concatenatedMatrix;
        if (activeElements.length > 1)  {

            // 中心点の座標情報
            const point = Util.$referenceController.pointer;

            const matrix = new Matrix(
                concatenatedMatrix[0], concatenatedMatrix[1], concatenatedMatrix[2],
                concatenatedMatrix[3], concatenatedMatrix[4], concatenatedMatrix[5]
            );
            matrix.invert();

            const referenceX = point.x * matrix.a + point.y * matrix.c + matrix.tx;
            const referenceY = point.x * matrix.b + point.y * matrix.d + matrix.ty;

            const parentMatrix = Util.$multiplicationMatrix(
                [scale_x, 0, 0, 1, 0, 0],
                [
                    1, 0, 0, 1,
                    -referenceX,
                    -referenceY
                ]
            );

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                // 中心点の移動
                const place = character.getPlace(frame);
                const point = place.point;
                const localMatrix = Util.$multiplicationMatrix(
                    parentMatrix, [1, 0, 0, 1, point.x, point.y]
                );

                point.x = localMatrix[4] + referenceX;
                point.y = localMatrix[5] + referenceY;

                // 実行
                const multiMatrix = Util.$multiplicationMatrix(
                    parentMatrix, place.matrix
                );

                place.matrix[0] = multiMatrix[0];
                place.matrix[1] = multiMatrix[1];
                place.matrix[2] = multiMatrix[2];
                place.matrix[3] = multiMatrix[3];
                place.matrix[4] = multiMatrix[4] + referenceX;
                place.matrix[5] = multiMatrix[5] + referenceY;

                const bounds = character.getBounds();
                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);

                character.dispose();

                // tweenの座標を再計算してポインターを再配置
                character.relocationTween(frame);
            }

            document
                .getElementById("transform-scale-y")
                .value = "100";

            document
                .getElementById("transform-scale-x")
                .value = "100";

        } else {

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const character = layer.getCharacter(
                    target.dataset.characterId | 0
                );

                const place  = character.getPlace(frame);
                const multiMatrix = Util.$multiplicationMatrix(
                    concatenatedMatrix,
                    place.matrix
                );

                const matrix = new Matrix(
                    multiMatrix[0], multiMatrix[1], multiMatrix[2],
                    multiMatrix[3], multiMatrix[4], multiMatrix[5]
                );
                matrix.invert();

                const point = place.point;
                const referenceX = point.x * matrix.a + point.y * matrix.c + matrix.tx;
                const referenceY = point.x * matrix.b + point.y * matrix.d + matrix.ty;

                const baseMatrix = [1, 0, 0, 1,
                    -referenceX,
                    -referenceY
                ];

                const beforeMatrix  = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    referenceX,
                    referenceY
                ], baseMatrix);

                character.x -= beforeMatrix[4];
                character.y -= beforeMatrix[5];

                character.scaleX = scale_x;

                const afterMatrix = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    referenceX,
                    referenceY
                ], baseMatrix);

                character.x += afterMatrix[4];
                character.y += afterMatrix[5];

                character.dispose();

                tx = Math.min(tx, character.x);
                ty = Math.min(ty, character.y);

                const afterBounds = character.getBounds();
                xMin = Math.min(xMin, afterBounds.xMin);
                xMax = Math.max(xMax, afterBounds.xMax);
                yMin = Math.min(yMin, afterBounds.yMin);
                yMax = Math.max(yMax, afterBounds.yMax);

                document
                    .getElementById("transform-scale-x")
                    .value = `${scale_x * 100}`;

                //  tweenの座標を再計算してポインターを再配置
                character.relocationTween(frame);
            }
        }

        document
            .getElementById("object-x")
            .value = `${tx}`;

        document
            .getElementById("object-y")
            .value = `${ty}`;

        document
            .getElementById("object-width")
            .value = `${Math.abs(xMax - xMin)}`;

        document
            .getElementById("object-height")
            .value = `${Math.abs(yMax - yMin)}`;

    }

    /**
     * @param  {number} height
     * @return {void}
     * @method
     * @public
     */
    updateHeight (height)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        height = Util.$clamp(
            height,
            TransformController.MIN_SIZE,
            TransformController.MAX_SIZE
        );

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;
        if (activeElements.length > 1) {

            let xMin =  Number.MAX_VALUE;
            let xMax = -Number.MAX_VALUE;
            let yMin =  Number.MAX_VALUE;
            let yMax = -Number.MAX_VALUE;

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                const bounds = character.getBounds([1, 0, 0, 1, 0, 0]);

                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);
            }

            this.updateScaleY(height / Math.abs(yMax - yMin));

        } else {

            const target  = activeElements[0];
            const layerId = target.dataset.layerId | 0;
            const layer   = scene.getLayer(layerId);

            const characterId = target.dataset.characterId | 0;
            const character   = layer.getCharacter(characterId);

            const instance = workSpace
                .getLibrary(character.libraryId);

            const bounds = instance.getBounds([1, 0, 0, 1, 0, 0]);

            this.updateScaleY(
                height / Math.abs(bounds.yMax - bounds.yMin)
            );

            document
                .getElementById("transform-scale-y")
                .value = `${character.scaleY * 100}`;

        }
    }

    /**
     * @param  {number} scale_y
     * @return {void}
     * @method
     * @public
     */
    updateScaleY (scale_y)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const { Matrix } = window.next2d.geom;

        scale_y = Util.$toFixed4(Util.$clamp(
            scale_y,
            TransformController.MIN_SCALE,
            TransformController.MAX_SCALE
        ));

        const workSpace = Util.$currentWorkSpace();
        const scene     = workSpace.scene;

        const frame = Util.$timelineFrame.currentFrame;

        let tx = Number.MAX_VALUE;
        let ty = Number.MAX_VALUE;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        const concatenatedMatrix = Util.$sceneChange.concatenatedMatrix;
        if (activeElements.length > 1) {

            // 中心点の座標情報
            const point = Util.$referenceController.pointer;

            const matrix = new Matrix(
                concatenatedMatrix[0], concatenatedMatrix[1], concatenatedMatrix[2],
                concatenatedMatrix[3], concatenatedMatrix[4], concatenatedMatrix[5]
            );
            matrix.invert();

            const referenceX = point.x * matrix.a + point.y * matrix.c + matrix.tx;
            const referenceY = point.x * matrix.b + point.y * matrix.d + matrix.ty;

            const parentMatrix = Util.$multiplicationMatrix(
                [1, 0, 0, scale_y, 0, 0],
                [
                    1, 0, 0, 1,
                    -referenceX,
                    -referenceY
                ]
            );

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                // 中心点の移動
                const place = character.getPlace(frame);
                const point = place.point;
                const localMatrix = Util.$multiplicationMatrix(
                    parentMatrix, [1, 0, 0, 1, point.x, point.y]
                );

                point.x = localMatrix[4] + referenceX;
                point.y = localMatrix[5] + referenceY;

                const multiMatrix = Util.$multiplicationMatrix(
                    parentMatrix, place.matrix
                );

                place.matrix[0] = multiMatrix[0];
                place.matrix[1] = multiMatrix[1];
                place.matrix[2] = multiMatrix[2];
                place.matrix[3] = multiMatrix[3];
                place.matrix[4] = multiMatrix[4] + referenceX;
                place.matrix[5] = multiMatrix[5] + referenceY;

                const bounds = character.getBounds();

                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);

                character.dispose();

                //  tweenの座標を再計算してポインターを再配置
                character.relocationTween(frame);
            }

            document
                .getElementById("transform-scale-y")
                .value = "100";

            document
                .getElementById("transform-scale-x")
                .value = "100";

        } else {

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const character = layer.getCharacter(
                    target.dataset.characterId | 0
                );

                const place  = character.getPlace(frame);
                const multiMatrix = Util.$multiplicationMatrix(
                    concatenatedMatrix,
                    place.matrix
                );

                const matrix = new Matrix(
                    multiMatrix[0], multiMatrix[1], multiMatrix[2],
                    multiMatrix[3], multiMatrix[4], multiMatrix[5]
                );
                matrix.invert();

                const point = place.point;
                const referenceX = point.x * matrix.a + point.y * matrix.c + matrix.tx;
                const referenceY = point.x * matrix.b + point.y * matrix.d + matrix.ty;

                const baseMatrix = [
                    1, 0, 0, 1,
                    -referenceX,
                    -referenceY
                ];

                const beforeMatrix  = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    referenceX,
                    referenceY
                ], baseMatrix);

                character.x -= beforeMatrix[4];
                character.y -= beforeMatrix[5];

                character.scaleY  = scale_y;

                const afterMatrix = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    referenceX,
                    referenceY
                ], baseMatrix);

                character.x += afterMatrix[4];
                character.y += afterMatrix[5];

                character.dispose();

                tx = Math.min(tx, character.x);
                ty = Math.min(ty, character.y);

                const afterBounds = character.getBounds();

                xMin = Math.min(xMin, afterBounds.xMin);
                xMax = Math.max(xMax, afterBounds.xMax);
                yMin = Math.min(yMin, afterBounds.yMin);
                yMax = Math.max(yMax, afterBounds.yMax);

                document
                    .getElementById("transform-scale-y")
                    .value = `${scale_y * 100}`;

                //  tweenの座標を再計算してポインターを再配置
                character.relocationTween(frame);
            }

        }

        document
            .getElementById("object-x")
            .value = `${tx}`;

        document
            .getElementById("object-y")
            .value = `${ty}`;

        document
            .getElementById("object-width")
            .value = `${Math.abs(xMax - xMin)}`;

        document
            .getElementById("object-height")
            .value = `${Math.abs(yMax - yMin)}`;

    }

    /**
     * @param  {number} rotate
     * @return {void}
     * @method
     * @public
     */
    updateRotate (rotate)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const { Matrix } = window.next2d.geom;

        const workSpace = Util.$currentWorkSpace();
        const scene = workSpace.scene;

        const frame = Util.$timelineFrame.currentFrame;

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        const concatenatedMatrix = Util.$sceneChange.concatenatedMatrix;
        if (activeElements.length > 1) {

            // 中心点の座標情報
            const point = Util.$referenceController.pointer;

            const matrix = new Matrix(
                concatenatedMatrix[0], concatenatedMatrix[1], concatenatedMatrix[2],
                concatenatedMatrix[3], concatenatedMatrix[4], concatenatedMatrix[5]
            );
            matrix.invert();

            const referenceX = point.x * matrix.a + point.y * matrix.c + matrix.tx;
            const referenceY = point.x * matrix.b + point.y * matrix.d + matrix.ty;

            const radian = rotate * Util.$Deg2Rad;
            const parentMatrix = Util.$multiplicationMatrix(
                [Math.cos(radian), Math.sin(radian), -Math.sin(radian), Math.cos(radian), 0, 0],
                [
                    1, 0, 0, 1,
                    -referenceX,
                    -referenceY
                ]
            );

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target  = activeElements[idx];
                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const characterId = target.dataset.characterId | 0;
                const character   = layer.getCharacter(characterId);

                // 中心点の移動
                const place = character.getPlace(frame);
                const point = place.point;

                point.x = referenceX;
                point.y = referenceY;

                const multiMatrix = Util.$multiplicationMatrix(
                    parentMatrix, place.matrix
                );

                place.matrix[0] = multiMatrix[0];
                place.matrix[1] = multiMatrix[1];
                place.matrix[2] = multiMatrix[2];
                place.matrix[3] = multiMatrix[3];
                place.matrix[4] = multiMatrix[4] + referenceX;
                place.matrix[5] = multiMatrix[5] + referenceY;

                const bounds = character.getBounds();

                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);

                character.dispose();

                //  tweenの座標を再計算してポインターを再配置
                character.relocationTween(frame);
            }

            document
                .getElementById("transform-scale-y")
                .value = "100";

            document
                .getElementById("transform-scale-x")
                .value = "100";

        } else {

            for (let idx = 0; idx < activeElements.length; ++idx) {

                const target = activeElements[idx];

                const layerId = target.dataset.layerId | 0;
                const layer   = scene.getLayer(layerId);

                const character = layer.getCharacter(
                    target.dataset.characterId | 0
                );
                if (character.rotation === rotate) {
                    return ;
                }

                const place  = character.getPlace(frame);

                const multiMatrix = Util.$multiplicationMatrix(
                    concatenatedMatrix,
                    place.matrix
                );

                const matrix = new Matrix(
                    multiMatrix[0], multiMatrix[1], multiMatrix[2],
                    multiMatrix[3], multiMatrix[4], multiMatrix[5]
                );
                matrix.invert();

                const point = place.point;
                const referenceX = point.x * matrix.a + point.y * matrix.c + matrix.tx;
                const referenceY = point.x * matrix.b + point.y * matrix.d + matrix.ty;

                const baseMatrix = [1, 0, 0, 1,
                    -referenceX,
                    -referenceY
                ];

                const beforeMatrix  = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    referenceX,
                    referenceY
                ], baseMatrix);

                character.x -= beforeMatrix[4];
                character.y -= beforeMatrix[5];

                // fixed
                character.rotation = rotate;

                const afterMatrix = Util.$multiplicationMatrix([
                    place.matrix[0], place.matrix[1],
                    place.matrix[2], place.matrix[3],
                    referenceX,
                    referenceY
                ], baseMatrix);

                character.x += afterMatrix[4];
                character.y += afterMatrix[5];

                // clear
                character.dispose();

                let xScale = character.scaleX;
                if (Math.atan2(place.matrix[1], place.matrix[0]) >= Math.PI) {
                    xScale *= -1;
                }

                document
                    .getElementById("transform-rotate")
                    .value = `${rotate}`;

                document
                    .getElementById("transform-scale-x")
                    .value = `${xScale * 100}`;

                document
                    .getElementById("transform-scale-y")
                    .value = `${character.scaleY * 100}`;

                const bounds = character.getBounds();
                xMin = Math.min(xMin, bounds.xMin);
                xMax = Math.max(xMax, bounds.xMax);
                yMin = Math.min(yMin, bounds.yMin);
                yMax = Math.max(yMax, bounds.yMax);

                //  tweenの座標を再計算してポインターを再配置
                character.relocationTween(frame);
            }
        }

        document
            .getElementById("object-x")
            .value = `${xMin}`;

        document
            .getElementById("object-y")
            .value = `${yMin}`;

        document
            .getElementById("object-width")
            .value = `${Math.abs(xMax - xMin)}`;

        document
            .getElementById("object-height")
            .value = `${Math.abs(yMax - yMin)}`;

    }
}

Util.$transformController = new TransformController();

/**
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class TweenController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("ease");

        /**
         * @type {HTMLDivElement}
         * @default null
         * @private
         */
        this._$easeTarget = null;

        /**
         * @type {CanvasRenderingContext2D}
         * @default null
         * @private
         */
        this._$viewContext = null;

        /**
         * @type {CanvasRenderingContext2D}
         * @default null
         * @private
         */
        this._$drawContext = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$moveCurvePointer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endMoveCurvePointer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$moveEasingPointer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$endMoveEasingPointer = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$deleteEasingPointer = null;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_CANVAS_WIDTH ()
    {
        return 300;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_CANVAS_HEIGHT ()
    {
        return 400;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_BASE_CANVAS_SIZE ()
    {
        return 200;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_MIN_POINTER_X ()
    {
        return 6;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_MIN_POINTER_Y ()
    {
        return -5;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_MAX_POINTER_X ()
    {
        return 306;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_MAX_POINTER_Y ()
    {
        return 395;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_SCREEN_X ()
    {
        return 57;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_SCREEN_Y ()
    {
        return 94;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_MOVE_Y ()
    {
        return 294;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_OFFSET_X ()
    {
        return 50;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_OFFSET_Y ()
    {
        return 100;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get EASE_RANGE ()
    {
        return 100;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const ratio = window.devicePixelRatio;

        const drawCanvas   = document.createElement("canvas");
        drawCanvas.width   = TweenController.EASE_CANVAS_WIDTH  * ratio;
        drawCanvas.height  = TweenController.EASE_CANVAS_HEIGHT * ratio;
        this._$drawContext = drawCanvas.getContext("2d");

        const viewCanvas = document.getElementById("ease-custom-canvas");
        if (viewCanvas) {

            viewCanvas.width  = TweenController.EASE_CANVAS_WIDTH  * ratio;
            viewCanvas.height = TweenController.EASE_CANVAS_HEIGHT * ratio;

            viewCanvas.style.transform          = `scale(${1 / ratio}, ${1 / ratio})`;
            viewCanvas.style.backfaceVisibility = "hidden";

            this._$viewContext = viewCanvas.getContext("2d");

            // 新規カーブポインター追加処理
            viewCanvas.addEventListener("dblclick", (event) =>
            {
                this.addEasingPointer(event);
            });
        }

        const element = document
            .getElementById("ease-canvas-view-area");

        // 削除イベント用の関数
        this._$deleteEasingPointer = this.deleteEasingPointer.bind(this);
        if (element) {

            // 非表示
            element.style.display = "none";

            // 削除イベントを無効化
            element.addEventListener("mouseleave", () =>
            {
                window
                    .removeEventListener("keydown", this._$deleteEasingPointer);
            });
        }

        const changeIds = [
            "ease-select",
            "ease-custom-file-input"
        ];

        for (let idx = 0; idx < changeIds.length; ++idx) {

            const element = document.getElementById(changeIds[idx]);
            if (!element) {
                continue;
            }

            element.addEventListener("change", (event) =>
            {
                // 他のイベントを中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event.target.id, event);
            });

        }

        const elementIds = [
            "ease-custom-data-export",
            "ease-custom-data-load"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {

            const element = document.getElementById(elementIds[idx]);
            if (!element) {
                continue;
            }

            element.addEventListener("click", (event) =>
            {
                // 他のイベントを中止
                event.stopPropagation();

                // id名で関数を実行
                this.executeFunction(event.target.id, event);
            });
        }
    }

    /**
     * @description カスタムイージングのJSONデータをfile inputへ転送
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    changeEaseCustomDataLoad (event)
    {
        event.preventDefault();

        const input = document
            .getElementById("ease-custom-file-input");

        input.click();
    }

    /**
     * @description カスタムイージングの情報をJSONとしてダウンロード
     *
     * @return {void}
     * @method
     * @public
     */
    changeEaseCustomDataExport ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const activeElement = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                activeElement.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            activeElement.dataset.characterId | 0
        );
        if (!character) {
            return ;
        }

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const instance = Util
            .$currentWorkSpace()
            .getLibrary(character.libraryId);
        if (!instance) {
            return ;
        }

        const anchor    = document.createElement("a");
        anchor.download = `${instance.name}_${range.startFrame}.json`;
        anchor.href     = URL.createObjectURL(new Blob(
            [JSON.stringify(character.getTween(range.startFrame).custom)],
            { "type" : "application/json" }
        ));
        anchor.click();
    }

    /**
     * @description カスタムイージングのJSONデータの取り込み実行
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    changeEaseCustomFileInput (event)
    {
        const file = event.target.files[0];

        file
            .text()
            .then((text) =>
            {
                /**
                 * @type {ArrowTool}
                 */
                const tool = Util.$tools.getDefaultTool("arrow");
                const activeElements = tool.activeElements;
                if (!activeElements.length || activeElements.length > 1) {
                    return ;
                }

                const activeElement = activeElements[0];

                const layer = Util
                    .$currentWorkSpace()
                    .scene
                    .getLayer(
                        activeElement.dataset.layerId | 0
                    );

                const character = layer.getCharacter(
                    activeElement.dataset.characterId | 0
                );
                if (!character) {
                    return ;
                }

                const range = character.getRange(
                    Util.$timelineFrame.currentFrame
                );
                if (!character.hasTween(range.startFrame)) {
                    return ;
                }

                // データの読み込み
                const tweenObject  = character.getTween(range.startFrame);
                tweenObject.custom = JSON.parse(text);

                // 変数を初期化
                this._$easeTarget = null;

                // 初期化して再生成
                this.clearEasingPointer();
                this.createEasingPointer();

                // 再描画
                this.drawEasingGraph();

                // 再計算
                this.relocationPlace(character, range.startFrame);

                // 再配置
                this
                    .clearPointer()
                    .relocationPointer();

            });

        // reset
        event.target.value = "";
    }

    /**
     * @description カスタムイージングポインターを追加
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    addEasingPointer (event)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const activeElement = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                activeElement.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            activeElement.dataset.characterId | 0
        );
        if (!character) {
            return ;
        }

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const parent = document
            .getElementById("ease-cubic-pointer-area");

        const children = parent.children;
        const tween    = character.getTween(range.startFrame);
        const types    = ["curve", "pointer", "curve"];
        const points   = [-20, 0, 20];

        const scale = TweenController.EASE_BASE_CANVAS_SIZE / TweenController.EASE_RANGE;

        const x = (event.layerX - TweenController.EASE_BASE_CANVAS_SIZE) / scale;
        const y = (TweenController.EASE_BASE_CANVAS_SIZE - (event.layerY - 300)) / scale;

        // new pointer
        for (let idx = 0; idx < types.length; ++idx) {

            const type = types[idx];

            const dx = x + points[idx];
            const dy = y + points[idx];

            const div = this.createEasingPointerDiv(dx, dy, type);

            parent.insertBefore(
                div, children[children.length - 1]
            );

            tween.custom.splice(-2, 0, {
                "type": type,
                "x": dx,
                "y": dy
            });
        }

        for (let idx = 0; idx < children.length; ++idx) {
            const child = children[idx];
            child.dataset.index = `${idx + 1}`;
        }

        // 変数を初期化
        this._$easeTarget = null;

        // 再描画
        this.drawEasingGraph();

        // 再計算
        this.relocationPlace(character, range.startFrame);

        // 再配置
        this
            .clearPointer()
            .relocationPointer();
    }

    /**
     * @description イージング関数の変更
     *
     * @return {void}
     * @method
     * @public
     */
    changeEaseSelect ()
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const element = document.getElementById("ease-select");
        if (element.value === "custom") {
            this.showCustomArea();
        } else {
            this.hideCustomArea();
        }

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(
            targetLayer.dataset.layerId | 0
        );

        const frame = Util.$timelineFrame.currentFrame;
        const characters = layer.getActiveCharacter(frame);
        if (!characters.length && characters.length > 1) {
            return ;
        }

        const character = characters[0];

        const range = character.getRange(frame);
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        character
            .getTween(range.startFrame)
            .method = element.value;

        //  tweenの座標を再計算してポインターを再配置
        character.relocationTween(range.startFrame);
    }

    /**
     * @description tweenの座標位置を再計算
     *
     * @param  {Character} character
     * @param  {number} frame
     * @param  {string} [mode="none"]
     * @return {void}
     * @method
     * @public
     */
    relocationPlace (character, frame, mode = "none")
    {
        const range = character.getRange(frame);

        // 指定レンジ以前のtweenがあれば再計算
        if (mode === "none" && range.startFrame - 1 >= character.startFrame) {
            const prevRange = character.getRange(range.startFrame - 1);
            if (character.hasTween(prevRange.startFrame)) {
                this.relocationPlace(character, prevRange.startFrame, "prev");
            }
        }

        // tweenのplaceを再構築
        character.updateTweenPlace(range.startFrame, range.endFrame);

        const library = Util
            .$currentWorkSpace()
            .getLibrary(character.libraryId);

        if (!library) {
            return ;
        }

        // translate
        const instance = library.createInstance(character.getPlace(frame));

        const point = character.referencePoint;

        const w = instance.width  / 2;
        const h = instance.height / 2;

        const baseBounds = library.getBounds();
        const rectangle  = instance.getBounds();
        const baseMatrix = [
            1, 0, 0, 1,
            -w - rectangle.x - point.x,
            -h - rectangle.y - point.y
        ];

        // start params
        const startPlace  = character.getPlace(range.startFrame);
        const startMatrix = startPlace.matrix;

        const startScaleX = Math.sqrt(
            startMatrix[0] * startMatrix[0]
            + startMatrix[1] * startMatrix[1]
        );
        const startScaleY = Math.sqrt(
            startMatrix[2] * startMatrix[2]
            + startMatrix[3] * startMatrix[3]
        );

        let startRotate = Math.atan2(startMatrix[1], startMatrix[0]) * Util.$Rad2Deg;
        if (0 > startRotate) {
            startRotate += 360;
        }

        const startMultiMatrix = Util.$multiplicationMatrix(
            [startMatrix[0], startMatrix[1], startMatrix[2], startMatrix[3], 0, 0],
            baseMatrix
        );

        const startX = startMatrix[4] - (startMultiMatrix[4] + w + rectangle.x + point.x);
        const startY = startMatrix[5] - (startMultiMatrix[5] + h + rectangle.y + point.y);

        const startDiv = document
            .getElementById(`tween-marker-${character.id}-${range.startFrame}`);

        if (startDiv) {
            const bounds = Util.$boundsMatrix(baseBounds, startMatrix);
            const width  = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2 * Util.$zoomScale);
            const height = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2 * Util.$zoomScale);

            startDiv.style.left = `${Util.$offsetLeft + bounds.xMin * Util.$zoomScale + width  - 2}px`;
            startDiv.style.top  = `${Util.$offsetTop  + bounds.yMin * Util.$zoomScale + height - 2}px`;
        }

        // end params
        let endFrame = range.endFrame - 1;
        let endPlace = character.getPlace(endFrame);
        if (character.hasTween(range.endFrame)) {
            endFrame = range.endFrame;
            endPlace = character.getPlace(range.endFrame);
        }

        const endMatrix = endPlace.matrix;
        const endScaleX = Math.sqrt(
            endMatrix[0] * endMatrix[0]
            + endMatrix[1] * endMatrix[1]
        );
        const endScaleY = Math.sqrt(
            endMatrix[2] * endMatrix[2]
            + endMatrix[3] * endMatrix[3]
        );

        let endRotate = Math.atan2(endMatrix[1], endMatrix[0]) * Util.$Rad2Deg;
        if (0 > endRotate) {
            endRotate += 360;
        }

        const endMultiMatrix = Util.$multiplicationMatrix(
            [endMatrix[0], endMatrix[1], endMatrix[2], endMatrix[3], 0, 0],
            baseMatrix
        );

        const endX = endMatrix[4] - (endMultiMatrix[4] + w + rectangle.x + point.x);
        const endY = endMatrix[5] - (endMultiMatrix[5] + h + rectangle.y + point.y);

        const endDiv = document
            .getElementById(`tween-marker-${character.id}-${endFrame}`);

        if (endDiv) {
            const bounds = Util.$boundsMatrix(baseBounds, endMatrix);
            const width  = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2 * Util.$zoomScale);
            const height = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2 * Util.$zoomScale);

            endDiv.style.left = `${Util.$offsetLeft + bounds.xMin * Util.$zoomScale + width  - 2}px`;
            endDiv.style.top  = `${Util.$offsetTop  + bounds.yMin * Util.$zoomScale + height - 2}px`;
        }

        const tween = character.getTween(range.startFrame);
        const functionName = tween.method;

        // (fixed logic)
        const totalFrame = endFrame - range.startFrame;

        // diff
        const diffX = endX - startX;
        const diffY = endY - startY;

        // scale
        const diffScaleX = endScaleX - startScaleX;
        const diffScaleY = endScaleY - startScaleY;

        // rotate
        const diffRotate = endRotate - startRotate;

        // ColorTransform
        const startColorTransform = startPlace.colorTransform;
        const endColorTransform   = endPlace.colorTransform;
        const ct0 = endColorTransform[0] - startColorTransform[0];
        const ct1 = endColorTransform[1] - startColorTransform[1];
        const ct2 = endColorTransform[2] - startColorTransform[2];
        const ct3 = endColorTransform[3] - startColorTransform[3];
        const ct4 = endColorTransform[4] - startColorTransform[4];
        const ct5 = endColorTransform[5] - startColorTransform[5];
        const ct6 = endColorTransform[6] - startColorTransform[6];
        const ct7 = endColorTransform[7] - startColorTransform[7];

        const { Easing } = window.next2d.ui;

        let time = 1;
        for (let frame = range.startFrame + 1; frame < endFrame; ++frame) {

            const place = character.getPlace(frame);

            const t = time / totalFrame;
            let customValue = 0;
            if (functionName === "custom") {
                for (let idx = 0; idx < tween.custom.length; idx += 3) {

                    const curve1 = tween.custom[idx + 1];

                    let pointer = tween.custom[idx + 3];
                    if (pointer.off) {
                        idx += 3;
                        for (;;) {
                            pointer = tween.custom[idx + 3];
                            if (pointer.fixed || !pointer.off) {
                                break;
                            }
                            idx += 3;
                        }
                    }

                    if (pointer.x / TweenController.EASE_RANGE > t) {

                        const curve2 = tween.custom[idx + 2];

                        customValue = this.cubicBezier(
                            curve1.x / TweenController.EASE_RANGE,
                            curve1.y / TweenController.EASE_RANGE,
                            curve2.x / TweenController.EASE_RANGE,
                            curve2.y / TweenController.EASE_RANGE
                        )(t);

                        break;
                    }
                }
            }

            const matrix = place.matrix;

            // scale
            const xScale = !diffScaleX
                ? startScaleX
                : functionName === "custom"
                    ? diffScaleX * customValue + startScaleX
                    : Easing[functionName](time, startScaleX, diffScaleX, totalFrame);

            const yScale = !diffScaleY
                ? startScaleY
                : functionName === "custom"
                    ? diffScaleY * customValue + startScaleY
                    : Easing[functionName](time, startScaleY, diffScaleY, totalFrame);

            const rotation = !diffRotate
                ? startRotate
                : functionName === "custom"
                    ? diffRotate * customValue + startRotate
                    : Easing[functionName](time, startRotate, diffRotate, totalFrame) % 360;

            // rotation
            let radianX  = Math.atan2(matrix[1],  matrix[0]);
            let radianY  = Math.atan2(-matrix[2], matrix[3]);
            const radian = rotation * Util.$Deg2Rad;
            radianY      = radianY + radian - radianX;
            radianX      = radian;

            // new matrix
            matrix[0] = xScale  * Math.cos(radianX);
            matrix[1] = xScale  * Math.sin(radianX);
            matrix[2] = -yScale * Math.sin(radianY);
            matrix[3] = yScale  * Math.cos(radianY);

            matrix[4] = !diffX
                ? startX
                : functionName === "custom"
                    ? customValue * diffX + startX
                    : Easing[functionName](time, startX, diffX, totalFrame);

            matrix[5] = !diffY
                ? startY
                : functionName === "custom"
                    ? customValue * diffY + startY
                    : Easing[functionName](time, startY, diffY, totalFrame);

            if (tween.curve.length) {

                const baseDistance = Math.sqrt(
                    Math.pow(diffX, 2)
                    + Math.pow(diffY, 2)
                );

                const distance = Math.sqrt(
                    Math.pow(matrix[4] - startX, 2)
                    + Math.pow(matrix[5] - startY, 2)
                );

                if (distance && baseDistance) {

                    const curvePoint = this.getCurvePoint(
                        distance / baseDistance,
                        startX, startY, endX, endY,
                        tween.curve
                    );

                    if (curvePoint) {
                        matrix[4] = curvePoint.x;
                        matrix[5] = curvePoint.y;
                    }
                }
            }

            const multiMatrix = Util.$multiplicationMatrix(
                [matrix[0], matrix[1], matrix[2], matrix[3], 0, 0],
                baseMatrix
            );

            matrix[4] += multiMatrix[4] + w + rectangle.x + point.x;
            matrix[5] += multiMatrix[5] + h + rectangle.y + point.y;

            // ColorTransform
            const colorTransform = place.colorTransform;

            colorTransform[0] = !ct0
                ? startColorTransform[0]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct0 * customValue + startColorTransform[0]
                        : Easing[functionName](time, startColorTransform[0], ct0, totalFrame),
                    ColorTransformController.MIN_MULTIPLIER,
                    ColorTransformController.MAX_MULTIPLIER
                );

            colorTransform[1] = !ct1
                ? startColorTransform[1]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct1 * customValue + startColorTransform[1]
                        : Easing[functionName](time, startColorTransform[1], ct1, totalFrame),
                    ColorTransformController.MIN_MULTIPLIER,
                    ColorTransformController.MAX_MULTIPLIER
                );

            colorTransform[2] = !ct2
                ? startColorTransform[2]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct2 * customValue + startColorTransform[2]
                        : Easing[functionName](time, startColorTransform[2], ct2, totalFrame),
                    ColorTransformController.MIN_MULTIPLIER,
                    ColorTransformController.MAX_MULTIPLIER
                );

            colorTransform[3] = !ct3
                ? startColorTransform[3]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct3 * customValue + startColorTransform[3]
                        : Easing[functionName](time, startColorTransform[3], ct3, totalFrame),
                    ColorTransformController.MIN_MULTIPLIER,
                    ColorTransformController.MAX_MULTIPLIER
                );

            colorTransform[4] = !ct4
                ? startColorTransform[4]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct4 * customValue + startColorTransform[4]
                        : Easing[functionName](time, startColorTransform[4], ct4, totalFrame),
                    ColorTransformController.MIN_OFFSET,
                    ColorTransformController.MAX_OFFSET
                );

            colorTransform[5] = !ct5
                ? startColorTransform[5]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct5 * customValue + startColorTransform[5]
                        : Easing[functionName](time, startColorTransform[5], ct5, totalFrame),
                    ColorTransformController.MIN_OFFSET,
                    ColorTransformController.MAX_OFFSET
                );

            colorTransform[6] = !ct6
                ? startColorTransform[6]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct6 * customValue + startColorTransform[6]
                        : Easing[functionName](time, startColorTransform[6], ct6, totalFrame),
                    ColorTransformController.MIN_OFFSET,
                    ColorTransformController.MAX_OFFSET
                );

            colorTransform[7] = !ct7
                ? startColorTransform[7]
                : Util.$clamp(
                    functionName === "custom"
                        ? ct7 * customValue + startColorTransform[7]
                        : Easing[functionName](time, startColorTransform[7], ct7, totalFrame),
                    ColorTransformController.MIN_OFFSET,
                    ColorTransformController.MAX_OFFSET
                );

            const div = document
                .getElementById(`tween-marker-${character.id}-${frame}`);

            if (div) {
                const bounds = Util.$boundsMatrix(baseBounds, matrix);
                const width  = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2 * Util.$zoomScale);
                const height = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2 * Util.$zoomScale);

                div.style.left = `${Util.$offsetLeft + bounds.xMin * Util.$zoomScale + width  - 2}px`;
                div.style.top  = `${Util.$offsetTop  + bounds.yMin * Util.$zoomScale + height - 2}px`;
            }

            time++;
        }

        // filter
        const startFilters = startPlace.filter;
        const endFilters   = endPlace.filter;
        if (startFilters.length && endFilters.length) {

            const params = [
                "blurX",
                "blurY",
                "quality",
                "color",
                "alpha",
                "distance",
                "angle",
                "highlightColor",
                "highlightAlpha",
                "shadowColor",
                "shadowAlpha",
                "strength"
            ];

            const length = startFilters.length;
            for (let idx = 0; idx < length; ++idx) {

                const startFilter = startFilters[idx];
                const endFilter   = endFilters[idx];

                if (startFilter.name !== endFilter.name) {
                    continue;
                }

                let time = 1;
                for (let frame = range.startFrame + 1; range.endFrame > frame; ++frame) {

                    const filters = character.getPlace(frame).filter;
                    if (!filters[idx]) {
                        filters[idx] = new Util.$filterClasses[startFilter.name]();
                    }

                    const filter = filters[idx];
                    for (let idx = 0; idx < params.length; ++idx) {

                        const name = params[idx];

                        if (name in filter) {

                            const diff = endFilter[name] - startFilter[name];
                            if (!diff) {
                                continue;
                            }

                            filter[name] = functionName === "custom"
                                ? diff * customValue + startFilter[name]
                                : Easing[functionName](time, startFilter[name], diff, totalFrame);

                        }

                    }

                    time++;
                }
            }
        }
    }

    /**
     * @description tweenのポインターをスクリーンに配置
     *
     * @return {void}
     * @method
     * @public
     */
    relocationPointer ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const concatenatedMatrix = Util.$sceneChange.concatenatedMatrix;

        const frame = Util.$timelineFrame.currentFrame;
        const scene = Util.$currentWorkSpace().scene;
        for (let idx = 0; idx < activeElements.length; ++idx) {

            const element = activeElements[idx];

            const layer = scene.getLayer(
                element.dataset.layerId | 0
            );

            if (!layer) {
                continue;
            }

            const character = layer.getCharacter(
                element.dataset.characterId | 0
            );

            if (!character) {
                continue;
            }

            const range = character.getRange(frame);
            if (!character.hasTween(range.startFrame)) {
                continue;
            }

            let startFrame = range.startFrame;
            while (character.startFrame !== startFrame && startFrame > 1) {

                const range = character.getRange(startFrame - 1);
                if (!character.hasTween(range.startFrame)) {
                    break;
                }

                startFrame = range.startFrame;
            }

            let endFrame = range.endFrame;
            while (character.hasTween(endFrame)) {
                endFrame = character.getTween(endFrame).endFrame;
            }

            const instance = Util
                .$currentWorkSpace()
                .getLibrary(character.libraryId);

            if (!instance) {
                continue;
            }

            const baseBounds = instance.getBounds();
            const parentElement = document.getElementById("stage-area");
            for (let frame = startFrame; frame < endFrame; ++frame) {

                const div = document.createElement("div");

                // 表示座標
                const matrix = character.getPlace(frame).matrix;

                const multiMatrix = Util.$multiplicationMatrix(
                    concatenatedMatrix,
                    matrix
                );

                const bounds = Util.$boundsMatrix(baseBounds, multiMatrix);
                const width  = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2 * Util.$zoomScale);
                const height = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2 * Util.$zoomScale);
                div.style.left = `${Util.$offsetLeft + bounds.xMin * Util.$zoomScale + width  - 2}px`;
                div.style.top  = `${Util.$offsetTop  + bounds.yMin * Util.$zoomScale + height - 2}px`;

                // 表示用データ
                div.id = `tween-marker-${character.id}-${frame}`;
                div.classList.add("tween-marker");
                div.dataset.child = "tween";

                parentElement.appendChild(div);
            }

            const tweenObject = character.getTween(range.startFrame);
            for (let idx = 0; idx < tweenObject.curve.length; ++idx) {

                const pointer = tweenObject.curve[idx];

                parentElement.appendChild(
                    this.createTweenCurveElement(pointer, idx, layer.id)
                );

            }
        }
    }

    /**
     * @description スクリーンのポインターを非表示にする
     *
     * @return {TweenController}
     * @method
     * @public
     */
    clearPointer ()
    {
        const element = document
            .getElementById("stage-area");

        if (!element) {
            return this;
        }

        let idx = 0;
        while (element.children.length > idx) {

            const node = element.children[idx];
            if (node.dataset.child !== "tween") {
                idx++;
                continue;
            }

            node.remove();
        }

        return this;
    }

    /**
     * @description カーブポインターの移動開始関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    startMoveCurvePointer (event)
    {
        if (event.button) {
            return ;
        }

        Util.$endMenu();

        // 他のイベントを中止
        event.stopPropagation();

        this._$currentTarget = event.target;

        this._$pointX = event.pageX;
        this._$pointY = event.pageY;

        if (!this._$moveCurvePointer) {
            this._$moveCurvePointer = this.moveCurvePointer.bind(this);
        }

        if (!this._$endMoveCurvePointer) {
            this._$endMoveCurvePointer = this.endMoveCurvePointer.bind(this);
        }

        // 保存開始
        this.save();

        window.addEventListener("mousemove", this._$moveCurvePointer);
        window.addEventListener("mouseup", this._$endMoveCurvePointer);
    }

    /**
     * @description カーブポインターを削除
     *
     * @return {void}
     * @method
     * @public
     */
    deleteCurvePointer ()
    {
        const element = this._$currentTarget;
        if (!element) {
            return ;
        }

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                element.dataset.layerId | 0
            );

        const frame = Util.$timelineFrame.currentFrame;
        const characters = layer.getActiveCharacter(frame);

        if (!characters.length || characters.length > 1) {
            return ;
        }

        // set select
        const character = characters[0];
        const range = character.getRange(frame);

        // カーブポインターを削除
        character
            .getTween(range.startFrame)
            .curve
            .splice(element.dataset.index | 0, 1);

        // カーブElementを削除
        element.remove();

        // 再計算
        this.relocationPlace(character, range.startFrame);

        // 再配置
        this
            .clearPointer()
            .relocationPointer();

        this.save();

        // 初期化
        this._$saved = false;
        this._$currentTarget = null;
    }

    /**
     * @description カーブポインターの移動関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveCurvePointer (event)
    {
        // 全てのイベントを中止
        event.preventDefault();

        window.requestAnimationFrame(() =>
        {
            const element = this._$currentTarget;
            if (!element) {
                return ;
            }

            const x = (event.pageX - this._$pointX) / Util.$zoomScale;
            const y = (event.pageY - this._$pointY) / Util.$zoomScale;

            const layer = Util
                .$currentWorkSpace()
                .scene
                .getLayer(
                    element.dataset.layerId | 0
                );

            const frame = Util.$timelineFrame.currentFrame;

            const characters = layer.getActiveCharacter(frame);
            if (!characters.length && characters.length > 1) {
                return ;
            }

            // set select
            const character = characters[0];

            // tweenがなければ終了
            const range = character.getRange(frame);
            if (!character.hasTween(range.startFrame)) {
                return ;
            }

            const point = character
                .getTween(range.startFrame)
                .curve[element.dataset.index];

            const parentMatrix = Util.$sceneChange.concatenatedMatrix;

            const { Matrix } = next2d.geom;

            const matrix = new Matrix(
                parentMatrix[0], parentMatrix[1], parentMatrix[2],
                parentMatrix[3], parentMatrix[4], parentMatrix[5]
            );
            matrix.invert();

            const dx = x * matrix.a + y * matrix.c;
            const dy = x * matrix.b + y * matrix.d;

            point.x += dx;
            point.y += dy;

            // 再計算
            this.relocationPlace(character, range.startFrame);

            // 再配置
            this
                .clearPointer()
                .relocationPointer();

            // 再描画
            this.reloadScreen();

            this._$pointX = event.pageX;
            this._$pointY = event.pageY;
        });
    }

    /**
     * @description カーブポインターの移動終了
     *
     * @return {void}
     * @method
     * @public
     */
    endMoveCurvePointer ()
    {
        // イベントを終了
        window.removeEventListener("mousemove", this._$moveCurvePointer);
        window.removeEventListener("mouseup", this._$endMoveCurvePointer);

        // 初期化
        this._$saved = false;
    }

    /**
     * @description カーブポインターのアクティブon/off
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    switchingCurvePointer (event)
    {
        const element = event.target;

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(element.dataset.layerId | 0);

        const frame = Util.$timelineFrame.currentFrame;

        const characters = layer.getActiveCharacter(frame);
        if (!characters.length && characters.length > 1) {
            return ;
        }

        // set select
        const character = characters[0];

        // tweenがなければ終了
        const range = character.getRange(frame);
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const pointer = character
            .getTween(range.startFrame)
            .curve[element.dataset.index];

        pointer.usePoint = !pointer.usePoint;

        if (pointer.usePoint) {

            element.classList.remove("tween-pointer-disabled");
            element.classList.add("tween-pointer-active");

        } else {

            element.classList.add("tween-pointer-disabled");
            element.classList.remove("tween-pointer-active");

        }

        // 再計算
        this.relocationPlace(character, range.startFrame);

        // ポインターを再配置
        this
            .clearPointer()
            .relocationPointer();

        // 再描画
        this.reloadScreen();
    }

    /**
     * @param  {object} pointer
     * @param  {number} index
     * @param  {number} layerId
     * @return {HTMLDivElement|null}
     * @method
     * @public
     */
    createTweenCurveElement (pointer, index, layerId)
    {
        const div = document.createElement("div");
        div.classList.add(
            "tween-pointer-marker",
            "tween-pointer-disabled"
        );

        const frame = Util.$timelineFrame.currentFrame;

        div.textContent     = `${index + 1}`;
        div.dataset.child   = "tween";
        div.dataset.curve   = "true";
        div.dataset.layerId = `${layerId}`;
        div.dataset.index   = `${index}`;
        div.dataset.detail  = "{{カーブポインター(ダブルクリックでON/OFF)}}";

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(layerId);

        const characters = layer.getActiveCharacter(frame);
        if (!characters.length || characters.length > 1) {
            return null;
        }

        const character = characters[0];

        const bounds = Util
            .$currentWorkSpace()
            .getLibrary(character.libraryId)
            .getBounds();

        const matrix = Util.$sceneChange.concatenatedMatrix;

        const x = pointer.x * matrix[0] + pointer.y * matrix[2] + matrix[4];
        const y = pointer.x * matrix[1] + pointer.y * matrix[3] + matrix[5];

        const width  = Math.abs(Math.ceil(bounds.xMax - bounds.xMin) / 2 * Util.$zoomScale);
        const height = Math.abs(Math.ceil(bounds.yMax - bounds.yMin) / 2 * Util.$zoomScale);

        div.style.left = `${Util.$offsetLeft + x * Util.$zoomScale + width  - 7}px`;
        div.style.top  = `${Util.$offsetTop  + y * Util.$zoomScale + height - 7}px`;

        if (pointer.usePoint) {
            div.classList.remove("tween-pointer-disabled");
            div.classList.add("tween-pointer-active");
        } else {
            div.classList.add("tween-pointer-disabled");
            div.classList.remove("tween-pointer-active");
        }

        div.addEventListener("mousedown", (event) =>
        {
            this.startMoveCurvePointer(event);
        });

        div.addEventListener("dblclick", (event) =>
        {
            this.switchingCurvePointer(event);
        });

        div.addEventListener("mouseover", Util.$fadeIn);
        div.addEventListener("mouseout",  Util.$fadeOut);

        return div;
    }

    /**
     * @description イージングポインターの初期オブジェクト
     *
     * @return {object}
     * @method
     * @public
     */
    createEasingObject ()
    {
        return [
            {
                "type": "pointer",
                "fixed": true,
                "x": 0,
                "y": 0
            },
            {
                "type": "curve",
                "x": 0,
                "y": 0
            },
            {
                "type": "curve",
                "x": 100,
                "y": 100
            },
            {
                "type": "pointer",
                "fixed": true,
                "x": 100,
                "y": 100
            }
        ];
    }

    /**
     * @description カスタムイージングのポインターを生成
     *
     * @return {void}
     * @method
     * @public
     */
    createEasingPointer ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const activeElement = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                activeElement.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            activeElement.dataset.characterId | 0
        );
        if (!character) {
            return ;
        }

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const tweenObject = character.getTween(range.startFrame);

        const element = document
            .getElementById("ease-cubic-pointer-area");

        for (let idx = 0; idx < tweenObject.custom.length; ++idx) {

            const custom = tweenObject.custom[idx];
            if (custom.fixed) {
                continue;
            }

            const div = this.createEasingPointerDiv(
                custom.x, custom.y, custom.type, idx
            );

            if (custom.off) {
                div.classList.add("ease-cubic-disable");
            }

            element.appendChild(div);
        }
    }

    /**
     * @description カスタムイージングのポインターの移動開始処理
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    startMoveEasingPointer (event)
    {
        this._$easeTarget = event.currentTarget;
        this._$pointX     = event.screenX;
        this._$pointY     = event.screenY;

        if (!this._$moveEasingPointer) {
            this._$moveEasingPointer = this.moveEasingPointer.bind(this);
        }

        if (!this._$endMoveEasingPointer) {
            this._$endMoveEasingPointer = this.endMoveEasingPointer.bind(this);
        }

        this.save();

        // イベントを登録
        window.addEventListener("mousemove", this._$moveEasingPointer);
        window.addEventListener("mouseup", this._$endMoveEasingPointer);
        window.removeEventListener("keydown", this._$deleteEasingPointer);
    }

    /**
     * @description カスタムイージングのポインターを削除
     *
     * @param  {KeyboardEvent} event
     * @return {void}
     * @method
     * @public
     */
    deleteEasingPointer (event)
    {
        if (event.key !== "Backspace" || !this._$easeTarget) {
            return ;
        }

        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const activeElement = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                activeElement.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            activeElement.dataset.characterId | 0
        );
        if (!character) {
            return ;
        }

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const tweenObject = character.getTween(range.startFrame);
        const index  = this._$easeTarget.dataset.index | 0;
        tweenObject.custom.splice(index - 1, 3);

        const children = document
            .getElementById("ease-cubic-pointer-area")
            .children;

        children[index].remove();
        children[index - 1].remove();
        children[index - 2].remove();

        for (let idx = 0; idx < children.length; ++idx) {
            const child = children[idx];
            child.dataset.index = `${idx + 1}`;
        }

        // 再描画
        this.drawEasingGraph();

        // 再計算
        this.relocationPlace(character, range.startFrame);

        // 再配置
        this
            .clearPointer()
            .relocationPointer();
    }

    /**
     * @description カスタムイージングのポインターの移動関数
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    moveEasingPointer (event)
    {
        window.requestAnimationFrame(() =>
        {
            if (!this._$easeTarget) {
                return ;
            }

            /**
             * @type {ArrowTool}
             */
            const tool = Util.$tools.getDefaultTool("arrow");
            const activeElements = tool.activeElements;
            if (!activeElements.length || activeElements.length > 1) {
                return ;
            }

            const activeElement = activeElements[0];

            const layer = Util
                .$currentWorkSpace()
                .scene
                .getLayer(
                    activeElement.dataset.layerId | 0
                );

            const character = layer.getCharacter(
                activeElement.dataset.characterId | 0
            );
            if (!character) {
                return ;
            }

            const range = character.getRange(
                Util.$timelineFrame.currentFrame
            );
            if (!character.hasTween(range.startFrame)) {
                return ;
            }

            const element = this._$easeTarget;
            let x = element.offsetLeft + event.screenX - this._$pointX;
            let y = element.offsetTop  + event.screenY - this._$pointY;

            // update
            this._$pointX = event.screenX;
            this._$pointY = event.screenY;

            if (TweenController.EASE_MIN_POINTER_Y > y) {
                y = TweenController.EASE_MIN_POINTER_Y;
            }

            if (TweenController.EASE_MAX_POINTER_Y < y) {
                y = TweenController.EASE_MAX_POINTER_Y;
            }

            if (TweenController.EASE_MIN_POINTER_X > x) {
                x = TweenController.EASE_MIN_POINTER_X;
            }

            if (TweenController.EASE_MAX_POINTER_X < x) {
                x = TweenController.EASE_MAX_POINTER_X;
            }

            element.style.left = `${x}px`;
            element.style.top  = `${y}px`;

            const tweenObject = character.getTween(range.startFrame);
            const custom = tweenObject.custom[element.dataset.index];

            const scale = TweenController.EASE_BASE_CANVAS_SIZE / TweenController.EASE_RANGE;
            custom.x = (x - TweenController.EASE_SCREEN_X) / scale;
            custom.y = (TweenController.EASE_MOVE_Y - y) / scale;

            document
                .getElementById("ease-cubic-current-text")
                .textContent = `(${custom.x / TweenController.EASE_RANGE * 100 | 0})`;

            document
                .getElementById("ease-cubic-current-tween")
                .textContent = `(${custom.y / TweenController.EASE_RANGE * 100 | 0})`;

            // 再描画
            this.drawEasingGraph();

            // 再計算
            this.relocationPlace(character, range.startFrame);

            // 再配置
            this
                .clearPointer()
                .relocationPointer();
        });
    }

    /**
     * @description カスタムイージングのポインターの移動を終了
     *
     * @return {void}
     * @method
     * @public
     */
    endMoveEasingPointer ()
    {
        // イベントを登録
        window.removeEventListener("mousemove", this._$moveEasingPointer);
        window.removeEventListener("mouseup", this._$endMoveEasingPointer);
        window.addEventListener("keydown", this._$deleteEasingPointer);

        // 初期化
        this._$saved = false;
    }

    /**
     * @description カスタムイージングポインターを削除
     *
     * @param  {MouseEvent} event
     * @return {void}
     * @method
     * @public
     */
    disabledEasingPointer (event)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const activeElement = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                activeElement.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            activeElement.dataset.characterId | 0
        );
        if (!character) {
            return ;
        }

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const tweenObject = character.getTween(range.startFrame);

        const index  = event.target.dataset.index | 0;
        const custom = tweenObject.custom[index];

        custom.off = !custom.off;
        tweenObject.custom[index - 1].off = custom.off;
        tweenObject.custom[index + 1].off = custom.off;

        const children = document
            .getElementById("ease-cubic-pointer-area")
            .children;

        if (custom.off) {
            children[index - 2].classList.add("ease-cubic-disable");
            children[index - 1].classList.add("ease-cubic-disable");
            children[index    ].classList.add("ease-cubic-disable");
        } else {
            children[index - 2].classList.remove("ease-cubic-disable");
            children[index - 1].classList.remove("ease-cubic-disable");
            children[index    ].classList.remove("ease-cubic-disable");
        }

        // 変数を初期化
        this._$easeTarget = null;

        // 再描画
        this.drawEasingGraph();

        // 再計算
        this.relocationPlace(character, range.startFrame);

        // 再配置
        this
            .clearPointer()
            .relocationPointer();
    }

    /**
     * @description カスタムイージングのdivを生成
     *
     * @param  {number}  [x=0]
     * @param  {number}  [y=0]
     * @param  {string}  [type="pointer"]
     * @param  {number}  [index=0]
     * @return {HTMLDivElement}
     * @method
     * @public
     */
    createEasingPointerDiv (x = 0, y = 0, type = "pointer", index = 0)
    {
        const div = document.createElement("div");

        // 移動開始イベント
        div.addEventListener("mousedown", (event) =>
        {
            this.startMoveEasingPointer(event);
        });

        if (type === "pointer") {
            // ポインターを非アクティブ化
            div.addEventListener("dblclick", (event) =>
            {
                this.disabledEasingPointer(event);
            });
        }

        div.classList.add(`ease-cubic-${type}`);
        div.dataset.index = `${index}`;
        div.dataset.type  = `${type}`;

        const scale = TweenController.EASE_BASE_CANVAS_SIZE / TweenController.EASE_RANGE;

        div.style.left = `${TweenController.EASE_SCREEN_X + x * scale}px`;
        div.style.top  = `${TweenController.EASE_SCREEN_Y + (TweenController.EASE_RANGE - y) * scale}px`;

        return div;
    }

    /**
     * @description カスタムイージングの状態を描画
     *
     * @return {void}
     * @method
     * @public
     */
    drawEasingGraph ()
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length || activeElements.length > 1) {
            return ;
        }

        const activeElement = activeElements[0];

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                activeElement.dataset.layerId | 0
            );

        const character = layer.getCharacter(
            activeElement.dataset.characterId | 0
        );
        if (!character) {
            return ;
        }

        const range = character.getRange(
            Util.$timelineFrame.currentFrame
        );
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const tweenObject = character.getTween(range.startFrame);

        const ratio   = window.devicePixelRatio;
        const offsetX = TweenController.EASE_OFFSET_X * ratio;
        const offsetY = TweenController.EASE_OFFSET_Y * ratio;

        const ctx = this._$drawContext;
        ctx.fillStyle = "rgb(240, 240, 240)";

        const size = TweenController.EASE_BASE_CANVAS_SIZE * ratio;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.fillRect(offsetX, offsetY, size, size);

        ctx.lineCap = "round";
        ctx.translate(offsetX, offsetY);

        // ベースの描画
        ctx.beginPath();
        ctx.strokeStyle = "rgba(200, 200, 200, 0.6)";
        ctx.lineWidth   = 10;
        ctx.moveTo(0, 0);
        ctx.lineTo(size, size);
        ctx.stroke();

        const scale = TweenController.EASE_BASE_CANVAS_SIZE
            / TweenController.EASE_RANGE * ratio;

        for (let idx = 0; idx < tweenObject.custom.length; idx += 3) {

            const startPointer = tweenObject.custom[idx    ];
            const startCurve   = tweenObject.custom[idx + 1];
            let endCurve       = tweenObject.custom[idx + 2];
            let endPointer     = tweenObject.custom[idx + 3];

            if (endPointer.off) {
                idx += 3;
                for (;;) {
                    endCurve   = tweenObject.custom[idx + 2];
                    endPointer = tweenObject.custom[idx + 3];
                    if (endPointer.fixed || !endPointer.off) {
                        break;
                    }
                    idx += 3;
                }
            }

            // start line
            ctx.beginPath();
            ctx.strokeStyle = "rgb(160, 160, 160)";
            ctx.lineWidth   = 3;
            ctx.moveTo(startPointer.x * scale, startPointer.y * scale);
            ctx.lineTo(startCurve.x * scale, startCurve.y * scale);
            ctx.stroke();

            // end line
            ctx.beginPath();
            ctx.strokeStyle = "rgb(160, 160, 160)";
            ctx.lineWidth   = 3;
            ctx.moveTo(endPointer.x * scale, endPointer.y * scale);
            ctx.lineTo(endCurve.x * scale, endCurve.y * scale);
            ctx.stroke();

            // bezier curve
            ctx.beginPath();
            ctx.strokeStyle = "rgb(80, 80, 80)";
            ctx.lineWidth   = 10;
            ctx.moveTo(startPointer.x * scale, startPointer.y * scale);
            ctx.bezierCurveTo(
                startCurve.x * scale, startCurve.y * scale,
                endCurve.x * scale, endCurve.y * scale,
                endPointer.x * scale, endPointer.y * scale
            );
            ctx.stroke();

            if (endPointer.fixed) {
                break;
            }
        }

        const viewContext = this._$viewContext;

        // clear
        viewContext.setTransform(1, 0, 0, 1, 0, 0);
        viewContext.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        // 反転して出力
        viewContext.scale(1, -1);
        viewContext.translate(0, -ctx.canvas.height);
        viewContext.drawImage(ctx.canvas, 0, 0);
    }

    /**
     * @description カーブポインターのxy座標計算
     *
     * @param  {number} d
     * @param  {number} sx
     * @param  {number} sy
     * @param  {number} ex
     * @param  {number} ey
     * @param  {array} curves
     * @return {object}
     * @method
     * @public
     */
    getCurvePoint (d, sx, sy, ex, ey, curves)
    {
        const targets = [];
        for (let idx = 0; idx < curves.length; ++idx) {

            const pointer = curves[idx];

            if (!pointer.usePoint) {
                continue;
            }

            targets.push(pointer);
        }

        if (!targets.length) {
            return null;
        }

        const t = 1 - d;
        const l = targets.length + 1;
        for (let idx = 0; idx < l; ++idx) {
            sx *= t;
            sy *= t;
            ex *= d;
            ey *= d;
        }

        let x = sx + ex;
        let y = sy + ey;
        for (let idx = 0; idx < targets.length; ++idx) {

            const curve = targets[idx];

            const p = idx + 1;

            let cx = curve.x * l;
            let cy = curve.y * l;
            for (let jdx = 0; jdx < p; ++jdx) {
                cx *= d;
                cy *= d;
            }

            for (let jdx = 0; jdx < l - p; ++jdx) {
                cx *= t;
                cy *= t;
            }

            x += cx;
            y += cy;
        }

        return {
            "x": x,
            "y": y
        };
    }

    /**
     * @description 3次ベジェのカーブの計算
     *
     * @param  {number} $x1
     * @param  {number} $y1
     * @param  {number} $x2
     * @param  {number} $y2
     * @return {function}
     * @method
     * @public
     */
    cubicBezier ($x1, $y1, $x2, $y2)
    {
        const cx = 3 * $x1,
            bx = 3 * ($x2 - $x1) - cx,
            ax = 1 - cx - bx;

        const cy = 3 * $y1,
            by = 3 * ($y2 - $y1) - cy,
            ay = 1 - cy - by;

        const bezierX = ($t) =>
        {
            return $t * (cx + $t * (bx + $t * ax));
        };

        const bezierDX = ($t) =>
        {
            return cx + $t * (2 * bx + 3 * ax * $t);
        };

        const newtonRaphson = ($x) =>
        {
            if ($x <= 0) {
                return 0;
            }

            if ($x >= 1) {
                return 1;
            }

            let limit = 0;
            let prev = 0, t = $x;
            while (Math.abs(t - prev) > 1e-4) {

                prev = t;
                t = t - (bezierX(t) - $x) / bezierDX(t);

                limit++;
                if (limit > 1000) {
                    break;
                }
            }

            return t;
        };

        return ($t) =>
        {
            const t = newtonRaphson($t);
            return t * (cy + t * (by + t * ay));
        };
    }

    /**
     * @description カスタムイージングポインターを初期化
     *
     * @return {TweenController}
     * @method
     * @public
     */
    clearEasingPointer ()
    {
        // 初期化
        const element = document
            .getElementById("ease-cubic-pointer-area");

        if (element) {
            while (element.children.length) {
                element.children[0].remove();
            }
        }
    }

    /**
     * @description イージングコントローラーを表示
     *
     * @return {TweenController}
     * @method
     * @public
     */
    showCustomArea ()
    {
        // 初期化
        this.clearEasingPointer();
        this._$easeTarget = null;

        document
            .getElementById("ease-canvas-view-area")
            .style.display = "";

        this.createEasingPointer();
        this.drawEasingGraph();
    }

    /**
     * @description イージングコントローラーを非表示
     *
     * @return {void}
     * @method
     * @public
     */
    hideCustomArea ()
    {
        const element = document
            .getElementById("ease-canvas-view-area");

        if (element) {
            element.style.display = "none";
        }
    }

    /**
     * @description tweenのカーブポイントを追加
     *
     * @return {void}
     * @method
     * @public
     */
    addCurvePinter ()
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const frame = Util.$timelineFrame.currentFrame;

        const scene = Util.$currentWorkSpace().scene;
        const layer = scene.getLayer(
            targetLayer.dataset.layerId | 0
        );

        const characters = layer.getActiveCharacter(frame);
        if (!characters.length || characters.length > 1) {
            return ;
        }

        const character = characters[0];

        const range = character.getRange(frame);
        if (!character.hasTween(range.startFrame)) {
            return ;
        }

        const tweenObject = character.getTween(range.startFrame);

        const index  = tweenObject.curve.length;

        const mateix = Util.$sceneChange.concatenatedMatrix;
        const bounds = character.getBounds(mateix);

        const pointer = {
            "usePoint": true,
            "x": bounds.xMin,
            "y": bounds.yMin
        };
        tweenObject.curve.push(pointer);

        const div = this.createTweenCurveElement(pointer, index, layer.id);
        if (div) {
            document
                .getElementById("stage-area")
                .appendChild(div);
        }

        // 再計算
        this.relocationPlace(character, range.startFrame);

        // ポインターを再配置
        this
            .clearPointer()
            .relocationPointer();
    }
}

Util.$tweenController = new TweenController();

/**
 * @class
 * @extends {BaseController}
 * @memberOf view.controller
 */
class VideoController extends BaseController
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        super("video");
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MIN_VOLUME ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @const
     * @static
     */
    static get MAX_VOLUME ()
    {
        return 100;
    }

    /**
     * @description 初期起動関数
     *
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        super.initialize();

        const elementIds = [
            "video-loop-select",
            "video-auto-select"
        ];

        for (let idx = 0; idx < elementIds.length; ++idx) {
            this.setChangeEvent(
                document.getElementById(elementIds[idx])
            );
        }

        this.setInputEvent(
            document.getElementById("video-volume")
        );
    }

    /**
     * @description Videoのループ設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeVideoLoopSelect (value)
    {
        this.updateVideoProperty("loop", (value | 0) === 1);
    }

    /**
     * @description Videoの自動再生設定
     *
     * @param  {string} value
     * @return {void}
     * @method
     * @public
     */
    changeVideoAutoSelect (value)
    {
        this.updateVideoProperty("autoPlay", (value | 0) === 1);
    }

    /**
     * @description Videoの音声設定
     *
     * @param  {string} value
     * @return {number}
     * @method
     * @public
     */
    changeVideoVolume (value)
    {
        value = Util.$clamp(
            value | 0,
            VideoController.MIN_VOLUME,
            VideoController.MAX_VOLUME
        );

        this.updateVideoProperty("volume", value);

        return value;
    }

    /**
     * @description Videoコントローラーの値を更新
     * @param {string} name
     * @param {*} value
     * @method
     * @public
     */
    updateVideoProperty (name, value)
    {
        /**
         * @type {ArrowTool}
         */
        const tool = Util.$tools.getDefaultTool("arrow");
        const activeElements = tool.activeElements;
        if (!activeElements.length) {
            return ;
        }

        const element  = activeElements[0];
        const instance = Util.$currentWorkSpace().getLibrary(
            element.dataset.libraryId | 0
        );

        instance[name] = value;
    }
}

Util.$videoController = new VideoController();

/**
 * @class
 * @memberOf external
 */
class DrawingLayer
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        this._$begin = false;
    }

    /**
     * @method
     * @public
     */
    beginDraw ()
    {
        this._$begin = true;
    }
}

/**
 * @class
 * @memberOf external
 */
class ExternalDocument
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {ExternalTimeline}
         * @private
         */
        this._$timeline = new ExternalTimeline();

        /**
         * @type {ExternalLibrary}
         * @private
         */
        this._$library = new ExternalLibrary();
    }

    /**
     * @return {ExternalTimeline}
     * @method
     * @public
     */
    getTimeline ()
    {
        return this._$timeline;
    }

    /**
     * @return {ExternalLibrary}
     */
    get library ()
    {
        return this._$library;
    }
}

/**
 * @class
 * @memberOf external
 */
class ExternalElement
{
    /**
     * @param {Character} character
     * @param {ExternalLayer} parent
     * @constructor
     * @public
     */
    constructor (character, parent)
    {
        /**
         * @type {Character}
         * @private
         */
        this._$character = character;

        /**
         * @type {ExternalLayer}
         * @private
         */
        this._$parent = parent;
    }

    /**
     * @return {number}
     * @public
     */
    get x ()
    {
        return this._$character.x;
    }

    /**
     * @param  {number} x
     * @return {void}
     * @public
     */
    set x (x)
    {
        this._$character.x = x;

        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace
            .getLibrary(this._$character.libraryId);

        let frame = Util.$timelineFrame.currentFrame;

        const place = this._$character.getPlace(frame);

        let keys = Object.keys(place);
        const placeObject = {};
        for (let idx = 0; idx < keys.length; ++idx) {
            const name = keys[idx];
            placeObject[name] = place[name];
        }

        placeObject.loop = Util.$getDefaultLoopConfig();

        // setup
        placeObject.startFrame = this._$character.startFrame;
        placeObject.endFrame   = this._$character.endFrame;

        const bounds = Util.$boundsMatrix(
            instance.getBounds(placeObject),
            placeObject.matrix
        );

        const tx = Util.$offsetLeft + bounds.xMin * Util.$zoomScale;
        this._$character._$screenX = tx;
        document
            .getElementById(`character-${this._$character.id}`)
            .style.left = `${tx}px`;
    }

    /**
     * @return {number}
     * @public
     */
    get y ()
    {
        return this._$character.y;
    }

    /**
     * @param  {number} y
     * @return {void}
     * @public
     */
    set y (y)
    {
        this._$character.y = y;

        const workSpace = Util.$currentWorkSpace();
        const instance  = workSpace
            .getLibrary(this._$character.libraryId);

        let frame = Util.$timelineFrame.currentFrame;

        const place = this._$character.getPlace(frame);

        let keys = Object.keys(place);
        const placeObject = {};
        for (let idx = 0; idx < keys.length; ++idx) {
            const name = keys[idx];
            placeObject[name] = place[name];
        }

        placeObject.loop = Util.$getDefaultLoopConfig();

        // setup
        placeObject.startFrame = this._$character.startFrame;
        placeObject.endFrame   = this._$character.endFrame;

        const bounds = Util.$boundsMatrix(
            instance.getBounds(placeObject),
            placeObject.matrix
        );

        const ty = Util.$offsetTop + bounds.yMin * Util.$zoomScale;
        this._$character._$screenY = ty;
        document
            .getElementById(`character-${this._$character.id}`)
            .style.top = `${ty}px`;
    }

    /**
     * @return {ExternalLibrary}
     * @readonly
     * @public
     */
    get libraryItem ()
    {
        return new ExternalLibrary(Util
            .$currentWorkSpace()
            .getLibrary(this._$character.libraryId)
        );
    }

    /**
     * @return {string}
     * @public
     */
    get loop ()
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                this._$character.libraryId
            );

        if (instance.type !== InstanceType.MOVIE_CLIP) {
            return "";
        }

        const place = this._$character.getPlace(this._$character.startFrame);
        if (!place.loop) {
            return "loop";
        }

        switch (place.loop.type) {

            case 1:
            case 3:
                return "play once";

            case 2:
                return "single frame";

            default:
                return "loop";

        }
    }

    /**
     *
     * @param  {string} loop_type
     * @return {void}
     * @public
     */
    set loop (loop_type)
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                this._$character.libraryId
            );

        if (instance.type !== InstanceType.MOVIE_CLIP) {
            return ;
        }

        const place = this
            ._$character
            .getPlace(this._$character.startFrame);

        switch (loop_type) {

            case "loop":
                place.loop.type = LoopController.REPEAT;
                break;

            case "play once":
                place.loop.type = LoopController.NO_REPEAT;
                break;

            case "single frame":
                place.loop.type = LoopController.FIXED_ONE;
                break;

            default:
                place.loop.type = LoopController.DEFAULT;
                break;

        }
    }

    /**
     * @return {string}
     * @public
     */
    get symbolType ()
    {
        const instance = Util
            .$currentWorkSpace()
            .getLibrary(
                this._$character.libraryId
            );

        return instance.type === InstanceType.MOVIE_CLIP ? "movie clip" : "";
    }

    /**
     * @param  {string} symbol_type
     * @return {void}
     * @public
     */
    set symbolType (symbol_type)
    {
        switch (symbol_type) {

            case "button":
            case "movie clip":
            case "graphic":
                {
                    const workSpace = Util.$currentWorkSpace();

                    const beforeInstance = workSpace.getLibrary(
                        this._$character.libraryId
                    );
                    if (beforeInstance.type === InstanceType.MOVIE_CLIP) {
                        return ;
                    }

                    const id = workSpace.nextLibraryId;
                    const instance = workSpace.addLibrary(
                        Util.$controller.createContainer(
                            InstanceType.MOVIE_CLIP, `MovieClip_${id}`, id
                        )
                    );

                    const character  = this._$character.clone();
                    const totalFrame = character._$endFrame - character._$startFrame + 1;

                    const moveFrame = character._$startFrame - 1;
                    const places = new Map();
                    for (let [frame, place] of character._$places) {
                        place.frame = frame - moveFrame;
                        places.set(place.frame, place);
                    }
                    character._$places     = places;
                    character._$startFrame = 1;
                    character._$endFrame   = totalFrame;

                    const layer = new Layer();

                    // clone frame
                    const frameClass = this._$parent._$layer._$frame;
                    for (let [frame, css] of frameClass._$classes) {
                        if (1 > frame - moveFrame) {
                            continue;
                        }
                        layer._$frame._$classes.set(frame - moveFrame, css);
                    }

                    instance.setLayer(instance._$layerId++, layer);
                    layer.addCharacter(character);

                    // cache clear
                    this._$character._$currentFrame = 0;
                    this._$character._$currentPlace = null;
                    this._$character.dispose();

                    // update
                    this._$character._$libraryId = id;
                    for (let place of this._$character._$places.values()) {
                        place.loop = Util.$getDefaultLoopConfig();
                    }

                    workSpace.scene.changeFrame(
                        Util.$timelineFrame.currentFrame
                    );
                }
                break;

            default:
                break;

        }
    }

}

/**
 * @class
 * @memberOf external
 */
class ExternalFrame
{
    /**
     * @param {number} frame
     * @param {ExternalLayer} parent
     * @constructor
     * @public
     */
    constructor (frame, parent)
    {
        this._$frame  = frame;
        this._$parent = parent;
    }

    /**
     * @return {array}
     * @public
     */
    get elements ()
    {
        const characters = this
            ._$parent
            ._$layer
            .getActiveCharacter(this._$frame);

        const elements = [];
        for (let idx = 0; idx < characters.length; ++idx) {
            elements.push(new ExternalElement(characters[idx], this._$parent));
        }

        return elements;
    }
}

/**
 * @class
 * @memberOf external
 */
class ExternalInterface
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {ExternalDocument}
         * @private
         */
        this._$dom = new ExternalDocument();

        /**
         * @type {Map}
         * @private
         */
        this._$panel = new Map();

        /**
         * @type {DrawingLayer}
         * @private
         */
        this._$drawingLayer = new DrawingLayer();
    }

    /**
     * @return {DrawingLayer}
     * @public
     */
    get drawingLayer ()
    {
        return this._$drawingLayer;
    }

    /**
     * @param  {string} text
     * @param  {function} [callback=null]
     * @return {void}
     * @method
     * @public
     */
    addMenu (text, callback = null)
    {
        const element = document
            .getElementById("plugin-menu");

        const div = document.createElement("div");
        div.classList.add("screen-menu-bottom");
        div.textContent = text;

        if (callback) {
            div.addEventListener("mousedown", callback);
        }

        element.appendChild(div);
    }

    /**
     * @param {string}  name
     * @param {Element} element
     * @param {number}  [width = 200]
     * @param {number}  [height = 200]
     */
    createPanel (name, element, width = 200, height = 200)
    {
        this._$panel.set(name, {
            "width": width,
            "height": height,
            "element": element
        });
    }

    /**
     * @param {string} name
     * @method
     * @public
     */
    showPanel (name)
    {
        if (!this._$panel.has(name)) {
            return ;
        }

        document
            .getElementById("plugin-title")
            .textContent = name;

        const panel = this._$panel.get(name);
        document
            .getElementById("plugin-modal-element")
            .appendChild(panel.element);

        document
            .documentElement
            .style
            .setProperty(
                "--plugin-modal-width",
                `${panel.width}px`
            );

        document
            .documentElement
            .style
            .setProperty(
                "--plugin-modal-height",
                `${panel.height}px`
            );

        const element = document
            .getElementById("plugin-modal");

        element.style.top  = "100px";
        element.style.left = "100px";

        element.setAttribute("class", "fadeIn");
        Util.$endMenu("plugin-modal");
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    hidePanel ()
    {
        Util.$endMenu();

        const children = document
            .getElementById("plugin-modal-element")
            .children;

        while (children.length) {
            children[0].remove();
        }
    }

    /**
     * @return {ExternalDocument}
     * @method
     * @public
     */
    getDocumentDOM ()
    {
        return this._$dom;
    }

    /**
     * @description 新規ツールを追加
     *
     * @param  {string} name
     * @return {ExternalTool}
     */
    addTool (name)
    {
        return new ExternalTool(name);
    }

    /**
     * @description オリジナルのショートカットコマンドを登録
     *
     * @param  {string} area
     * @param  {string} key
     * @param  {function} callback
     * @return {void}
     * @method
     * @public
     */
    setShortcut (area, key, callback)
    {
        switch (area) {

            case "global":
                Util.$setShortcut(key, callback);
                break;

            case "screen":
                Util.$screenKeyboardCommand.add(key, callback);
                break;

            case "timeline":
                Util.Util.$timelineKeyboardCommand.add(key, callback);
                break;

            case "library":
                Util.Util.$libraryKeyboardCommand.add(key, callback);
                break;

            default:
                break;

        }
    }

    /**
     * @description 登録済みのショートカットコマンドを削除
     *
     * @param  {string} area
     * @param  {string} key
     * @return {void}
     * @method
     * @public
     */
    deleteShortcut (area, key)
    {
        switch (area) {

            case "global":
                Util.$deleteShortcut(key);
                break;

            case "screen":
                Util.$screenKeyboardCommand.delete(key);
                break;

            case "timeline":
                Util.Util.$timelineKeyboardCommand.delete(key);
                break;

            case "library":
                Util.Util.$libraryKeyboardCommand.delete(key);
                break;

            default:
                break;

        }
    }
}

/**
 * @class
 * @memberOf external
 */
class ExternalLayer
{
    /**
     * @param {Layer} layer
     */
    constructor (layer)
    {
        this._$layer = layer;
    }

    /**
     * @return {array}
     */
    get frames ()
    {
        const frames = [undefined];
        const totalFrame = this._$layer.totalFrame;
        for (let frame = 1; totalFrame >= frame; ++frame) {
            frames.push(new ExternalFrame(frame, this));
        }
        return frames;
    }

    /**
     * @return {boolean}
     * @public
     */
    get locked ()
    {
        return this._$layer.lock;
    }

    /**
     * @param  {boolean} lock
     * @return {void}
     * @public
     */
    set locked (lock)
    {
        this._$layer.lock = !!lock;

        const element = document
            .getElementById(`layer-lock-icon-${this._$layer.id}`);

        element.classList.remove("icon-disable", "icon-active");
        element.classList.add(this._$layer.lock ? "icon-active" : "icon-disable");
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        return this._$layer.name;
    }
}

/**
 * @class
 * @memberOf external
 */
class ExternalLibrary
{
    /**
     * @param {Instance} [instance=null]
     */
    constructor (instance = null)
    {
        this._$instance = instance;
    }

    /**
     * @return {string}
     * @public
     */
    get name ()
    {
        if (!this._$instance) {
            return "";
        }

        return this._$instance.path;
    }

    /**
     * @param  {string} path
     * @return {ExternalLibrary|null}
     */
    getItem (path)
    {
        path = `${path}`;

        const workSpace = Util.$currentWorkSpace();
        for (let instance of workSpace._$libraries.values()) {

            if (instance.path !== path) {
                continue;
            }

            return new ExternalLibrary(instance);
        }

        return null;
    }

    /**
     * @param  {number} [frame=1]
     * @return {HTMLImageElement}
     * @method
     * @public
     */
    toImage (frame = 1)
    {
        if (!this._$instance) {
            return new Image();
        }

        const bounds = this._$instance.getBounds(
            [1, 0, 0, 1, 0, 0], null, null, frame
        );

        const width  = Math.abs(bounds.xMax - bounds.xMin);
        const height = Math.abs(bounds.yMax - bounds.yMin);

        const currentFrame = Util.$currentFrame;

        Util.$currentFrame = frame;
        const context = this._$instance.draw(
            Util.$getCanvas(),
            Math.ceil(width),
            Math.ceil(height),
            {
                "frame": frame,
                "matrix": [1, 0, 0, 1, 0, 0],
                "colorTransform": [1, 1, 1, 1, 0, 0, 0, 0],
                "blendMode": "normal",
                "filter": [],
                "loop": Util.$getDefaultLoopConfig()
            },
            null,
            frame
        );

        Util.$currentFrame = currentFrame;

        const image  = new Image();
        image.width  = Math.ceil(width);
        image.height = Math.ceil(height);
        image.src    = context.canvas.toDataURL();

        Util.$poolCanvas(context);

        return image;
    }

    /**
     * @param  {object} point
     * @param  {string} path
     * @return {boolean}
     * @method
     * @public
     */
    addItemToDocument (point, path)
    {
        if (!point || !path) {
            return false;
        }

        path = `${path}`;

        const workSpace = Util.$currentWorkSpace();
        for (let instance of workSpace._$libraries.values()) {

            if (instance.path !== path) {
                continue;
            }

            // ライブラリを選択状態に
            Util
                .$libraryController
                .activeInstance = document.getElementById(
                    `library-child-id-${instance.id}`
                );

            Util.$dragElement = {
                "dataset": {
                    "libraryId": instance.id
                }
            };

            Util.$screen.drop({
                "offsetX": point.x + Util.$offsetLeft,
                "offsetY": point.y + Util.$offsetTop
            });

            Util.$dragElement = null;

            return true;
        }

        return false;
    }
}

/**
 * @class
 * @memberOf external
 */
class ExternalTimeline
{
    /**
     * @return {number}
     * @readonly
     * @public
     */
    get currentFrame ()
    {
        return Util.$timelineFrame.currentFrame;
    }

    /**
     * @return {number}
     * @public
     */
    get currentLayer ()
    {
        const layerElement = Util.$timelineLayer.targetLayer;
        if (!layerElement) {
            return 0;
        }

        const layerId = layerElement.dataset.layerId | 0;
        const scene   = Util.$currentWorkSpace().scene;
        return Array.from(scene._$layers.keys()).indexOf(layerId) | 0;
    }

    /**
     * @param  {number} index
     * @return {void}
     * @public
     */
    set currentLayer (index)
    {
        const scene = Util.$currentWorkSpace().scene;
        const id    = Array.from(scene._$layers.keys())[index];

        // target layer
        Util.$timelineLayer.targetLayer = document
            .getElementById(`layer-id-${id}`);
    }

    /**
     * @return {array}
     * @readonly
     * @public
     */
    get layers ()
    {
        const children = Array.from(
            document.getElementById("timeline-content").children
        );

        const scene  = Util.$currentWorkSpace().scene;
        const layers = [];
        for (const layer of scene._$layers.values()) {

            const index = children.indexOf(
                document.getElementById(`layer-id-${layer.id}`)
            );

            layers[index] = new ExternalLayer(layer);
        }

        return layers;
    }

    /**
     * @return {array}
     * @method
     * @public
     */
    getSelectedLayers ()
    {
        const indexes = [];

        const children = Array.from(
            document.getElementById("timeline-content").children
        );

        const targetLayers = Util.$timelineLayer.targetLayers;
        for (const layerElement of targetLayers.values()) {

            const layerId = layerElement.dataset.layerId | 0;

            const index = children.indexOf(
                document.getElementById(`layer-id-${layerId}`)
            );

            indexes.push(index);
        }

        if (indexes.length > 1) {
            indexes.sort((a, b) =>
            {
                // 昇順
                switch (true) {

                    case a > b:
                        return 1;

                    case a < b:
                        return -1;

                    default:
                        return 0;

                }
            });
        }

        return indexes;
    }

    /**
     * @param  {string}  [name=""]
     * @param  {string}  [type="normal"]
     * @param  {boolean} [above=true]
     * @return {ExternalLayer}
     * @method
     * @public
     */
    addNewLayer (name = "", type = "normal", above = true)
    {
        const scene = Util.$currentWorkSpace().scene;
        const layer = new Layer();
        if (name) {
            layer.name = name;
        }

        switch (type) {

            case "mask":
                layer.mode = LayerMode.MASK;
                break;

            case "masked":
                layer.mode = LayerMode.MASK_IN;
                break;

            default:
                break;

        }

        // cache(fixed logic)
        const targetIndex = this.currentLayer;

        let index = 0;
        const layers = new Map();
        for (const value of scene._$layers.values()) {

            if (above && index === targetIndex) {
                layers.set(index++, layer);
            }

            layers.set(index++, value);

            if (!above && index === targetIndex + 1) {
                layers.set(index++, layer);
            }
        }

        scene._$layers = layers;
        scene.initialize();

        // target layer
        Util.$timelineLayer.targetLayer = document
            .getElementById(`layer-id-${layer.id}`);

        // target frame
        Util.$timelineLayer.clearActiveFrames();

        Util
            .$timelineLayer
            .addTargetFrame(layer, this.currentFrame);

        return new ExternalLayer(layer);
    }

    /**
     * @param  {number} start_frame
     * @param  {number} end_frame
     * @return {void}
     * @method
     * @public
     */
    setSelectedFrames (start_frame, end_frame)
    {
        const layerElement = Util.$timelineLayer.targetLayer;
        if (!layerElement) {
            return ;
        }

        Util.$timelineLayer.clearActiveFrames();

        end_frame = Math.max(start_frame, end_frame);

        const layer = Util
            .$currentWorkSpace()
            .scene
            .getLayer(
                layerElement.dataset.layerId | 0
            );

        for (let frame = start_frame; end_frame >= frame; ++frame) {

            Util
                .$timelineLayer
                .addTargetFrame(layer, frame);

        }

        Util.$timelineFrame.currentFrame = start_frame;
    }

    /**
     * @param  {number} [start_frame = -1]
     * @param  {number} [end_frame = -1]
     * @return {void}
     * @public
     */
    clearKeyframes (start_frame = -1, end_frame = -1)
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const layerId = targetLayer.dataset.layerId | 0;
        if (Util.$timelineLayer.targetFrames.has(layerId)) {

            const targetFrames = Util
                .$timelineLayer
                .targetFrames
                .get(layerId)
                .slice();

            if (targetFrames.length > 1) {
                targetFrames.sort((a, b) =>
                {
                    const aFrame = a | 0;
                    const bFrame = b | 0;

                    // 昇順
                    switch (true) {

                        case aFrame > bFrame:
                            return 1;

                        case aFrame < bFrame:
                            return -1;

                        default:
                            return 0;

                    }
                });
            }

            if (start_frame === -1) {
                start_frame = targetFrames[0];
            }

            if (end_frame === -1) {
                end_frame = targetFrames[targetFrames.length - 1];
            }

        }

        if (end_frame === -1) {
            end_frame = start_frame;
        }

        if (start_frame === -1 || end_frame === -1) {
            return ;
        }

        this.setSelectedFrames(start_frame, end_frame);
    }

    /**
     * @param  {number} [start_frame = -1]
     * @param  {number} [end_frame = -1]
     * @return {void}
     * @public
     */
    convertToBlankKeyframes (start_frame = -1, end_frame = -1)
    {
        const targetLayer = Util.$timelineLayer.targetLayer;
        if (!targetLayer) {
            return ;
        }

        const layerId = targetLayer.dataset.layerId | 0;
        if (Util.$timelineLayer.targetFrames.has(layerId)) {

            const targetFrames = Util
                .$timelineLayer
                .targetFrames
                .get(layerId)
                .slice();

            if (targetFrames.length > 1) {
                targetFrames.sort((a, b) =>
                {
                    const aFrame = a | 0;
                    const bFrame = b | 0;

                    // 昇順
                    switch (true) {

                        case aFrame > bFrame:
                            return 1;

                        case aFrame < bFrame:
                            return -1;

                        default:
                            return 0;

                    }
                });
            }

            if (start_frame === -1) {
                start_frame = targetFrames[0];
            }

            if (end_frame === -1) {
                end_frame = targetFrames[targetFrames.length - 1];
            }

        }

        if (end_frame === -1) {
            end_frame = start_frame;
        }

        if (start_frame === -1 || end_frame === -1) {
            return ;
        }

        // 指定レイヤーの指定フレームを選択
        this.setSelectedFrames(start_frame, end_frame);

        // 空のキーフレームを追加
        Util.$timelineTool.executeTimelineEmptyAdd();
    }

}

/**
 * @class
 * @memberOf external
 */
class ExternalTool extends CommonTool
{
    /**
     * @param {string} name
     * @constructor
     * @public
     */
    constructor (name)
    {
        super(name);
    }
}


        global["nt"] = global["fl"] = new ExternalInterface();
    })(this);
}
